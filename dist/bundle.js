(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\node_modules\\base64-js\\index.js":[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\node_modules\\browser-resolve\\empty.js":[function(require,module,exports){

},{}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\node_modules\\buffer\\index.js":[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\node_modules\\base64-js\\index.js","ieee754":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\node_modules\\ieee754\\index.js","isarray":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\node_modules\\buffer\\node_modules\\isarray\\index.js"}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\node_modules\\buffer\\node_modules\\isarray\\index.js":[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\node_modules\\ieee754\\index.js":[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\node_modules\\opentype.js\\dist\\opentype.js":[function(require,module,exports){
(function (Buffer){
/**
 * https://opentype.js.org v0.8.0 | (c) Frederik De Bleser and other contributors | MIT License | Uses tiny-inflate by Devon Govett
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.opentype = global.opentype || {})));
}(this, (function (exports) { 'use strict';

var TINF_OK = 0;
var TINF_DATA_ERROR = -3;

function Tree() {
  this.table = new Uint16Array(16);   /* table of code length counts */
  this.trans = new Uint16Array(288);  /* code -> symbol translation table */
}

function Data(source, dest) {
  this.source = source;
  this.sourceIndex = 0;
  this.tag = 0;
  this.bitcount = 0;
  
  this.dest = dest;
  this.destLen = 0;
  
  this.ltree = new Tree();  /* dynamic length/symbol tree */
  this.dtree = new Tree();  /* dynamic distance tree */
}

/* --------------------------------------------------- *
 * -- uninitialized global data (static structures) -- *
 * --------------------------------------------------- */

var sltree = new Tree();
var sdtree = new Tree();

/* extra bits and base tables for length codes */
var length_bits = new Uint8Array(30);
var length_base = new Uint16Array(30);

/* extra bits and base tables for distance codes */
var dist_bits = new Uint8Array(30);
var dist_base = new Uint16Array(30);

/* special ordering of code length codes */
var clcidx = new Uint8Array([
  16, 17, 18, 0, 8, 7, 9, 6,
  10, 5, 11, 4, 12, 3, 13, 2,
  14, 1, 15
]);

/* used by tinf_decode_trees, avoids allocations every call */
var code_tree = new Tree();
var lengths = new Uint8Array(288 + 32);

/* ----------------------- *
 * -- utility functions -- *
 * ----------------------- */

/* build extra bits and base tables */
function tinf_build_bits_base(bits, base, delta, first) {
  var i, sum;

  /* build bits table */
  for (i = 0; i < delta; ++i) { bits[i] = 0; }
  for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }

  /* build base table */
  for (sum = first, i = 0; i < 30; ++i) {
    base[i] = sum;
    sum += 1 << bits[i];
  }
}

/* build the fixed huffman trees */
function tinf_build_fixed_trees(lt, dt) {
  var i;

  /* build fixed length tree */
  for (i = 0; i < 7; ++i) { lt.table[i] = 0; }

  lt.table[7] = 24;
  lt.table[8] = 152;
  lt.table[9] = 112;

  for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }
  for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }
  for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }
  for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }

  /* build fixed distance tree */
  for (i = 0; i < 5; ++i) { dt.table[i] = 0; }

  dt.table[5] = 32;

  for (i = 0; i < 32; ++i) { dt.trans[i] = i; }
}

/* given an array of code lengths, build a tree */
var offs = new Uint16Array(16);

function tinf_build_tree(t, lengths, off, num) {
  var i, sum;

  /* clear code length count table */
  for (i = 0; i < 16; ++i) { t.table[i] = 0; }

  /* scan symbol lengths, and sum code length counts */
  for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }

  t.table[0] = 0;

  /* compute offset table for distribution sort */
  for (sum = 0, i = 0; i < 16; ++i) {
    offs[i] = sum;
    sum += t.table[i];
  }

  /* create code->symbol translation table (symbols sorted by code) */
  for (i = 0; i < num; ++i) {
    if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }
  }
}

/* ---------------------- *
 * -- decode functions -- *
 * ---------------------- */

/* get one bit from source stream */
function tinf_getbit(d) {
  /* check if tag is empty */
  if (!d.bitcount--) {
    /* load next tag */
    d.tag = d.source[d.sourceIndex++];
    d.bitcount = 7;
  }

  /* shift bit out of tag */
  var bit = d.tag & 1;
  d.tag >>>= 1;

  return bit;
}

/* read a num bit value from a stream and add base */
function tinf_read_bits(d, num, base) {
  if (!num)
    { return base; }

  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }

  var val = d.tag & (0xffff >>> (16 - num));
  d.tag >>>= num;
  d.bitcount -= num;
  return val + base;
}

/* given a data stream and a tree, decode a symbol */
function tinf_decode_symbol(d, t) {
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  
  var sum = 0, cur = 0, len = 0;
  var tag = d.tag;

  /* get more bits while code value is above sum */
  do {
    cur = 2 * cur + (tag & 1);
    tag >>>= 1;
    ++len;

    sum += t.table[len];
    cur -= t.table[len];
  } while (cur >= 0);
  
  d.tag = tag;
  d.bitcount -= len;

  return t.trans[sum + cur];
}

/* given a data stream, decode dynamic trees from it */
function tinf_decode_trees(d, lt, dt) {
  var hlit, hdist, hclen;
  var i, num, length;

  /* get 5 bits HLIT (257-286) */
  hlit = tinf_read_bits(d, 5, 257);

  /* get 5 bits HDIST (1-32) */
  hdist = tinf_read_bits(d, 5, 1);

  /* get 4 bits HCLEN (4-19) */
  hclen = tinf_read_bits(d, 4, 4);

  for (i = 0; i < 19; ++i) { lengths[i] = 0; }

  /* read code lengths for code length alphabet */
  for (i = 0; i < hclen; ++i) {
    /* get 3 bits code length (0-7) */
    var clen = tinf_read_bits(d, 3, 0);
    lengths[clcidx[i]] = clen;
  }

  /* build code length tree */
  tinf_build_tree(code_tree, lengths, 0, 19);

  /* decode code lengths for the dynamic trees */
  for (num = 0; num < hlit + hdist;) {
    var sym = tinf_decode_symbol(d, code_tree);

    switch (sym) {
      case 16:
        /* copy previous code length 3-6 times (read 2 bits) */
        var prev = lengths[num - 1];
        for (length = tinf_read_bits(d, 2, 3); length; --length) {
          lengths[num++] = prev;
        }
        break;
      case 17:
        /* repeat code length 0 for 3-10 times (read 3 bits) */
        for (length = tinf_read_bits(d, 3, 3); length; --length) {
          lengths[num++] = 0;
        }
        break;
      case 18:
        /* repeat code length 0 for 11-138 times (read 7 bits) */
        for (length = tinf_read_bits(d, 7, 11); length; --length) {
          lengths[num++] = 0;
        }
        break;
      default:
        /* values 0-15 represent the actual code lengths */
        lengths[num++] = sym;
        break;
    }
  }

  /* build dynamic trees */
  tinf_build_tree(lt, lengths, 0, hlit);
  tinf_build_tree(dt, lengths, hlit, hdist);
}

/* ----------------------------- *
 * -- block inflate functions -- *
 * ----------------------------- */

/* given a stream and two trees, inflate a block of data */
function tinf_inflate_block_data(d, lt, dt) {
  while (1) {
    var sym = tinf_decode_symbol(d, lt);

    /* check for end of block */
    if (sym === 256) {
      return TINF_OK;
    }

    if (sym < 256) {
      d.dest[d.destLen++] = sym;
    } else {
      var length, dist, offs;
      var i;

      sym -= 257;

      /* possibly get more bits from length code */
      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);

      dist = tinf_decode_symbol(d, dt);

      /* possibly get more bits from distance code */
      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);

      /* copy match */
      for (i = offs; i < offs + length; ++i) {
        d.dest[d.destLen++] = d.dest[i];
      }
    }
  }
}

/* inflate an uncompressed block of data */
function tinf_inflate_uncompressed_block(d) {
  var length, invlength;
  var i;
  
  /* unread from bitbuffer */
  while (d.bitcount > 8) {
    d.sourceIndex--;
    d.bitcount -= 8;
  }

  /* get length */
  length = d.source[d.sourceIndex + 1];
  length = 256 * length + d.source[d.sourceIndex];

  /* get one's complement of length */
  invlength = d.source[d.sourceIndex + 3];
  invlength = 256 * invlength + d.source[d.sourceIndex + 2];

  /* check length */
  if (length !== (~invlength & 0x0000ffff))
    { return TINF_DATA_ERROR; }

  d.sourceIndex += 4;

  /* copy block */
  for (i = length; i; --i)
    { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }

  /* make sure we start next block on a byte boundary */
  d.bitcount = 0;

  return TINF_OK;
}

/* inflate stream from source to dest */
function tinf_uncompress(source, dest) {
  var d = new Data(source, dest);
  var bfinal, btype, res;

  do {
    /* read final block flag */
    bfinal = tinf_getbit(d);

    /* read block type (2 bits) */
    btype = tinf_read_bits(d, 2, 0);

    /* decompress block */
    switch (btype) {
      case 0:
        /* decompress uncompressed block */
        res = tinf_inflate_uncompressed_block(d);
        break;
      case 1:
        /* decompress block with fixed huffman trees */
        res = tinf_inflate_block_data(d, sltree, sdtree);
        break;
      case 2:
        /* decompress block with dynamic huffman trees */
        tinf_decode_trees(d, d.ltree, d.dtree);
        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
        break;
      default:
        res = TINF_DATA_ERROR;
    }

    if (res !== TINF_OK)
      { throw new Error('Data error'); }

  } while (!bfinal);

  if (d.destLen < d.dest.length) {
    if (typeof d.dest.slice === 'function')
      { return d.dest.slice(0, d.destLen); }
    else
      { return d.dest.subarray(0, d.destLen); }
  }
  
  return d.dest;
}

/* -------------------- *
 * -- initialization -- *
 * -------------------- */

/* build fixed huffman trees */
tinf_build_fixed_trees(sltree, sdtree);

/* build extra bits and base tables */
tinf_build_bits_base(length_bits, length_base, 4, 3);
tinf_build_bits_base(dist_bits, dist_base, 2, 1);

/* fix a special case */
length_bits[28] = 0;
length_base[28] = 258;

var tinyInflate = tinf_uncompress;

// The Bounding Box object

function derive(v0, v1, v2, v3, t) {
    return Math.pow(1 - t, 3) * v0 +
        3 * Math.pow(1 - t, 2) * t * v1 +
        3 * (1 - t) * Math.pow(t, 2) * v2 +
        Math.pow(t, 3) * v3;
}
/**
 * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.
 * It is used to calculate the bounding box of a glyph or text path.
 *
 * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.
 *
 * @exports opentype.BoundingBox
 * @class
 * @constructor
 */
function BoundingBox() {
    this.x1 = Number.NaN;
    this.y1 = Number.NaN;
    this.x2 = Number.NaN;
    this.y2 = Number.NaN;
}

/**
 * Returns true if the bounding box is empty, that is, no points have been added to the box yet.
 */
BoundingBox.prototype.isEmpty = function() {
    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
};

/**
 * Add the point to the bounding box.
 * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.
 * @param {number} x - The X coordinate of the point.
 * @param {number} y - The Y coordinate of the point.
 */
BoundingBox.prototype.addPoint = function(x, y) {
    if (typeof x === 'number') {
        if (isNaN(this.x1) || isNaN(this.x2)) {
            this.x1 = x;
            this.x2 = x;
        }
        if (x < this.x1) {
            this.x1 = x;
        }
        if (x > this.x2) {
            this.x2 = x;
        }
    }
    if (typeof y === 'number') {
        if (isNaN(this.y1) || isNaN(this.y2)) {
            this.y1 = y;
            this.y2 = y;
        }
        if (y < this.y1) {
            this.y1 = y;
        }
        if (y > this.y2) {
            this.y2 = y;
        }
    }
};

/**
 * Add a X coordinate to the bounding box.
 * This extends the bounding box to include the X coordinate.
 * This function is used internally inside of addBezier.
 * @param {number} x - The X coordinate of the point.
 */
BoundingBox.prototype.addX = function(x) {
    this.addPoint(x, null);
};

/**
 * Add a Y coordinate to the bounding box.
 * This extends the bounding box to include the Y coordinate.
 * This function is used internally inside of addBezier.
 * @param {number} y - The Y coordinate of the point.
 */
BoundingBox.prototype.addY = function(y) {
    this.addPoint(null, y);
};

/**
 * Add a Bzier curve to the bounding box.
 * This extends the bounding box to include the entire Bzier.
 * @param {number} x0 - The starting X coordinate.
 * @param {number} y0 - The starting Y coordinate.
 * @param {number} x1 - The X coordinate of the first control point.
 * @param {number} y1 - The Y coordinate of the first control point.
 * @param {number} x2 - The X coordinate of the second control point.
 * @param {number} y2 - The Y coordinate of the second control point.
 * @param {number} x - The ending X coordinate.
 * @param {number} y - The ending Y coordinate.
 */
BoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {
    var this$1 = this;

    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html
    // and https://github.com/icons8/svg-path-bounding-box

    var p0 = [x0, y0];
    var p1 = [x1, y1];
    var p2 = [x2, y2];
    var p3 = [x, y];

    this.addPoint(x0, y0);
    this.addPoint(x, y);

    for (var i = 0; i <= 1; i++) {
        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
        var c = 3 * p1[i] - 3 * p0[i];

        if (a === 0) {
            if (b === 0) { continue; }
            var t = -c / b;
            if (0 < t && t < 1) {
                if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t)); }
                if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t)); }
            }
            continue;
        }

        var b2ac = Math.pow(b, 2) - 4 * c * a;
        if (b2ac < 0) { continue; }
        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
        if (0 < t1 && t1 < 1) {
            if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
            if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
        }
        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
        if (0 < t2 && t2 < 1) {
            if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
            if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
        }
    }
};

/**
 * Add a quadratic curve to the bounding box.
 * This extends the bounding box to include the entire quadratic curve.
 * @param {number} x0 - The starting X coordinate.
 * @param {number} y0 - The starting Y coordinate.
 * @param {number} x1 - The X coordinate of the control point.
 * @param {number} y1 - The Y coordinate of the control point.
 * @param {number} x - The ending X coordinate.
 * @param {number} y - The ending Y coordinate.
 */
BoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {
    var cp1x = x0 + 2 / 3 * (x1 - x0);
    var cp1y = y0 + 2 / 3 * (y1 - y0);
    var cp2x = cp1x + 1 / 3 * (x - x0);
    var cp2y = cp1y + 1 / 3 * (y - y0);
    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
};

// Geometric objects

/**
 * A bzier path containing a set of path commands similar to a SVG path.
 * Paths can be drawn on a context using `draw`.
 * @exports opentype.Path
 * @class
 * @constructor
 */
function Path() {
    this.commands = [];
    this.fill = 'black';
    this.stroke = null;
    this.strokeWidth = 1;
}

/**
 * @param  {number} x
 * @param  {number} y
 */
Path.prototype.moveTo = function(x, y) {
    this.commands.push({
        type: 'M',
        x: x,
        y: y
    });
};

/**
 * @param  {number} x
 * @param  {number} y
 */
Path.prototype.lineTo = function(x, y) {
    this.commands.push({
        type: 'L',
        x: x,
        y: y
    });
};

/**
 * Draws cubic curve
 * @function
 * curveTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control 1
 * @param  {number} y1 - y of control 1
 * @param  {number} x2 - x of control 2
 * @param  {number} y2 - y of control 2
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 */

/**
 * Draws cubic curve
 * @function
 * bezierCurveTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control 1
 * @param  {number} y1 - y of control 1
 * @param  {number} x2 - x of control 2
 * @param  {number} y2 - y of control 2
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 * @see curveTo
 */
Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
    this.commands.push({
        type: 'C',
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        x: x,
        y: y
    });
};

/**
 * Draws quadratic curve
 * @function
 * quadraticCurveTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control
 * @param  {number} y1 - y of control
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 */

/**
 * Draws quadratic curve
 * @function
 * quadTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control
 * @param  {number} y1 - y of control
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 */
Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
    this.commands.push({
        type: 'Q',
        x1: x1,
        y1: y1,
        x: x,
        y: y
    });
};

/**
 * Closes the path
 * @function closePath
 * @memberof opentype.Path.prototype
 */

/**
 * Close the path
 * @function close
 * @memberof opentype.Path.prototype
 */
Path.prototype.close = Path.prototype.closePath = function() {
    this.commands.push({
        type: 'Z'
    });
};

/**
 * Add the given path or list of commands to the commands of this path.
 * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.
 */
Path.prototype.extend = function(pathOrCommands) {
    if (pathOrCommands.commands) {
        pathOrCommands = pathOrCommands.commands;
    } else if (pathOrCommands instanceof BoundingBox) {
        var box = pathOrCommands;
        this.moveTo(box.x1, box.y1);
        this.lineTo(box.x2, box.y1);
        this.lineTo(box.x2, box.y2);
        this.lineTo(box.x1, box.y2);
        this.close();
        return;
    }

    Array.prototype.push.apply(this.commands, pathOrCommands);
};

/**
 * Calculate the bounding box of the path.
 * @returns {opentype.BoundingBox}
 */
Path.prototype.getBoundingBox = function() {
    var this$1 = this;

    var box = new BoundingBox();

    var startX = 0;
    var startY = 0;
    var prevX = 0;
    var prevY = 0;
    for (var i = 0; i < this.commands.length; i++) {
        var cmd = this$1.commands[i];
        switch (cmd.type) {
            case 'M':
                box.addPoint(cmd.x, cmd.y);
                startX = prevX = cmd.x;
                startY = prevY = cmd.y;
                break;
            case 'L':
                box.addPoint(cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'Q':
                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'C':
                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'Z':
                prevX = startX;
                prevY = startY;
                break;
            default:
                throw new Error('Unexpected path command ' + cmd.type);
        }
    }
    if (box.isEmpty()) {
        box.addPoint(0, 0);
    }
    return box;
};

/**
 * Draw the path to a 2D context.
 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.
 */
Path.prototype.draw = function(ctx) {
    var this$1 = this;

    ctx.beginPath();
    for (var i = 0; i < this.commands.length; i += 1) {
        var cmd = this$1.commands[i];
        if (cmd.type === 'M') {
            ctx.moveTo(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            ctx.lineTo(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            ctx.closePath();
        }
    }

    if (this.fill) {
        ctx.fillStyle = this.fill;
        ctx.fill();
    }

    if (this.stroke) {
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth;
        ctx.stroke();
    }
};

/**
 * Convert the Path to a string of path data instructions
 * See http://www.w3.org/TR/SVG/paths.html#PathData
 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
 * @return {string}
 */
Path.prototype.toPathData = function(decimalPlaces) {
    var this$1 = this;

    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;

    function floatToString(v) {
        if (Math.round(v) === v) {
            return '' + Math.round(v);
        } else {
            return v.toFixed(decimalPlaces);
        }
    }

    function packValues() {
        var arguments$1 = arguments;

        var s = '';
        for (var i = 0; i < arguments.length; i += 1) {
            var v = arguments$1[i];
            if (v >= 0 && i > 0) {
                s += ' ';
            }

            s += floatToString(v);
        }

        return s;
    }

    var d = '';
    for (var i = 0; i < this.commands.length; i += 1) {
        var cmd = this$1.commands[i];
        if (cmd.type === 'M') {
            d += 'M' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            d += 'L' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            d += 'Z';
        }
    }

    return d;
};

/**
 * Convert the path to an SVG <path> element, as a string.
 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
 * @return {string}
 */
Path.prototype.toSVG = function(decimalPlaces) {
    var svg = '<path d="';
    svg += this.toPathData(decimalPlaces);
    svg += '"';
    if (this.fill && this.fill !== 'black') {
        if (this.fill === null) {
            svg += ' fill="none"';
        } else {
            svg += ' fill="' + this.fill + '"';
        }
    }

    if (this.stroke) {
        svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
    }

    svg += '/>';
    return svg;
};

/**
 * Convert the path to a DOM element.
 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
 * @return {SVGPathElement}
 */
Path.prototype.toDOMElement = function(decimalPlaces) {
    var temporaryPath = this.toPathData(decimalPlaces);
    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');

    newPath.setAttribute('d', temporaryPath);

    return newPath;
};

// Run-time checking of preconditions.

function fail(message) {
    throw new Error(message);
}

// Precondition function that checks if the given predicate is true.
// If not, it will throw an error.
function argument(predicate, message) {
    if (!predicate) {
        fail(message);
    }
}

var check = { fail: fail, argument: argument, assert: argument };

// Data types used in the OpenType font file.
// All OpenType fonts use Motorola-style byte ordering (Big Endian)

var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31

/**
 * @exports opentype.decode
 * @class
 */
var decode = {};
/**
 * @exports opentype.encode
 * @class
 */
var encode = {};
/**
 * @exports opentype.sizeOf
 * @class
 */
var sizeOf = {};

// Return a function that always returns the same value.
function constant(v) {
    return function() {
        return v;
    };
}

// OpenType data types //////////////////////////////////////////////////////

/**
 * Convert an 8-bit unsigned integer to a list of 1 byte.
 * @param {number}
 * @returns {Array}
 */
encode.BYTE = function(v) {
    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
    return [v];
};
/**
 * @constant
 * @type {number}
 */
sizeOf.BYTE = constant(1);

/**
 * Convert a 8-bit signed integer to a list of 1 byte.
 * @param {string}
 * @returns {Array}
 */
encode.CHAR = function(v) {
    return [v.charCodeAt(0)];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.CHAR = constant(1);

/**
 * Convert an ASCII string to a list of bytes.
 * @param {string}
 * @returns {Array}
 */
encode.CHARARRAY = function(v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        b[i] = v.charCodeAt(i);
    }

    return b;
};

/**
 * @param {Array}
 * @returns {number}
 */
sizeOf.CHARARRAY = function(v) {
    return v.length;
};

/**
 * Convert a 16-bit unsigned integer to a list of 2 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.USHORT = function(v) {
    return [(v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.USHORT = constant(2);

/**
 * Convert a 16-bit signed integer to a list of 2 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.SHORT = function(v) {
    // Two's complement
    if (v >= LIMIT16) {
        v = -(2 * LIMIT16 - v);
    }

    return [(v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.SHORT = constant(2);

/**
 * Convert a 24-bit unsigned integer to a list of 3 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.UINT24 = function(v) {
    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.UINT24 = constant(3);

/**
 * Convert a 32-bit unsigned integer to a list of 4 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.ULONG = function(v) {
    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.ULONG = constant(4);

/**
 * Convert a 32-bit unsigned integer to a list of 4 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.LONG = function(v) {
    // Two's complement
    if (v >= LIMIT32) {
        v = -(2 * LIMIT32 - v);
    }

    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.LONG = constant(4);

encode.FIXED = encode.ULONG;
sizeOf.FIXED = sizeOf.ULONG;

encode.FWORD = encode.SHORT;
sizeOf.FWORD = sizeOf.SHORT;

encode.UFWORD = encode.USHORT;
sizeOf.UFWORD = sizeOf.USHORT;

/**
 * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.
 * @param {number}
 * @returns {Array}
 */
encode.LONGDATETIME = function(v) {
    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.LONGDATETIME = constant(8);

/**
 * Convert a 4-char tag to a list of 4 bytes.
 * @param {string}
 * @returns {Array}
 */
encode.TAG = function(v) {
    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
    return [v.charCodeAt(0),
            v.charCodeAt(1),
            v.charCodeAt(2),
            v.charCodeAt(3)];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.TAG = constant(4);

// CFF data types ///////////////////////////////////////////////////////////

encode.Card8 = encode.BYTE;
sizeOf.Card8 = sizeOf.BYTE;

encode.Card16 = encode.USHORT;
sizeOf.Card16 = sizeOf.USHORT;

encode.OffSize = encode.BYTE;
sizeOf.OffSize = sizeOf.BYTE;

encode.SID = encode.USHORT;
sizeOf.SID = sizeOf.USHORT;

// Convert a numeric operand or charstring number to a variable-size list of bytes.
/**
 * Convert a numeric operand or charstring number to a variable-size list of bytes.
 * @param {number}
 * @returns {Array}
 */
encode.NUMBER = function(v) {
    if (v >= -107 && v <= 107) {
        return [v + 139];
    } else if (v >= 108 && v <= 1131) {
        v = v - 108;
        return [(v >> 8) + 247, v & 0xFF];
    } else if (v >= -1131 && v <= -108) {
        v = -v - 108;
        return [(v >> 8) + 251, v & 0xFF];
    } else if (v >= -32768 && v <= 32767) {
        return encode.NUMBER16(v);
    } else {
        return encode.NUMBER32(v);
    }
};

/**
 * @param {number}
 * @returns {number}
 */
sizeOf.NUMBER = function(v) {
    return encode.NUMBER(v).length;
};

/**
 * Convert a signed number between -32768 and +32767 to a three-byte value.
 * This ensures we always use three bytes, but is not the most compact format.
 * @param {number}
 * @returns {Array}
 */
encode.NUMBER16 = function(v) {
    return [28, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.NUMBER16 = constant(3);

/**
 * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.
 * This is useful if you want to be sure you always use four bytes,
 * at the expense of wasting a few bytes for smaller numbers.
 * @param {number}
 * @returns {Array}
 */
encode.NUMBER32 = function(v) {
    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.NUMBER32 = constant(5);

/**
 * @param {number}
 * @returns {Array}
 */
encode.REAL = function(v) {
    var value = v.toString();

    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)
    // This code converts it back to a number without the epsilon.
    var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
    if (m) {
        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
        value = (Math.round(v * epsilon) / epsilon).toString();
    }

    var nibbles = '';
    for (var i = 0, ii = value.length; i < ii; i += 1) {
        var c = value[i];
        if (c === 'e') {
            nibbles += value[++i] === '-' ? 'c' : 'b';
        } else if (c === '.') {
            nibbles += 'a';
        } else if (c === '-') {
            nibbles += 'e';
        } else {
            nibbles += c;
        }
    }

    nibbles += (nibbles.length & 1) ? 'f' : 'ff';
    var out = [30];
    for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {
        out.push(parseInt(nibbles.substr(i$1, 2), 16));
    }

    return out;
};

/**
 * @param {number}
 * @returns {number}
 */
sizeOf.REAL = function(v) {
    return encode.REAL(v).length;
};

encode.NAME = encode.CHARARRAY;
sizeOf.NAME = sizeOf.CHARARRAY;

encode.STRING = encode.CHARARRAY;
sizeOf.STRING = sizeOf.CHARARRAY;

/**
 * @param {DataView} data
 * @param {number} offset
 * @param {number} numBytes
 * @returns {string}
 */
decode.UTF8 = function(data, offset, numBytes) {
    var codePoints = [];
    var numChars = numBytes;
    for (var j = 0; j < numChars; j++, offset += 1) {
        codePoints[j] = data.getUint8(offset);
    }

    return String.fromCharCode.apply(null, codePoints);
};

/**
 * @param {DataView} data
 * @param {number} offset
 * @param {number} numBytes
 * @returns {string}
 */
decode.UTF16 = function(data, offset, numBytes) {
    var codePoints = [];
    var numChars = numBytes / 2;
    for (var j = 0; j < numChars; j++, offset += 2) {
        codePoints[j] = data.getUint16(offset);
    }

    return String.fromCharCode.apply(null, codePoints);
};

/**
 * Convert a JavaScript string to UTF16-BE.
 * @param {string}
 * @returns {Array}
 */
encode.UTF16 = function(v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        var codepoint = v.charCodeAt(i);
        b[b.length] = (codepoint >> 8) & 0xFF;
        b[b.length] = codepoint & 0xFF;
    }

    return b;
};

/**
 * @param {string}
 * @returns {number}
 */
sizeOf.UTF16 = function(v) {
    return v.length * 2;
};

// Data for converting old eight-bit Macintosh encodings to Unicode.
// This representation is optimized for decoding; encoding is slower
// and needs more memory. The assumption is that all opentype.js users
// want to open fonts, but saving a font will be comparatively rare
// so it can be more expensive. Keyed by IANA character set name.
//
// Python script for generating these strings:
//
//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])
//     print(s.encode('utf-8'))
/**
 * @private
 */
var eightBitMacEncodings = {
    'x-mac-croatian':  // Python: 'mac_croatian'
    '' +
    '',
    'x-mac-cyrillic':  // Python: 'mac_cyrillic'
    '' +
    '',
    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
    '' +
    '',
    'x-mac-greek':  // Python: 'mac_greek'
    '' +
    '\u00AD',
    'x-mac-icelandic':  // Python: 'mac_iceland'
    '' +
    '',
    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
    '' +
    '',
    'x-mac-ce':  // Python: 'mac_latin2'
    '' +
    '',
    macintosh:  // Python: 'mac_roman'
    '' +
    '',
    'x-mac-romanian':  // Python: 'mac_romanian'
    '' +
    '',
    'x-mac-turkish':  // Python: 'mac_turkish'
    '' +
    ''
};

/**
 * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript
 * string, or 'undefined' if the encoding is unsupported. For example, we do
 * not support Chinese, Japanese or Korean because these would need large
 * mapping tables.
 * @param {DataView} dataView
 * @param {number} offset
 * @param {number} dataLength
 * @param {string} encoding
 * @returns {string}
 */
decode.MACSTRING = function(dataView, offset, dataLength, encoding) {
    var table = eightBitMacEncodings[encoding];
    if (table === undefined) {
        return undefined;
    }

    var result = '';
    for (var i = 0; i < dataLength; i++) {
        var c = dataView.getUint8(offset + i);
        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
        // mapped to U+0000..U+007F; we only need to look up the others.
        if (c <= 0x7F) {
            result += String.fromCharCode(c);
        } else {
            result += table[c & 0x7F];
        }
    }

    return result;
};

// Helper function for encode.MACSTRING. Returns a dictionary for mapping
// Unicode character codes to their 8-bit MacOS equivalent. This table
// is not exactly a super cheap data structure, but we do not care because
// encoding Macintosh strings is only rarely needed in typical applications.
var macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();
var macEncodingCacheKeys;
var getMacEncodingTable = function (encoding) {
    // Since we use encoding as a cache key for WeakMap, it has to be
    // a String object and not a literal. And at least on NodeJS 2.10.1,
    // WeakMap requires that the same String instance is passed for cache hits.
    if (!macEncodingCacheKeys) {
        macEncodingCacheKeys = {};
        for (var e in eightBitMacEncodings) {
            /*jshint -W053 */  // Suppress "Do not use String as a constructor."
            macEncodingCacheKeys[e] = new String(e);
        }
    }

    var cacheKey = macEncodingCacheKeys[encoding];
    if (cacheKey === undefined) {
        return undefined;
    }

    // We can't do "if (cache.has(key)) {return cache.get(key)}" here:
    // since garbage collection may run at any time, it could also kick in
    // between the calls to cache.has() and cache.get(). In that case,
    // we would return 'undefined' even though we do support the encoding.
    if (macEncodingTableCache) {
        var cachedTable = macEncodingTableCache.get(cacheKey);
        if (cachedTable !== undefined) {
            return cachedTable;
        }
    }

    var decodingTable = eightBitMacEncodings[encoding];
    if (decodingTable === undefined) {
        return undefined;
    }

    var encodingTable = {};
    for (var i = 0; i < decodingTable.length; i++) {
        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;
    }

    if (macEncodingTableCache) {
        macEncodingTableCache.set(cacheKey, encodingTable);
    }

    return encodingTable;
};

/**
 * Encodes an old-style Macintosh string. Returns a byte array upon success.
 * If the requested encoding is unsupported, or if the input string contains
 * a character that cannot be expressed in the encoding, the function returns
 * 'undefined'.
 * @param {string} str
 * @param {string} encoding
 * @returns {Array}
 */
encode.MACSTRING = function(str, encoding) {
    var table = getMacEncodingTable(encoding);
    if (table === undefined) {
        return undefined;
    }

    var result = [];
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);

        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
        // mapped to U+0000..U+007F; we only need to look up the others.
        if (c >= 0x80) {
            c = table[c];
            if (c === undefined) {
                // str contains a Unicode character that cannot be encoded
                // in the requested encoding.
                return undefined;
            }
        }
        result[i] = c;
        // result.push(c);
    }

    return result;
};

/**
 * @param {string} str
 * @param {string} encoding
 * @returns {number}
 */
sizeOf.MACSTRING = function(str, encoding) {
    var b = encode.MACSTRING(str, encoding);
    if (b !== undefined) {
        return b.length;
    } else {
        return 0;
    }
};

// Helper for encode.VARDELTAS
function isByteEncodable(value) {
    return value >= -128 && value <= 127;
}

// Helper for encode.VARDELTAS
function encodeVarDeltaRunAsZeroes(deltas, pos, result) {
    var runLength = 0;
    var numDeltas = deltas.length;
    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {
        ++pos;
        ++runLength;
    }
    result.push(0x80 | (runLength - 1));
    return pos;
}

// Helper for encode.VARDELTAS
function encodeVarDeltaRunAsBytes(deltas, offset, result) {
    var runLength = 0;
    var numDeltas = deltas.length;
    var pos = offset;
    while (pos < numDeltas && runLength < 64) {
        var value = deltas[pos];
        if (!isByteEncodable(value)) {
            break;
        }

        // Within a byte-encoded run of deltas, a single zero is best
        // stored literally as 0x00 value. However, if we have two or
        // more zeroes in a sequence, it is better to start a new run.
        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]
        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero
        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)
        // when starting a new run.
        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {
            break;
        }

        ++pos;
        ++runLength;
    }
    result.push(runLength - 1);
    for (var i = offset; i < pos; ++i) {
        result.push((deltas[i] + 256) & 0xff);
    }
    return pos;
}

// Helper for encode.VARDELTAS
function encodeVarDeltaRunAsWords(deltas, offset, result) {
    var runLength = 0;
    var numDeltas = deltas.length;
    var pos = offset;
    while (pos < numDeltas && runLength < 64) {
        var value = deltas[pos];

        // Within a word-encoded run of deltas, it is easiest to start
        // a new run (with a different encoding) whenever we encounter
        // a zero value. For example, the sequence [0x6666, 0, 0x7777]
        // needs 7 bytes when storing the zero inside the current run
        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a
        // new run (40 66 66 80 40 77 77).
        if (value === 0) {
            break;
        }

        // Within a word-encoded run of deltas, a single value in the
        // range (-128..127) should be encoded within the current run
        // because it is more compact. For example, the sequence
        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value
        // literally (42 66 66 00 02 77 77), but 8 bytes when starting
        // a new run (40 66 66 00 02 40 77 77).
        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {
            break;
        }

        ++pos;
        ++runLength;
    }
    result.push(0x40 | (runLength - 1));
    for (var i = offset; i < pos; ++i) {
        var val = deltas[i];
        result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);
    }
    return pos;
}

/**
 * Encode a list of variation adjustment deltas.
 *
 * Variation adjustment deltas are used in gvar and cvar tables.
 * They indicate how points (in gvar) or values (in cvar) get adjusted
 * when generating instances of variation fonts.
 *
 * @see https://www.microsoft.com/typography/otspec/gvar.htm
 * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html
 * @param {Array}
 * @return {Array}
 */
encode.VARDELTAS = function(deltas) {
    var pos = 0;
    var result = [];
    while (pos < deltas.length) {
        var value = deltas[pos];
        if (value === 0) {
            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);
        } else if (value >= -128 && value <= 127) {
            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);
        } else {
            pos = encodeVarDeltaRunAsWords(deltas, pos, result);
        }
    }
    return result;
};

// Convert a list of values to a CFF INDEX structure.
// The values should be objects containing name / type / value.
/**
 * @param {Array} l
 * @returns {Array}
 */
encode.INDEX = function(l) {
    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
    //    i, v;
    // Because we have to know which data type to use to encode the offsets,
    // we have to go through the values twice: once to encode the data and
    // calculate the offsets, then again to encode the offsets using the fitting data type.
    var offset = 1; // First offset is always 1.
    var offsets = [offset];
    var data = [];
    for (var i = 0; i < l.length; i += 1) {
        var v = encode.OBJECT(l[i]);
        Array.prototype.push.apply(data, v);
        offset += v.length;
        offsets.push(offset);
    }

    if (data.length === 0) {
        return [0, 0];
    }

    var encodedOffsets = [];
    var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;
    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
    for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {
        var encodedOffset = offsetEncoder(offsets[i$1]);
        Array.prototype.push.apply(encodedOffsets, encodedOffset);
    }

    return Array.prototype.concat(encode.Card16(l.length),
                           encode.OffSize(offSize),
                           encodedOffsets,
                           data);
};

/**
 * @param {Array}
 * @returns {number}
 */
sizeOf.INDEX = function(v) {
    return encode.INDEX(v).length;
};

/**
 * Convert an object to a CFF DICT structure.
 * The keys should be numeric.
 * The values should be objects containing name / type / value.
 * @param {Object} m
 * @returns {Array}
 */
encode.DICT = function(m) {
    var d = [];
    var keys = Object.keys(m);
    var length = keys.length;

    for (var i = 0; i < length; i += 1) {
        // Object.keys() return string keys, but our keys are always numeric.
        var k = parseInt(keys[i], 0);
        var v = m[k];
        // Value comes before the key.
        d = d.concat(encode.OPERAND(v.value, v.type));
        d = d.concat(encode.OPERATOR(k));
    }

    return d;
};

/**
 * @param {Object}
 * @returns {number}
 */
sizeOf.DICT = function(m) {
    return encode.DICT(m).length;
};

/**
 * @param {number}
 * @returns {Array}
 */
encode.OPERATOR = function(v) {
    if (v < 1200) {
        return [v];
    } else {
        return [12, v - 1200];
    }
};

/**
 * @param {Array} v
 * @param {string}
 * @returns {Array}
 */
encode.OPERAND = function(v, type) {
    var d = [];
    if (Array.isArray(type)) {
        for (var i = 0; i < type.length; i += 1) {
            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);
            d = d.concat(encode.OPERAND(v[i], type[i]));
        }
    } else {
        if (type === 'SID') {
            d = d.concat(encode.NUMBER(v));
        } else if (type === 'offset') {
            // We make it easy for ourselves and always encode offsets as
            // 4 bytes. This makes offset calculation for the top dict easier.
            d = d.concat(encode.NUMBER32(v));
        } else if (type === 'number') {
            d = d.concat(encode.NUMBER(v));
        } else if (type === 'real') {
            d = d.concat(encode.REAL(v));
        } else {
            throw new Error('Unknown operand type ' + type);
            // FIXME Add support for booleans
        }
    }

    return d;
};

encode.OP = encode.BYTE;
sizeOf.OP = sizeOf.BYTE;

// memoize charstring encoding using WeakMap if available
var wmm = typeof WeakMap === 'function' && new WeakMap();

/**
 * Convert a list of CharString operations to bytes.
 * @param {Array}
 * @returns {Array}
 */
encode.CHARSTRING = function(ops) {
    // See encode.MACSTRING for why we don't do "if (wmm && wmm.has(ops))".
    if (wmm) {
        var cachedValue = wmm.get(ops);
        if (cachedValue !== undefined) {
            return cachedValue;
        }
    }

    var d = [];
    var length = ops.length;

    for (var i = 0; i < length; i += 1) {
        var op = ops[i];
        d = d.concat(encode[op.type](op.value));
    }

    if (wmm) {
        wmm.set(ops, d);
    }

    return d;
};

/**
 * @param {Array}
 * @returns {number}
 */
sizeOf.CHARSTRING = function(ops) {
    return encode.CHARSTRING(ops).length;
};

// Utility functions ////////////////////////////////////////////////////////

/**
 * Convert an object containing name / type / value to bytes.
 * @param {Object}
 * @returns {Array}
 */
encode.OBJECT = function(v) {
    var encodingFunction = encode[v.type];
    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
    return encodingFunction(v.value);
};

/**
 * @param {Object}
 * @returns {number}
 */
sizeOf.OBJECT = function(v) {
    var sizeOfFunction = sizeOf[v.type];
    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);
    return sizeOfFunction(v.value);
};

/**
 * Convert a table object to bytes.
 * A table contains a list of fields containing the metadata (name, type and default value).
 * The table itself has the field values set as attributes.
 * @param {opentype.Table}
 * @returns {Array}
 */
encode.TABLE = function(table) {
    var d = [];
    var length = table.fields.length;
    var subtables = [];
    var subtableOffsets = [];

    for (var i = 0; i < length; i += 1) {
        var field = table.fields[i];
        var encodingFunction = encode[field.type];
        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');
        var value = table[field.name];
        if (value === undefined) {
            value = field.value;
        }

        var bytes = encodingFunction(value);

        if (field.type === 'TABLE') {
            subtableOffsets.push(d.length);
            d = d.concat([0, 0]);
            subtables.push(bytes);
        } else {
            d = d.concat(bytes);
        }
    }

    for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {
        var o = subtableOffsets[i$1];
        var offset = d.length;
        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');
        d[o] = offset >> 8;
        d[o + 1] = offset & 0xff;
        d = d.concat(subtables[i$1]);
    }

    return d;
};

/**
 * @param {opentype.Table}
 * @returns {number}
 */
sizeOf.TABLE = function(table) {
    var numBytes = 0;
    var length = table.fields.length;

    for (var i = 0; i < length; i += 1) {
        var field = table.fields[i];
        var sizeOfFunction = sizeOf[field.type];
        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');
        var value = table[field.name];
        if (value === undefined) {
            value = field.value;
        }

        numBytes += sizeOfFunction(value);

        // Subtables take 2 more bytes for offsets.
        if (field.type === 'TABLE') {
            numBytes += 2;
        }
    }

    return numBytes;
};

encode.RECORD = encode.TABLE;
sizeOf.RECORD = sizeOf.TABLE;

// Merge in a list of bytes.
encode.LITERAL = function(v) {
    return v;
};

sizeOf.LITERAL = function(v) {
    return v.length;
};

// Table metadata

/**
 * @exports opentype.Table
 * @class
 * @param {string} tableName
 * @param {Array} fields
 * @param {Object} options
 * @constructor
 */
function Table(tableName, fields, options) {
    var this$1 = this;

    for (var i = 0; i < fields.length; i += 1) {
        var field = fields[i];
        this$1[field.name] = field.value;
    }

    this.tableName = tableName;
    this.fields = fields;
    if (options) {
        var optionKeys = Object.keys(options);
        for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {
            var k = optionKeys[i$1];
            var v = options[k];
            if (this$1[k] !== undefined) {
                this$1[k] = v;
            }
        }
    }
}

/**
 * Encodes the table and returns an array of bytes
 * @return {Array}
 */
Table.prototype.encode = function() {
    return encode.TABLE(this);
};

/**
 * Get the size of the table.
 * @return {number}
 */
Table.prototype.sizeOf = function() {
    return sizeOf.TABLE(this);
};

/**
 * @private
 */
function ushortList(itemName, list, count) {
    if (count === undefined) {
        count = list.length;
    }
    var fields = new Array(list.length + 1);
    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
    for (var i = 0; i < list.length; i++) {
        fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};
    }
    return fields;
}

/**
 * @private
 */
function tableList(itemName, records, itemCallback) {
    var count = records.length;
    var fields = new Array(count + 1);
    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
    for (var i = 0; i < count; i++) {
        fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};
    }
    return fields;
}

/**
 * @private
 */
function recordList(itemName, records, itemCallback) {
    var count = records.length;
    var fields = [];
    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
    for (var i = 0; i < count; i++) {
        fields = fields.concat(itemCallback(records[i], i));
    }
    return fields;
}

// Common Layout Tables

/**
 * @exports opentype.Coverage
 * @class
 * @param {opentype.Table}
 * @constructor
 * @extends opentype.Table
 */
function Coverage(coverageTable) {
    if (coverageTable.format === 1) {
        Table.call(this, 'coverageTable',
            [{name: 'coverageFormat', type: 'USHORT', value: 1}]
            .concat(ushortList('glyph', coverageTable.glyphs))
        );
    } else {
        check.assert(false, 'Can\'t create coverage table format 2 yet.');
    }
}
Coverage.prototype = Object.create(Table.prototype);
Coverage.prototype.constructor = Coverage;

function ScriptList(scriptListTable) {
    Table.call(this, 'scriptListTable',
        recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {
            var script = scriptRecord.script;
            var defaultLangSys = script.defaultLangSys;
            check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');
            return [
                {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},
                {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [
                    {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [
                        {name: 'lookupOrder', type: 'USHORT', value: 0},
                        {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]
                        .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}
                    ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {
                        var langSys = langSysRecord.langSys;
                        return [
                            {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},
                            {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [
                                {name: 'lookupOrder', type: 'USHORT', value: 0},
                                {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}
                                ].concat(ushortList('featureIndex', langSys.featureIndexes)))}
                        ];
                    })))}
            ];
        })
    );
}
ScriptList.prototype = Object.create(Table.prototype);
ScriptList.prototype.constructor = ScriptList;

/**
 * @exports opentype.FeatureList
 * @class
 * @param {opentype.Table}
 * @constructor
 * @extends opentype.Table
 */
function FeatureList(featureListTable) {
    Table.call(this, 'featureListTable',
        recordList('featureRecord', featureListTable, function(featureRecord, i) {
            var feature = featureRecord.feature;
            return [
                {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},
                {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [
                    {name: 'featureParams', type: 'USHORT', value: feature.featureParams} ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}
            ];
        })
    );
}
FeatureList.prototype = Object.create(Table.prototype);
FeatureList.prototype.constructor = FeatureList;

/**
 * @exports opentype.LookupList
 * @class
 * @param {opentype.Table}
 * @param {Object}
 * @constructor
 * @extends opentype.Table
 */
function LookupList(lookupListTable, subtableMakers) {
    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {
        var subtableCallback = subtableMakers[lookupTable.lookupType];
        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');
        return new Table('lookupTable', [
            {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},
            {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}
        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));
    }));
}
LookupList.prototype = Object.create(Table.prototype);
LookupList.prototype.constructor = LookupList;

// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)
// Don't use offsets inside Records (probable bug), only in Tables.
var table = {
    Table: Table,
    Record: Table,
    Coverage: Coverage,
    ScriptList: ScriptList,
    FeatureList: FeatureList,
    LookupList: LookupList,
    ushortList: ushortList,
    tableList: tableList,
    recordList: recordList,
};

// Parsing utility functions

// Retrieve an unsigned byte from the DataView.
function getByte(dataView, offset) {
    return dataView.getUint8(offset);
}

// Retrieve an unsigned 16-bit short from the DataView.
// The value is stored in big endian.
function getUShort(dataView, offset) {
    return dataView.getUint16(offset, false);
}

// Retrieve a signed 16-bit short from the DataView.
// The value is stored in big endian.
function getShort(dataView, offset) {
    return dataView.getInt16(offset, false);
}

// Retrieve an unsigned 32-bit long from the DataView.
// The value is stored in big endian.
function getULong(dataView, offset) {
    return dataView.getUint32(offset, false);
}

// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
// The value is stored in big endian.
function getFixed(dataView, offset) {
    var decimal = dataView.getInt16(offset, false);
    var fraction = dataView.getUint16(offset + 2, false);
    return decimal + fraction / 65535;
}

// Retrieve a 4-character tag from the DataView.
// Tags are used to identify tables.
function getTag(dataView, offset) {
    var tag = '';
    for (var i = offset; i < offset + 4; i += 1) {
        tag += String.fromCharCode(dataView.getInt8(i));
    }

    return tag;
}

// Retrieve an offset from the DataView.
// Offsets are 1 to 4 bytes in length, depending on the offSize argument.
function getOffset(dataView, offset, offSize) {
    var v = 0;
    for (var i = 0; i < offSize; i += 1) {
        v <<= 8;
        v += dataView.getUint8(offset + i);
    }

    return v;
}

// Retrieve a number of bytes from start offset to the end offset from the DataView.
function getBytes(dataView, startOffset, endOffset) {
    var bytes = [];
    for (var i = startOffset; i < endOffset; i += 1) {
        bytes.push(dataView.getUint8(i));
    }

    return bytes;
}

// Convert the list of bytes to a string.
function bytesToString(bytes) {
    var s = '';
    for (var i = 0; i < bytes.length; i += 1) {
        s += String.fromCharCode(bytes[i]);
    }

    return s;
}

var typeOffsets = {
    byte: 1,
    uShort: 2,
    short: 2,
    uLong: 4,
    fixed: 4,
    longDateTime: 8,
    tag: 4
};

// A stateful parser that changes the offset whenever a value is retrieved.
// The data is a DataView.
function Parser(data, offset) {
    this.data = data;
    this.offset = offset;
    this.relativeOffset = 0;
}

Parser.prototype.parseByte = function() {
    var v = this.data.getUint8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseChar = function() {
    var v = this.data.getInt8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseCard8 = Parser.prototype.parseByte;

Parser.prototype.parseUShort = function() {
    var v = this.data.getUint16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
Parser.prototype.parseSID = Parser.prototype.parseUShort;
Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;

Parser.prototype.parseShort = function() {
    var v = this.data.getInt16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseF2Dot14 = function() {
    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseULong = function() {
    var v = getULong(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseOffset32 = Parser.prototype.parseULong;

Parser.prototype.parseFixed = function() {
    var v = getFixed(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseString = function(length) {
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    var string = '';
    this.relativeOffset += length;
    for (var i = 0; i < length; i++) {
        string += String.fromCharCode(dataView.getUint8(offset + i));
    }

    return string;
};

Parser.prototype.parseTag = function() {
    return this.parseString(4);
};

// LONGDATETIME is a 64-bit integer.
// JavaScript and unix timestamps traditionally use 32 bits, so we
// only take the last 32 bits.
// + Since until 2038 those bits will be filled by zeros we can ignore them.
Parser.prototype.parseLongDateTime = function() {
    var v = getULong(this.data, this.offset + this.relativeOffset + 4);
    // Subtract seconds between 01/01/1904 and 01/01/1970
    // to convert Apple Mac timestamp to Standard Unix timestamp
    v -= 2082844800;
    this.relativeOffset += 8;
    return v;
};

Parser.prototype.parseVersion = function(minorBase) {
    var major = getUShort(this.data, this.offset + this.relativeOffset);

    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
    // Default returns the correct number if minor = 0xN000 where N is 0-9
    // Set minorBase to 1 for tables that use minor = N where N is 0-9
    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
    this.relativeOffset += 4;
    if (minorBase === undefined) { minorBase = 0x1000; }
    return major + minor / minorBase / 10;
};

Parser.prototype.skip = function(type, amount) {
    if (amount === undefined) {
        amount = 1;
    }

    this.relativeOffset += typeOffsets[type] * amount;
};

///// Parsing lists and records ///////////////////////////////

// Parse a list of 32 bit unsigned integers.
Parser.prototype.parseULongList = function(count) {
    if (count === undefined) { count = this.parseULong(); }
    var offsets = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        offsets[i] = dataView.getUint32(offset);
        offset += 4;
    }

    this.relativeOffset += count * 4;
    return offsets;
};

// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream
// or provided as an argument.
Parser.prototype.parseOffset16List =
Parser.prototype.parseUShortList = function(count) {
    if (count === undefined) { count = this.parseUShort(); }
    var offsets = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        offsets[i] = dataView.getUint16(offset);
        offset += 2;
    }

    this.relativeOffset += count * 2;
    return offsets;
};

// Parses a list of 16 bit signed integers.
Parser.prototype.parseShortList = function(count) {
    var list = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        list[i] = dataView.getInt16(offset);
        offset += 2;
    }

    this.relativeOffset += count * 2;
    return list;
};

// Parses a list of bytes.
Parser.prototype.parseByteList = function(count) {
    var list = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        list[i] = dataView.getUint8(offset++);
    }

    this.relativeOffset += count;
    return list;
};

/**
 * Parse a list of items.
 * Record count is optional, if omitted it is read from the stream.
 * itemCallback is one of the Parser methods.
 */
Parser.prototype.parseList = function(count, itemCallback) {
    var this$1 = this;

    if (!itemCallback) {
        itemCallback = count;
        count = this.parseUShort();
    }
    var list = new Array(count);
    for (var i = 0; i < count; i++) {
        list[i] = itemCallback.call(this$1);
    }
    return list;
};

Parser.prototype.parseList32 = function(count, itemCallback) {
    var this$1 = this;

    if (!itemCallback) {
        itemCallback = count;
        count = this.parseULong();
    }
    var list = new Array(count);
    for (var i = 0; i < count; i++) {
        list[i] = itemCallback.call(this$1);
    }
    return list;
};

/**
 * Parse a list of records.
 * Record count is optional, if omitted it is read from the stream.
 * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
 */
Parser.prototype.parseRecordList = function(count, recordDescription) {
    var this$1 = this;

    // If the count argument is absent, read it in the stream.
    if (!recordDescription) {
        recordDescription = count;
        count = this.parseUShort();
    }
    var records = new Array(count);
    var fields = Object.keys(recordDescription);
    for (var i = 0; i < count; i++) {
        var rec = {};
        for (var j = 0; j < fields.length; j++) {
            var fieldName = fields[j];
            var fieldType = recordDescription[fieldName];
            rec[fieldName] = fieldType.call(this$1);
        }
        records[i] = rec;
    }
    return records;
};

Parser.prototype.parseRecordList32 = function(count, recordDescription) {
    var this$1 = this;

    // If the count argument is absent, read it in the stream.
    if (!recordDescription) {
        recordDescription = count;
        count = this.parseULong();
    }
    var records = new Array(count);
    var fields = Object.keys(recordDescription);
    for (var i = 0; i < count; i++) {
        var rec = {};
        for (var j = 0; j < fields.length; j++) {
            var fieldName = fields[j];
            var fieldType = recordDescription[fieldName];
            rec[fieldName] = fieldType.call(this$1);
        }
        records[i] = rec;
    }
    return records;
};

// Parse a data structure into an object
// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
Parser.prototype.parseStruct = function(description) {
    var this$1 = this;

    if (typeof description === 'function') {
        return description.call(this);
    } else {
        var fields = Object.keys(description);
        var struct = {};
        for (var j = 0; j < fields.length; j++) {
            var fieldName = fields[j];
            var fieldType = description[fieldName];
            struct[fieldName] = fieldType.call(this$1);
        }
        return struct;
    }
};

/**
 * Parse a GPOS valueRecord
 * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
 * valueFormat is optional, if omitted it is read from the stream.
 */
Parser.prototype.parseValueRecord = function(valueFormat) {
    if (valueFormat === undefined) {
        valueFormat = this.parseUShort();
    }
    if (valueFormat === 0) {
        // valueFormat2 in kerning pairs is most often 0
        // in this case return undefined instead of an empty object, to save space
        return;
    }
    var valueRecord = {};

    if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }
    if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }
    if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }
    if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }

    // Device table (non-variable font) / VariationIndex table (variable font) not supported
    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls
    if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }
    if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }
    if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }
    if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }

    return valueRecord;
};

/**
 * Parse a list of GPOS valueRecords
 * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
 * valueFormat and valueCount are read from the stream.
 */
Parser.prototype.parseValueRecordList = function() {
    var this$1 = this;

    var valueFormat = this.parseUShort();
    var valueCount = this.parseUShort();
    var values = new Array(valueCount);
    for (var i = 0; i < valueCount; i++) {
        values[i] = this$1.parseValueRecord(valueFormat);
    }
    return values;
};

Parser.prototype.parsePointer = function(description) {
    var structOffset = this.parseOffset16();
    if (structOffset > 0) {
        // NULL offset => return undefined
        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
    }
    return undefined;
};

Parser.prototype.parsePointer32 = function(description) {
    var structOffset = this.parseOffset32();
    if (structOffset > 0) {
        // NULL offset => return undefined
        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
    }
    return undefined;
};

/**
 * Parse a list of offsets to lists of 16-bit integers,
 * or a list of offsets to lists of offsets to any kind of items.
 * If itemCallback is not provided, a list of list of UShort is assumed.
 * If provided, itemCallback is called on each item and must parse the item.
 * See examples in tables/gsub.js
 */
Parser.prototype.parseListOfLists = function(itemCallback) {
    var this$1 = this;

    var offsets = this.parseOffset16List();
    var count = offsets.length;
    var relativeOffset = this.relativeOffset;
    var list = new Array(count);
    for (var i = 0; i < count; i++) {
        var start = offsets[i];
        if (start === 0) {
            // NULL offset
            // Add i as owned property to list. Convenient with assert.
            list[i] = undefined;
            continue;
        }
        this$1.relativeOffset = start;
        if (itemCallback) {
            var subOffsets = this$1.parseOffset16List();
            var subList = new Array(subOffsets.length);
            for (var j = 0; j < subOffsets.length; j++) {
                this$1.relativeOffset = start + subOffsets[j];
                subList[j] = itemCallback.call(this$1);
            }
            list[i] = subList;
        } else {
            list[i] = this$1.parseUShortList();
        }
    }
    this.relativeOffset = relativeOffset;
    return list;
};

///// Complex tables parsing //////////////////////////////////

// Parse a coverage table in a GSUB, GPOS or GDEF table.
// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
// parser.offset must point to the start of the table containing the coverage.
Parser.prototype.parseCoverage = function() {
    var this$1 = this;

    var startOffset = this.offset + this.relativeOffset;
    var format = this.parseUShort();
    var count = this.parseUShort();
    if (format === 1) {
        return {
            format: 1,
            glyphs: this.parseUShortList(count)
        };
    } else if (format === 2) {
        var ranges = new Array(count);
        for (var i = 0; i < count; i++) {
            ranges[i] = {
                start: this$1.parseUShort(),
                end: this$1.parseUShort(),
                index: this$1.parseUShort()
            };
        }
        return {
            format: 2,
            ranges: ranges
        };
    }
    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');
};

// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
Parser.prototype.parseClassDef = function() {
    var startOffset = this.offset + this.relativeOffset;
    var format = this.parseUShort();
    if (format === 1) {
        return {
            format: 1,
            startGlyph: this.parseUShort(),
            classes: this.parseUShortList()
        };
    } else if (format === 2) {
        return {
            format: 2,
            ranges: this.parseRecordList({
                start: Parser.uShort,
                end: Parser.uShort,
                classId: Parser.uShort
            })
        };
    }
    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');
};

///// Static methods ///////////////////////////////////
// These convenience methods can be used as callbacks and should be called with "this" context set to a Parser instance.

Parser.list = function(count, itemCallback) {
    return function() {
        return this.parseList(count, itemCallback);
    };
};

Parser.list32 = function(count, itemCallback) {
    return function() {
        return this.parseList32(count, itemCallback);
    };
};

Parser.recordList = function(count, recordDescription) {
    return function() {
        return this.parseRecordList(count, recordDescription);
    };
};

Parser.recordList32 = function(count, recordDescription) {
    return function() {
        return this.parseRecordList32(count, recordDescription);
    };
};

Parser.pointer = function(description) {
    return function() {
        return this.parsePointer(description);
    };
};

Parser.pointer32 = function(description) {
    return function() {
        return this.parsePointer32(description);
    };
};

Parser.tag = Parser.prototype.parseTag;
Parser.byte = Parser.prototype.parseByte;
Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort;
Parser.uShortList = Parser.prototype.parseUShortList;
Parser.uLong = Parser.offset32 = Parser.prototype.parseULong;
Parser.uLongList = Parser.prototype.parseULongList;
Parser.struct = Parser.prototype.parseStruct;
Parser.coverage = Parser.prototype.parseCoverage;
Parser.classDef = Parser.prototype.parseClassDef;

///// Script, Feature, Lookup lists ///////////////////////////////////////////////
// https://www.microsoft.com/typography/OTSPEC/chapter2.htm

var langSysTable = {
    reserved: Parser.uShort,
    reqFeatureIndex: Parser.uShort,
    featureIndexes: Parser.uShortList
};

Parser.prototype.parseScriptList = function() {
    return this.parsePointer(Parser.recordList({
        tag: Parser.tag,
        script: Parser.pointer({
            defaultLangSys: Parser.pointer(langSysTable),
            langSysRecords: Parser.recordList({
                tag: Parser.tag,
                langSys: Parser.pointer(langSysTable)
            })
        })
    })) || [];
};

Parser.prototype.parseFeatureList = function() {
    return this.parsePointer(Parser.recordList({
        tag: Parser.tag,
        feature: Parser.pointer({
            featureParams: Parser.offset16,
            lookupListIndexes: Parser.uShortList
        })
    })) || [];
};

Parser.prototype.parseLookupList = function(lookupTableParsers) {
    return this.parsePointer(Parser.list(Parser.pointer(function() {
        var lookupType = this.parseUShort();
        check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');
        var lookupFlag = this.parseUShort();
        var useMarkFilteringSet = lookupFlag & 0x10;
        return {
            lookupType: lookupType,
            lookupFlag: lookupFlag,
            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),
            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined
        };
    }))) || [];
};

Parser.prototype.parseFeatureVariationsList = function() {
    return this.parsePointer32(function() {
        var majorVersion = this.parseUShort();
        var minorVersion = this.parseUShort();
        check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');
        var featureVariations = this.parseRecordList32({
            conditionSetOffset: Parser.offset32,
            featureTableSubstitutionOffset: Parser.offset32
        });
        return featureVariations;
    }) || [];
};

var parse = {
    getByte: getByte,
    getCard8: getByte,
    getUShort: getUShort,
    getCard16: getUShort,
    getShort: getShort,
    getULong: getULong,
    getFixed: getFixed,
    getTag: getTag,
    getOffset: getOffset,
    getBytes: getBytes,
    bytesToString: bytesToString,
    Parser: Parser,
};

// The `cmap` table stores the mappings from characters to glyphs.
// https://www.microsoft.com/typography/OTSPEC/cmap.htm

function parseCmapTableFormat12(cmap, p) {
    //Skip reserved.
    p.parseUShort();

    // Length in bytes of the sub-tables.
    cmap.length = p.parseULong();
    cmap.language = p.parseULong();

    var groupCount;
    cmap.groupCount = groupCount = p.parseULong();
    cmap.glyphIndexMap = {};

    for (var i = 0; i < groupCount; i += 1) {
        var startCharCode = p.parseULong();
        var endCharCode = p.parseULong();
        var startGlyphId = p.parseULong();

        for (var c = startCharCode; c <= endCharCode; c += 1) {
            cmap.glyphIndexMap[c] = startGlyphId;
            startGlyphId++;
        }
    }
}

function parseCmapTableFormat4(cmap, p, data, start, offset) {
    // Length in bytes of the sub-tables.
    cmap.length = p.parseUShort();
    cmap.language = p.parseUShort();

    // segCount is stored x 2.
    var segCount;
    cmap.segCount = segCount = p.parseUShort() >> 1;

    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);

    // The "unrolled" mapping from character codes to glyph indices.
    cmap.glyphIndexMap = {};
    var endCountParser = new parse.Parser(data, start + offset + 14);
    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
    var glyphIndexOffset = start + offset + 16 + segCount * 8;
    for (var i = 0; i < segCount - 1; i += 1) {
        var glyphIndex = (void 0);
        var endCount = endCountParser.parseUShort();
        var startCount = startCountParser.parseUShort();
        var idDelta = idDeltaParser.parseShort();
        var idRangeOffset = idRangeOffsetParser.parseUShort();
        for (var c = startCount; c <= endCount; c += 1) {
            if (idRangeOffset !== 0) {
                // The idRangeOffset is relative to the current position in the idRangeOffset array.
                // Take the current offset in the idRangeOffset array.
                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);

                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
                glyphIndexOffset += idRangeOffset;

                // Then add the character index of the current segment, multiplied by 2 for USHORTs.
                glyphIndexOffset += (c - startCount) * 2;
                glyphIndex = parse.getUShort(data, glyphIndexOffset);
                if (glyphIndex !== 0) {
                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;
                }
            } else {
                glyphIndex = (c + idDelta) & 0xFFFF;
            }

            cmap.glyphIndexMap[c] = glyphIndex;
        }
    }
}

// Parse the `cmap` table. This table stores the mappings from characters to glyphs.
// There are many available formats, but we only support the Windows format 4 and 12.
// This function returns a `CmapEncoding` object or null if no supported format could be found.
function parseCmapTable(data, start) {
    var cmap = {};
    cmap.version = parse.getUShort(data, start);
    check.argument(cmap.version === 0, 'cmap table version should be 0.');

    // The cmap table can contain many sub-tables, each with their own format.
    // We're only interested in a "platform 3" table. This is a Windows format.
    cmap.numTables = parse.getUShort(data, start + 2);
    var offset = -1;
    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {
        var platformId = parse.getUShort(data, start + 4 + (i * 8));
        var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);
        if (platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) {
            offset = parse.getULong(data, start + 4 + (i * 8) + 4);
            break;
        }
    }

    if (offset === -1) {
        // There is no cmap table in the font that we support.
        throw new Error('No valid cmap sub-tables found.');
    }

    var p = new parse.Parser(data, start + offset);
    cmap.format = p.parseUShort();

    if (cmap.format === 12) {
        parseCmapTableFormat12(cmap, p);
    } else if (cmap.format === 4) {
        parseCmapTableFormat4(cmap, p, data, start, offset);
    } else {
        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');
    }

    return cmap;
}

function addSegment(t, code, glyphIndex) {
    t.segments.push({
        end: code,
        start: code,
        delta: -(code - glyphIndex),
        offset: 0,
        glyphIndex: glyphIndex
    });
}

function addTerminatorSegment(t) {
    t.segments.push({
        end: 0xFFFF,
        start: 0xFFFF,
        delta: 1,
        offset: 0
    });
}

// Make cmap table, format 4 by default, 12 if needed only
function makeCmapTable(glyphs) {
    // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)
    var isPlan0Only = true;
    var i;

    // Check if we need to add cmap format 12 or if format 4 only is fine
    for (i = glyphs.length - 1; i > 0; i -= 1) {
        var g = glyphs.get(i);
        if (g.unicode > 65535) {
            console.log('Adding CMAP format 12 (needed!)');
            isPlan0Only = false;
            break;
        }
    }

    var cmapTable = [
        {name: 'version', type: 'USHORT', value: 0},
        {name: 'numTables', type: 'USHORT', value: isPlan0Only ? 1 : 2},

        // CMAP 4 header
        {name: 'platformID', type: 'USHORT', value: 3},
        {name: 'encodingID', type: 'USHORT', value: 1},
        {name: 'offset', type: 'ULONG', value: isPlan0Only ? 12 : (12 + 8)}
    ];

    if (!isPlan0Only)
        { cmapTable = cmapTable.concat([
            // CMAP 12 header
            {name: 'cmap12PlatformID', type: 'USHORT', value: 3}, // We encode only for PlatformID = 3 (Windows) because it is supported everywhere
            {name: 'cmap12EncodingID', type: 'USHORT', value: 10},
            {name: 'cmap12Offset', type: 'ULONG', value: 0}
        ]); }

    cmapTable = cmapTable.concat([
        // CMAP 4 Subtable
        {name: 'format', type: 'USHORT', value: 4},
        {name: 'cmap4Length', type: 'USHORT', value: 0},
        {name: 'language', type: 'USHORT', value: 0},
        {name: 'segCountX2', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);

    var t = new table.Table('cmap', cmapTable);

    t.segments = [];
    for (i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        for (var j = 0; j < glyph.unicodes.length; j += 1) {
            addSegment(t, glyph.unicodes[j], i);
        }

        t.segments = t.segments.sort(function (a, b) {
            return a.start - b.start;
        });
    }

    addTerminatorSegment(t);

    var segCount = t.segments.length;
    var segCountToRemove = 0;

    // CMAP 4
    // Set up parallel segment arrays.
    var endCounts = [];
    var startCounts = [];
    var idDeltas = [];
    var idRangeOffsets = [];
    var glyphIds = [];

    // CMAP 12
    var cmap12Groups = [];

    // Reminder this loop is not following the specification at 100%
    // The specification -> find suites of characters and make a group
    // Here we're doing one group for each letter
    // Doing as the spec can save 8 times (or more) space
    for (i = 0; i < segCount; i += 1) {
        var segment = t.segments[i];

        // CMAP 4
        if (segment.end <= 65535 && segment.start <= 65535) {
            endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});
            startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});
            idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});
            idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});
            if (segment.glyphId !== undefined) {
                glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});
            }
        } else {
            // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12
            segCountToRemove += 1;
        }

        // CMAP 12
        // Skip Terminator Segment
        if (!isPlan0Only && segment.glyphIndex !== undefined) {
            cmap12Groups = cmap12Groups.concat({name: 'cmap12Start_' + i, type: 'ULONG', value: segment.start});
            cmap12Groups = cmap12Groups.concat({name: 'cmap12End_' + i, type: 'ULONG', value: segment.end});
            cmap12Groups = cmap12Groups.concat({name: 'cmap12Glyph_' + i, type: 'ULONG', value: segment.glyphIndex});
        }
    }

    // CMAP 4 Subtable
    t.segCountX2 = (segCount - segCountToRemove) * 2;
    t.searchRange = Math.pow(2, Math.floor(Math.log((segCount - segCountToRemove)) / Math.log(2))) * 2;
    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
    t.rangeShift = t.segCountX2 - t.searchRange;

    t.fields = t.fields.concat(endCounts);
    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});
    t.fields = t.fields.concat(startCounts);
    t.fields = t.fields.concat(idDeltas);
    t.fields = t.fields.concat(idRangeOffsets);
    t.fields = t.fields.concat(glyphIds);

    t.cmap4Length = 14 + // Subtable header
        endCounts.length * 2 +
        2 + // reservedPad
        startCounts.length * 2 +
        idDeltas.length * 2 +
        idRangeOffsets.length * 2 +
        glyphIds.length * 2;

    if (!isPlan0Only) {
        // CMAP 12 Subtable
        var cmap12Length = 16 + // Subtable header
            cmap12Groups.length * 4;

        t.cmap12Offset = 12 + (2 * 2) + 4 + t.cmap4Length;
        t.fields = t.fields.concat([
            {name: 'cmap12Format', type: 'USHORT', value: 12},
            {name: 'cmap12Reserved', type: 'USHORT', value: 0},
            {name: 'cmap12Length', type: 'ULONG', value: cmap12Length},
            {name: 'cmap12Language', type: 'ULONG', value: 0},
            {name: 'cmap12nGroups', type: 'ULONG', value: cmap12Groups.length / 3}
        ]);

        t.fields = t.fields.concat(cmap12Groups);
    }

    return t;
}

var cmap = { parse: parseCmapTable, make: makeCmapTable };

// Glyph encoding

var cffStandardStrings = [
    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',
    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',
    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',
    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',
    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',
    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',
    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',
    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',
    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',
    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',
    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',
    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',
    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',
    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',
    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',
    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',
    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',
    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',
    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',
    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',
    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',
    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',
    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',
    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',
    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',
    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',
    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',
    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',
    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',
    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',
    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',
    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];

var cffStandardEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',
    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',
    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',
    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',
    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',
    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',
    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',
    'lslash', 'oslash', 'oe', 'germandbls'];

var cffExpertEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',
    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',
    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',
    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',
    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',
    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',
    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',
    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',
    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',
    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',
    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',
    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',
    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',
    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',
    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',
    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',
    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',
    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];

var standardNames = [
    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',
    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',
    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',
    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',
    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',
    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',
    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',
    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',
    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',
    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',
    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',
    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',
    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',
    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',
    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',
    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',
    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',
    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',
    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',
    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',
    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',
    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',
    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];

/**
 * This is the encoding used for fonts created from scratch.
 * It loops through all glyphs and finds the appropriate unicode value.
 * Since it's linear time, other encodings will be faster.
 * @exports opentype.DefaultEncoding
 * @class
 * @constructor
 * @param {opentype.Font}
 */
function DefaultEncoding(font) {
    this.font = font;
}

DefaultEncoding.prototype.charToGlyphIndex = function(c) {
    var code = c.charCodeAt(0);
    var glyphs = this.font.glyphs;
    if (glyphs) {
        for (var i = 0; i < glyphs.length; i += 1) {
            var glyph = glyphs.get(i);
            for (var j = 0; j < glyph.unicodes.length; j += 1) {
                if (glyph.unicodes[j] === code) {
                    return i;
                }
            }
        }
    }
    return null;
};

/**
 * @exports opentype.CmapEncoding
 * @class
 * @constructor
 * @param {Object} cmap - a object with the cmap encoded data
 */
function CmapEncoding(cmap) {
    this.cmap = cmap;
}

/**
 * @param  {string} c - the character
 * @return {number} The glyph index.
 */
CmapEncoding.prototype.charToGlyphIndex = function(c) {
    return this.cmap.glyphIndexMap[c.charCodeAt(0)] || 0;
};

/**
 * @exports opentype.CffEncoding
 * @class
 * @constructor
 * @param {string} encoding - The encoding
 * @param {Array} charset - The character set.
 */
function CffEncoding(encoding, charset) {
    this.encoding = encoding;
    this.charset = charset;
}

/**
 * @param  {string} s - The character
 * @return {number} The index.
 */
CffEncoding.prototype.charToGlyphIndex = function(s) {
    var code = s.charCodeAt(0);
    var charName = this.encoding[code];
    return this.charset.indexOf(charName);
};

/**
 * @exports opentype.GlyphNames
 * @class
 * @constructor
 * @param {Object} post
 */
function GlyphNames(post) {
    var this$1 = this;

    switch (post.version) {
        case 1:
            this.names = standardNames.slice();
            break;
        case 2:
            this.names = new Array(post.numberOfGlyphs);
            for (var i = 0; i < post.numberOfGlyphs; i++) {
                if (post.glyphNameIndex[i] < standardNames.length) {
                    this$1.names[i] = standardNames[post.glyphNameIndex[i]];
                } else {
                    this$1.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];
                }
            }

            break;
        case 2.5:
            this.names = new Array(post.numberOfGlyphs);
            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
                this$1.names[i$1] = standardNames[i$1 + post.glyphNameIndex[i$1]];
            }

            break;
        case 3:
            this.names = [];
            break;
        default:
            this.names = [];
            break;
    }
}

/**
 * Gets the index of a glyph by name.
 * @param  {string} name - The glyph name
 * @return {number} The index
 */
GlyphNames.prototype.nameToGlyphIndex = function(name) {
    return this.names.indexOf(name);
};

/**
 * @param  {number} gid
 * @return {string}
 */
GlyphNames.prototype.glyphIndexToName = function(gid) {
    return this.names[gid];
};

/**
 * @alias opentype.addGlyphNames
 * @param {opentype.Font}
 */
function addGlyphNames(font) {
    var glyph;
    var glyphIndexMap = font.tables.cmap.glyphIndexMap;
    var charCodes = Object.keys(glyphIndexMap);

    for (var i = 0; i < charCodes.length; i += 1) {
        var c = charCodes[i];
        var glyphIndex = glyphIndexMap[c];
        glyph = font.glyphs.get(glyphIndex);
        glyph.addUnicode(parseInt(c));
    }

    for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {
        glyph = font.glyphs.get(i$1);
        if (font.cffEncoding) {
            if (font.isCIDFont) {
                glyph.name = 'gid' + i$1;
            } else {
                glyph.name = font.cffEncoding.charset[i$1];
            }
        } else if (font.glyphNames.names) {
            glyph.name = font.glyphNames.glyphIndexToName(i$1);
        }
    }
}

// Drawing utility functions.

// Draw a line on the given context from point `x1,y1` to point `x2,y2`.
function line(ctx, x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
}

var draw = { line: line };

// The `glyf` table describes the glyphs in TrueType outline format.
// http://www.microsoft.com/typography/otspec/glyf.htm

// Parse the coordinate data for a glyph.
function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
    var v;
    if ((flag & shortVectorBitMask) > 0) {
        // The coordinate is 1 byte long.
        v = p.parseByte();
        // The `same` bit is re-used for short values to signify the sign of the value.
        if ((flag & sameBitMask) === 0) {
            v = -v;
        }

        v = previousValue + v;
    } else {
        //  The coordinate is 2 bytes long.
        // If the `same` bit is set, the coordinate is the same as the previous coordinate.
        if ((flag & sameBitMask) > 0) {
            v = previousValue;
        } else {
            // Parse the coordinate as a signed 16-bit delta value.
            v = previousValue + p.parseShort();
        }
    }

    return v;
}

// Parse a TrueType glyph.
function parseGlyph(glyph, data, start) {
    var p = new parse.Parser(data, start);
    glyph.numberOfContours = p.parseShort();
    glyph._xMin = p.parseShort();
    glyph._yMin = p.parseShort();
    glyph._xMax = p.parseShort();
    glyph._yMax = p.parseShort();
    var flags;
    var flag;

    if (glyph.numberOfContours > 0) {
        // This glyph is not a composite.
        var endPointIndices = glyph.endPointIndices = [];
        for (var i = 0; i < glyph.numberOfContours; i += 1) {
            endPointIndices.push(p.parseUShort());
        }

        glyph.instructionLength = p.parseUShort();
        glyph.instructions = [];
        for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {
            glyph.instructions.push(p.parseByte());
        }

        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
        flags = [];
        for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {
            flag = p.parseByte();
            flags.push(flag);
            // If bit 3 is set, we repeat this flag n times, where n is the next byte.
            if ((flag & 8) > 0) {
                var repeatCount = p.parseByte();
                for (var j = 0; j < repeatCount; j += 1) {
                    flags.push(flag);
                    i$2 += 1;
                }
            }
        }

        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');

        if (endPointIndices.length > 0) {
            var points = [];
            var point;
            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
            if (numberOfCoordinates > 0) {
                for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {
                    flag = flags[i$3];
                    point = {};
                    point.onCurve = !!(flag & 1);
                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;
                    points.push(point);
                }

                var px = 0;
                for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {
                    flag = flags[i$4];
                    point = points[i$4];
                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
                    px = point.x;
                }

                var py = 0;
                for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {
                    flag = flags[i$5];
                    point = points[i$5];
                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
                    py = point.y;
                }
            }

            glyph.points = points;
        } else {
            glyph.points = [];
        }
    } else if (glyph.numberOfContours === 0) {
        glyph.points = [];
    } else {
        glyph.isComposite = true;
        glyph.points = [];
        glyph.components = [];
        var moreComponents = true;
        while (moreComponents) {
            flags = p.parseUShort();
            var component = {
                glyphIndex: p.parseUShort(),
                xScale: 1,
                scale01: 0,
                scale10: 0,
                yScale: 1,
                dx: 0,
                dy: 0
            };
            if ((flags & 1) > 0) {
                // The arguments are words
                if ((flags & 2) > 0) {
                    // values are offset
                    component.dx = p.parseShort();
                    component.dy = p.parseShort();
                } else {
                    // values are matched points
                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];
                }

            } else {
                // The arguments are bytes
                if ((flags & 2) > 0) {
                    // values are offset
                    component.dx = p.parseChar();
                    component.dy = p.parseChar();
                } else {
                    // values are matched points
                    component.matchedPoints = [p.parseByte(), p.parseByte()];
                }
            }

            if ((flags & 8) > 0) {
                // We have a scale
                component.xScale = component.yScale = p.parseF2Dot14();
            } else if ((flags & 64) > 0) {
                // We have an X / Y scale
                component.xScale = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            } else if ((flags & 128) > 0) {
                // We have a 2x2 transformation
                component.xScale = p.parseF2Dot14();
                component.scale01 = p.parseF2Dot14();
                component.scale10 = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            }

            glyph.components.push(component);
            moreComponents = !!(flags & 32);
        }
        if (flags & 0x100) {
            // We have instructions
            glyph.instructionLength = p.parseUShort();
            glyph.instructions = [];
            for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {
                glyph.instructions.push(p.parseByte());
            }
        }
    }
}

// Transform an array of points and return a new array.
function transformPoints(points, transform) {
    var newPoints = [];
    for (var i = 0; i < points.length; i += 1) {
        var pt = points[i];
        var newPt = {
            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
            onCurve: pt.onCurve,
            lastPointOfContour: pt.lastPointOfContour
        };
        newPoints.push(newPt);
    }

    return newPoints;
}

function getContours(points) {
    var contours = [];
    var currentContour = [];
    for (var i = 0; i < points.length; i += 1) {
        var pt = points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }

    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
}

// Convert the TrueType glyph outline to a Path.
function getPath(points) {
    var p = new Path();
    if (!points) {
        return p;
    }

    var contours = getContours(points);

    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {
        var contour = contours[contourIndex];

        var prev = null;
        var curr = contour[contour.length - 1];
        var next = contour[0];

        if (curr.onCurve) {
            p.moveTo(curr.x, curr.y);
        } else {
            if (next.onCurve) {
                p.moveTo(next.x, next.y);
            } else {
                // If both first and last points are off-curve, start at their middle.
                var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};
                p.moveTo(start.x, start.y);
            }
        }

        for (var i = 0; i < contour.length; ++i) {
            prev = curr;
            curr = next;
            next = contour[(i + 1) % contour.length];

            if (curr.onCurve) {
                // This is a straight line.
                p.lineTo(curr.x, curr.y);
            } else {
                var prev2 = prev;
                var next2 = next;

                if (!prev.onCurve) {
                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };
                    p.lineTo(prev2.x, prev2.y);
                }

                if (!next.onCurve) {
                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
                }

                p.lineTo(prev2.x, prev2.y);
                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);
            }
        }

        p.closePath();
    }
    return p;
}

function buildPath(glyphs, glyph) {
    if (glyph.isComposite) {
        for (var j = 0; j < glyph.components.length; j += 1) {
            var component = glyph.components[j];
            var componentGlyph = glyphs.get(component.glyphIndex);
            // Force the ttfGlyphLoader to parse the glyph.
            componentGlyph.getPath();
            if (componentGlyph.points) {
                var transformedPoints = (void 0);
                if (component.matchedPoints === undefined) {
                    // component positioned by offset
                    transformedPoints = transformPoints(componentGlyph.points, component);
                } else {
                    // component positioned by matched points
                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||
                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {
                        throw Error('Matched points out of range in ' + glyph.name);
                    }
                    var firstPt = glyph.points[component.matchedPoints[0]];
                    var secondPt = componentGlyph.points[component.matchedPoints[1]];
                    var transform = {
                        xScale: component.xScale, scale01: component.scale01,
                        scale10: component.scale10, yScale: component.yScale,
                        dx: 0, dy: 0
                    };
                    secondPt = transformPoints([secondPt], transform)[0];
                    transform.dx = firstPt.x - secondPt.x;
                    transform.dy = firstPt.y - secondPt.y;
                    transformedPoints = transformPoints(componentGlyph.points, transform);
                }
                glyph.points = glyph.points.concat(transformedPoints);
            }
        }
    }

    return getPath(glyph.points);
}

// Parse all the glyphs according to the offsets from the `loca` table.
function parseGlyfTable(data, start, loca, font) {
    var glyphs = new glyphset.GlyphSet(font);

    // The last element of the loca table is invalid.
    for (var i = 0; i < loca.length - 1; i += 1) {
        var offset = loca[i];
        var nextOffset = loca[i + 1];
        if (offset !== nextOffset) {
            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
        } else {
            glyphs.push(i, glyphset.glyphLoader(font, i));
        }
    }

    return glyphs;
}

var glyf = { getPath: getPath, parse: parseGlyfTable };

// The Glyph object

function getPathDefinition(glyph, path) {
    var _path = path || new Path();
    return {
        configurable: true,

        get: function() {
            if (typeof _path === 'function') {
                _path = _path();
            }

            return _path;
        },

        set: function(p) {
            _path = p;
        }
    };
}
/**
 * @typedef GlyphOptions
 * @type Object
 * @property {string} [name] - The glyph name
 * @property {number} [unicode]
 * @property {Array} [unicodes]
 * @property {number} [xMin]
 * @property {number} [yMin]
 * @property {number} [xMax]
 * @property {number} [yMax]
 * @property {number} [advanceWidth]
 */

// A Glyph is an individual mark that often corresponds to a character.
// Some glyphs, such as ligatures, are a combination of many characters.
// Glyphs are the basic building blocks of a font.
//
// The `Glyph` class contains utility methods for drawing the path and its points.
/**
 * @exports opentype.Glyph
 * @class
 * @param {GlyphOptions}
 * @constructor
 */
function Glyph(options) {
    // By putting all the code on a prototype function (which is only declared once)
    // we reduce the memory requirements for larger fonts by some 2%
    this.bindConstructorValues(options);
}

/**
 * @param  {GlyphOptions}
 */
Glyph.prototype.bindConstructorValues = function(options) {
    this.index = options.index || 0;

    // These three values cannot be deferred for memory optimization:
    this.name = options.name || null;
    this.unicode = options.unicode || undefined;
    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];

    // But by binding these values only when necessary, we reduce can
    // the memory requirements by almost 3% for larger fonts.
    if (options.xMin) {
        this.xMin = options.xMin;
    }

    if (options.yMin) {
        this.yMin = options.yMin;
    }

    if (options.xMax) {
        this.xMax = options.xMax;
    }

    if (options.yMax) {
        this.yMax = options.yMax;
    }

    if (options.advanceWidth) {
        this.advanceWidth = options.advanceWidth;
    }

    // The path for a glyph is the most memory intensive, and is bound as a value
    // with a getter/setter to ensure we actually do path parsing only once the
    // path is actually needed by anything.
    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));
};

/**
 * @param {number}
 */
Glyph.prototype.addUnicode = function(unicode) {
    if (this.unicodes.length === 0) {
        this.unicode = unicode;
    }

    this.unicodes.push(unicode);
};

/**
 * Calculate the minimum bounding box for this glyph.
 * @return {opentype.BoundingBox}
 */
Glyph.prototype.getBoundingBox = function() {
    return this.path.getBoundingBox();
};

/**
 * Convert the glyph to a Path we can draw on a drawing context.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {Object=} options - xScale, yScale to stretch the glyph.
 * @param  {opentype.Font} if hinting is to be used, the font
 * @return {opentype.Path}
 */
Glyph.prototype.getPath = function(x, y, fontSize, options, font) {
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    var commands;
    var hPoints;
    if (!options) { options = { }; }
    var xScale = options.xScale;
    var yScale = options.yScale;

    if (options.hinting && font && font.hinting) {
        // in case of hinting, the hinting engine takes care
        // of scaling the points (not the path) before hinting.
        hPoints = this.path && font.hinting.exec(this, fontSize);
        // in case the hinting engine failed hPoints is undefined
        // and thus reverts to plain rending
    }

    if (hPoints) {
        commands = glyf.getPath(hPoints).commands;
        x = Math.round(x);
        y = Math.round(y);
        // TODO in case of hinting xyScaling is not yet supported
        xScale = yScale = 1;
    } else {
        commands = this.path.commands;
        var scale = 1 / this.path.unitsPerEm * fontSize;
        if (xScale === undefined) { xScale = scale; }
        if (yScale === undefined) { yScale = scale; }
    }

    var p = new Path();
    for (var i = 0; i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type === 'M') {
            p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'L') {
            p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'Q') {
            p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
                               x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'C') {
            p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
                      x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),
                      x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'Z') {
            p.closePath();
        }
    }

    return p;
};

/**
 * Split the glyph into contours.
 * This function is here for backwards compatibility, and to
 * provide raw access to the TrueType glyph outlines.
 * @return {Array}
 */
Glyph.prototype.getContours = function() {
    var this$1 = this;

    if (this.points === undefined) {
        return [];
    }

    var contours = [];
    var currentContour = [];
    for (var i = 0; i < this.points.length; i += 1) {
        var pt = this$1.points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }

    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
};

/**
 * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
 * @return {Object}
 */
Glyph.prototype.getMetrics = function() {
    var commands = this.path.commands;
    var xCoords = [];
    var yCoords = [];
    for (var i = 0; i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type !== 'Z') {
            xCoords.push(cmd.x);
            yCoords.push(cmd.y);
        }

        if (cmd.type === 'Q' || cmd.type === 'C') {
            xCoords.push(cmd.x1);
            yCoords.push(cmd.y1);
        }

        if (cmd.type === 'C') {
            xCoords.push(cmd.x2);
            yCoords.push(cmd.y2);
        }
    }

    var metrics = {
        xMin: Math.min.apply(null, xCoords),
        yMin: Math.min.apply(null, yCoords),
        xMax: Math.max.apply(null, xCoords),
        yMax: Math.max.apply(null, yCoords),
        leftSideBearing: this.leftSideBearing
    };

    if (!isFinite(metrics.xMin)) {
        metrics.xMin = 0;
    }

    if (!isFinite(metrics.xMax)) {
        metrics.xMax = this.advanceWidth;
    }

    if (!isFinite(metrics.yMin)) {
        metrics.yMin = 0;
    }

    if (!isFinite(metrics.yMax)) {
        metrics.yMax = 0;
    }

    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
    return metrics;
};

/**
 * Draw the glyph on the given context.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {Object=} options - xScale, yScale to stretch the glyph.
 */
Glyph.prototype.draw = function(ctx, x, y, fontSize, options) {
    this.getPath(x, y, fontSize, options).draw(ctx);
};

/**
 * Draw the points of the glyph.
 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 */
Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
    function drawCircles(l, x, y, scale) {
        var PI_SQ = Math.PI * 2;
        ctx.beginPath();
        for (var j = 0; j < l.length; j += 1) {
            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));
            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, PI_SQ, false);
        }

        ctx.closePath();
        ctx.fill();
    }

    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    var scale = 1 / this.path.unitsPerEm * fontSize;

    var blueCircles = [];
    var redCircles = [];
    var path = this.path;
    for (var i = 0; i < path.commands.length; i += 1) {
        var cmd = path.commands[i];
        if (cmd.x !== undefined) {
            blueCircles.push({x: cmd.x, y: -cmd.y});
        }

        if (cmd.x1 !== undefined) {
            redCircles.push({x: cmd.x1, y: -cmd.y1});
        }

        if (cmd.x2 !== undefined) {
            redCircles.push({x: cmd.x2, y: -cmd.y2});
        }
    }

    ctx.fillStyle = 'blue';
    drawCircles(blueCircles, x, y, scale);
    ctx.fillStyle = 'red';
    drawCircles(redCircles, x, y, scale);
};

/**
 * Draw lines indicating important font measurements.
 * Black lines indicate the origin of the coordinate system (point 0,0).
 * Blue lines indicate the glyph bounding box.
 * Green line indicates the advance width of the glyph.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 */
Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
    var scale;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    scale = 1 / this.path.unitsPerEm * fontSize;
    ctx.lineWidth = 1;

    // Draw the origin
    ctx.strokeStyle = 'black';
    draw.line(ctx, x, -10000, x, 10000);
    draw.line(ctx, -10000, y, 10000, y);

    // This code is here due to memory optimization: by not using
    // defaults in the constructor, we save a notable amount of memory.
    var xMin = this.xMin || 0;
    var yMin = this.yMin || 0;
    var xMax = this.xMax || 0;
    var yMax = this.yMax || 0;
    var advanceWidth = this.advanceWidth || 0;

    // Draw the glyph box
    ctx.strokeStyle = 'blue';
    draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);
    draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);
    draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));
    draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));

    // Draw the advance width
    ctx.strokeStyle = 'green';
    draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);
};

// The GlyphSet object

// Define a property on the glyph that depends on the path being loaded.
function defineDependentProperty(glyph, externalName, internalName) {
    Object.defineProperty(glyph, externalName, {
        get: function() {
            // Request the path property to make sure the path is loaded.
            glyph.path; // jshint ignore:line
            return glyph[internalName];
        },
        set: function(newValue) {
            glyph[internalName] = newValue;
        },
        enumerable: true,
        configurable: true
    });
}

/**
 * A GlyphSet represents all glyphs available in the font, but modelled using
 * a deferred glyph loader, for retrieving glyphs only once they are absolutely
 * necessary, to keep the memory footprint down.
 * @exports opentype.GlyphSet
 * @class
 * @param {opentype.Font}
 * @param {Array}
 */
function GlyphSet(font, glyphs) {
    var this$1 = this;

    this.font = font;
    this.glyphs = {};
    if (Array.isArray(glyphs)) {
        for (var i = 0; i < glyphs.length; i++) {
            this$1.glyphs[i] = glyphs[i];
        }
    }

    this.length = (glyphs && glyphs.length) || 0;
}

/**
 * @param  {number} index
 * @return {opentype.Glyph}
 */
GlyphSet.prototype.get = function(index) {
    if (typeof this.glyphs[index] === 'function') {
        this.glyphs[index] = this.glyphs[index]();
    }

    return this.glyphs[index];
};

/**
 * @param  {number} index
 * @param  {Object}
 */
GlyphSet.prototype.push = function(index, loader) {
    this.glyphs[index] = loader;
    this.length++;
};

/**
 * @alias opentype.glyphLoader
 * @param  {opentype.Font} font
 * @param  {number} index
 * @return {opentype.Glyph}
 */
function glyphLoader(font, index) {
    return new Glyph({index: index, font: font});
}

/**
 * Generate a stub glyph that can be filled with all metadata *except*
 * the "points" and "path" properties, which must be loaded only once
 * the glyph's path is actually requested for text shaping.
 * @alias opentype.ttfGlyphLoader
 * @param  {opentype.Font} font
 * @param  {number} index
 * @param  {Function} parseGlyph
 * @param  {Object} data
 * @param  {number} position
 * @param  {Function} buildPath
 * @return {opentype.Glyph}
 */
function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {
    return function() {
        var glyph = new Glyph({index: index, font: font});

        glyph.path = function() {
            parseGlyph(glyph, data, position);
            var path = buildPath(font.glyphs, glyph);
            path.unitsPerEm = font.unitsPerEm;
            return path;
        };

        defineDependentProperty(glyph, 'xMin', '_xMin');
        defineDependentProperty(glyph, 'xMax', '_xMax');
        defineDependentProperty(glyph, 'yMin', '_yMin');
        defineDependentProperty(glyph, 'yMax', '_yMax');

        return glyph;
    };
}
/**
 * @alias opentype.cffGlyphLoader
 * @param  {opentype.Font} font
 * @param  {number} index
 * @param  {Function} parseCFFCharstring
 * @param  {string} charstring
 * @return {opentype.Glyph}
 */
function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {
    return function() {
        var glyph = new Glyph({index: index, font: font});

        glyph.path = function() {
            var path = parseCFFCharstring(font, glyph, charstring);
            path.unitsPerEm = font.unitsPerEm;
            return path;
        };

        return glyph;
    };
}

var glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };

// The `CFF` table contains the glyph outlines in PostScript format.
// https://www.microsoft.com/typography/OTSPEC/cff.htm
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/cff.pdf
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/type2.pdf

// Custom equals function that can also check lists.
function equals(a, b) {
    if (a === b) {
        return true;
    } else if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return false;
        }

        for (var i = 0; i < a.length; i += 1) {
            if (!equals(a[i], b[i])) {
                return false;
            }
        }

        return true;
    } else {
        return false;
    }
}

// Subroutines are encoded using the negative half of the number space.
// See type 2 chapter 4.7 "Subroutine operators".
function calcCFFSubroutineBias(subrs) {
    var bias;
    if (subrs.length < 1240) {
        bias = 107;
    } else if (subrs.length < 33900) {
        bias = 1131;
    } else {
        bias = 32768;
    }

    return bias;
}

// Parse a `CFF` INDEX array.
// An index array consists of a list of offsets, then a list of objects at those offsets.
function parseCFFIndex(data, start, conversionFn) {
    var offsets = [];
    var objects = [];
    var count = parse.getCard16(data, start);
    var objectOffset;
    var endOffset;
    if (count !== 0) {
        var offsetSize = parse.getByte(data, start + 2);
        objectOffset = start + ((count + 1) * offsetSize) + 2;
        var pos = start + 3;
        for (var i = 0; i < count + 1; i += 1) {
            offsets.push(parse.getOffset(data, pos, offsetSize));
            pos += offsetSize;
        }

        // The total size of the index array is 4 header bytes + the value of the last offset.
        endOffset = objectOffset + offsets[count];
    } else {
        endOffset = start + 2;
    }

    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {
        var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);
        if (conversionFn) {
            value = conversionFn(value);
        }

        objects.push(value);
    }

    return {objects: objects, startOffset: start, endOffset: endOffset};
}

// Parse a `CFF` DICT real value.
function parseFloatOperand(parser) {
    var s = '';
    var eof = 15;
    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
    while (true) {
        var b = parser.parseByte();
        var n1 = b >> 4;
        var n2 = b & 15;

        if (n1 === eof) {
            break;
        }

        s += lookup[n1];

        if (n2 === eof) {
            break;
        }

        s += lookup[n2];
    }

    return parseFloat(s);
}

// Parse a `CFF` DICT operand.
function parseOperand(parser, b0) {
    var b1;
    var b2;
    var b3;
    var b4;
    if (b0 === 28) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        return b1 << 8 | b2;
    }

    if (b0 === 29) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        b3 = parser.parseByte();
        b4 = parser.parseByte();
        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
    }

    if (b0 === 30) {
        return parseFloatOperand(parser);
    }

    if (b0 >= 32 && b0 <= 246) {
        return b0 - 139;
    }

    if (b0 >= 247 && b0 <= 250) {
        b1 = parser.parseByte();
        return (b0 - 247) * 256 + b1 + 108;
    }

    if (b0 >= 251 && b0 <= 254) {
        b1 = parser.parseByte();
        return -(b0 - 251) * 256 - b1 - 108;
    }

    throw new Error('Invalid b0 ' + b0);
}

// Convert the entries returned by `parseDict` to a proper dictionary.
// If a value is a list of one, it is unpacked.
function entriesToObject(entries) {
    var o = {};
    for (var i = 0; i < entries.length; i += 1) {
        var key = entries[i][0];
        var values = entries[i][1];
        var value = (void 0);
        if (values.length === 1) {
            value = values[0];
        } else {
            value = values;
        }

        if (o.hasOwnProperty(key) && !isNaN(o[key])) {
            throw new Error('Object ' + o + ' already has key ' + key);
        }

        o[key] = value;
    }

    return o;
}

// Parse a `CFF` DICT object.
// A dictionary contains key-value pairs in a compact tokenized format.
function parseCFFDict(data, start, size) {
    start = start !== undefined ? start : 0;
    var parser = new parse.Parser(data, start);
    var entries = [];
    var operands = [];
    size = size !== undefined ? size : data.length;

    while (parser.relativeOffset < size) {
        var op = parser.parseByte();

        // The first byte for each dict item distinguishes between operator (key) and operand (value).
        // Values <= 21 are operators.
        if (op <= 21) {
            // Two-byte operators have an initial escape byte of 12.
            if (op === 12) {
                op = 1200 + parser.parseByte();
            }

            entries.push([op, operands]);
            operands = [];
        } else {
            // Since the operands (values) come before the operators (keys), we store all operands in a list
            // until we encounter an operator.
            operands.push(parseOperand(parser, op));
        }
    }

    return entriesToObject(entries);
}

// Given a String Index (SID), return the value of the string.
// Strings below index 392 are standard CFF strings and are not encoded in the font.
function getCFFString(strings, index) {
    if (index <= 390) {
        index = cffStandardStrings[index];
    } else {
        index = strings[index - 391];
    }

    return index;
}

// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
function interpretDict(dict, meta, strings) {
    var newDict = {};
    var value;

    // Because we also want to include missing values, we start out from the meta list
    // and lookup values in the dict.
    for (var i = 0; i < meta.length; i += 1) {
        var m = meta[i];

        if (Array.isArray(m.type)) {
            var values = [];
            values.length = m.type.length;
            for (var j = 0; j < m.type.length; j++) {
                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;
                if (value === undefined) {
                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;
                }
                if (m.type[j] === 'SID') {
                    value = getCFFString(strings, value);
                }
                values[j] = value;
            }
            newDict[m.name] = values;
        } else {
            value = dict[m.op];
            if (value === undefined) {
                value = m.value !== undefined ? m.value : null;
            }

            if (m.type === 'SID') {
                value = getCFFString(strings, value);
            }
            newDict[m.name] = value;
        }
    }

    return newDict;
}

// Parse the CFF header.
function parseCFFHeader(data, start) {
    var header = {};
    header.formatMajor = parse.getCard8(data, start);
    header.formatMinor = parse.getCard8(data, start + 1);
    header.size = parse.getCard8(data, start + 2);
    header.offsetSize = parse.getCard8(data, start + 3);
    header.startOffset = start;
    header.endOffset = start + 4;
    return header;
}

var TOP_DICT_META = [
    {name: 'version', op: 0, type: 'SID'},
    {name: 'notice', op: 1, type: 'SID'},
    {name: 'copyright', op: 1200, type: 'SID'},
    {name: 'fullName', op: 2, type: 'SID'},
    {name: 'familyName', op: 3, type: 'SID'},
    {name: 'weight', op: 4, type: 'SID'},
    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},
    {name: 'italicAngle', op: 1202, type: 'number', value: 0},
    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},
    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},
    {name: 'paintType', op: 1205, type: 'number', value: 0},
    {name: 'charstringType', op: 1206, type: 'number', value: 2},
    {
        name: 'fontMatrix',
        op: 1207,
        type: ['real', 'real', 'real', 'real', 'real', 'real'],
        value: [0.001, 0, 0, 0.001, 0, 0]
    },
    {name: 'uniqueId', op: 13, type: 'number'},
    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},
    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},
    {name: 'xuid', op: 14, type: [], value: null},
    {name: 'charset', op: 15, type: 'offset', value: 0},
    {name: 'encoding', op: 16, type: 'offset', value: 0},
    {name: 'charStrings', op: 17, type: 'offset', value: 0},
    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},
    {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},
    {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},
    {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},
    {name: 'cidFontType', op: 1233, type: 'number', value: 0},
    {name: 'cidCount', op: 1234, type: 'number', value: 8720},
    {name: 'uidBase', op: 1235, type: 'number'},
    {name: 'fdArray', op: 1236, type: 'offset'},
    {name: 'fdSelect', op: 1237, type: 'offset'},
    {name: 'fontName', op: 1238, type: 'SID'}
];

var PRIVATE_DICT_META = [
    {name: 'subrs', op: 19, type: 'offset', value: 0},
    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},
    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}
];

// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
// The top dictionary contains the essential metadata for the font, together with the private dictionary.
function parseCFFTopDict(data, strings) {
    var dict = parseCFFDict(data, 0, data.byteLength);
    return interpretDict(dict, TOP_DICT_META, strings);
}

// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
function parseCFFPrivateDict(data, start, size, strings) {
    var dict = parseCFFDict(data, start, size);
    return interpretDict(dict, PRIVATE_DICT_META, strings);
}

// Returns a list of "Top DICT"s found using an INDEX list.
// Used to read both the usual high-level Top DICTs and also the FDArray
// discovered inside CID-keyed fonts.  When a Top DICT has a reference to
// a Private DICT that is read and saved into the Top DICT.
//
// In addition to the expected/optional values as outlined in TOP_DICT_META
// the following values might be saved into the Top DICT.
//
//    _subrs []        array of local CFF subroutines from Private DICT
//    _subrsBias       bias value computed from number of subroutines
//                      (see calcCFFSubroutineBias() and parseCFFCharstring())
//    _defaultWidthX   default widths for CFF characters
//    _nominalWidthX   bias added to width embedded within glyph description
//
//    _privateDict     saved copy of parsed Private DICT from Top DICT
function gatherCFFTopDicts(data, start, cffIndex, strings) {
    var topDictArray = [];
    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {
        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);
        var topDict = parseCFFTopDict(topDictData, strings);
        topDict._subrs = [];
        topDict._subrsBias = 0;
        var privateSize = topDict.private[0];
        var privateOffset = topDict.private[1];
        if (privateSize !== 0 && privateOffset !== 0) {
            var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);
            topDict._defaultWidthX = privateDict.defaultWidthX;
            topDict._nominalWidthX = privateDict.nominalWidthX;
            if (privateDict.subrs !== 0) {
                var subrOffset = privateOffset + privateDict.subrs;
                var subrIndex = parseCFFIndex(data, subrOffset + start);
                topDict._subrs = subrIndex.objects;
                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);
            }
            topDict._privateDict = privateDict;
        }
        topDictArray.push(topDict);
    }
    return topDictArray;
}

// Parse the CFF charset table, which contains internal names for all the glyphs.
// This function will return a list of glyph names.
// See Adobe TN #5176 chapter 13, "Charsets".
function parseCFFCharset(data, start, nGlyphs, strings) {
    var sid;
    var count;
    var parser = new parse.Parser(data, start);

    // The .notdef glyph is not included, so subtract 1.
    nGlyphs -= 1;
    var charset = ['.notdef'];

    var format = parser.parseCard8();
    if (format === 0) {
        for (var i = 0; i < nGlyphs; i += 1) {
            sid = parser.parseSID();
            charset.push(getCFFString(strings, sid));
        }
    } else if (format === 1) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard8();
            for (var i$1 = 0; i$1 <= count; i$1 += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else if (format === 2) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard16();
            for (var i$2 = 0; i$2 <= count; i$2 += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else {
        throw new Error('Unknown charset format ' + format);
    }

    return charset;
}

// Parse the CFF encoding data. Only one encoding can be specified per font.
// See Adobe TN #5176 chapter 12, "Encodings".
function parseCFFEncoding(data, start, charset) {
    var code;
    var enc = {};
    var parser = new parse.Parser(data, start);
    var format = parser.parseCard8();
    if (format === 0) {
        var nCodes = parser.parseCard8();
        for (var i = 0; i < nCodes; i += 1) {
            code = parser.parseCard8();
            enc[code] = i;
        }
    } else if (format === 1) {
        var nRanges = parser.parseCard8();
        code = 1;
        for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {
            var first = parser.parseCard8();
            var nLeft = parser.parseCard8();
            for (var j = first; j <= first + nLeft; j += 1) {
                enc[j] = code;
                code += 1;
            }
        }
    } else {
        throw new Error('Unknown encoding format ' + format);
    }

    return new CffEncoding(enc, charset);
}

// Take in charstring code and return a Glyph object.
// The encoding is described in the Type 2 Charstring Format
// https://www.microsoft.com/typography/OTSPEC/charstr2.htm
function parseCFFCharstring(font, glyph, code) {
    var c1x;
    var c1y;
    var c2x;
    var c2y;
    var p = new Path();
    var stack = [];
    var nStems = 0;
    var haveWidth = false;
    var open = false;
    var x = 0;
    var y = 0;
    var subrs;
    var subrsBias;
    var defaultWidthX;
    var nominalWidthX;
    if (font.isCIDFont) {
        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];
        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];
        subrs = fdDict._subrs;
        subrsBias = fdDict._subrsBias;
        defaultWidthX = fdDict._defaultWidthX;
        nominalWidthX = fdDict._nominalWidthX;
    } else {
        subrs = font.tables.cff.topDict._subrs;
        subrsBias = font.tables.cff.topDict._subrsBias;
        defaultWidthX = font.tables.cff.topDict._defaultWidthX;
        nominalWidthX = font.tables.cff.topDict._nominalWidthX;
    }
    var width = defaultWidthX;

    function newContour(x, y) {
        if (open) {
            p.closePath();
        }

        p.moveTo(x, y);
        open = true;
    }

    function parseStems() {
        var hasWidthArg;

        // The number of stem operators on the stack is always even.
        // If the value is uneven, that means a width is specified.
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
            width = stack.shift() + nominalWidthX;
        }

        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
    }

    function parse$$1(code) {
        var b1;
        var b2;
        var b3;
        var b4;
        var codeIndex;
        var subrCode;
        var jpx;
        var jpy;
        var c3x;
        var c3y;
        var c4x;
        var c4y;

        var i = 0;
        while (i < code.length) {
            var v = code[i];
            i += 1;
            switch (v) {
                case 1: // hstem
                    parseStems();
                    break;
                case 3: // vstem
                    parseStems();
                    break;
                case 4: // vmoveto
                    if (stack.length > 1 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }

                    y += stack.pop();
                    newContour(x, y);
                    break;
                case 5: // rlineto
                    while (stack.length > 0) {
                        x += stack.shift();
                        y += stack.shift();
                        p.lineTo(x, y);
                    }

                    break;
                case 6: // hlineto
                    while (stack.length > 0) {
                        x += stack.shift();
                        p.lineTo(x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        y += stack.shift();
                        p.lineTo(x, y);
                    }

                    break;
                case 7: // vlineto
                    while (stack.length > 0) {
                        y += stack.shift();
                        p.lineTo(x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        x += stack.shift();
                        p.lineTo(x, y);
                    }

                    break;
                case 8: // rrcurveto
                    while (stack.length > 0) {
                        c1x = x + stack.shift();
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 10: // callsubr
                    codeIndex = stack.pop() + subrsBias;
                    subrCode = subrs[codeIndex];
                    if (subrCode) {
                        parse$$1(subrCode);
                    }

                    break;
                case 11: // return
                    return;
                case 12: // flex operators
                    v = code[i];
                    i += 1;
                    switch (v) {
                        case 35: // flex
                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-
                            c1x = x   + stack.shift();    // dx1
                            c1y = y   + stack.shift();    // dy1
                            c2x = c1x + stack.shift();    // dx2
                            c2y = c1y + stack.shift();    // dy2
                            jpx = c2x + stack.shift();    // dx3
                            jpy = c2y + stack.shift();    // dy3
                            c3x = jpx + stack.shift();    // dx4
                            c3y = jpy + stack.shift();    // dy4
                            c4x = c3x + stack.shift();    // dx5
                            c4y = c3y + stack.shift();    // dy5
                            x = c4x   + stack.shift();    // dx6
                            y = c4y   + stack.shift();    // dy6
                            stack.shift();                // flex depth
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 34: // hflex
                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-
                            c1x = x   + stack.shift();    // dx1
                            c1y = y;                      // dy1
                            c2x = c1x + stack.shift();    // dx2
                            c2y = c1y + stack.shift();    // dy2
                            jpx = c2x + stack.shift();    // dx3
                            jpy = c2y;                    // dy3
                            c3x = jpx + stack.shift();    // dx4
                            c3y = c2y;                    // dy4
                            c4x = c3x + stack.shift();    // dx5
                            c4y = y;                      // dy5
                            x = c4x + stack.shift();      // dx6
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 36: // hflex1
                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-
                            c1x = x   + stack.shift();    // dx1
                            c1y = y   + stack.shift();    // dy1
                            c2x = c1x + stack.shift();    // dx2
                            c2y = c1y + stack.shift();    // dy2
                            jpx = c2x + stack.shift();    // dx3
                            jpy = c2y;                    // dy3
                            c3x = jpx + stack.shift();    // dx4
                            c3y = c2y;                    // dy4
                            c4x = c3x + stack.shift();    // dx5
                            c4y = c3y + stack.shift();    // dy5
                            x = c4x + stack.shift();      // dx6
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 37: // flex1
                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-
                            c1x = x   + stack.shift();    // dx1
                            c1y = y   + stack.shift();    // dy1
                            c2x = c1x + stack.shift();    // dx2
                            c2y = c1y + stack.shift();    // dy2
                            jpx = c2x + stack.shift();    // dx3
                            jpy = c2y + stack.shift();    // dy3
                            c3x = jpx + stack.shift();    // dx4
                            c3y = jpy + stack.shift();    // dy4
                            c4x = c3x + stack.shift();    // dx5
                            c4y = c3y + stack.shift();    // dy5
                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
                                x = c4x + stack.shift();
                            } else {
                                y = c4y + stack.shift();
                            }

                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        default:
                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);
                            stack.length = 0;
                    }
                    break;
                case 14: // endchar
                    if (stack.length > 0 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }

                    if (open) {
                        p.closePath();
                        open = false;
                    }

                    break;
                case 18: // hstemhm
                    parseStems();
                    break;
                case 19: // hintmask
                case 20: // cntrmask
                    parseStems();
                    i += (nStems + 7) >> 3;
                    break;
                case 21: // rmoveto
                    if (stack.length > 2 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }

                    y += stack.pop();
                    x += stack.pop();
                    newContour(x, y);
                    break;
                case 22: // hmoveto
                    if (stack.length > 1 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }

                    x += stack.pop();
                    newContour(x, y);
                    break;
                case 23: // vstemhm
                    parseStems();
                    break;
                case 24: // rcurveline
                    while (stack.length > 2) {
                        c1x = x + stack.shift();
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    x += stack.shift();
                    y += stack.shift();
                    p.lineTo(x, y);
                    break;
                case 25: // rlinecurve
                    while (stack.length > 6) {
                        x += stack.shift();
                        y += stack.shift();
                        p.lineTo(x, y);
                    }

                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    break;
                case 26: // vvcurveto
                    if (stack.length % 2) {
                        x += stack.shift();
                    }

                    while (stack.length > 0) {
                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x;
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 27: // hhcurveto
                    if (stack.length % 2) {
                        y += stack.shift();
                    }

                    while (stack.length > 0) {
                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y;
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 28: // shortint
                    b1 = code[i];
                    b2 = code[i + 1];
                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);
                    i += 2;
                    break;
                case 29: // callgsubr
                    codeIndex = stack.pop() + font.gsubrsBias;
                    subrCode = font.gsubrs[codeIndex];
                    if (subrCode) {
                        parse$$1(subrCode);
                    }

                    break;
                case 30: // vhcurveto
                    while (stack.length > 0) {
                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        y = c2y + stack.shift();
                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 31: // hvcurveto
                    while (stack.length > 0) {
                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        y = c2y + stack.shift();
                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                default:
                    if (v < 32) {
                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);
                    } else if (v < 247) {
                        stack.push(v - 139);
                    } else if (v < 251) {
                        b1 = code[i];
                        i += 1;
                        stack.push((v - 247) * 256 + b1 + 108);
                    } else if (v < 255) {
                        b1 = code[i];
                        i += 1;
                        stack.push(-(v - 251) * 256 - b1 - 108);
                    } else {
                        b1 = code[i];
                        b2 = code[i + 1];
                        b3 = code[i + 2];
                        b4 = code[i + 3];
                        i += 4;
                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);
                    }
            }
        }
    }

    parse$$1(code);

    glyph.advanceWidth = width;
    return p;
}

function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {
    var fdSelect = [];
    var fdIndex;
    var parser = new parse.Parser(data, start);
    var format = parser.parseCard8();
    if (format === 0) {
        // Simple list of nGlyphs elements
        for (var iGid = 0; iGid < nGlyphs; iGid++) {
            fdIndex = parser.parseCard8();
            if (fdIndex >= fdArrayCount) {
                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
            }
            fdSelect.push(fdIndex);
        }
    } else if (format === 3) {
        // Ranges
        var nRanges = parser.parseCard16();
        var first = parser.parseCard16();
        if (first !== 0) {
            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);
        }
        var next;
        for (var iRange = 0; iRange < nRanges; iRange++) {
            fdIndex = parser.parseCard8();
            next = parser.parseCard16();
            if (fdIndex >= fdArrayCount) {
                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
            }
            if (next > nGlyphs) {
                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);
            }
            for (; first < next; first++) {
                fdSelect.push(fdIndex);
            }
            first = next;
        }
        if (next !== nGlyphs) {
            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);
        }
    } else {
        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);
    }
    return fdSelect;
}

// Parse the `CFF` table, which contains the glyph outlines in PostScript format.
function parseCFFTable(data, start, font) {
    font.tables.cff = {};
    var header = parseCFFHeader(data, start);
    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
    font.gsubrs = globalSubrIndex.objects;
    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);

    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);
    if (topDictArray.length !== 1) {
        throw new Error('CFF table has too many fonts in \'FontSet\' - count of fonts NameIndex.length = ' + topDictArray.length);
    }

    var topDict = topDictArray[0];
    font.tables.cff.topDict = topDict;

    if (topDict._privateDict) {
        font.defaultWidthX = topDict._privateDict.defaultWidthX;
        font.nominalWidthX = topDict._privateDict.nominalWidthX;
    }

    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {
        font.isCIDFont = true;
    }

    if (font.isCIDFont) {
        var fdArrayOffset = topDict.fdArray;
        var fdSelectOffset = topDict.fdSelect;
        if (fdArrayOffset === 0 || fdSelectOffset === 0) {
            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');
        }
        fdArrayOffset += start;
        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);
        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);
        topDict._fdArray = fdArray;
        fdSelectOffset += start;
        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);
    }

    var privateDictOffset = start + topDict.private[1];
    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);
    font.defaultWidthX = privateDict.defaultWidthX;
    font.nominalWidthX = privateDict.nominalWidthX;

    if (privateDict.subrs !== 0) {
        var subrOffset = privateDictOffset + privateDict.subrs;
        var subrIndex = parseCFFIndex(data, subrOffset);
        font.subrs = subrIndex.objects;
        font.subrsBias = calcCFFSubroutineBias(font.subrs);
    } else {
        font.subrs = [];
        font.subrsBias = 0;
    }

    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
    var charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.objects.length;

    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
    if (topDict.encoding === 0) {
        // Standard encoding
        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);
    } else if (topDict.encoding === 1) {
        // Expert encoding
        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);
    } else {
        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
    }

    // Prefer the CMAP encoding to the CFF encoding.
    font.encoding = font.encoding || font.cffEncoding;

    font.glyphs = new glyphset.GlyphSet(font);
    for (var i = 0; i < font.nGlyphs; i += 1) {
        var charString = charStringsIndex.objects[i];
        font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
    }
}

// Convert a string to a String ID (SID).
// The list of strings is modified in place.
function encodeString(s, strings) {
    var sid;

    // Is the string in the CFF standard strings?
    var i = cffStandardStrings.indexOf(s);
    if (i >= 0) {
        sid = i;
    }

    // Is the string already in the string index?
    i = strings.indexOf(s);
    if (i >= 0) {
        sid = i + cffStandardStrings.length;
    } else {
        sid = cffStandardStrings.length + strings.length;
        strings.push(s);
    }

    return sid;
}

function makeHeader() {
    return new table.Record('Header', [
        {name: 'major', type: 'Card8', value: 1},
        {name: 'minor', type: 'Card8', value: 0},
        {name: 'hdrSize', type: 'Card8', value: 4},
        {name: 'major', type: 'Card8', value: 1}
    ]);
}

function makeNameIndex(fontNames) {
    var t = new table.Record('Name INDEX', [
        {name: 'names', type: 'INDEX', value: []}
    ]);
    t.names = [];
    for (var i = 0; i < fontNames.length; i += 1) {
        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});
    }

    return t;
}

// Given a dictionary's metadata, create a DICT structure.
function makeDict(meta, attrs, strings) {
    var m = {};
    for (var i = 0; i < meta.length; i += 1) {
        var entry = meta[i];
        var value = attrs[entry.name];
        if (value !== undefined && !equals(value, entry.value)) {
            if (entry.type === 'SID') {
                value = encodeString(value, strings);
            }

            m[entry.op] = {name: entry.name, type: entry.type, value: value};
        }
    }

    return m;
}

// The Top DICT houses the global font attributes.
function makeTopDict(attrs, strings) {
    var t = new table.Record('Top DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(TOP_DICT_META, attrs, strings);
    return t;
}

function makeTopDictIndex(topDict) {
    var t = new table.Record('Top DICT INDEX', [
        {name: 'topDicts', type: 'INDEX', value: []}
    ]);
    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];
    return t;
}

function makeStringIndex(strings) {
    var t = new table.Record('String INDEX', [
        {name: 'strings', type: 'INDEX', value: []}
    ]);
    t.strings = [];
    for (var i = 0; i < strings.length; i += 1) {
        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});
    }

    return t;
}

function makeGlobalSubrIndex() {
    // Currently we don't use subroutines.
    return new table.Record('Global Subr INDEX', [
        {name: 'subrs', type: 'INDEX', value: []}
    ]);
}

function makeCharsets(glyphNames, strings) {
    var t = new table.Record('Charsets', [
        {name: 'format', type: 'Card8', value: 0}
    ]);
    for (var i = 0; i < glyphNames.length; i += 1) {
        var glyphName = glyphNames[i];
        var glyphSID = encodeString(glyphName, strings);
        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});
    }

    return t;
}

function glyphToOps(glyph) {
    var ops = [];
    var path = glyph.path;
    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});
    var x = 0;
    var y = 0;
    for (var i = 0; i < path.commands.length; i += 1) {
        var dx = (void 0);
        var dy = (void 0);
        var cmd = path.commands[i];
        if (cmd.type === 'Q') {
            // CFF only supports bzier curves, so convert the quad to a bzier.
            var _13 = 1 / 3;
            var _23 = 2 / 3;

            // We're going to create a new command so we don't change the original path.
            cmd = {
                type: 'C',
                x: cmd.x,
                y: cmd.y,
                x1: _13 * x + _23 * cmd.x1,
                y1: _13 * y + _23 * cmd.y1,
                x2: _13 * cmd.x + _23 * cmd.x1,
                y2: _13 * cmd.y + _23 * cmd.y1
            };
        }

        if (cmd.type === 'M') {
            dx = Math.round(cmd.x - x);
            dy = Math.round(cmd.y - y);
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rmoveto', type: 'OP', value: 21});
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        } else if (cmd.type === 'L') {
            dx = Math.round(cmd.x - x);
            dy = Math.round(cmd.y - y);
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rlineto', type: 'OP', value: 5});
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        } else if (cmd.type === 'C') {
            var dx1 = Math.round(cmd.x1 - x);
            var dy1 = Math.round(cmd.y1 - y);
            var dx2 = Math.round(cmd.x2 - cmd.x1);
            var dy2 = Math.round(cmd.y2 - cmd.y1);
            dx = Math.round(cmd.x - cmd.x2);
            dy = Math.round(cmd.y - cmd.y2);
            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});
            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});
            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});
            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rrcurveto', type: 'OP', value: 8});
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        }

        // Contours are closed automatically.
    }

    ops.push({name: 'endchar', type: 'OP', value: 14});
    return ops;
}

function makeCharStringsIndex(glyphs) {
    var t = new table.Record('CharStrings INDEX', [
        {name: 'charStrings', type: 'INDEX', value: []}
    ]);

    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        var ops = glyphToOps(glyph);
        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});
    }

    return t;
}

function makePrivateDict(attrs, strings) {
    var t = new table.Record('Private DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
    return t;
}

function makeCFFTable(glyphs, options) {
    var t = new table.Table('CFF ', [
        {name: 'header', type: 'RECORD'},
        {name: 'nameIndex', type: 'RECORD'},
        {name: 'topDictIndex', type: 'RECORD'},
        {name: 'stringIndex', type: 'RECORD'},
        {name: 'globalSubrIndex', type: 'RECORD'},
        {name: 'charsets', type: 'RECORD'},
        {name: 'charStringsIndex', type: 'RECORD'},
        {name: 'privateDict', type: 'RECORD'}
    ]);

    var fontScale = 1 / options.unitsPerEm;
    // We use non-zero values for the offsets so that the DICT encodes them.
    // This is important because the size of the Top DICT plays a role in offset calculation,
    // and the size shouldn't change after we've written correct offsets.
    var attrs = {
        version: options.version,
        fullName: options.fullName,
        familyName: options.familyName,
        weight: options.weightName,
        fontBBox: options.fontBBox || [0, 0, 0, 0],
        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
        charset: 999,
        encoding: 0,
        charStrings: 999,
        private: [0, 999]
    };

    var privateAttrs = {};

    var glyphNames = [];
    var glyph;

    // Skip first glyph (.notdef)
    for (var i = 1; i < glyphs.length; i += 1) {
        glyph = glyphs.get(i);
        glyphNames.push(glyph.name);
    }

    var strings = [];

    t.header = makeHeader();
    t.nameIndex = makeNameIndex([options.postScriptName]);
    var topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);
    t.globalSubrIndex = makeGlobalSubrIndex();
    t.charsets = makeCharsets(glyphNames, strings);
    t.charStringsIndex = makeCharStringsIndex(glyphs);
    t.privateDict = makePrivateDict(privateAttrs, strings);

    // Needs to come at the end, to encode all custom strings used in the font.
    t.stringIndex = makeStringIndex(strings);

    var startOffset = t.header.sizeOf() +
        t.nameIndex.sizeOf() +
        t.topDictIndex.sizeOf() +
        t.stringIndex.sizeOf() +
        t.globalSubrIndex.sizeOf();
    attrs.charset = startOffset;

    // We use the CFF standard encoding; proper encoding will be handled in cmap.
    attrs.encoding = 0;
    attrs.charStrings = attrs.charset + t.charsets.sizeOf();
    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();

    // Recreate the Top DICT INDEX with the correct offsets.
    topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);

    return t;
}

var cff = { parse: parseCFFTable, make: makeCFFTable };

// The `head` table contains global information about the font.
// https://www.microsoft.com/typography/OTSPEC/head.htm

// Parse the header `head` table
function parseHeadTable(data, start) {
    var head = {};
    var p = new parse.Parser(data, start);
    head.version = p.parseVersion();
    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
    head.checkSumAdjustment = p.parseULong();
    head.magicNumber = p.parseULong();
    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
    head.flags = p.parseUShort();
    head.unitsPerEm = p.parseUShort();
    head.created = p.parseLongDateTime();
    head.modified = p.parseLongDateTime();
    head.xMin = p.parseShort();
    head.yMin = p.parseShort();
    head.xMax = p.parseShort();
    head.yMax = p.parseShort();
    head.macStyle = p.parseUShort();
    head.lowestRecPPEM = p.parseUShort();
    head.fontDirectionHint = p.parseShort();
    head.indexToLocFormat = p.parseShort();
    head.glyphDataFormat = p.parseShort();
    return head;
}

function makeHeadTable(options) {
    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970
    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;
    var createdTimestamp = timestamp;

    if (options.createdTimestamp) {
        createdTimestamp = options.createdTimestamp + 2082844800;
    }

    return new table.Table('head', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},
        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},
        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},
        {name: 'flags', type: 'USHORT', value: 0},
        {name: 'unitsPerEm', type: 'USHORT', value: 1000},
        {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},
        {name: 'modified', type: 'LONGDATETIME', value: timestamp},
        {name: 'xMin', type: 'SHORT', value: 0},
        {name: 'yMin', type: 'SHORT', value: 0},
        {name: 'xMax', type: 'SHORT', value: 0},
        {name: 'yMax', type: 'SHORT', value: 0},
        {name: 'macStyle', type: 'USHORT', value: 0},
        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},
        {name: 'fontDirectionHint', type: 'SHORT', value: 2},
        {name: 'indexToLocFormat', type: 'SHORT', value: 0},
        {name: 'glyphDataFormat', type: 'SHORT', value: 0}
    ], options);
}

var head = { parse: parseHeadTable, make: makeHeadTable };

// The `hhea` table contains information for horizontal layout.
// https://www.microsoft.com/typography/OTSPEC/hhea.htm

// Parse the horizontal header `hhea` table
function parseHheaTable(data, start) {
    var hhea = {};
    var p = new parse.Parser(data, start);
    hhea.version = p.parseVersion();
    hhea.ascender = p.parseShort();
    hhea.descender = p.parseShort();
    hhea.lineGap = p.parseShort();
    hhea.advanceWidthMax = p.parseUShort();
    hhea.minLeftSideBearing = p.parseShort();
    hhea.minRightSideBearing = p.parseShort();
    hhea.xMaxExtent = p.parseShort();
    hhea.caretSlopeRise = p.parseShort();
    hhea.caretSlopeRun = p.parseShort();
    hhea.caretOffset = p.parseShort();
    p.relativeOffset += 8;
    hhea.metricDataFormat = p.parseShort();
    hhea.numberOfHMetrics = p.parseUShort();
    return hhea;
}

function makeHheaTable(options) {
    return new table.Table('hhea', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'ascender', type: 'FWORD', value: 0},
        {name: 'descender', type: 'FWORD', value: 0},
        {name: 'lineGap', type: 'FWORD', value: 0},
        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},
        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},
        {name: 'minRightSideBearing', type: 'FWORD', value: 0},
        {name: 'xMaxExtent', type: 'FWORD', value: 0},
        {name: 'caretSlopeRise', type: 'SHORT', value: 1},
        {name: 'caretSlopeRun', type: 'SHORT', value: 0},
        {name: 'caretOffset', type: 'SHORT', value: 0},
        {name: 'reserved1', type: 'SHORT', value: 0},
        {name: 'reserved2', type: 'SHORT', value: 0},
        {name: 'reserved3', type: 'SHORT', value: 0},
        {name: 'reserved4', type: 'SHORT', value: 0},
        {name: 'metricDataFormat', type: 'SHORT', value: 0},
        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}
    ], options);
}

var hhea = { parse: parseHheaTable, make: makeHheaTable };

// The `hmtx` table contains the horizontal metrics for all glyphs.
// https://www.microsoft.com/typography/OTSPEC/hmtx.htm

// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.
// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {
    var advanceWidth;
    var leftSideBearing;
    var p = new parse.Parser(data, start);
    for (var i = 0; i < numGlyphs; i += 1) {
        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
        if (i < numMetrics) {
            advanceWidth = p.parseUShort();
            leftSideBearing = p.parseShort();
        }

        var glyph = glyphs.get(i);
        glyph.advanceWidth = advanceWidth;
        glyph.leftSideBearing = leftSideBearing;
    }
}

function makeHmtxTable(glyphs) {
    var t = new table.Table('hmtx', []);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        var advanceWidth = glyph.advanceWidth || 0;
        var leftSideBearing = glyph.leftSideBearing || 0;
        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});
        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});
    }

    return t;
}

var hmtx = { parse: parseHmtxTable, make: makeHmtxTable };

// The `ltag` table stores IETF BCP-47 language tags. It allows supporting
// languages for which TrueType does not assign a numeric code.
// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6ltag.html
// http://www.w3.org/International/articles/language-tags/
// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry

function makeLtagTable(tags) {
    var result = new table.Table('ltag', [
        {name: 'version', type: 'ULONG', value: 1},
        {name: 'flags', type: 'ULONG', value: 0},
        {name: 'numTags', type: 'ULONG', value: tags.length}
    ]);

    var stringPool = '';
    var stringPoolOffset = 12 + tags.length * 4;
    for (var i = 0; i < tags.length; ++i) {
        var pos = stringPool.indexOf(tags[i]);
        if (pos < 0) {
            pos = stringPool.length;
            stringPool += tags[i];
        }

        result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});
        result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});
    }

    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});
    return result;
}

function parseLtagTable(data, start) {
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseULong();
    check.argument(tableVersion === 1, 'Unsupported ltag table version.');
    // The 'ltag' specification does not define any flags; skip the field.
    p.skip('uLong', 1);
    var numTags = p.parseULong();

    var tags = [];
    for (var i = 0; i < numTags; i++) {
        var tag = '';
        var offset = start + p.parseUShort();
        var length = p.parseUShort();
        for (var j = offset; j < offset + length; ++j) {
            tag += String.fromCharCode(data.getInt8(j));
        }

        tags.push(tag);
    }

    return tags;
}

var ltag = { make: makeLtagTable, parse: parseLtagTable };

// The `maxp` table establishes the memory requirements for the font.
// We need it just to get the number of glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/maxp.htm

// Parse the maximum profile `maxp` table.
function parseMaxpTable(data, start) {
    var maxp = {};
    var p = new parse.Parser(data, start);
    maxp.version = p.parseVersion();
    maxp.numGlyphs = p.parseUShort();
    if (maxp.version === 1.0) {
        maxp.maxPoints = p.parseUShort();
        maxp.maxContours = p.parseUShort();
        maxp.maxCompositePoints = p.parseUShort();
        maxp.maxCompositeContours = p.parseUShort();
        maxp.maxZones = p.parseUShort();
        maxp.maxTwilightPoints = p.parseUShort();
        maxp.maxStorage = p.parseUShort();
        maxp.maxFunctionDefs = p.parseUShort();
        maxp.maxInstructionDefs = p.parseUShort();
        maxp.maxStackElements = p.parseUShort();
        maxp.maxSizeOfInstructions = p.parseUShort();
        maxp.maxComponentElements = p.parseUShort();
        maxp.maxComponentDepth = p.parseUShort();
    }

    return maxp;
}

function makeMaxpTable(numGlyphs) {
    return new table.Table('maxp', [
        {name: 'version', type: 'FIXED', value: 0x00005000},
        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}
    ]);
}

var maxp = { parse: parseMaxpTable, make: makeMaxpTable };

// The `name` naming table.
// https://www.microsoft.com/typography/OTSPEC/name.htm

// NameIDs for the name table.
var nameTableNames = [
    'copyright',              // 0
    'fontFamily',             // 1
    'fontSubfamily',          // 2
    'uniqueID',               // 3
    'fullName',               // 4
    'version',                // 5
    'postScriptName',         // 6
    'trademark',              // 7
    'manufacturer',           // 8
    'designer',               // 9
    'description',            // 10
    'manufacturerURL',        // 11
    'designerURL',            // 12
    'license',                // 13
    'licenseURL',             // 14
    'reserved',               // 15
    'preferredFamily',        // 16
    'preferredSubfamily',     // 17
    'compatibleFullName',     // 18
    'sampleText',             // 19
    'postScriptFindFontName', // 20
    'wwsFamily',              // 21
    'wwsSubfamily'            // 22
];

var macLanguages = {
    0: 'en',
    1: 'fr',
    2: 'de',
    3: 'it',
    4: 'nl',
    5: 'sv',
    6: 'es',
    7: 'da',
    8: 'pt',
    9: 'no',
    10: 'he',
    11: 'ja',
    12: 'ar',
    13: 'fi',
    14: 'el',
    15: 'is',
    16: 'mt',
    17: 'tr',
    18: 'hr',
    19: 'zh-Hant',
    20: 'ur',
    21: 'hi',
    22: 'th',
    23: 'ko',
    24: 'lt',
    25: 'pl',
    26: 'hu',
    27: 'es',
    28: 'lv',
    29: 'se',
    30: 'fo',
    31: 'fa',
    32: 'ru',
    33: 'zh',
    34: 'nl-BE',
    35: 'ga',
    36: 'sq',
    37: 'ro',
    38: 'cz',
    39: 'sk',
    40: 'si',
    41: 'yi',
    42: 'sr',
    43: 'mk',
    44: 'bg',
    45: 'uk',
    46: 'be',
    47: 'uz',
    48: 'kk',
    49: 'az-Cyrl',
    50: 'az-Arab',
    51: 'hy',
    52: 'ka',
    53: 'mo',
    54: 'ky',
    55: 'tg',
    56: 'tk',
    57: 'mn-CN',
    58: 'mn',
    59: 'ps',
    60: 'ks',
    61: 'ku',
    62: 'sd',
    63: 'bo',
    64: 'ne',
    65: 'sa',
    66: 'mr',
    67: 'bn',
    68: 'as',
    69: 'gu',
    70: 'pa',
    71: 'or',
    72: 'ml',
    73: 'kn',
    74: 'ta',
    75: 'te',
    76: 'si',
    77: 'my',
    78: 'km',
    79: 'lo',
    80: 'vi',
    81: 'id',
    82: 'tl',
    83: 'ms',
    84: 'ms-Arab',
    85: 'am',
    86: 'ti',
    87: 'om',
    88: 'so',
    89: 'sw',
    90: 'rw',
    91: 'rn',
    92: 'ny',
    93: 'mg',
    94: 'eo',
    128: 'cy',
    129: 'eu',
    130: 'ca',
    131: 'la',
    132: 'qu',
    133: 'gn',
    134: 'ay',
    135: 'tt',
    136: 'ug',
    137: 'dz',
    138: 'jv',
    139: 'su',
    140: 'gl',
    141: 'af',
    142: 'br',
    143: 'iu',
    144: 'gd',
    145: 'gv',
    146: 'ga',
    147: 'to',
    148: 'el-polyton',
    149: 'kl',
    150: 'az',
    151: 'nn'
};

// MacOS language ID  MacOS script ID
//
// Note that the script ID is not sufficient to determine what encoding
// to use in TrueType files. For some languages, MacOS used a modification
// of a mainstream script. For example, an Icelandic name would be stored
// with smRoman in the TrueType naming table, but the actual encoding
// is a special Icelandic version of the normal Macintosh Roman encoding.
// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal
// Syllables but MacOS had run out of available script codes, so this was
// done as a (pretty radical) "modification" of Ethiopic.
//
// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
var macLanguageToScript = {
    0: 0,  // langEnglish  smRoman
    1: 0,  // langFrench  smRoman
    2: 0,  // langGerman  smRoman
    3: 0,  // langItalian  smRoman
    4: 0,  // langDutch  smRoman
    5: 0,  // langSwedish  smRoman
    6: 0,  // langSpanish  smRoman
    7: 0,  // langDanish  smRoman
    8: 0,  // langPortuguese  smRoman
    9: 0,  // langNorwegian  smRoman
    10: 5,  // langHebrew  smHebrew
    11: 1,  // langJapanese  smJapanese
    12: 4,  // langArabic  smArabic
    13: 0,  // langFinnish  smRoman
    14: 6,  // langGreek  smGreek
    15: 0,  // langIcelandic  smRoman (modified)
    16: 0,  // langMaltese  smRoman
    17: 0,  // langTurkish  smRoman (modified)
    18: 0,  // langCroatian  smRoman (modified)
    19: 2,  // langTradChinese  smTradChinese
    20: 4,  // langUrdu  smArabic
    21: 9,  // langHindi  smDevanagari
    22: 21,  // langThai  smThai
    23: 3,  // langKorean  smKorean
    24: 29,  // langLithuanian  smCentralEuroRoman
    25: 29,  // langPolish  smCentralEuroRoman
    26: 29,  // langHungarian  smCentralEuroRoman
    27: 29,  // langEstonian  smCentralEuroRoman
    28: 29,  // langLatvian  smCentralEuroRoman
    29: 0,  // langSami  smRoman
    30: 0,  // langFaroese  smRoman (modified)
    31: 4,  // langFarsi  smArabic (modified)
    32: 7,  // langRussian  smCyrillic
    33: 25,  // langSimpChinese  smSimpChinese
    34: 0,  // langFlemish  smRoman
    35: 0,  // langIrishGaelic  smRoman (modified)
    36: 0,  // langAlbanian  smRoman
    37: 0,  // langRomanian  smRoman (modified)
    38: 29,  // langCzech  smCentralEuroRoman
    39: 29,  // langSlovak  smCentralEuroRoman
    40: 0,  // langSlovenian  smRoman (modified)
    41: 5,  // langYiddish  smHebrew
    42: 7,  // langSerbian  smCyrillic
    43: 7,  // langMacedonian  smCyrillic
    44: 7,  // langBulgarian  smCyrillic
    45: 7,  // langUkrainian  smCyrillic (modified)
    46: 7,  // langByelorussian  smCyrillic
    47: 7,  // langUzbek  smCyrillic
    48: 7,  // langKazakh  smCyrillic
    49: 7,  // langAzerbaijani  smCyrillic
    50: 4,  // langAzerbaijanAr  smArabic
    51: 24,  // langArmenian  smArmenian
    52: 23,  // langGeorgian  smGeorgian
    53: 7,  // langMoldavian  smCyrillic
    54: 7,  // langKirghiz  smCyrillic
    55: 7,  // langTajiki  smCyrillic
    56: 7,  // langTurkmen  smCyrillic
    57: 27,  // langMongolian  smMongolian
    58: 7,  // langMongolianCyr  smCyrillic
    59: 4,  // langPashto  smArabic
    60: 4,  // langKurdish  smArabic
    61: 4,  // langKashmiri  smArabic
    62: 4,  // langSindhi  smArabic
    63: 26,  // langTibetan  smTibetan
    64: 9,  // langNepali  smDevanagari
    65: 9,  // langSanskrit  smDevanagari
    66: 9,  // langMarathi  smDevanagari
    67: 13,  // langBengali  smBengali
    68: 13,  // langAssamese  smBengali
    69: 11,  // langGujarati  smGujarati
    70: 10,  // langPunjabi  smGurmukhi
    71: 12,  // langOriya  smOriya
    72: 17,  // langMalayalam  smMalayalam
    73: 16,  // langKannada  smKannada
    74: 14,  // langTamil  smTamil
    75: 15,  // langTelugu  smTelugu
    76: 18,  // langSinhalese  smSinhalese
    77: 19,  // langBurmese  smBurmese
    78: 20,  // langKhmer  smKhmer
    79: 22,  // langLao  smLao
    80: 30,  // langVietnamese  smVietnamese
    81: 0,  // langIndonesian  smRoman
    82: 0,  // langTagalog  smRoman
    83: 0,  // langMalayRoman  smRoman
    84: 4,  // langMalayArabic  smArabic
    85: 28,  // langAmharic  smEthiopic
    86: 28,  // langTigrinya  smEthiopic
    87: 28,  // langOromo  smEthiopic
    88: 0,  // langSomali  smRoman
    89: 0,  // langSwahili  smRoman
    90: 0,  // langKinyarwanda  smRoman
    91: 0,  // langRundi  smRoman
    92: 0,  // langNyanja  smRoman
    93: 0,  // langMalagasy  smRoman
    94: 0,  // langEsperanto  smRoman
    128: 0,  // langWelsh  smRoman (modified)
    129: 0,  // langBasque  smRoman
    130: 0,  // langCatalan  smRoman
    131: 0,  // langLatin  smRoman
    132: 0,  // langQuechua  smRoman
    133: 0,  // langGuarani  smRoman
    134: 0,  // langAymara  smRoman
    135: 7,  // langTatar  smCyrillic
    136: 4,  // langUighur  smArabic
    137: 26,  // langDzongkha  smTibetan
    138: 0,  // langJavaneseRom  smRoman
    139: 0,  // langSundaneseRom  smRoman
    140: 0,  // langGalician  smRoman
    141: 0,  // langAfrikaans  smRoman
    142: 0,  // langBreton  smRoman (modified)
    143: 28,  // langInuktitut  smEthiopic (modified)
    144: 0,  // langScottishGaelic  smRoman (modified)
    145: 0,  // langManxGaelic  smRoman (modified)
    146: 0,  // langIrishGaelicScript  smRoman (modified)
    147: 0,  // langTongan  smRoman
    148: 6,  // langGreekAncient  smRoman
    149: 0,  // langGreenlandic  smRoman
    150: 0,  // langAzerbaijanRoman  smRoman
    151: 0   // langNynorsk  smRoman
};

// While Microsoft indicates a region/country for all its language
// IDs, we omit the region code if it's equal to the "most likely
// region subtag" according to Unicode CLDR. For scripts, we omit
// the subtag if it is equal to the Suppress-Script entry in the
// IANA language subtag registry for IETF BCP 47.
//
// For example, Microsoft states that its language code 0x041A is
// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'
// and not 'hr-HR' because Croatia is the default country for Croatian,
// according to Unicode CLDR. As another example, Microsoft states
// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform
// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script
// for the Croatian language, according to IANA.
//
// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html
// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
var windowsLanguages = {
    0x0436: 'af',
    0x041C: 'sq',
    0x0484: 'gsw',
    0x045E: 'am',
    0x1401: 'ar-DZ',
    0x3C01: 'ar-BH',
    0x0C01: 'ar',
    0x0801: 'ar-IQ',
    0x2C01: 'ar-JO',
    0x3401: 'ar-KW',
    0x3001: 'ar-LB',
    0x1001: 'ar-LY',
    0x1801: 'ary',
    0x2001: 'ar-OM',
    0x4001: 'ar-QA',
    0x0401: 'ar-SA',
    0x2801: 'ar-SY',
    0x1C01: 'aeb',
    0x3801: 'ar-AE',
    0x2401: 'ar-YE',
    0x042B: 'hy',
    0x044D: 'as',
    0x082C: 'az-Cyrl',
    0x042C: 'az',
    0x046D: 'ba',
    0x042D: 'eu',
    0x0423: 'be',
    0x0845: 'bn',
    0x0445: 'bn-IN',
    0x201A: 'bs-Cyrl',
    0x141A: 'bs',
    0x047E: 'br',
    0x0402: 'bg',
    0x0403: 'ca',
    0x0C04: 'zh-HK',
    0x1404: 'zh-MO',
    0x0804: 'zh',
    0x1004: 'zh-SG',
    0x0404: 'zh-TW',
    0x0483: 'co',
    0x041A: 'hr',
    0x101A: 'hr-BA',
    0x0405: 'cs',
    0x0406: 'da',
    0x048C: 'prs',
    0x0465: 'dv',
    0x0813: 'nl-BE',
    0x0413: 'nl',
    0x0C09: 'en-AU',
    0x2809: 'en-BZ',
    0x1009: 'en-CA',
    0x2409: 'en-029',
    0x4009: 'en-IN',
    0x1809: 'en-IE',
    0x2009: 'en-JM',
    0x4409: 'en-MY',
    0x1409: 'en-NZ',
    0x3409: 'en-PH',
    0x4809: 'en-SG',
    0x1C09: 'en-ZA',
    0x2C09: 'en-TT',
    0x0809: 'en-GB',
    0x0409: 'en',
    0x3009: 'en-ZW',
    0x0425: 'et',
    0x0438: 'fo',
    0x0464: 'fil',
    0x040B: 'fi',
    0x080C: 'fr-BE',
    0x0C0C: 'fr-CA',
    0x040C: 'fr',
    0x140C: 'fr-LU',
    0x180C: 'fr-MC',
    0x100C: 'fr-CH',
    0x0462: 'fy',
    0x0456: 'gl',
    0x0437: 'ka',
    0x0C07: 'de-AT',
    0x0407: 'de',
    0x1407: 'de-LI',
    0x1007: 'de-LU',
    0x0807: 'de-CH',
    0x0408: 'el',
    0x046F: 'kl',
    0x0447: 'gu',
    0x0468: 'ha',
    0x040D: 'he',
    0x0439: 'hi',
    0x040E: 'hu',
    0x040F: 'is',
    0x0470: 'ig',
    0x0421: 'id',
    0x045D: 'iu',
    0x085D: 'iu-Latn',
    0x083C: 'ga',
    0x0434: 'xh',
    0x0435: 'zu',
    0x0410: 'it',
    0x0810: 'it-CH',
    0x0411: 'ja',
    0x044B: 'kn',
    0x043F: 'kk',
    0x0453: 'km',
    0x0486: 'quc',
    0x0487: 'rw',
    0x0441: 'sw',
    0x0457: 'kok',
    0x0412: 'ko',
    0x0440: 'ky',
    0x0454: 'lo',
    0x0426: 'lv',
    0x0427: 'lt',
    0x082E: 'dsb',
    0x046E: 'lb',
    0x042F: 'mk',
    0x083E: 'ms-BN',
    0x043E: 'ms',
    0x044C: 'ml',
    0x043A: 'mt',
    0x0481: 'mi',
    0x047A: 'arn',
    0x044E: 'mr',
    0x047C: 'moh',
    0x0450: 'mn',
    0x0850: 'mn-CN',
    0x0461: 'ne',
    0x0414: 'nb',
    0x0814: 'nn',
    0x0482: 'oc',
    0x0448: 'or',
    0x0463: 'ps',
    0x0415: 'pl',
    0x0416: 'pt',
    0x0816: 'pt-PT',
    0x0446: 'pa',
    0x046B: 'qu-BO',
    0x086B: 'qu-EC',
    0x0C6B: 'qu',
    0x0418: 'ro',
    0x0417: 'rm',
    0x0419: 'ru',
    0x243B: 'smn',
    0x103B: 'smj-NO',
    0x143B: 'smj',
    0x0C3B: 'se-FI',
    0x043B: 'se',
    0x083B: 'se-SE',
    0x203B: 'sms',
    0x183B: 'sma-NO',
    0x1C3B: 'sms',
    0x044F: 'sa',
    0x1C1A: 'sr-Cyrl-BA',
    0x0C1A: 'sr',
    0x181A: 'sr-Latn-BA',
    0x081A: 'sr-Latn',
    0x046C: 'nso',
    0x0432: 'tn',
    0x045B: 'si',
    0x041B: 'sk',
    0x0424: 'sl',
    0x2C0A: 'es-AR',
    0x400A: 'es-BO',
    0x340A: 'es-CL',
    0x240A: 'es-CO',
    0x140A: 'es-CR',
    0x1C0A: 'es-DO',
    0x300A: 'es-EC',
    0x440A: 'es-SV',
    0x100A: 'es-GT',
    0x480A: 'es-HN',
    0x080A: 'es-MX',
    0x4C0A: 'es-NI',
    0x180A: 'es-PA',
    0x3C0A: 'es-PY',
    0x280A: 'es-PE',
    0x500A: 'es-PR',

    // Microsoft has defined two different language codes for
    // Spanish with modern sorting and Spanish with traditional
    // sorting. This makes sense for collation APIs, and it would be
    // possible to express this in BCP 47 language tags via Unicode
    // extensions (eg., es-u-co-trad is Spanish with traditional
    // sorting). However, for storing names in fonts, the distinction
    // does not make sense, so we give es in both cases.
    0x0C0A: 'es',
    0x040A: 'es',

    0x540A: 'es-US',
    0x380A: 'es-UY',
    0x200A: 'es-VE',
    0x081D: 'sv-FI',
    0x041D: 'sv',
    0x045A: 'syr',
    0x0428: 'tg',
    0x085F: 'tzm',
    0x0449: 'ta',
    0x0444: 'tt',
    0x044A: 'te',
    0x041E: 'th',
    0x0451: 'bo',
    0x041F: 'tr',
    0x0442: 'tk',
    0x0480: 'ug',
    0x0422: 'uk',
    0x042E: 'hsb',
    0x0420: 'ur',
    0x0843: 'uz-Cyrl',
    0x0443: 'uz',
    0x042A: 'vi',
    0x0452: 'cy',
    0x0488: 'wo',
    0x0485: 'sah',
    0x0478: 'ii',
    0x046A: 'yo'
};

// Returns a IETF BCP 47 language code, for example 'zh-Hant'
// for 'Chinese in the traditional script'.
function getLanguageCode(platformID, languageID, ltag) {
    switch (platformID) {
        case 0:  // Unicode
            if (languageID === 0xFFFF) {
                return 'und';
            } else if (ltag) {
                return ltag[languageID];
            }

            break;

        case 1:  // Macintosh
            return macLanguages[languageID];

        case 3:  // Windows
            return windowsLanguages[languageID];
    }

    return undefined;
}

var utf16 = 'utf-16';

// MacOS script ID  encoding. This table stores the default case,
// which can be overridden by macLanguageEncodings.
var macScriptEncodings = {
    0: 'macintosh',           // smRoman
    1: 'x-mac-japanese',      // smJapanese
    2: 'x-mac-chinesetrad',   // smTradChinese
    3: 'x-mac-korean',        // smKorean
    6: 'x-mac-greek',         // smGreek
    7: 'x-mac-cyrillic',      // smCyrillic
    9: 'x-mac-devanagai',     // smDevanagari
    10: 'x-mac-gurmukhi',     // smGurmukhi
    11: 'x-mac-gujarati',     // smGujarati
    12: 'x-mac-oriya',        // smOriya
    13: 'x-mac-bengali',      // smBengali
    14: 'x-mac-tamil',        // smTamil
    15: 'x-mac-telugu',       // smTelugu
    16: 'x-mac-kannada',      // smKannada
    17: 'x-mac-malayalam',    // smMalayalam
    18: 'x-mac-sinhalese',    // smSinhalese
    19: 'x-mac-burmese',      // smBurmese
    20: 'x-mac-khmer',        // smKhmer
    21: 'x-mac-thai',         // smThai
    22: 'x-mac-lao',          // smLao
    23: 'x-mac-georgian',     // smGeorgian
    24: 'x-mac-armenian',     // smArmenian
    25: 'x-mac-chinesesimp',  // smSimpChinese
    26: 'x-mac-tibetan',      // smTibetan
    27: 'x-mac-mongolian',    // smMongolian
    28: 'x-mac-ethiopic',     // smEthiopic
    29: 'x-mac-ce',           // smCentralEuroRoman
    30: 'x-mac-vietnamese',   // smVietnamese
    31: 'x-mac-extarabic'     // smExtArabic
};

// MacOS language ID  encoding. This table stores the exceptional
// cases, which override macScriptEncodings. For writing MacOS naming
// tables, we need to emit a MacOS script ID. Therefore, we cannot
// merge macScriptEncodings into macLanguageEncodings.
//
// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
var macLanguageEncodings = {
    15: 'x-mac-icelandic',    // langIcelandic
    17: 'x-mac-turkish',      // langTurkish
    18: 'x-mac-croatian',     // langCroatian
    24: 'x-mac-ce',           // langLithuanian
    25: 'x-mac-ce',           // langPolish
    26: 'x-mac-ce',           // langHungarian
    27: 'x-mac-ce',           // langEstonian
    28: 'x-mac-ce',           // langLatvian
    30: 'x-mac-icelandic',    // langFaroese
    37: 'x-mac-romanian',     // langRomanian
    38: 'x-mac-ce',           // langCzech
    39: 'x-mac-ce',           // langSlovak
    40: 'x-mac-ce',           // langSlovenian
    143: 'x-mac-inuit',       // langInuktitut
    146: 'x-mac-gaelic'       // langIrishGaelicScript
};

function getEncoding(platformID, encodingID, languageID) {
    switch (platformID) {
        case 0:  // Unicode
            return utf16;

        case 1:  // Apple Macintosh
            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];

        case 3:  // Microsoft Windows
            if (encodingID === 1 || encodingID === 10) {
                return utf16;
            }

            break;
    }

    return undefined;
}

// Parse the naming `name` table.
// FIXME: Format 1 additional fields are not supported yet.
// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].
function parseNameTable(data, start, ltag) {
    var name = {};
    var p = new parse.Parser(data, start);
    var format = p.parseUShort();
    var count = p.parseUShort();
    var stringOffset = p.offset + p.parseUShort();
    for (var i = 0; i < count; i++) {
        var platformID = p.parseUShort();
        var encodingID = p.parseUShort();
        var languageID = p.parseUShort();
        var nameID = p.parseUShort();
        var property = nameTableNames[nameID] || nameID;
        var byteLength = p.parseUShort();
        var offset = p.parseUShort();
        var language = getLanguageCode(platformID, languageID, ltag);
        var encoding = getEncoding(platformID, encodingID, languageID);
        if (encoding !== undefined && language !== undefined) {
            var text = (void 0);
            if (encoding === utf16) {
                text = decode.UTF16(data, stringOffset + offset, byteLength);
            } else {
                text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);
            }

            if (text) {
                var translations = name[property];
                if (translations === undefined) {
                    translations = name[property] = {};
                }

                translations[language] = text;
            }
        }
    }

    var langTagCount = 0;
    if (format === 1) {
        // FIXME: Also handle Microsoft's 'name' table 1.
        langTagCount = p.parseUShort();
    }

    return name;
}

// {23: 'foo'}  {'foo': 23}
// ['bar', 'baz']  {'bar': 0, 'baz': 1}
function reverseDict(dict) {
    var result = {};
    for (var key in dict) {
        result[dict[key]] = parseInt(key);
    }

    return result;
}

function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
    return new table.Record('NameRecord', [
        {name: 'platformID', type: 'USHORT', value: platformID},
        {name: 'encodingID', type: 'USHORT', value: encodingID},
        {name: 'languageID', type: 'USHORT', value: languageID},
        {name: 'nameID', type: 'USHORT', value: nameID},
        {name: 'length', type: 'USHORT', value: length},
        {name: 'offset', type: 'USHORT', value: offset}
    ]);
}

// Finds the position of needle in haystack, or -1 if not there.
// Like String.indexOf(), but for arrays.
function findSubArray(needle, haystack) {
    var needleLength = needle.length;
    var limit = haystack.length - needleLength + 1;

    loop:
    for (var pos = 0; pos < limit; pos++) {
        for (; pos < limit; pos++) {
            for (var k = 0; k < needleLength; k++) {
                if (haystack[pos + k] !== needle[k]) {
                    continue loop;
                }
            }

            return pos;
        }
    }

    return -1;
}

function addStringToPool(s, pool) {
    var offset = findSubArray(s, pool);
    if (offset < 0) {
        offset = pool.length;
        var i = 0;
        var len = s.length;
        for (; i < len; ++i) {
            pool.push(s[i]);
        }

    }

    return offset;
}

function makeNameTable(names, ltag) {
    var nameID;
    var nameIDs = [];

    var namesWithNumericKeys = {};
    var nameTableIds = reverseDict(nameTableNames);
    for (var key in names) {
        var id = nameTableIds[key];
        if (id === undefined) {
            id = key;
        }

        nameID = parseInt(id);

        if (isNaN(nameID)) {
            throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
        }

        namesWithNumericKeys[nameID] = names[key];
        nameIDs.push(nameID);
    }

    var macLanguageIds = reverseDict(macLanguages);
    var windowsLanguageIds = reverseDict(windowsLanguages);

    var nameRecords = [];
    var stringPool = [];

    for (var i = 0; i < nameIDs.length; i++) {
        nameID = nameIDs[i];
        var translations = namesWithNumericKeys[nameID];
        for (var lang in translations) {
            var text = translations[lang];

            // For MacOS, we try to emit the name in the form that was introduced
            // in the initial version of the TrueType spec (in the late 1980s).
            // However, this can fail for various reasons: the requested BCP 47
            // language code might not have an old-style Mac equivalent;
            // we might not have a codec for the needed character encoding;
            // or the name might contain characters that cannot be expressed
            // in the old-style Macintosh encoding. In case of failure, we emit
            // the name in a more modern fashion (Unicode encoding with BCP 47
            // language tags) that is recognized by MacOS 10.5, released in 2009.
            // If fonts were only read by operating systems, we could simply
            // emit all names in the modern form; this would be much easier.
            // However, there are many applications and libraries that read
            // 'name' tables directly, and these will usually only recognize
            // the ancient form (silently skipping the unrecognized names).
            var macPlatform = 1;  // Macintosh
            var macLanguage = macLanguageIds[lang];
            var macScript = macLanguageToScript[macLanguage];
            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
            var macName = encode.MACSTRING(text, macEncoding);
            if (macName === undefined) {
                macPlatform = 0;  // Unicode
                macLanguage = ltag.indexOf(lang);
                if (macLanguage < 0) {
                    macLanguage = ltag.length;
                    ltag.push(lang);
                }

                macScript = 4;  // Unicode 2.0 and later
                macName = encode.UTF16(text);
            }

            var macNameOffset = addStringToPool(macName, stringPool);
            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,
                                            nameID, macName.length, macNameOffset));

            var winLanguage = windowsLanguageIds[lang];
            if (winLanguage !== undefined) {
                var winName = encode.UTF16(text);
                var winNameOffset = addStringToPool(winName, stringPool);
                nameRecords.push(makeNameRecord(3, 1, winLanguage,
                                                nameID, winName.length, winNameOffset));
            }
        }
    }

    nameRecords.sort(function(a, b) {
        return ((a.platformID - b.platformID) ||
                (a.encodingID - b.encodingID) ||
                (a.languageID - b.languageID) ||
                (a.nameID - b.nameID));
    });

    var t = new table.Table('name', [
        {name: 'format', type: 'USHORT', value: 0},
        {name: 'count', type: 'USHORT', value: nameRecords.length},
        {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}
    ]);

    for (var r = 0; r < nameRecords.length; r++) {
        t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});
    }

    t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});
    return t;
}

var _name = { parse: parseNameTable, make: makeNameTable };

// The `OS/2` table contains metrics required in OpenType fonts.
// https://www.microsoft.com/typography/OTSPEC/os2.htm

var unicodeRanges = [
    {begin: 0x0000, end: 0x007F}, // Basic Latin
    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement
    {begin: 0x0100, end: 0x017F}, // Latin Extended-A
    {begin: 0x0180, end: 0x024F}, // Latin Extended-B
    {begin: 0x0250, end: 0x02AF}, // IPA Extensions
    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters
    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks
    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic
    {begin: 0x2C80, end: 0x2CFF}, // Coptic
    {begin: 0x0400, end: 0x04FF}, // Cyrillic
    {begin: 0x0530, end: 0x058F}, // Armenian
    {begin: 0x0590, end: 0x05FF}, // Hebrew
    {begin: 0xA500, end: 0xA63F}, // Vai
    {begin: 0x0600, end: 0x06FF}, // Arabic
    {begin: 0x07C0, end: 0x07FF}, // NKo
    {begin: 0x0900, end: 0x097F}, // Devanagari
    {begin: 0x0980, end: 0x09FF}, // Bengali
    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi
    {begin: 0x0A80, end: 0x0AFF}, // Gujarati
    {begin: 0x0B00, end: 0x0B7F}, // Oriya
    {begin: 0x0B80, end: 0x0BFF}, // Tamil
    {begin: 0x0C00, end: 0x0C7F}, // Telugu
    {begin: 0x0C80, end: 0x0CFF}, // Kannada
    {begin: 0x0D00, end: 0x0D7F}, // Malayalam
    {begin: 0x0E00, end: 0x0E7F}, // Thai
    {begin: 0x0E80, end: 0x0EFF}, // Lao
    {begin: 0x10A0, end: 0x10FF}, // Georgian
    {begin: 0x1B00, end: 0x1B7F}, // Balinese
    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo
    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional
    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended
    {begin: 0x2000, end: 0x206F}, // General Punctuation
    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts
    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol
    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols
    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols
    {begin: 0x2150, end: 0x218F}, // Number Forms
    {begin: 0x2190, end: 0x21FF}, // Arrows
    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators
    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical
    {begin: 0x2400, end: 0x243F}, // Control Pictures
    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition
    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics
    {begin: 0x2500, end: 0x257F}, // Box Drawing
    {begin: 0x2580, end: 0x259F}, // Block Elements
    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes
    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols
    {begin: 0x2700, end: 0x27BF}, // Dingbats
    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation
    {begin: 0x3040, end: 0x309F}, // Hiragana
    {begin: 0x30A0, end: 0x30FF}, // Katakana
    {begin: 0x3100, end: 0x312F}, // Bopomofo
    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo
    {begin: 0xA840, end: 0xA87F}, // Phags-pa
    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months
    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility
    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables
    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *
    {begin: 0x10900, end: 0x1091F}, // Phoenicia
    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs
    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)
    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes
    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms
    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A
    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks
    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms
    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants
    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B
    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms
    {begin: 0xFFF0, end: 0xFFFF}, // Specials
    {begin: 0x0F00, end: 0x0FFF}, // Tibetan
    {begin: 0x0700, end: 0x074F}, // Syriac
    {begin: 0x0780, end: 0x07BF}, // Thaana
    {begin: 0x0D80, end: 0x0DFF}, // Sinhala
    {begin: 0x1000, end: 0x109F}, // Myanmar
    {begin: 0x1200, end: 0x137F}, // Ethiopic
    {begin: 0x13A0, end: 0x13FF}, // Cherokee
    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics
    {begin: 0x1680, end: 0x169F}, // Ogham
    {begin: 0x16A0, end: 0x16FF}, // Runic
    {begin: 0x1780, end: 0x17FF}, // Khmer
    {begin: 0x1800, end: 0x18AF}, // Mongolian
    {begin: 0x2800, end: 0x28FF}, // Braille Patterns
    {begin: 0xA000, end: 0xA48F}, // Yi Syllables
    {begin: 0x1700, end: 0x171F}, // Tagalog
    {begin: 0x10300, end: 0x1032F}, // Old Italic
    {begin: 0x10330, end: 0x1034F}, // Gothic
    {begin: 0x10400, end: 0x1044F}, // Deseret
    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols
    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols
    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)
    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors
    {begin: 0xE0000, end: 0xE007F}, // Tags
    {begin: 0x1900, end: 0x194F}, // Limbu
    {begin: 0x1950, end: 0x197F}, // Tai Le
    {begin: 0x1980, end: 0x19DF}, // New Tai Lue
    {begin: 0x1A00, end: 0x1A1F}, // Buginese
    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic
    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh
    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols
    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri
    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary
    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers
    {begin: 0x10380, end: 0x1039F}, // Ugaritic
    {begin: 0x103A0, end: 0x103DF}, // Old Persian
    {begin: 0x10450, end: 0x1047F}, // Shavian
    {begin: 0x10480, end: 0x104AF}, // Osmanya
    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary
    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi
    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols
    {begin: 0x12000, end: 0x123FF}, // Cuneiform
    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals
    {begin: 0x1B80, end: 0x1BBF}, // Sundanese
    {begin: 0x1C00, end: 0x1C4F}, // Lepcha
    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki
    {begin: 0xA880, end: 0xA8DF}, // Saurashtra
    {begin: 0xA900, end: 0xA92F}, // Kayah Li
    {begin: 0xA930, end: 0xA95F}, // Rejang
    {begin: 0xAA00, end: 0xAA5F}, // Cham
    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols
    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc
    {begin: 0x102A0, end: 0x102DF}, // Carian
    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles
];

function getUnicodeRange(unicode) {
    for (var i = 0; i < unicodeRanges.length; i += 1) {
        var range = unicodeRanges[i];
        if (unicode >= range.begin && unicode < range.end) {
            return i;
        }
    }

    return -1;
}

// Parse the OS/2 and Windows metrics `OS/2` table
function parseOS2Table(data, start) {
    var os2 = {};
    var p = new parse.Parser(data, start);
    os2.version = p.parseUShort();
    os2.xAvgCharWidth = p.parseShort();
    os2.usWeightClass = p.parseUShort();
    os2.usWidthClass = p.parseUShort();
    os2.fsType = p.parseUShort();
    os2.ySubscriptXSize = p.parseShort();
    os2.ySubscriptYSize = p.parseShort();
    os2.ySubscriptXOffset = p.parseShort();
    os2.ySubscriptYOffset = p.parseShort();
    os2.ySuperscriptXSize = p.parseShort();
    os2.ySuperscriptYSize = p.parseShort();
    os2.ySuperscriptXOffset = p.parseShort();
    os2.ySuperscriptYOffset = p.parseShort();
    os2.yStrikeoutSize = p.parseShort();
    os2.yStrikeoutPosition = p.parseShort();
    os2.sFamilyClass = p.parseShort();
    os2.panose = [];
    for (var i = 0; i < 10; i++) {
        os2.panose[i] = p.parseByte();
    }

    os2.ulUnicodeRange1 = p.parseULong();
    os2.ulUnicodeRange2 = p.parseULong();
    os2.ulUnicodeRange3 = p.parseULong();
    os2.ulUnicodeRange4 = p.parseULong();
    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
    os2.fsSelection = p.parseUShort();
    os2.usFirstCharIndex = p.parseUShort();
    os2.usLastCharIndex = p.parseUShort();
    os2.sTypoAscender = p.parseShort();
    os2.sTypoDescender = p.parseShort();
    os2.sTypoLineGap = p.parseShort();
    os2.usWinAscent = p.parseUShort();
    os2.usWinDescent = p.parseUShort();
    if (os2.version >= 1) {
        os2.ulCodePageRange1 = p.parseULong();
        os2.ulCodePageRange2 = p.parseULong();
    }

    if (os2.version >= 2) {
        os2.sxHeight = p.parseShort();
        os2.sCapHeight = p.parseShort();
        os2.usDefaultChar = p.parseUShort();
        os2.usBreakChar = p.parseUShort();
        os2.usMaxContent = p.parseUShort();
    }

    return os2;
}

function makeOS2Table(options) {
    return new table.Table('OS/2', [
        {name: 'version', type: 'USHORT', value: 0x0003},
        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},
        {name: 'usWeightClass', type: 'USHORT', value: 0},
        {name: 'usWidthClass', type: 'USHORT', value: 0},
        {name: 'fsType', type: 'USHORT', value: 0},
        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},
        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},
        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},
        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},
        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},
        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},
        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},
        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},
        {name: 'sFamilyClass', type: 'SHORT', value: 0},
        {name: 'bFamilyType', type: 'BYTE', value: 0},
        {name: 'bSerifStyle', type: 'BYTE', value: 0},
        {name: 'bWeight', type: 'BYTE', value: 0},
        {name: 'bProportion', type: 'BYTE', value: 0},
        {name: 'bContrast', type: 'BYTE', value: 0},
        {name: 'bStrokeVariation', type: 'BYTE', value: 0},
        {name: 'bArmStyle', type: 'BYTE', value: 0},
        {name: 'bLetterform', type: 'BYTE', value: 0},
        {name: 'bMidline', type: 'BYTE', value: 0},
        {name: 'bXHeight', type: 'BYTE', value: 0},
        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},
        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},
        {name: 'fsSelection', type: 'USHORT', value: 0},
        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},
        {name: 'usLastCharIndex', type: 'USHORT', value: 0},
        {name: 'sTypoAscender', type: 'SHORT', value: 0},
        {name: 'sTypoDescender', type: 'SHORT', value: 0},
        {name: 'sTypoLineGap', type: 'SHORT', value: 0},
        {name: 'usWinAscent', type: 'USHORT', value: 0},
        {name: 'usWinDescent', type: 'USHORT', value: 0},
        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},
        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},
        {name: 'sxHeight', type: 'SHORT', value: 0},
        {name: 'sCapHeight', type: 'SHORT', value: 0},
        {name: 'usDefaultChar', type: 'USHORT', value: 0},
        {name: 'usBreakChar', type: 'USHORT', value: 0},
        {name: 'usMaxContext', type: 'USHORT', value: 0}
    ], options);
}

var os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange };

// The `post` table stores additional PostScript information, such as glyph names.
// https://www.microsoft.com/typography/OTSPEC/post.htm

// Parse the PostScript `post` table
function parsePostTable(data, start) {
    var post = {};
    var p = new parse.Parser(data, start);
    post.version = p.parseVersion();
    post.italicAngle = p.parseFixed();
    post.underlinePosition = p.parseShort();
    post.underlineThickness = p.parseShort();
    post.isFixedPitch = p.parseULong();
    post.minMemType42 = p.parseULong();
    post.maxMemType42 = p.parseULong();
    post.minMemType1 = p.parseULong();
    post.maxMemType1 = p.parseULong();
    switch (post.version) {
        case 1:
            post.names = standardNames.slice();
            break;
        case 2:
            post.numberOfGlyphs = p.parseUShort();
            post.glyphNameIndex = new Array(post.numberOfGlyphs);
            for (var i = 0; i < post.numberOfGlyphs; i++) {
                post.glyphNameIndex[i] = p.parseUShort();
            }

            post.names = [];
            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
                if (post.glyphNameIndex[i$1] >= standardNames.length) {
                    var nameLength = p.parseChar();
                    post.names.push(p.parseString(nameLength));
                }
            }

            break;
        case 2.5:
            post.numberOfGlyphs = p.parseUShort();
            post.offset = new Array(post.numberOfGlyphs);
            for (var i$2 = 0; i$2 < post.numberOfGlyphs; i$2++) {
                post.offset[i$2] = p.parseChar();
            }

            break;
    }
    return post;
}

function makePostTable() {
    return new table.Table('post', [
        {name: 'version', type: 'FIXED', value: 0x00030000},
        {name: 'italicAngle', type: 'FIXED', value: 0},
        {name: 'underlinePosition', type: 'FWORD', value: 0},
        {name: 'underlineThickness', type: 'FWORD', value: 0},
        {name: 'isFixedPitch', type: 'ULONG', value: 0},
        {name: 'minMemType42', type: 'ULONG', value: 0},
        {name: 'maxMemType42', type: 'ULONG', value: 0},
        {name: 'minMemType1', type: 'ULONG', value: 0},
        {name: 'maxMemType1', type: 'ULONG', value: 0}
    ]);
}

var post = { parse: parsePostTable, make: makePostTable };

// The `GSUB` table contains ligatures, among other things.
// https://www.microsoft.com/typography/OTSPEC/gsub.htm

var subtableParsers = new Array(9);         // subtableParsers[0] is unused

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS
subtableParsers[1] = function parseLookup1() {
    var start = this.offset + this.relativeOffset;
    var substFormat = this.parseUShort();
    if (substFormat === 1) {
        return {
            substFormat: 1,
            coverage: this.parsePointer(Parser.coverage),
            deltaGlyphId: this.parseUShort()
        };
    } else if (substFormat === 2) {
        return {
            substFormat: 2,
            coverage: this.parsePointer(Parser.coverage),
            substitute: this.parseOffset16List()
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS
subtableParsers[2] = function parseLookup2() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        sequences: this.parseListOfLists()
    };
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS
subtableParsers[3] = function parseLookup3() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        alternateSets: this.parseListOfLists()
    };
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS
subtableParsers[4] = function parseLookup4() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        ligatureSets: this.parseListOfLists(function() {
            return {
                ligGlyph: this.parseUShort(),
                components: this.parseUShortList(this.parseUShort() - 1)
            };
        })
    };
};

var lookupRecordDesc = {
    sequenceIndex: Parser.uShort,
    lookupListIndex: Parser.uShort
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF
subtableParsers[5] = function parseLookup5() {
    var start = this.offset + this.relativeOffset;
    var substFormat = this.parseUShort();

    if (substFormat === 1) {
        return {
            substFormat: substFormat,
            coverage: this.parsePointer(Parser.coverage),
            ruleSets: this.parseListOfLists(function() {
                var glyphCount = this.parseUShort();
                var substCount = this.parseUShort();
                return {
                    input: this.parseUShortList(glyphCount - 1),
                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 2) {
        return {
            substFormat: substFormat,
            coverage: this.parsePointer(Parser.coverage),
            classDef: this.parsePointer(Parser.classDef),
            classSets: this.parseListOfLists(function() {
                var glyphCount = this.parseUShort();
                var substCount = this.parseUShort();
                return {
                    classes: this.parseUShortList(glyphCount - 1),
                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 3) {
        var glyphCount = this.parseUShort();
        var substCount = this.parseUShort();
        return {
            substFormat: substFormat,
            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),
            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC
subtableParsers[6] = function parseLookup6() {
    var start = this.offset + this.relativeOffset;
    var substFormat = this.parseUShort();
    if (substFormat === 1) {
        return {
            substFormat: 1,
            coverage: this.parsePointer(Parser.coverage),
            chainRuleSets: this.parseListOfLists(function() {
                return {
                    backtrack: this.parseUShortList(),
                    input: this.parseUShortList(this.parseShort() - 1),
                    lookahead: this.parseUShortList(),
                    lookupRecords: this.parseRecordList(lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 2) {
        return {
            substFormat: 2,
            coverage: this.parsePointer(Parser.coverage),
            backtrackClassDef: this.parsePointer(Parser.classDef),
            inputClassDef: this.parsePointer(Parser.classDef),
            lookaheadClassDef: this.parsePointer(Parser.classDef),
            chainClassSet: this.parseListOfLists(function() {
                return {
                    backtrack: this.parseUShortList(),
                    input: this.parseUShortList(this.parseShort() - 1),
                    lookahead: this.parseUShortList(),
                    lookupRecords: this.parseRecordList(lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 3) {
        return {
            substFormat: 3,
            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            lookupRecords: this.parseRecordList(lookupRecordDesc)
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES
subtableParsers[7] = function parseLookup7() {
    // Extension Substitution subtable
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');
    var extensionLookupType = this.parseUShort();
    var extensionParser = new Parser(this.data, this.offset + this.parseULong());
    return {
        substFormat: 1,
        lookupType: extensionLookupType,
        extension: subtableParsers[extensionLookupType].call(extensionParser)
    };
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS
subtableParsers[8] = function parseLookup8() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
        substitutes: this.parseUShortList()
    };
};

// https://www.microsoft.com/typography/OTSPEC/gsub.htm
function parseGsubTable(data, start) {
    start = start || 0;
    var p = new Parser(data, start);
    var tableVersion = p.parseVersion(1);
    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GSUB table version.');
    if (tableVersion === 1) {
        return {
            version: tableVersion,
            scripts: p.parseScriptList(),
            features: p.parseFeatureList(),
            lookups: p.parseLookupList(subtableParsers)
        };
    } else {
        return {
            version: tableVersion,
            scripts: p.parseScriptList(),
            features: p.parseFeatureList(),
            lookups: p.parseLookupList(subtableParsers),
            variations: p.parseFeatureVariationsList()
        };
    }

}

// GSUB Writing //////////////////////////////////////////////
var subtableMakers = new Array(9);

subtableMakers[1] = function makeLookup1(subtable) {
    if (subtable.substFormat === 1) {
        return new table.Table('substitutionTable', [
            {name: 'substFormat', type: 'USHORT', value: 1},
            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)},
            {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}
        ]);
    } else {
        return new table.Table('substitutionTable', [
            {name: 'substFormat', type: 'USHORT', value: 2},
            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
        ].concat(table.ushortList('substitute', subtable.substitute)));
    }
    check.fail('Lookup type 1 substFormat must be 1 or 2.');
};

subtableMakers[3] = function makeLookup3(subtable) {
    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');
    return new table.Table('substitutionTable', [
        {name: 'substFormat', type: 'USHORT', value: 1},
        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
    ].concat(table.tableList('altSet', subtable.alternateSets, function(alternateSet) {
        return new table.Table('alternateSetTable', table.ushortList('alternate', alternateSet));
    })));
};

subtableMakers[4] = function makeLookup4(subtable) {
    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');
    return new table.Table('substitutionTable', [
        {name: 'substFormat', type: 'USHORT', value: 1},
        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
    ].concat(table.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {
        return new table.Table('ligatureSetTable', table.tableList('ligature', ligatureSet, function(ligature) {
            return new table.Table('ligatureTable',
                [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]
                .concat(table.ushortList('component', ligature.components, ligature.components.length + 1))
            );
        }));
    })));
};

function makeGsubTable(gsub) {
    return new table.Table('GSUB', [
        {name: 'version', type: 'ULONG', value: 0x10000},
        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gsub.scripts)},
        {name: 'features', type: 'TABLE', value: new table.FeatureList(gsub.features)},
        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gsub.lookups, subtableMakers)}
    ]);
}

var gsub = { parse: parseGsubTable, make: makeGsubTable };

// The `GPOS` table contains kerning pairs, among other things.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm

// Parse the metadata `meta` table.
// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html
function parseMetaTable(data, start) {
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseULong();
    check.argument(tableVersion === 1, 'Unsupported META table version.');
    p.parseULong(); // flags - currently unused and set to 0
    p.parseULong(); // tableOffset
    var numDataMaps = p.parseULong();

    var tags = {};
    for (var i = 0; i < numDataMaps; i++) {
        var tag = p.parseTag();
        var dataOffset = p.parseULong();
        var dataLength = p.parseULong();
        var text = decode.UTF8(data, start + dataOffset, dataLength);

        tags[tag] = text;
    }
    return tags;
}

function makeMetaTable(tags) {
    var numTags = Object.keys(tags).length;
    var stringPool = '';
    var stringPoolOffset = 16 + numTags * 12;

    var result = new table.Table('meta', [
        {name: 'version', type: 'ULONG', value: 1},
        {name: 'flags', type: 'ULONG', value: 0},
        {name: 'offset', type: 'ULONG', value: stringPoolOffset},
        {name: 'numTags', type: 'ULONG', value: numTags}
    ]);

    for (var tag in tags) {
        var pos = stringPool.length;
        stringPool += tags[tag];

        result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});
        result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});
        result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});
    }

    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});

    return result;
}

var meta = { parse: parseMetaTable, make: makeMetaTable };

// The `sfnt` wrapper provides organization for the tables in the font.
// It is the top-level data structure in a font.
// https://www.microsoft.com/typography/OTSPEC/otff.htm
// Recommendations for creating OpenType Fonts:
// http://www.microsoft.com/typography/otspec140/recom.htm

function log2(v) {
    return Math.log(v) / Math.log(2) | 0;
}

function computeCheckSum(bytes) {
    while (bytes.length % 4 !== 0) {
        bytes.push(0);
    }

    var sum = 0;
    for (var i = 0; i < bytes.length; i += 4) {
        sum += (bytes[i] << 24) +
            (bytes[i + 1] << 16) +
            (bytes[i + 2] << 8) +
            (bytes[i + 3]);
    }

    sum %= Math.pow(2, 32);
    return sum;
}

function makeTableRecord(tag, checkSum, offset, length) {
    return new table.Record('Table Record', [
        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},
        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},
        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},
        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}
    ]);
}

function makeSfntTable(tables) {
    var sfnt = new table.Table('sfnt', [
        {name: 'version', type: 'TAG', value: 'OTTO'},
        {name: 'numTables', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);
    sfnt.tables = tables;
    sfnt.numTables = tables.length;
    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
    sfnt.searchRange = 16 * highestPowerOf2;
    sfnt.entrySelector = log2(highestPowerOf2);
    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;

    var recordFields = [];
    var tableFields = [];

    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);
    while (offset % 4 !== 0) {
        offset += 1;
        tableFields.push({name: 'padding', type: 'BYTE', value: 0});
    }

    for (var i = 0; i < tables.length; i += 1) {
        var t = tables[i];
        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
        var tableLength = t.sizeOf();
        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});
        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});
        offset += tableLength;
        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');
        while (offset % 4 !== 0) {
            offset += 1;
            tableFields.push({name: 'padding', type: 'BYTE', value: 0});
        }
    }

    // Table records need to be sorted alphabetically.
    recordFields.sort(function(r1, r2) {
        if (r1.value.tag > r2.value.tag) {
            return 1;
        } else {
            return -1;
        }
    });

    sfnt.fields = sfnt.fields.concat(recordFields);
    sfnt.fields = sfnt.fields.concat(tableFields);
    return sfnt;
}

// Get the metrics for a character. If the string has more than one character
// this function returns metrics for the first available character.
// You can provide optional fallback metrics if no characters are available.
function metricsForChar(font, chars, notFoundMetrics) {
    for (var i = 0; i < chars.length; i += 1) {
        var glyphIndex = font.charToGlyphIndex(chars[i]);
        if (glyphIndex > 0) {
            var glyph = font.glyphs.get(glyphIndex);
            return glyph.getMetrics();
        }
    }

    return notFoundMetrics;
}

function average(vs) {
    var sum = 0;
    for (var i = 0; i < vs.length; i += 1) {
        sum += vs[i];
    }

    return sum / vs.length;
}

// Convert the font object to a SFNT data structure.
// This structure contains all the necessary tables and metadata to create a binary OTF file.
function fontToSfntTable(font) {
    var xMins = [];
    var yMins = [];
    var xMaxs = [];
    var yMaxs = [];
    var advanceWidths = [];
    var leftSideBearings = [];
    var rightSideBearings = [];
    var firstCharIndex;
    var lastCharIndex = 0;
    var ulUnicodeRange1 = 0;
    var ulUnicodeRange2 = 0;
    var ulUnicodeRange3 = 0;
    var ulUnicodeRange4 = 0;

    for (var i = 0; i < font.glyphs.length; i += 1) {
        var glyph = font.glyphs.get(i);
        var unicode = glyph.unicode | 0;

        if (isNaN(glyph.advanceWidth)) {
            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');
        }

        if (firstCharIndex > unicode || firstCharIndex === undefined) {
            // ignore .notdef char
            if (unicode > 0) {
                firstCharIndex = unicode;
            }
        }

        if (lastCharIndex < unicode) {
            lastCharIndex = unicode;
        }

        var position = os2.getUnicodeRange(unicode);
        if (position < 32) {
            ulUnicodeRange1 |= 1 << position;
        } else if (position < 64) {
            ulUnicodeRange2 |= 1 << position - 32;
        } else if (position < 96) {
            ulUnicodeRange3 |= 1 << position - 64;
        } else if (position < 123) {
            ulUnicodeRange4 |= 1 << position - 96;
        } else {
            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');
        }
        // Skip non-important characters.
        if (glyph.name === '.notdef') { continue; }
        var metrics = glyph.getMetrics();
        xMins.push(metrics.xMin);
        yMins.push(metrics.yMin);
        xMaxs.push(metrics.xMax);
        yMaxs.push(metrics.yMax);
        leftSideBearings.push(metrics.leftSideBearing);
        rightSideBearings.push(metrics.rightSideBearing);
        advanceWidths.push(glyph.advanceWidth);
    }

    var globals = {
        xMin: Math.min.apply(null, xMins),
        yMin: Math.min.apply(null, yMins),
        xMax: Math.max.apply(null, xMaxs),
        yMax: Math.max.apply(null, yMaxs),
        advanceWidthMax: Math.max.apply(null, advanceWidths),
        advanceWidthAvg: average(advanceWidths),
        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
        minRightSideBearing: Math.min.apply(null, rightSideBearings)
    };
    globals.ascender = font.ascender;
    globals.descender = font.descender;

    var headTable = head.make({
        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)
        unitsPerEm: font.unitsPerEm,
        xMin: globals.xMin,
        yMin: globals.yMin,
        xMax: globals.xMax,
        yMax: globals.yMax,
        lowestRecPPEM: 3,
        createdTimestamp: font.createdTimestamp
    });

    var hheaTable = hhea.make({
        ascender: globals.ascender,
        descender: globals.descender,
        advanceWidthMax: globals.advanceWidthMax,
        minLeftSideBearing: globals.minLeftSideBearing,
        minRightSideBearing: globals.minRightSideBearing,
        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
        numberOfHMetrics: font.glyphs.length
    });

    var maxpTable = maxp.make(font.glyphs.length);

    var os2Table = os2.make({
        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
        usWeightClass: font.tables.os2.usWeightClass,
        usWidthClass: font.tables.os2.usWidthClass,
        usFirstCharIndex: firstCharIndex,
        usLastCharIndex: lastCharIndex,
        ulUnicodeRange1: ulUnicodeRange1,
        ulUnicodeRange2: ulUnicodeRange2,
        ulUnicodeRange3: ulUnicodeRange3,
        ulUnicodeRange4: ulUnicodeRange4,
        fsSelection: font.tables.os2.fsSelection, // REGULAR
        // See http://typophile.com/node/13081 for more info on vertical metrics.
        // We get metrics for typical characters (such as "x" for xHeight).
        // We provide some fallback characters if characters are unavailable: their
        // ordering was chosen experimentally.
        sTypoAscender: globals.ascender,
        sTypoDescender: globals.descender,
        sTypoLineGap: 0,
        usWinAscent: globals.yMax,
        usWinDescent: Math.abs(globals.yMin),
        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now
        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,
        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.
        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.
    });

    var hmtxTable = hmtx.make(font.glyphs);
    var cmapTable = cmap.make(font.glyphs);

    var englishFamilyName = font.getEnglishName('fontFamily');
    var englishStyleName = font.getEnglishName('fontSubfamily');
    var englishFullName = englishFamilyName + ' ' + englishStyleName;
    var postScriptName = font.getEnglishName('postScriptName');
    if (!postScriptName) {
        postScriptName = englishFamilyName.replace(/\s/g, '') + '-' + englishStyleName;
    }

    var names = {};
    for (var n in font.names) {
        names[n] = font.names[n];
    }

    if (!names.uniqueID) {
        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};
    }

    if (!names.postScriptName) {
        names.postScriptName = {en: postScriptName};
    }

    if (!names.preferredFamily) {
        names.preferredFamily = font.names.fontFamily;
    }

    if (!names.preferredSubfamily) {
        names.preferredSubfamily = font.names.fontSubfamily;
    }

    var languageTags = [];
    var nameTable = _name.make(names, languageTags);
    var ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);

    var postTable = post.make();
    var cffTable = cff.make(font.glyphs, {
        version: font.getEnglishName('version'),
        fullName: englishFullName,
        familyName: englishFamilyName,
        weightName: englishStyleName,
        postScriptName: postScriptName,
        unitsPerEm: font.unitsPerEm,
        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]
    });

    var metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;

    // The order does not matter because makeSfntTable() will sort them.
    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
    if (ltagTable) {
        tables.push(ltagTable);
    }
    // Optional tables
    if (font.tables.gsub) {
        tables.push(gsub.make(font.tables.gsub));
    }
    if (metaTable) {
        tables.push(metaTable);
    }

    var sfntTable = makeSfntTable(tables);

    // Compute the font's checkSum and store it in head.checkSumAdjustment.
    var bytes = sfntTable.encode();
    var checkSum = computeCheckSum(bytes);
    var tableFields = sfntTable.fields;
    var checkSumAdjusted = false;
    for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {
        if (tableFields[i$1].name === 'head table') {
            tableFields[i$1].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;
            checkSumAdjusted = true;
            break;
        }
    }

    if (!checkSumAdjusted) {
        throw new Error('Could not find head table with checkSum to adjust.');
    }

    return sfntTable;
}

var sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum };

// The Layout object is the prototype of Substitution objects, and provides
// utility methods to manipulate common layout tables (GPOS, GSUB, GDEF...)

function searchTag(arr, tag) {
    /* jshint bitwise: false */
    var imin = 0;
    var imax = arr.length - 1;
    while (imin <= imax) {
        var imid = (imin + imax) >>> 1;
        var val = arr[imid].tag;
        if (val === tag) {
            return imid;
        } else if (val < tag) {
            imin = imid + 1;
        } else { imax = imid - 1; }
    }
    // Not found: return -1-insertion point
    return -imin - 1;
}

function binSearch(arr, value) {
    /* jshint bitwise: false */
    var imin = 0;
    var imax = arr.length - 1;
    while (imin <= imax) {
        var imid = (imin + imax) >>> 1;
        var val = arr[imid];
        if (val === value) {
            return imid;
        } else if (val < value) {
            imin = imid + 1;
        } else { imax = imid - 1; }
    }
    // Not found: return -1-insertion point
    return -imin - 1;
}

// binary search in a list of ranges (coverage, class definition)
function searchRange(ranges, value) {
    // jshint bitwise: false
    var range;
    var imin = 0;
    var imax = ranges.length - 1;
    while (imin <= imax) {
        var imid = (imin + imax) >>> 1;
        range = ranges[imid];
        var start = range.start;
        if (start === value) {
            return range;
        } else if (start < value) {
            imin = imid + 1;
        } else { imax = imid - 1; }
    }
    if (imin > 0) {
        range = ranges[imin - 1];
        if (value > range.end) { return 0; }
        return range;
    }
}

/**
 * @exports opentype.Layout
 * @class
 */
function Layout(font, tableName) {
    this.font = font;
    this.tableName = tableName;
}

Layout.prototype = {

    /**
     * Binary search an object by "tag" property
     * @instance
     * @function searchTag
     * @memberof opentype.Layout
     * @param  {Array} arr
     * @param  {string} tag
     * @return {number}
     */
    searchTag: searchTag,

    /**
     * Binary search in a list of numbers
     * @instance
     * @function binSearch
     * @memberof opentype.Layout
     * @param  {Array} arr
     * @param  {number} value
     * @return {number}
     */
    binSearch: binSearch,

    /**
     * Get or create the Layout table (GSUB, GPOS etc).
     * @param  {boolean} create - Whether to create a new one.
     * @return {Object} The GSUB or GPOS table.
     */
    getTable: function(create) {
        var layout = this.font.tables[this.tableName];
        if (!layout && create) {
            layout = this.font.tables[this.tableName] = this.createDefaultTable();
        }
        return layout;
    },

    /**
     * Returns all scripts in the substitution table.
     * @instance
     * @return {Array}
     */
    getScriptNames: function() {
        var layout = this.getTable();
        if (!layout) { return []; }
        return layout.scripts.map(function(script) {
            return script.tag;
        });
    },

    /**
     * Returns the best bet for a script name.
     * Returns 'DFLT' if it exists.
     * If not, returns 'latn' if it exists.
     * If neither exist, returns undefined.
     */
    getDefaultScriptName: function() {
        var layout = this.getTable();
        if (!layout) { return; }
        var hasLatn = false;
        for (var i = 0; i < layout.scripts.length; i++) {
            var name = layout.scripts[i].tag;
            if (name === 'DFLT') { return name; }
            if (name === 'latn') { hasLatn = true; }
        }
        if (hasLatn) { return 'latn'; }
    },

    /**
     * Returns all LangSysRecords in the given script.
     * @instance
     * @param {string} [script='DFLT']
     * @param {boolean} create - forces the creation of this script table if it doesn't exist.
     * @return {Object} An object with tag and script properties.
     */
    getScriptTable: function(script, create) {
        var layout = this.getTable(create);
        if (layout) {
            script = script || 'DFLT';
            var scripts = layout.scripts;
            var pos = searchTag(layout.scripts, script);
            if (pos >= 0) {
                return scripts[pos].script;
            } else if (create) {
                var scr = {
                    tag: script,
                    script: {
                        defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},
                        langSysRecords: []
                    }
                };
                scripts.splice(-1 - pos, 0, scr);
                return scr.script;
            }
        }
    },

    /**
     * Returns a language system table
     * @instance
     * @param {string} [script='DFLT']
     * @param {string} [language='dlft']
     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.
     * @return {Object}
     */
    getLangSysTable: function(script, language, create) {
        var scriptTable = this.getScriptTable(script, create);
        if (scriptTable) {
            if (!language || language === 'dflt' || language === 'DFLT') {
                return scriptTable.defaultLangSys;
            }
            var pos = searchTag(scriptTable.langSysRecords, language);
            if (pos >= 0) {
                return scriptTable.langSysRecords[pos].langSys;
            } else if (create) {
                var langSysRecord = {
                    tag: language,
                    langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}
                };
                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
                return langSysRecord.langSys;
            }
        }
    },

    /**
     * Get a specific feature table.
     * @instance
     * @param {string} [script='DFLT']
     * @param {string} [language='dlft']
     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm
     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.
     * @return {Object}
     */
    getFeatureTable: function(script, language, feature, create) {
        var langSysTable = this.getLangSysTable(script, language, create);
        if (langSysTable) {
            var featureRecord;
            var featIndexes = langSysTable.featureIndexes;
            var allFeatures = this.font.tables[this.tableName].features;
            // The FeatureIndex array of indices is in arbitrary order,
            // even if allFeatures is sorted alphabetically by feature tag.
            for (var i = 0; i < featIndexes.length; i++) {
                featureRecord = allFeatures[featIndexes[i]];
                if (featureRecord.tag === feature) {
                    return featureRecord.feature;
                }
            }
            if (create) {
                var index = allFeatures.length;
                // Automatic ordering of features would require to shift feature indexes in the script list.
                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');
                featureRecord = {
                    tag: feature,
                    feature: { params: 0, lookupListIndexes: [] }
                };
                allFeatures.push(featureRecord);
                featIndexes.push(index);
                return featureRecord.feature;
            }
        }
    },

    /**
     * Get the lookup tables of a given type for a script/language/feature.
     * @instance
     * @param {string} [script='DFLT']
     * @param {string} [language='dlft']
     * @param {string} feature - 4-letter feature code
     * @param {number} lookupType - 1 to 9
     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.
     * @return {Object[]}
     */
    getLookupTables: function(script, language, feature, lookupType, create) {
        var featureTable = this.getFeatureTable(script, language, feature, create);
        var tables = [];
        if (featureTable) {
            var lookupTable;
            var lookupListIndexes = featureTable.lookupListIndexes;
            var allLookups = this.font.tables[this.tableName].lookups;
            // lookupListIndexes are in no particular order, so use naive search.
            for (var i = 0; i < lookupListIndexes.length; i++) {
                lookupTable = allLookups[lookupListIndexes[i]];
                if (lookupTable.lookupType === lookupType) {
                    tables.push(lookupTable);
                }
            }
            if (tables.length === 0 && create) {
                lookupTable = {
                    lookupType: lookupType,
                    lookupFlag: 0,
                    subtables: [],
                    markFilteringSet: undefined
                };
                var index = allLookups.length;
                allLookups.push(lookupTable);
                lookupListIndexes.push(index);
                return [lookupTable];
            }
        }
        return tables;
    },

    /**
     * Find a glyph in a class definition table
     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table
     * @param {object} classDefTable - an OpenType Layout class definition table
     * @param {number} glyphIndex - the index of the glyph to find
     * @returns {number} -1 if not found
     */
    getGlyphClass: function(classDefTable, glyphIndex) {
        switch (classDefTable.format) {
            case 1:
                if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {
                    return classDefTable.classes[glyphIndex - classDefTable.startGlyph];
                }
                return 0;
            case 2:
                var range = searchRange(classDefTable.ranges, glyphIndex);
                return range ? range.classId : 0;
        }
    },

    /**
     * Find a glyph in a coverage table
     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table
     * @param {object} coverageTable - an OpenType Layout coverage table
     * @param {number} glyphIndex - the index of the glyph to find
     * @returns {number} -1 if not found
     */
    getCoverageIndex: function(coverageTable, glyphIndex) {
        switch (coverageTable.format) {
            case 1:
                var index = binSearch(coverageTable.glyphs, glyphIndex);
                return index >= 0 ? index : -1;
            case 2:
                var range = searchRange(coverageTable.ranges, glyphIndex);
                return range ? range.index + glyphIndex - range.start : -1;
        }
    },

    /**
     * Returns the list of glyph indexes of a coverage table.
     * Format 1: the list is stored raw
     * Format 2: compact list as range records.
     * @instance
     * @param  {Object} coverageTable
     * @return {Array}
     */
    expandCoverage: function(coverageTable) {
        if (coverageTable.format === 1) {
            return coverageTable.glyphs;
        } else {
            var glyphs = [];
            var ranges = coverageTable.ranges;
            for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                var start = range.start;
                var end = range.end;
                for (var j = start; j <= end; j++) {
                    glyphs.push(j);
                }
            }
            return glyphs;
        }
    }

};

// The Position object provides utility methods to manipulate
// the GPOS position table.

/**
 * @exports opentype.Position
 * @class
 * @extends opentype.Layout
 * @param {opentype.Font}
 * @constructor
 */
function Position(font) {
    Layout.call(this, font, 'gpos');
}

Position.prototype = Layout.prototype;

/**
 * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.
 *
 * @param {integer} leftIndex - left glyph index
 * @param {integer} rightIndex - right glyph index
 * @returns {integer}
 */
Position.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {
    var this$1 = this;

    for (var i = 0; i < kerningLookups.length; i++) {
        var subtables = kerningLookups[i].subtables;
        for (var j = 0; j < subtables.length; j++) {
            var subtable = subtables[j];
            var covIndex = this$1.getCoverageIndex(subtable.coverage, leftIndex);
            if (covIndex < 0) { continue; }
            switch (subtable.posFormat) {
                case 1:
                    // Search Pair Adjustment Positioning Format 1
                    var pairSet = subtable.pairSets[covIndex];
                    for (var k = 0; k < pairSet.length; k++) {
                        var pair = pairSet[k];
                        if (pair.secondGlyph === rightIndex) {
                            return pair.value1 && pair.value1.xAdvance || 0;
                        }
                    }
                    break;      // left glyph found, not right glyph - try next subtable
                case 2:
                    // Search Pair Adjustment Positioning Format 2
                    var class1 = this$1.getGlyphClass(subtable.classDef1, leftIndex);
                    var class2 = this$1.getGlyphClass(subtable.classDef2, rightIndex);
                    var pair$1 = subtable.classRecords[class1][class2];
                    return pair$1.value1 && pair$1.value1.xAdvance || 0;
            }
        }
    }
    return 0;
};

/**
 * List all kerning lookup tables.
 *
 * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value
 * @param {string} [language='dflt']
 * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)
 */
Position.prototype.getKerningTables = function(script, language) {
    if (this.font.tables.gpos) {
        return this.getLookupTables(script, language, 'kern', 2);
    }
};

// The Substitution object provides utility methods to manipulate
// the GSUB substitution table.

/**
 * @exports opentype.Substitution
 * @class
 * @extends opentype.Layout
 * @param {opentype.Font}
 * @constructor
 */
function Substitution(font) {
    Layout.call(this, font, 'gsub');
}

// Check if 2 arrays of primitives are equal.
function arraysEqual(ar1, ar2) {
    var n = ar1.length;
    if (n !== ar2.length) { return false; }
    for (var i = 0; i < n; i++) {
        if (ar1[i] !== ar2[i]) { return false; }
    }
    return true;
}

// Find the first subtable of a lookup table in a particular format.
function getSubstFormat(lookupTable, format, defaultSubtable) {
    var subtables = lookupTable.subtables;
    for (var i = 0; i < subtables.length; i++) {
        var subtable = subtables[i];
        if (subtable.substFormat === format) {
            return subtable;
        }
    }
    if (defaultSubtable) {
        subtables.push(defaultSubtable);
        return defaultSubtable;
    }
    return undefined;
}

Substitution.prototype = Layout.prototype;

/**
 * Create a default GSUB table.
 * @return {Object} gsub - The GSUB table.
 */
Substitution.prototype.createDefaultTable = function() {
    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.
    return {
        version: 1,
        scripts: [{
            tag: 'DFLT',
            script: {
                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },
                langSysRecords: []
            }
        }],
        features: [],
        lookups: []
    };
};

/**
 * List all single substitutions (lookup type 1) for a given script, language, and feature.
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)
 * @return {Array} substitutions - The list of substitutions.
 */
Substitution.prototype.getSingle = function(feature, script, language) {
    var this$1 = this;

    var substitutions = [];
    var lookupTables = this.getLookupTables(script, language, feature, 1);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this$1.expandCoverage(subtable.coverage);
            var j = (void 0);
            if (subtable.substFormat === 1) {
                var delta = subtable.deltaGlyphId;
                for (j = 0; j < glyphs.length; j++) {
                    var glyph = glyphs[j];
                    substitutions.push({ sub: glyph, by: glyph + delta });
                }
            } else {
                var substitute = subtable.substitute;
                for (j = 0; j < glyphs.length; j++) {
                    substitutions.push({ sub: glyphs[j], by: substitute[j] });
                }
            }
        }
    }
    return substitutions;
};

/**
 * List all alternates (lookup type 3) for a given script, language, and feature.
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @param {string} feature - 4-character feature name ('aalt', 'salt'...)
 * @return {Array} alternates - The list of alternates
 */
Substitution.prototype.getAlternates = function(feature, script, language) {
    var this$1 = this;

    var alternates = [];
    var lookupTables = this.getLookupTables(script, language, feature, 3);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this$1.expandCoverage(subtable.coverage);
            var alternateSets = subtable.alternateSets;
            for (var j = 0; j < glyphs.length; j++) {
                alternates.push({ sub: glyphs[j], by: alternateSets[j] });
            }
        }
    }
    return alternates;
};

/**
 * List all ligatures (lookup type 4) for a given script, language, and feature.
 * The result is an array of ligature objects like { sub: [ids], by: id }
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @return {Array} ligatures - The list of ligatures.
 */
Substitution.prototype.getLigatures = function(feature, script, language) {
    var this$1 = this;

    var ligatures = [];
    var lookupTables = this.getLookupTables(script, language, feature, 4);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this$1.expandCoverage(subtable.coverage);
            var ligatureSets = subtable.ligatureSets;
            for (var j = 0; j < glyphs.length; j++) {
                var startGlyph = glyphs[j];
                var ligSet = ligatureSets[j];
                for (var k = 0; k < ligSet.length; k++) {
                    var lig = ligSet[k];
                    ligatures.push({
                        sub: [startGlyph].concat(lig.components),
                        by: lig.ligGlyph
                    });
                }
            }
        }
    }
    return ligatures;
};

/**
 * Add or modify a single substitution (lookup type 1)
 * Format 2, more flexible, is always used.
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {Object} substitution - { sub: id, delta: number } for format 1 or { sub: id, by: id } for format 2.
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.addSingle = function(feature, substitution, script, language) {
    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];
    var subtable = getSubstFormat(lookupTable, 2, {                // lookup type 1 subtable, format 2, coverage format 1
        substFormat: 2,
        coverage: {format: 1, glyphs: []},
        substitute: []
    });
    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = substitution.sub;
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos < 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.substitute.splice(pos, 0, 0);
    }
    subtable.substitute[pos] = substitution.by;
};

/**
 * Add or modify an alternate substitution (lookup type 1)
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {Object} substitution - { sub: id, by: [ids] }
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.addAlternate = function(feature, substitution, script, language) {
    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];
    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 3 subtable, format 1, coverage format 1
        substFormat: 1,
        coverage: {format: 1, glyphs: []},
        alternateSets: []
    });
    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = substitution.sub;
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos < 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.alternateSets.splice(pos, 0, 0);
    }
    subtable.alternateSets[pos] = substitution.by;
};

/**
 * Add a ligature (lookup type 4)
 * Ligatures with more components must be stored ahead of those with fewer components in order to be found
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {Object} ligature - { sub: [ids], by: id }
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.addLigature = function(feature, ligature, script, language) {
    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];
    var subtable = lookupTable.subtables[0];
    if (!subtable) {
        subtable = {                // lookup type 4 subtable, format 1, coverage format 1
            substFormat: 1,
            coverage: { format: 1, glyphs: [] },
            ligatureSets: []
        };
        lookupTable.subtables[0] = subtable;
    }
    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = ligature.sub[0];
    var ligComponents = ligature.sub.slice(1);
    var ligatureTable = {
        ligGlyph: ligature.by,
        components: ligComponents
    };
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos >= 0) {
        // ligatureSet already exists
        var ligatureSet = subtable.ligatureSets[pos];
        for (var i = 0; i < ligatureSet.length; i++) {
            // If ligature already exists, return.
            if (arraysEqual(ligatureSet[i].components, ligComponents)) {
                return;
            }
        }
        // ligature does not exist: add it.
        ligatureSet.push(ligatureTable);
    } else {
        // Create a new ligatureSet and add coverage for the first glyph.
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
    }
};

/**
 * List all feature data for a given script and language.
 * @param {string} feature - 4-letter feature name
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @return {Array} substitutions - The list of substitutions.
 */
Substitution.prototype.getFeature = function(feature, script, language) {
    if (/ss\d\d/.test(feature)) {
        // ss01 - ss20
        return this.getSingle(feature, script, language);
    }
    switch (feature) {
        case 'aalt':
        case 'salt':
            return this.getSingle(feature, script, language)
                    .concat(this.getAlternates(feature, script, language));
        case 'dlig':
        case 'liga':
        case 'rlig': return this.getLigatures(feature, script, language);
    }
    return undefined;
};

/**
 * Add a substitution to a feature for a given script and language.
 * @param {string} feature - 4-letter feature name
 * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.add = function(feature, sub, script, language) {
    if (/ss\d\d/.test(feature)) {
        // ss01 - ss20
        return this.addSingle(feature, sub, script, language);
    }
    switch (feature) {
        case 'aalt':
        case 'salt':
            if (typeof sub.by === 'number') {
                return this.addSingle(feature, sub, script, language);
            }
            return this.addAlternate(feature, sub, script, language);
        case 'dlig':
        case 'liga':
        case 'rlig':
            return this.addLigature(feature, sub, script, language);
    }
    return undefined;
};

function isBrowser() {
    return typeof window !== 'undefined';
}

function nodeBufferToArrayBuffer(buffer) {
    var ab = new ArrayBuffer(buffer.length);
    var view = new Uint8Array(ab);
    for (var i = 0; i < buffer.length; ++i) {
        view[i] = buffer[i];
    }

    return ab;
}

function arrayBufferToNodeBuffer(ab) {
    var buffer = new Buffer(ab.byteLength);
    var view = new Uint8Array(ab);
    for (var i = 0; i < buffer.length; ++i) {
        buffer[i] = view[i];
    }

    return buffer;
}

function checkArgument(expression, message) {
    if (!expression) {
        throw message;
    }
}

/* A TrueType font hinting interpreter.
*
* (c) 2017 Axel Kittenberger
*
* This interpreter has been implemented according to this documentation:
* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html
*
* According to the documentation F24DOT6 values are used for pixels.
* That means calculation is 1/64 pixel accurate and uses integer operations.
* However, Javascript has floating point operations by default and only
* those are available. One could make a case to simulate the 1/64 accuracy
* exactly by truncating after every division operation
* (for example with << 0) to get pixel exactly results as other TrueType
* implementations. It may make sense since some fonts are pixel optimized
* by hand using DELTAP instructions. The current implementation doesn't
* and rather uses full floating point precision.
*
* xScale, yScale and rotation is currently ignored.
*
* A few non-trivial instructions are missing as I didn't encounter yet
* a font that used them to test a possible implementation.
*
* Some fonts seem to use undocumented features regarding the twilight zone.
* Only some of them are implemented as they were encountered.
*
* The exports.DEBUG statements are removed on the minified distribution file.
*/
var instructionTable;
var exec;
var execGlyph;
var execComponent;

/*
* Creates a hinting object.
*
* There ought to be exactly one
* for each truetype font that is used for hinting.
*/
function Hinting(font) {
    // the font this hinting object is for
    this.font = font;

    // cached states
    this._fpgmState  =
    this._prepState  =
        undefined;

    // errorState
    // 0 ... all okay
    // 1 ... had an error in a glyf,
    //       continue working but stop spamming
    //       the console
    // 2 ... error at prep, stop hinting at this ppem
    // 3 ... error at fpeg, stop hinting for this font at all
    this._errorState = 0;
}

/*
* Not rounding.
*/
function roundOff(v) {
    return v;
}

/*
* Rounding to grid.
*/
function roundToGrid(v) {
    //Rounding in TT is supposed to "symmetrical around zero"
    return Math.sign(v) * Math.round(Math.abs(v));
}

/*
* Rounding to double grid.
*/
function roundToDoubleGrid(v) {
    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;
}

/*
* Rounding to half grid.
*/
function roundToHalfGrid(v) {
    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);
}

/*
* Rounding to up to grid.
*/
function roundUpToGrid(v) {
    return Math.sign(v) * Math.ceil(Math.abs(v));
}

/*
* Rounding to down to grid.
*/
function roundDownToGrid(v) {
    return Math.sign(v) * Math.floor(Math.abs(v));
}

/*
* Super rounding.
*/
var roundSuper = function (v) {
    var period = this.srPeriod;
    var phase = this.srPhase;
    var threshold = this.srThreshold;
    var sign = 1;

    if (v < 0) {
        v = -v;
        sign = -1;
    }

    v += threshold - phase;

    v = Math.trunc(v / period) * period;

    v += phase;

    // according to http://xgridfit.sourceforge.net/round.html
    if (v < 0) { return phase * sign; }

    return v * sign;
};

/*
* Unit vector of x-axis.
*/
var xUnitVector = {
    x: 1,

    y: 0,

    axis: 'x',

    // Gets the projected distance between two points.
    // o1/o2 ... if true, respective original position is used.
    distance: function (p1, p2, o1, o2) {
        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);
    },

    // Moves point p so the moved position has the same relative
    // position to the moved positions of rp1 and rp2 than the
    // original positions had.
    //
    // See APPENDIX on INTERPOLATE at the bottom of this file.
    interpolate: function (p, rp1, rp2, pv) {
        var do1;
        var do2;
        var doa1;
        var doa2;
        var dm1;
        var dm2;
        var dt;

        if (!pv || pv === this) {
            do1 = p.xo - rp1.xo;
            do2 = p.xo - rp2.xo;
            dm1 = rp1.x - rp1.xo;
            dm2 = rp2.x - rp2.xo;
            doa1 = Math.abs(do1);
            doa2 = Math.abs(do2);
            dt = doa1 + doa2;

            if (dt === 0) {
                p.x = p.xo + (dm1 + dm2) / 2;
                return;
            }

            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;
            return;
        }

        do1 = pv.distance(p, rp1, true, true);
        do2 = pv.distance(p, rp2, true, true);
        dm1 = pv.distance(rp1, rp1, false, true);
        dm2 = pv.distance(rp2, rp2, false, true);
        doa1 = Math.abs(do1);
        doa2 = Math.abs(do2);
        dt = doa1 + doa2;

        if (dt === 0) {
            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
            return;
        }

        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
    },

    // Slope of line normal to this
    normalSlope: Number.NEGATIVE_INFINITY,

    // Sets the point 'p' relative to point 'rp'
    // by the distance 'd'.
    //
    // See APPENDIX on SETRELATIVE at the bottom of this file.
    //
    // p   ... point to set
    // rp  ... reference point
    // d   ... distance on projection vector
    // pv  ... projection vector (undefined = this)
    // org ... if true, uses the original position of rp as reference.
    setRelative: function (p, rp, d, pv, org) {
        if (!pv || pv === this) {
            p.x = (org ? rp.xo : rp.x) + d;
            return;
        }

        var rpx = org ? rp.xo : rp.x;
        var rpy = org ? rp.yo : rp.y;
        var rpdx = rpx + d * pv.x;
        var rpdy = rpy + d * pv.y;

        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;
    },

    // Slope of vector line.
    slope: 0,

    // Touches the point p.
    touch: function (p) {
        p.xTouched = true;
    },

    // Tests if a point p is touched.
    touched: function (p) {
        return p.xTouched;
    },

    // Untouches the point p.
    untouch: function (p) {
        p.xTouched = false;
    }
};

/*
* Unit vector of y-axis.
*/
var yUnitVector = {
    x: 0,

    y: 1,

    axis: 'y',

    // Gets the projected distance between two points.
    // o1/o2 ... if true, respective original position is used.
    distance: function (p1, p2, o1, o2) {
        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);
    },

    // Moves point p so the moved position has the same relative
    // position to the moved positions of rp1 and rp2 than the
    // original positions had.
    //
    // See APPENDIX on INTERPOLATE at the bottom of this file.
    interpolate: function (p, rp1, rp2, pv) {
        var do1;
        var do2;
        var doa1;
        var doa2;
        var dm1;
        var dm2;
        var dt;

        if (!pv || pv === this) {
            do1 = p.yo - rp1.yo;
            do2 = p.yo - rp2.yo;
            dm1 = rp1.y - rp1.yo;
            dm2 = rp2.y - rp2.yo;
            doa1 = Math.abs(do1);
            doa2 = Math.abs(do2);
            dt = doa1 + doa2;

            if (dt === 0) {
                p.y = p.yo + (dm1 + dm2) / 2;
                return;
            }

            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;
            return;
        }

        do1 = pv.distance(p, rp1, true, true);
        do2 = pv.distance(p, rp2, true, true);
        dm1 = pv.distance(rp1, rp1, false, true);
        dm2 = pv.distance(rp2, rp2, false, true);
        doa1 = Math.abs(do1);
        doa2 = Math.abs(do2);
        dt = doa1 + doa2;

        if (dt === 0) {
            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
            return;
        }

        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
    },

    // Slope of line normal to this.
    normalSlope: 0,

    // Sets the point 'p' relative to point 'rp'
    // by the distance 'd'
    //
    // See APPENDIX on SETRELATIVE at the bottom of this file.
    //
    // p   ... point to set
    // rp  ... reference point
    // d   ... distance on projection vector
    // pv  ... projection vector (undefined = this)
    // org ... if true, uses the original position of rp as reference.
    setRelative: function (p, rp, d, pv, org) {
        if (!pv || pv === this) {
            p.y = (org ? rp.yo : rp.y) + d;
            return;
        }

        var rpx = org ? rp.xo : rp.x;
        var rpy = org ? rp.yo : rp.y;
        var rpdx = rpx + d * pv.x;
        var rpdy = rpy + d * pv.y;

        p.y = rpdy + pv.normalSlope * (p.x - rpdx);
    },

    // Slope of vector line.
    slope: Number.POSITIVE_INFINITY,

    // Touches the point p.
    touch: function (p) {
        p.yTouched = true;
    },

    // Tests if a point p is touched.
    touched: function (p) {
        return p.yTouched;
    },

    // Untouches the point p.
    untouch: function (p) {
        p.yTouched = false;
    }
};

Object.freeze(xUnitVector);
Object.freeze(yUnitVector);

/*
* Creates a unit vector that is not x- or y-axis.
*/
function UnitVector(x, y) {
    this.x = x;
    this.y = y;
    this.axis = undefined;
    this.slope = y / x;
    this.normalSlope = -x / y;
    Object.freeze(this);
}

/*
* Gets the projected distance between two points.
* o1/o2 ... if true, respective original position is used.
*/
UnitVector.prototype.distance = function(p1, p2, o1, o2) {
    return (
        this.x * xUnitVector.distance(p1, p2, o1, o2) +
        this.y * yUnitVector.distance(p1, p2, o1, o2)
    );
};

/*
* Moves point p so the moved position has the same relative
* position to the moved positions of rp1 and rp2 than the
* original positions had.
*
* See APPENDIX on INTERPOLATE at the bottom of this file.
*/
UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {
    var dm1;
    var dm2;
    var do1;
    var do2;
    var doa1;
    var doa2;
    var dt;

    do1 = pv.distance(p, rp1, true, true);
    do2 = pv.distance(p, rp2, true, true);
    dm1 = pv.distance(rp1, rp1, false, true);
    dm2 = pv.distance(rp2, rp2, false, true);
    doa1 = Math.abs(do1);
    doa2 = Math.abs(do2);
    dt = doa1 + doa2;

    if (dt === 0) {
        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
        return;
    }

    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
};

/*
* Sets the point 'p' relative to point 'rp'
* by the distance 'd'
*
* See APPENDIX on SETRELATIVE at the bottom of this file.
*
* p   ...  point to set
* rp  ... reference point
* d   ... distance on projection vector
* pv  ... projection vector (undefined = this)
* org ... if true, uses the original position of rp as reference.
*/
UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {
    pv = pv || this;

    var rpx = org ? rp.xo : rp.x;
    var rpy = org ? rp.yo : rp.y;
    var rpdx = rpx + d * pv.x;
    var rpdy = rpy + d * pv.y;

    var pvns = pv.normalSlope;
    var fvs = this.slope;

    var px = p.x;
    var py = p.y;

    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);
    p.y = fvs * (p.x - px) + py;
};

/*
* Touches the point p.
*/
UnitVector.prototype.touch = function(p) {
    p.xTouched = true;
    p.yTouched = true;
};

/*
* Returns a unit vector with x/y coordinates.
*/
function getUnitVector(x, y) {
    var d = Math.sqrt(x * x + y * y);

    x /= d;
    y /= d;

    if (x === 1 && y === 0) { return xUnitVector; }
    else if (x === 0 && y === 1) { return yUnitVector; }
    else { return new UnitVector(x, y); }
}

/*
* Creates a point in the hinting engine.
*/
function HPoint(
    x,
    y,
    lastPointOfContour,
    onCurve
) {
    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value
    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value

    this.lastPointOfContour = lastPointOfContour;
    this.onCurve = onCurve;
    this.prevPointOnContour = undefined;
    this.nextPointOnContour = undefined;
    this.xTouched = false;
    this.yTouched = false;

    Object.preventExtensions(this);
}

/*
* Returns the next touched point on the contour.
*
* v  ... unit vector to test touch axis.
*/
HPoint.prototype.nextTouched = function(v) {
    var p = this.nextPointOnContour;

    while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }

    return p;
};

/*
* Returns the previous touched point on the contour
*
* v  ... unit vector to test touch axis.
*/
HPoint.prototype.prevTouched = function(v) {
    var p = this.prevPointOnContour;

    while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }

    return p;
};

/*
* The zero point.
*/
var HPZero = Object.freeze(new HPoint(0, 0));

/*
* The default state of the interpreter.
*
* Note: Freezing the defaultState and then deriving from it
* makes the V8 Javascript engine going awkward,
* so this is avoided, albeit the defaultState shouldn't
* ever change.
*/
var defaultState = {
    cvCutIn: 17 / 16,    // control value cut in
    deltaBase: 9,
    deltaShift: 0.125,
    loop: 1,             // loops some instructions
    minDis: 1,           // minimum distance
    autoFlip: true
};

/*
* The current state of the interpreter.
*
* env  ... 'fpgm' or 'prep' or 'glyf'
* prog ... the program
*/
function State(env, prog) {
    this.env = env;
    this.stack = [];
    this.prog = prog;

    switch (env) {
        case 'glyf' :
            this.zp0 = this.zp1 = this.zp2 = 1;
            this.rp0 = this.rp1 = this.rp2 = 0;
            /* fall through */
        case 'prep' :
            this.fv = this.pv = this.dpv = xUnitVector;
            this.round = roundToGrid;
    }
}

/*
* Executes a glyph program.
*
* This does the hinting for each glyph.
*
* Returns an array of moved points.
*
* glyph: the glyph to hint
* ppem: the size the glyph is rendered for
*/
Hinting.prototype.exec = function(glyph, ppem) {
    if (typeof ppem !== 'number') {
        throw new Error('Point size is not a number!');
    }

    // Received a fatal error, don't do any hinting anymore.
    if (this._errorState > 2) { return; }

    var font = this.font;
    var prepState = this._prepState;

    if (!prepState || prepState.ppem !== ppem) {
        var fpgmState = this._fpgmState;

        if (!fpgmState) {
            // Executes the fpgm state.
            // This is used by fonts to define functions.
            State.prototype = defaultState;

            fpgmState =
            this._fpgmState =
                new State('fpgm', font.tables.fpgm);

            fpgmState.funcs = [ ];
            fpgmState.font = font;

            if (exports.DEBUG) {
                console.log('---EXEC FPGM---');
                fpgmState.step = -1;
            }

            try {
                exec(fpgmState);
            } catch (e) {
                console.log('Hinting error in FPGM:' + e);
                this._errorState = 3;
                return;
            }
        }

        // Executes the prep program for this ppem setting.
        // This is used by fonts to set cvt values
        // depending on to be rendered font size.

        State.prototype = fpgmState;
        prepState =
        this._prepState =
            new State('prep', font.tables.prep);

        prepState.ppem = ppem;

        // Creates a copy of the cvt table
        // and scales it to the current ppem setting.
        var oCvt = font.tables.cvt;
        if (oCvt) {
            var cvt = prepState.cvt = new Array(oCvt.length);
            var scale = ppem / font.unitsPerEm;
            for (var c = 0; c < oCvt.length; c++) {
                cvt[c] = oCvt[c] * scale;
            }
        } else {
            prepState.cvt = [];
        }

        if (exports.DEBUG) {
            console.log('---EXEC PREP---');
            prepState.step = -1;
        }

        try {
            exec(prepState);
        } catch (e) {
            if (this._errorState < 2) {
                console.log('Hinting error in PREP:' + e);
            }
            this._errorState = 2;
        }
    }

    if (this._errorState > 1) { return; }

    try {
        return execGlyph(glyph, prepState);
    } catch (e) {
        if (this._errorState < 1) {
            console.log('Hinting error:' + e);
            console.log('Note: further hinting errors are silenced');
        }
        this._errorState = 1;
        return undefined;
    }
};

/*
* Executes the hinting program for a glyph.
*/
execGlyph = function(glyph, prepState) {
    // original point positions
    var xScale = prepState.ppem / prepState.font.unitsPerEm;
    var yScale = xScale;
    var components = glyph.components;
    var contours;
    var gZone;
    var state;

    State.prototype = prepState;
    if (!components) {
        state = new State('glyf', glyph.instructions);
        if (exports.DEBUG) {
            console.log('---EXEC GLYPH---');
            state.step = -1;
        }
        execComponent(glyph, state, xScale, yScale);
        gZone = state.gZone;
    } else {
        var font = prepState.font;
        gZone = [];
        contours = [];
        for (var i = 0; i < components.length; i++) {
            var c = components[i];
            var cg = font.glyphs.get(c.glyphIndex);

            state = new State('glyf', cg.instructions);

            if (exports.DEBUG) {
                console.log('---EXEC COMP ' + i + '---');
                state.step = -1;
            }

            execComponent(cg, state, xScale, yScale);
            // appends the computed points to the result array
            // post processes the component points
            var dx = Math.round(c.dx * xScale);
            var dy = Math.round(c.dy * yScale);
            var gz = state.gZone;
            var cc = state.contours;
            for (var pi = 0; pi < gz.length; pi++) {
                var p = gz[pi];
                p.xTouched = p.yTouched = false;
                p.xo = p.x = p.x + dx;
                p.yo = p.y = p.y + dy;
            }

            var gLen = gZone.length;
            gZone.push.apply(gZone, gz);
            for (var j = 0; j < cc.length; j++) {
                contours.push(cc[j] + gLen);
            }
        }

        if (glyph.instructions && !state.inhibitGridFit) {
            // the composite has instructions on its own
            state = new State('glyf', glyph.instructions);

            state.gZone = state.z0 = state.z1 = state.z2 = gZone;

            state.contours = contours;

            // note: HPZero cannot be used here, since
            //       the point might be modified
            gZone.push(
                new HPoint(0, 0),
                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
            );

            if (exports.DEBUG) {
                console.log('---EXEC COMPOSITE---');
                state.step = -1;
            }

            exec(state);

            gZone.length -= 2;
        }
    }

    return gZone;
};

/*
* Executes the hinting program for a component of a multi-component glyph
* or of the glyph itself for a non-component glyph.
*/
execComponent = function(glyph, state, xScale, yScale)
{
    var points = glyph.points || [];
    var pLen = points.length;
    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];
    var contours = state.contours = [];

    // Scales the original points and
    // makes copies for the hinted points.
    var cp; // current point
    for (var i = 0; i < pLen; i++) {
        cp = points[i];

        gZone[i] = new HPoint(
            cp.x * xScale,
            cp.y * yScale,
            cp.lastPointOfContour,
            cp.onCurve
        );
    }

    // Chain links the contours.
    var sp; // start point
    var np; // next point

    for (var i$1 = 0; i$1 < pLen; i$1++) {
        cp = gZone[i$1];

        if (!sp) {
            sp = cp;
            contours.push(i$1);
        }

        if (cp.lastPointOfContour) {
            cp.nextPointOnContour = sp;
            sp.prevPointOnContour = cp;
            sp = undefined;
        } else {
            np = gZone[i$1 + 1];
            cp.nextPointOnContour = np;
            np.prevPointOnContour = cp;
        }
    }

    if (state.inhibitGridFit) { return; }

    if (exports.DEBUG) {
        console.log('PROCESSING GLYPH', state.stack);
        for (var i$2 = 0; i$2 < pLen; i$2++) {
            console.log(i$2, gZone[i$2].x, gZone[i$2].y);
        }
    }

    gZone.push(
        new HPoint(0, 0),
        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
    );

    exec(state);

    // Removes the extra points.
    gZone.length -= 2;

    if (exports.DEBUG) {
        console.log('FINISHED GLYPH', state.stack);
        for (var i$3 = 0; i$3 < pLen; i$3++) {
            console.log(i$3, gZone[i$3].x, gZone[i$3].y);
        }
    }
};

/*
* Executes the program loaded in state.
*/
exec = function(state) {
    var prog = state.prog;

    if (!prog) { return; }

    var pLen = prog.length;
    var ins;

    for (state.ip = 0; state.ip < pLen; state.ip++) {
        if (exports.DEBUG) { state.step++; }
        ins = instructionTable[prog[state.ip]];

        if (!ins) {
            throw new Error(
                'unknown instruction: 0x' +
                Number(prog[state.ip]).toString(16)
            );
        }

        ins(state);

        // very extensive debugging for each step
        /*
        if (exports.DEBUG) {
            var da;
            if (state.gZone) {
                da = [];
                for (let i = 0; i < state.gZone.length; i++)
                {
                    da.push(i + ' ' +
                        state.gZone[i].x * 64 + ' ' +
                        state.gZone[i].y * 64 + ' ' +
                        (state.gZone[i].xTouched ? 'x' : '') +
                        (state.gZone[i].yTouched ? 'y' : '')
                    );
                }
                console.log('GZ', da);
            }

            if (state.tZone) {
                da = [];
                for (let i = 0; i < state.tZone.length; i++) {
                    da.push(i + ' ' +
                        state.tZone[i].x * 64 + ' ' +
                        state.tZone[i].y * 64 + ' ' +
                        (state.tZone[i].xTouched ? 'x' : '') +
                        (state.tZone[i].yTouched ? 'y' : '')
                    );
                }
                console.log('TZ', da);
            }

            if (state.stack.length > 10) {
                console.log(
                    state.stack.length,
                    '...', state.stack.slice(state.stack.length - 10)
                );
            } else {
                console.log(state.stack.length, state.stack);
            }
        }
        */
    }
};

/*
* Initializes the twilight zone.
*
* This is only done if a SZPx instruction
* refers to the twilight zone.
*/
function initTZone(state)
{
    var tZone = state.tZone = new Array(state.gZone.length);

    // no idea if this is actually correct...
    for (var i = 0; i < tZone.length; i++)
    {
        tZone[i] = new HPoint(0, 0);
    }
}

/*
* Skips the instruction pointer ahead over an IF/ELSE block.
* handleElse .. if true breaks on matching ELSE
*/
function skip(state, handleElse)
{
    var prog = state.prog;
    var ip = state.ip;
    var nesting = 1;
    var ins;

    do {
        ins = prog[++ip];
        if (ins === 0x58) // IF
            { nesting++; }
        else if (ins === 0x59) // EIF
            { nesting--; }
        else if (ins === 0x40) // NPUSHB
            { ip += prog[ip + 1] + 1; }
        else if (ins === 0x41) // NPUSHW
            { ip += 2 * prog[ip + 1] + 1; }
        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB
            { ip += ins - 0xB0 + 1; }
        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW
            { ip += (ins - 0xB8 + 1) * 2; }
        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE
            { break; }
    } while (nesting > 0);

    state.ip = ip;
}

/*----------------------------------------------------------*
*          And then a lot of instructions...                *
*----------------------------------------------------------*/

// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis
// 0x00-0x01
function SVTCA(v, state) {
    if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }

    state.fv = state.pv = state.dpv = v;
}

// SPVTCA[a] Set Projection Vector to Coordinate Axis
// 0x02-0x03
function SPVTCA(v, state) {
    if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }

    state.pv = state.dpv = v;
}

// SFVTCA[a] Set Freedom Vector to Coordinate Axis
// 0x04-0x05
function SFVTCA(v, state) {
    if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }

    state.fv = v;
}

// SPVTL[a] Set Projection Vector To Line
// 0x06-0x07
function SPVTL(a, state) {
    var stack = state.stack;
    var p2i = stack.pop();
    var p1i = stack.pop();
    var p2 = state.z2[p2i];
    var p1 = state.z1[p1i];

    if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }

    var dx;
    var dy;

    if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
    } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
    }

    state.pv = state.dpv = getUnitVector(dx, dy);
}

// SFVTL[a] Set Freedom Vector To Line
// 0x08-0x09
function SFVTL(a, state) {
    var stack = state.stack;
    var p2i = stack.pop();
    var p1i = stack.pop();
    var p2 = state.z2[p2i];
    var p1 = state.z1[p1i];

    if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }

    var dx;
    var dy;

    if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
    } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
    }

    state.fv = getUnitVector(dx, dy);
}

// SPVFS[] Set Projection Vector From Stack
// 0x0A
function SPVFS(state) {
    var stack = state.stack;
    var y = stack.pop();
    var x = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }

    state.pv = state.dpv = getUnitVector(x, y);
}

// SFVFS[] Set Freedom Vector From Stack
// 0x0B
function SFVFS(state) {
    var stack = state.stack;
    var y = stack.pop();
    var x = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }

    state.fv = getUnitVector(x, y);
}

// GPV[] Get Projection Vector
// 0x0C
function GPV(state) {
    var stack = state.stack;
    var pv = state.pv;

    if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }

    stack.push(pv.x * 0x4000);
    stack.push(pv.y * 0x4000);
}

// GFV[] Get Freedom Vector
// 0x0C
function GFV(state) {
    var stack = state.stack;
    var fv = state.fv;

    if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }

    stack.push(fv.x * 0x4000);
    stack.push(fv.y * 0x4000);
}

// SFVTPV[] Set Freedom Vector To Projection Vector
// 0x0E
function SFVTPV(state) {
    state.fv = state.pv;

    if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }
}

// ISECT[] moves point p to the InterSECTion of two lines
// 0x0F
function ISECT(state)
{
    var stack = state.stack;
    var pa0i = stack.pop();
    var pa1i = stack.pop();
    var pb0i = stack.pop();
    var pb1i = stack.pop();
    var pi = stack.pop();
    var z0 = state.z0;
    var z1 = state.z1;
    var pa0 = z0[pa0i];
    var pa1 = z0[pa1i];
    var pb0 = z1[pb0i];
    var pb1 = z1[pb1i];
    var p = state.z2[pi];

    if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }

    // math from
    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line

    var x1 = pa0.x;
    var y1 = pa0.y;
    var x2 = pa1.x;
    var y2 = pa1.y;
    var x3 = pb0.x;
    var y3 = pb0.y;
    var x4 = pb1.x;
    var y4 = pb1.y;

    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    var f1 = x1 * y2 - y1 * x2;
    var f2 = x3 * y4 - y3 * x4;

    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;
    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;
}

// SRP0[] Set Reference Point 0
// 0x10
function SRP0(state) {
    state.rp0 = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }
}

// SRP1[] Set Reference Point 1
// 0x11
function SRP1(state) {
    state.rp1 = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }
}

// SRP1[] Set Reference Point 2
// 0x12
function SRP2(state) {
    state.rp2 = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }
}

// SZP0[] Set Zone Pointer 0
// 0x13
function SZP0(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }

    state.zp0 = n;

    switch (n) {
        case 0:
            if (!state.tZone) { initTZone(state); }
            state.z0 = state.tZone;
            break;
        case 1 :
            state.z0 = state.gZone;
            break;
        default :
            throw new Error('Invalid zone pointer');
    }
}

// SZP1[] Set Zone Pointer 1
// 0x14
function SZP1(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }

    state.zp1 = n;

    switch (n) {
        case 0:
            if (!state.tZone) { initTZone(state); }
            state.z1 = state.tZone;
            break;
        case 1 :
            state.z1 = state.gZone;
            break;
        default :
            throw new Error('Invalid zone pointer');
    }
}

// SZP2[] Set Zone Pointer 2
// 0x15
function SZP2(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }

    state.zp2 = n;

    switch (n) {
        case 0:
            if (!state.tZone) { initTZone(state); }
            state.z2 = state.tZone;
            break;
        case 1 :
            state.z2 = state.gZone;
            break;
        default :
            throw new Error('Invalid zone pointer');
    }
}

// SZPS[] Set Zone PointerS
// 0x16
function SZPS(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }

    state.zp0 = state.zp1 = state.zp2 = n;

    switch (n) {
        case 0:
            if (!state.tZone) { initTZone(state); }
            state.z0 = state.z1 = state.z2 = state.tZone;
            break;
        case 1 :
            state.z0 = state.z1 = state.z2 = state.gZone;
            break;
        default :
            throw new Error('Invalid zone pointer');
    }
}

// SLOOP[] Set LOOP variable
// 0x17
function SLOOP(state) {
    state.loop = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }
}

// RTG[] Round To Grid
// 0x18
function RTG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }

    state.round = roundToGrid;
}

// RTHG[] Round To Half Grid
// 0x19
function RTHG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }

    state.round = roundToHalfGrid;
}

// SMD[] Set Minimum Distance
// 0x1A
function SMD(state) {
    var d = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }

    state.minDis = d / 0x40;
}

// ELSE[] ELSE clause
// 0x1B
function ELSE(state) {
    // This instruction has been reached by executing a then branch
    // so it just skips ahead until matching EIF.
    //
    // In case the IF was negative the IF[] instruction already
    // skipped forward over the ELSE[]

    if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }

    skip(state, false);
}

// JMPR[] JuMP Relative
// 0x1C
function JMPR(state) {
    var o = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }

    // A jump by 1 would do nothing.
    state.ip += o - 1;
}

// SCVTCI[] Set Control Value Table Cut-In
// 0x1D
function SCVTCI(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }

    state.cvCutIn = n / 0x40;
}

// DUP[] DUPlicate top stack element
// 0x20
function DUP(state) {
    var stack = state.stack;

    if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }

    stack.push(stack[stack.length - 1]);
}

// POP[] POP top stack element
// 0x21
function POP(state) {
    if (exports.DEBUG) { console.log(state.step, 'POP[]'); }

    state.stack.pop();
}

// CLEAR[] CLEAR the stack
// 0x22
function CLEAR(state) {
    if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }

    state.stack.length = 0;
}

// SWAP[] SWAP the top two elements on the stack
// 0x23
function SWAP(state) {
    var stack = state.stack;

    var a = stack.pop();
    var b = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }

    stack.push(a);
    stack.push(b);
}

// DEPTH[] DEPTH of the stack
// 0x24
function DEPTH(state) {
    var stack = state.stack;

    if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }

    stack.push(stack.length);
}

// LOOPCALL[] LOOPCALL function
// 0x2A
function LOOPCALL(state) {
    var stack = state.stack;
    var fn = stack.pop();
    var c = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }

    // saves callers program
    var cip = state.ip;
    var cprog = state.prog;

    state.prog = state.funcs[fn];

    // executes the function
    for (var i = 0; i < c; i++) {
        exec(state);

        if (exports.DEBUG) { console.log(
            ++state.step,
            i + 1 < c ? 'next loopcall' : 'done loopcall',
            i
        ); }
    }

    // restores the callers program
    state.ip = cip;
    state.prog = cprog;
}

// CALL[] CALL function
// 0x2B
function CALL(state) {
    var fn = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }

    // saves callers program
    var cip = state.ip;
    var cprog = state.prog;

    state.prog = state.funcs[fn];

    // executes the function
    exec(state);

    // restores the callers program
    state.ip = cip;
    state.prog = cprog;

    if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }
}

// CINDEX[] Copy the INDEXed element to the top of the stack
// 0x25
function CINDEX(state) {
    var stack = state.stack;
    var k = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }

    // In case of k == 1, it copies the last element after popping
    // thus stack.length - k.
    stack.push(stack[stack.length - k]);
}

// MINDEX[] Move the INDEXed element to the top of the stack
// 0x26
function MINDEX(state) {
    var stack = state.stack;
    var k = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }

    stack.push(stack.splice(stack.length - k, 1)[0]);
}

// FDEF[] Function DEFinition
// 0x2C
function FDEF(state) {
    if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }
    var stack = state.stack;
    var prog = state.prog;
    var ip = state.ip;

    var fn = stack.pop();
    var ipBegin = ip;

    if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }

    while (prog[++ip] !== 0x2D){  }

    state.ip = ip;
    state.funcs[fn] = prog.slice(ipBegin + 1, ip);
}

// MDAP[a] Move Direct Absolute Point
// 0x2E-0x2F
function MDAP(round, state) {
    var pi = state.stack.pop();
    var p = state.z0[pi];
    var fv = state.fv;
    var pv = state.pv;

    if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }

    var d = pv.distance(p, HPZero);

    if (round) { d = state.round(d); }

    fv.setRelative(p, HPZero, d, pv);
    fv.touch(p);

    state.rp0 = state.rp1 = pi;
}

// IUP[a] Interpolate Untouched Points through the outline
// 0x30
function IUP(v, state) {
    var z2 = state.z2;
    var pLen = z2.length - 2;
    var cp;
    var pp;
    var np;

    if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }

    for (var i = 0; i < pLen; i++) {
        cp = z2[i]; // current point

        // if this point has been touched go on
        if (v.touched(cp)) { continue; }

        pp = cp.prevTouched(v);

        // no point on the contour has been touched?
        if (pp === cp) { continue; }

        np = cp.nextTouched(v);

        if (pp === np) {
            // only one point on the contour has been touched
            // so simply moves the point like that

            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);
        }

        v.interpolate(cp, pp, np, v);
    }
}

// SHP[] SHift Point using reference point
// 0x32-0x33
function SHP(a, state) {
    var stack = state.stack;
    var rpi = a ? state.rp1 : state.rp2;
    var rp = (a ? state.z0 : state.z1)[rpi];
    var fv = state.fv;
    var pv = state.pv;
    var loop = state.loop;
    var z2 = state.z2;

    while (loop--)
    {
        var pi = stack.pop();
        var p = z2[pi];

        var d = pv.distance(rp, rp, false, true);
        fv.setRelative(p, p, d, pv);
        fv.touch(p);

        if (exports.DEBUG) {
            console.log(
                state.step,
                (state.loop > 1 ?
                   'loop ' + (state.loop - loop) + ': ' :
                   ''
                ) +
                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi
            );
        }
    }

    state.loop = 1;
}

// SHC[] SHift Contour using reference point
// 0x36-0x37
function SHC(a, state) {
    var stack = state.stack;
    var rpi = a ? state.rp1 : state.rp2;
    var rp = (a ? state.z0 : state.z1)[rpi];
    var fv = state.fv;
    var pv = state.pv;
    var ci = stack.pop();
    var sp = state.z2[state.contours[ci]];
    var p = sp;

    if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }

    var d = pv.distance(rp, rp, false, true);

    do {
        if (p !== rp) { fv.setRelative(p, p, d, pv); }
        p = p.nextPointOnContour;
    } while (p !== sp);
}

// SHZ[] SHift Zone using reference point
// 0x36-0x37
function SHZ(a, state) {
    var stack = state.stack;
    var rpi = a ? state.rp1 : state.rp2;
    var rp = (a ? state.z0 : state.z1)[rpi];
    var fv = state.fv;
    var pv = state.pv;

    var e = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }

    var z;
    switch (e) {
        case 0 : z = state.tZone; break;
        case 1 : z = state.gZone; break;
        default : throw new Error('Invalid zone');
    }

    var p;
    var d = pv.distance(rp, rp, false, true);
    var pLen = z.length - 2;
    for (var i = 0; i < pLen; i++)
    {
        p = z[i];
        fv.setRelative(p, p, d, pv);
        //if (p !== rp) fv.setRelative(p, p, d, pv);
    }
}

// SHPIX[] SHift point by a PIXel amount
// 0x38
function SHPIX(state) {
    var stack = state.stack;
    var loop = state.loop;
    var fv = state.fv;
    var d = stack.pop() / 0x40;
    var z2 = state.z2;

    while (loop--) {
        var pi = stack.pop();
        var p = z2[pi];

        if (exports.DEBUG) {
            console.log(
                state.step,
                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
                'SHPIX[]', pi, d
            );
        }

        fv.setRelative(p, p, d);
        fv.touch(p);
    }

    state.loop = 1;
}

// IP[] Interpolate Point
// 0x39
function IP(state) {
    var stack = state.stack;
    var rp1i = state.rp1;
    var rp2i = state.rp2;
    var loop = state.loop;
    var rp1 = state.z0[rp1i];
    var rp2 = state.z1[rp2i];
    var fv = state.fv;
    var pv = state.dpv;
    var z2 = state.z2;

    while (loop--) {
        var pi = stack.pop();
        var p = z2[pi];

        if (exports.DEBUG) {
            console.log(
                state.step,
                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
                'IP[]', pi, rp1i, '<->', rp2i
            );
        }

        fv.interpolate(p, rp1, rp2, pv);

        fv.touch(p);
    }

    state.loop = 1;
}

// MSIRP[a] Move Stack Indirect Relative Point
// 0x3A-0x3B
function MSIRP(a, state) {
    var stack = state.stack;
    var d = stack.pop() / 64;
    var pi = stack.pop();
    var p = state.z1[pi];
    var rp0 = state.z0[state.rp0];
    var fv = state.fv;
    var pv = state.pv;

    fv.setRelative(p, rp0, d, pv);
    fv.touch(p);

    if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }

    state.rp1 = state.rp0;
    state.rp2 = pi;
    if (a) { state.rp0 = pi; }
}

// ALIGNRP[] Align to reference point.
// 0x3C
function ALIGNRP(state) {
    var stack = state.stack;
    var rp0i = state.rp0;
    var rp0 = state.z0[rp0i];
    var loop = state.loop;
    var fv = state.fv;
    var pv = state.pv;
    var z1 = state.z1;

    while (loop--) {
        var pi = stack.pop();
        var p = z1[pi];

        if (exports.DEBUG) {
            console.log(
                state.step,
                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
                'ALIGNRP[]', pi
            );
        }

        fv.setRelative(p, rp0, 0, pv);
        fv.touch(p);
    }

    state.loop = 1;
}

// RTG[] Round To Double Grid
// 0x3D
function RTDG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }

    state.round = roundToDoubleGrid;
}

// MIAP[a] Move Indirect Absolute Point
// 0x3E-0x3F
function MIAP(round, state) {
    var stack = state.stack;
    var n = stack.pop();
    var pi = stack.pop();
    var p = state.z0[pi];
    var fv = state.fv;
    var pv = state.pv;
    var cv = state.cvt[n];

    if (exports.DEBUG) {
        console.log(
            state.step,
            'MIAP[' + round + ']',
            n, '(', cv, ')', pi
        );
    }

    var d = pv.distance(p, HPZero);

    if (round) {
        if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }

        d = state.round(d);
    }

    fv.setRelative(p, HPZero, d, pv);

    if (state.zp0 === 0) {
        p.xo = p.x;
        p.yo = p.y;
    }

    fv.touch(p);

    state.rp0 = state.rp1 = pi;
}

// NPUSB[] PUSH N Bytes
// 0x40
function NPUSHB(state) {
    var prog = state.prog;
    var ip = state.ip;
    var stack = state.stack;

    var n = prog[++ip];

    if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }

    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }

    state.ip = ip;
}

// NPUSHW[] PUSH N Words
// 0x41
function NPUSHW(state) {
    var ip = state.ip;
    var prog = state.prog;
    var stack = state.stack;
    var n = prog[++ip];

    if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }

    for (var i = 0; i < n; i++) {
        var w = (prog[++ip] << 8) | prog[++ip];
        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
        stack.push(w);
    }

    state.ip = ip;
}

// WS[] Write Store
// 0x42
function WS(state) {
    var stack = state.stack;
    var store = state.store;

    if (!store) { store = state.store = []; }

    var v = stack.pop();
    var l = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }

    store[l] = v;
}

// RS[] Read Store
// 0x43
function RS(state) {
    var stack = state.stack;
    var store = state.store;

    var l = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'RS', l); }

    var v = (store && store[l]) || 0;

    stack.push(v);
}

// WCVTP[] Write Control Value Table in Pixel units
// 0x44
function WCVTP(state) {
    var stack = state.stack;

    var v = stack.pop();
    var l = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }

    state.cvt[l] = v / 0x40;
}

// RCVT[] Read Control Value Table entry
// 0x45
function RCVT(state) {
    var stack = state.stack;
    var cvte = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }

    stack.push(state.cvt[cvte] * 0x40);
}

// GC[] Get Coordinate projected onto the projection vector
// 0x46-0x47
function GC(a, state) {
    var stack = state.stack;
    var pi = stack.pop();
    var p = state.z2[pi];

    if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }

    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);
}

// MD[a] Measure Distance
// 0x49-0x4A
function MD(a, state) {
    var stack = state.stack;
    var pi2 = stack.pop();
    var pi1 = stack.pop();
    var p2 = state.z1[pi2];
    var p1 = state.z0[pi1];
    var d = state.dpv.distance(p1, p2, a, a);

    if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }

    state.stack.push(Math.round(d * 64));
}

// MPPEM[] Measure Pixels Per EM
// 0x4B
function MPPEM(state) {
    if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }
    state.stack.push(state.ppem);
}

// FLIPON[] set the auto FLIP Boolean to ON
// 0x4D
function FLIPON(state) {
    if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }
    state.autoFlip = true;
}

// LT[] Less Than
// 0x50
function LT(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }

    stack.push(e1 < e2 ? 1 : 0);
}

// LTEQ[] Less Than or EQual
// 0x53
function LTEQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }

    stack.push(e1 <= e2 ? 1 : 0);
}

// GTEQ[] Greater Than
// 0x52
function GT(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }

    stack.push(e1 > e2 ? 1 : 0);
}

// GTEQ[] Greater Than or EQual
// 0x53
function GTEQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }

    stack.push(e1 >= e2 ? 1 : 0);
}

// EQ[] EQual
// 0x54
function EQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }

    stack.push(e2 === e1 ? 1 : 0);
}

// NEQ[] Not EQual
// 0x55
function NEQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }

    stack.push(e2 !== e1 ? 1 : 0);
}

// ODD[] ODD
// 0x56
function ODD(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }

    stack.push(Math.trunc(n) % 2 ? 1 : 0);
}

// EVEN[] EVEN
// 0x57
function EVEN(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }

    stack.push(Math.trunc(n) % 2 ? 0 : 1);
}

// IF[] IF test
// 0x58
function IF(state) {
    var test = state.stack.pop();
    var ins;

    if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }

    // if test is true it just continues
    // if not the ip is skipped until matching ELSE or EIF
    if (!test) {
        skip(state, true);

        if (exports.DEBUG) { console.log(state.step, ins === 0x1B ? 'ELSE[]' : 'EIF[]'); }
    }
}

// EIF[] End IF
// 0x59
function EIF(state) {
    // this can be reached normally when
    // executing an else branch.
    // -> just ignore it

    if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }
}

// AND[] logical AND
// 0x5A
function AND(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }

    stack.push(e2 && e1 ? 1 : 0);
}

// OR[] logical OR
// 0x5B
function OR(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }

    stack.push(e2 || e1 ? 1 : 0);
}

// NOT[] logical NOT
// 0x5C
function NOT(state) {
    var stack = state.stack;
    var e = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }

    stack.push(e ? 0 : 1);
}

// DELTAP1[] DELTA exception P1
// DELTAP2[] DELTA exception P2
// DELTAP3[] DELTA exception P3
// 0x5D, 0x71, 0x72
function DELTAP123(b, state) {
    var stack = state.stack;
    var n = stack.pop();
    var fv = state.fv;
    var pv = state.pv;
    var ppem = state.ppem;
    var base = state.deltaBase + (b - 1) * 16;
    var ds = state.deltaShift;
    var z0 = state.z0;

    if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }

    for (var i = 0; i < n; i++) {
        var pi = stack.pop();
        var arg = stack.pop();
        var appem = base + ((arg & 0xF0) >> 4);
        if (appem !== ppem) { continue; }

        var mag = (arg & 0x0F) - 8;
        if (mag >= 0) { mag++; }
        if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }

        var p = z0[pi];
        fv.setRelative(p, p, mag * ds, pv);
    }
}

// SDB[] Set Delta Base in the graphics state
// 0x5E
function SDB(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }

    state.deltaBase = n;
}

// SDS[] Set Delta Shift in the graphics state
// 0x5F
function SDS(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }

    state.deltaShift = Math.pow(0.5, n);
}

// ADD[] ADD
// 0x60
function ADD(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }

    stack.push(n1 + n2);
}

// SUB[] SUB
// 0x61
function SUB(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }

    stack.push(n1 - n2);
}

// DIV[] DIV
// 0x62
function DIV(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }

    stack.push(n1 * 64 / n2);
}

// MUL[] MUL
// 0x63
function MUL(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }

    stack.push(n1 * n2 / 64);
}

// ABS[] ABSolute value
// 0x64
function ABS(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }

    stack.push(Math.abs(n));
}

// NEG[] NEGate
// 0x65
function NEG(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }

    stack.push(-n);
}

// FLOOR[] FLOOR
// 0x66
function FLOOR(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }

    stack.push(Math.floor(n / 0x40) * 0x40);
}

// CEILING[] CEILING
// 0x67
function CEILING(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }

    stack.push(Math.ceil(n / 0x40) * 0x40);
}

// ROUND[ab] ROUND value
// 0x68-0x6B
function ROUND(dt, state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }

    stack.push(state.round(n / 0x40) * 0x40);
}

// WCVTF[] Write Control Value Table in Funits
// 0x70
function WCVTF(state) {
    var stack = state.stack;
    var v = stack.pop();
    var l = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }

    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;
}

// DELTAC1[] DELTA exception C1
// DELTAC2[] DELTA exception C2
// DELTAC3[] DELTA exception C3
// 0x73, 0x74, 0x75
function DELTAC123(b, state) {
    var stack = state.stack;
    var n = stack.pop();
    var ppem = state.ppem;
    var base = state.deltaBase + (b - 1) * 16;
    var ds = state.deltaShift;

    if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }

    for (var i = 0; i < n; i++) {
        var c = stack.pop();
        var arg = stack.pop();
        var appem = base + ((arg & 0xF0) >> 4);
        if (appem !== ppem) { continue; }

        var mag = (arg & 0x0F) - 8;
        if (mag >= 0) { mag++; }

        var delta = mag * ds;

        if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }

        state.cvt[c] += delta;
    }
}

// SROUND[] Super ROUND
// 0x76
function SROUND(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }

    state.round = roundSuper;

    var period;

    switch (n & 0xC0) {
        case 0x00:
            period = 0.5;
            break;
        case 0x40:
            period = 1;
            break;
        case 0x80:
            period = 2;
            break;
        default:
            throw new Error('invalid SROUND value');
    }

    state.srPeriod = period;

    switch (n & 0x30) {
        case 0x00:
            state.srPhase = 0;
            break;
        case 0x10:
            state.srPhase = 0.25 * period;
            break;
        case 0x20:
            state.srPhase = 0.5  * period;
            break;
        case 0x30:
            state.srPhase = 0.75 * period;
            break;
        default: throw new Error('invalid SROUND value');
    }

    n &= 0x0F;

    if (n === 0) { state.srThreshold = 0; }
    else { state.srThreshold = (n / 8 - 0.5) * period; }
}

// S45ROUND[] Super ROUND 45 degrees
// 0x77
function S45ROUND(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }

    state.round = roundSuper;

    var period;

    switch (n & 0xC0) {
        case 0x00:
            period = Math.sqrt(2) / 2;
            break;
        case 0x40:
            period = Math.sqrt(2);
            break;
        case 0x80:
            period = 2 * Math.sqrt(2);
            break;
        default:
            throw new Error('invalid S45ROUND value');
    }

    state.srPeriod = period;

    switch (n & 0x30) {
        case 0x00:
            state.srPhase = 0;
            break;
        case 0x10:
            state.srPhase = 0.25 * period;
            break;
        case 0x20:
            state.srPhase = 0.5  * period;
            break;
        case 0x30:
            state.srPhase = 0.75 * period;
            break;
        default:
            throw new Error('invalid S45ROUND value');
    }

    n &= 0x0F;

    if (n === 0) { state.srThreshold = 0; }
    else { state.srThreshold = (n / 8 - 0.5) * period; }
}

// ROFF[] Round Off
// 0x7A
function ROFF(state) {
    if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }

    state.round = roundOff;
}

// RUTG[] Round Up To Grid
// 0x7C
function RUTG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }

    state.round = roundUpToGrid;
}

// RDTG[] Round Down To Grid
// 0x7D
function RDTG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }

    state.round = roundDownToGrid;
}

// SCANCTRL[] SCAN conversion ConTRoL
// 0x85
function SCANCTRL(state) {
    var n = state.stack.pop();

    // ignored by opentype.js

    if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }
}

// SDPVTL[a] Set Dual Projection Vector To Line
// 0x86-0x87
function SDPVTL(a, state) {
    var stack = state.stack;
    var p2i = stack.pop();
    var p1i = stack.pop();
    var p2 = state.z2[p2i];
    var p1 = state.z1[p1i];

    if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }

    var dx;
    var dy;

    if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
    } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
    }

    state.dpv = getUnitVector(dx, dy);
}

// GETINFO[] GET INFOrmation
// 0x88
function GETINFO(state) {
    var stack = state.stack;
    var sel = stack.pop();
    var r = 0;

    if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }

    // v35 as in no subpixel hinting
    if (sel & 0x01) { r = 35; }

    // TODO rotation and stretch currently not supported
    // and thus those GETINFO are always 0.

    // opentype.js is always gray scaling
    if (sel & 0x20) { r |= 0x1000; }

    stack.push(r);
}

// ROLL[] ROLL the top three stack elements
// 0x8A
function ROLL(state) {
    var stack = state.stack;
    var a = stack.pop();
    var b = stack.pop();
    var c = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }

    stack.push(b);
    stack.push(a);
    stack.push(c);
}

// MAX[] MAXimum of top two stack elements
// 0x8B
function MAX(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }

    stack.push(Math.max(e1, e2));
}

// MIN[] MINimum of top two stack elements
// 0x8C
function MIN(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }

    stack.push(Math.min(e1, e2));
}

// SCANTYPE[] SCANTYPE
// 0x8D
function SCANTYPE(state) {
    var n = state.stack.pop();
    // ignored by opentype.js
    if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }
}

// INSTCTRL[] INSTCTRL
// 0x8D
function INSTCTRL(state) {
    var s = state.stack.pop();
    var v = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }

    switch (s) {
        case 1 : state.inhibitGridFit = !!v; return;
        case 2 : state.ignoreCvt = !!v; return;
        default: throw new Error('invalid INSTCTRL[] selector');
    }
}

// PUSHB[abc] PUSH Bytes
// 0xB0-0xB7
function PUSHB(n, state) {
    var stack = state.stack;
    var prog = state.prog;
    var ip = state.ip;

    if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }

    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }

    state.ip = ip;
}

// PUSHW[abc] PUSH Words
// 0xB8-0xBF
function PUSHW(n, state) {
    var ip = state.ip;
    var prog = state.prog;
    var stack = state.stack;

    if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }

    for (var i = 0; i < n; i++) {
        var w = (prog[++ip] << 8) | prog[++ip];
        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
        stack.push(w);
    }

    state.ip = ip;
}

// MDRP[abcde] Move Direct Relative Point
// 0xD0-0xEF
// (if indirect is 0)
//
// and
//
// MIRP[abcde] Move Indirect Relative Point
// 0xE0-0xFF
// (if indirect is 1)

function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {
    var stack = state.stack;
    var cvte = indirect && stack.pop();
    var pi = stack.pop();
    var rp0i = state.rp0;
    var rp = state.z0[rp0i];
    var p = state.z1[pi];

    var md = state.minDis;
    var fv = state.fv;
    var pv = state.dpv;
    var od; // original distance
    var d; // moving distance
    var sign; // sign of distance
    var cv;

    d = od = pv.distance(p, rp, true, true);
    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0

    // TODO consider autoFlip
    d = Math.abs(d);

    if (indirect) {
        cv = state.cvt[cvte];

        if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }
    }

    if (keepD && d < md) { d = md; }

    if (ro) { d = state.round(d); }

    fv.setRelative(p, rp, sign * d, pv);
    fv.touch(p);

    if (exports.DEBUG) {
        console.log(
            state.step,
            (indirect ? 'MIRP[' : 'MDRP[') +
            (setRp0 ? 'M' : 'm') +
            (keepD ? '>' : '_') +
            (ro ? 'R' : '_') +
            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +
            ']',
            indirect ?
                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :
                '',
            pi,
            '(d =', od, '->', sign * d, ')'
        );
    }

    state.rp1 = state.rp0;
    state.rp2 = pi;
    if (setRp0) { state.rp0 = pi; }
}

/*
* The instruction table.
*/
instructionTable = [
    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),
    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),
    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),
    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),
    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),
    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),
    /* 0x06 */ SPVTL.bind(undefined, 0),
    /* 0x07 */ SPVTL.bind(undefined, 1),
    /* 0x08 */ SFVTL.bind(undefined, 0),
    /* 0x09 */ SFVTL.bind(undefined, 1),
    /* 0x0A */ SPVFS,
    /* 0x0B */ SFVFS,
    /* 0x0C */ GPV,
    /* 0x0D */ GFV,
    /* 0x0E */ SFVTPV,
    /* 0x0F */ ISECT,
    /* 0x10 */ SRP0,
    /* 0x11 */ SRP1,
    /* 0x12 */ SRP2,
    /* 0x13 */ SZP0,
    /* 0x14 */ SZP1,
    /* 0x15 */ SZP2,
    /* 0x16 */ SZPS,
    /* 0x17 */ SLOOP,
    /* 0x18 */ RTG,
    /* 0x19 */ RTHG,
    /* 0x1A */ SMD,
    /* 0x1B */ ELSE,
    /* 0x1C */ JMPR,
    /* 0x1D */ SCVTCI,
    /* 0x1E */ undefined,   // TODO SSWCI
    /* 0x1F */ undefined,   // TODO SSW
    /* 0x20 */ DUP,
    /* 0x21 */ POP,
    /* 0x22 */ CLEAR,
    /* 0x23 */ SWAP,
    /* 0x24 */ DEPTH,
    /* 0x25 */ CINDEX,
    /* 0x26 */ MINDEX,
    /* 0x27 */ undefined,   // TODO ALIGNPTS
    /* 0x28 */ undefined,
    /* 0x29 */ undefined,   // TODO UTP
    /* 0x2A */ LOOPCALL,
    /* 0x2B */ CALL,
    /* 0x2C */ FDEF,
    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)
    /* 0x2E */ MDAP.bind(undefined, 0),
    /* 0x2F */ MDAP.bind(undefined, 1),
    /* 0x30 */ IUP.bind(undefined, yUnitVector),
    /* 0x31 */ IUP.bind(undefined, xUnitVector),
    /* 0x32 */ SHP.bind(undefined, 0),
    /* 0x33 */ SHP.bind(undefined, 1),
    /* 0x34 */ SHC.bind(undefined, 0),
    /* 0x35 */ SHC.bind(undefined, 1),
    /* 0x36 */ SHZ.bind(undefined, 0),
    /* 0x37 */ SHZ.bind(undefined, 1),
    /* 0x38 */ SHPIX,
    /* 0x39 */ IP,
    /* 0x3A */ MSIRP.bind(undefined, 0),
    /* 0x3B */ MSIRP.bind(undefined, 1),
    /* 0x3C */ ALIGNRP,
    /* 0x3D */ RTDG,
    /* 0x3E */ MIAP.bind(undefined, 0),
    /* 0x3F */ MIAP.bind(undefined, 1),
    /* 0x40 */ NPUSHB,
    /* 0x41 */ NPUSHW,
    /* 0x42 */ WS,
    /* 0x43 */ RS,
    /* 0x44 */ WCVTP,
    /* 0x45 */ RCVT,
    /* 0x46 */ GC.bind(undefined, 0),
    /* 0x47 */ GC.bind(undefined, 1),
    /* 0x48 */ undefined,   // TODO SCFS
    /* 0x49 */ MD.bind(undefined, 0),
    /* 0x4A */ MD.bind(undefined, 1),
    /* 0x4B */ MPPEM,
    /* 0x4C */ undefined,   // TODO MPS
    /* 0x4D */ FLIPON,
    /* 0x4E */ undefined,   // TODO FLIPOFF
    /* 0x4F */ undefined,   // TODO DEBUG
    /* 0x50 */ LT,
    /* 0x51 */ LTEQ,
    /* 0x52 */ GT,
    /* 0x53 */ GTEQ,
    /* 0x54 */ EQ,
    /* 0x55 */ NEQ,
    /* 0x56 */ ODD,
    /* 0x57 */ EVEN,
    /* 0x58 */ IF,
    /* 0x59 */ EIF,
    /* 0x5A */ AND,
    /* 0x5B */ OR,
    /* 0x5C */ NOT,
    /* 0x5D */ DELTAP123.bind(undefined, 1),
    /* 0x5E */ SDB,
    /* 0x5F */ SDS,
    /* 0x60 */ ADD,
    /* 0x61 */ SUB,
    /* 0x62 */ DIV,
    /* 0x63 */ MUL,
    /* 0x64 */ ABS,
    /* 0x65 */ NEG,
    /* 0x66 */ FLOOR,
    /* 0x67 */ CEILING,
    /* 0x68 */ ROUND.bind(undefined, 0),
    /* 0x69 */ ROUND.bind(undefined, 1),
    /* 0x6A */ ROUND.bind(undefined, 2),
    /* 0x6B */ ROUND.bind(undefined, 3),
    /* 0x6C */ undefined,   // TODO NROUND[ab]
    /* 0x6D */ undefined,   // TODO NROUND[ab]
    /* 0x6E */ undefined,   // TODO NROUND[ab]
    /* 0x6F */ undefined,   // TODO NROUND[ab]
    /* 0x70 */ WCVTF,
    /* 0x71 */ DELTAP123.bind(undefined, 2),
    /* 0x72 */ DELTAP123.bind(undefined, 3),
    /* 0x73 */ DELTAC123.bind(undefined, 1),
    /* 0x74 */ DELTAC123.bind(undefined, 2),
    /* 0x75 */ DELTAC123.bind(undefined, 3),
    /* 0x76 */ SROUND,
    /* 0x77 */ S45ROUND,
    /* 0x78 */ undefined,   // TODO JROT[]
    /* 0x79 */ undefined,   // TODO JROF[]
    /* 0x7A */ ROFF,
    /* 0x7B */ undefined,
    /* 0x7C */ RUTG,
    /* 0x7D */ RDTG,
    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though
    /* 0x7F */ POP, // actually AA, supposed to do only a pop though
    /* 0x80 */ undefined,   // TODO FLIPPT
    /* 0x81 */ undefined,   // TODO FLIPRGON
    /* 0x82 */ undefined,   // TODO FLIPRGOFF
    /* 0x83 */ undefined,
    /* 0x84 */ undefined,
    /* 0x85 */ SCANCTRL,
    /* 0x86 */ SDPVTL.bind(undefined, 0),
    /* 0x87 */ SDPVTL.bind(undefined, 1),
    /* 0x88 */ GETINFO,
    /* 0x89 */ undefined,   // TODO IDEF
    /* 0x8A */ ROLL,
    /* 0x8B */ MAX,
    /* 0x8C */ MIN,
    /* 0x8D */ SCANTYPE,
    /* 0x8E */ INSTCTRL,
    /* 0x8F */ undefined,
    /* 0x90 */ undefined,
    /* 0x91 */ undefined,
    /* 0x92 */ undefined,
    /* 0x93 */ undefined,
    /* 0x94 */ undefined,
    /* 0x95 */ undefined,
    /* 0x96 */ undefined,
    /* 0x97 */ undefined,
    /* 0x98 */ undefined,
    /* 0x99 */ undefined,
    /* 0x9A */ undefined,
    /* 0x9B */ undefined,
    /* 0x9C */ undefined,
    /* 0x9D */ undefined,
    /* 0x9E */ undefined,
    /* 0x9F */ undefined,
    /* 0xA0 */ undefined,
    /* 0xA1 */ undefined,
    /* 0xA2 */ undefined,
    /* 0xA3 */ undefined,
    /* 0xA4 */ undefined,
    /* 0xA5 */ undefined,
    /* 0xA6 */ undefined,
    /* 0xA7 */ undefined,
    /* 0xA8 */ undefined,
    /* 0xA9 */ undefined,
    /* 0xAA */ undefined,
    /* 0xAB */ undefined,
    /* 0xAC */ undefined,
    /* 0xAD */ undefined,
    /* 0xAE */ undefined,
    /* 0xAF */ undefined,
    /* 0xB0 */ PUSHB.bind(undefined, 1),
    /* 0xB1 */ PUSHB.bind(undefined, 2),
    /* 0xB2 */ PUSHB.bind(undefined, 3),
    /* 0xB3 */ PUSHB.bind(undefined, 4),
    /* 0xB4 */ PUSHB.bind(undefined, 5),
    /* 0xB5 */ PUSHB.bind(undefined, 6),
    /* 0xB6 */ PUSHB.bind(undefined, 7),
    /* 0xB7 */ PUSHB.bind(undefined, 8),
    /* 0xB8 */ PUSHW.bind(undefined, 1),
    /* 0xB9 */ PUSHW.bind(undefined, 2),
    /* 0xBA */ PUSHW.bind(undefined, 3),
    /* 0xBB */ PUSHW.bind(undefined, 4),
    /* 0xBC */ PUSHW.bind(undefined, 5),
    /* 0xBD */ PUSHW.bind(undefined, 6),
    /* 0xBE */ PUSHW.bind(undefined, 7),
    /* 0xBF */ PUSHW.bind(undefined, 8),
    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),
    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),
    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),
    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),
    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),
    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),
    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),
    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),
    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),
    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),
    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),
    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),
    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),
    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),
    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),
    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),
    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),
    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),
    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),
    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),
    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),
    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),
    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),
    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),
    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),
    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),
    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),
    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),
    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),
    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),
    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),
    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),
    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),
    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),
    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),
    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),
    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),
    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),
    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),
    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),
    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),
    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),
    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),
    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),
    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),
    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),
    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),
    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),
    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),
    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),
    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),
    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),
    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),
    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),
    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),
    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),
    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),
    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),
    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),
    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),
    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),
    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),
    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),
    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)
];



/*****************************
  Mathematical Considerations
******************************

fv ... refers to freedom vector
pv ... refers to projection vector
rp ... refers to reference point
p  ... refers to to point being operated on
d  ... refers to distance

SETRELATIVE:
============

case freedom vector == x-axis:
------------------------------

                        (pv)
                     .-'
              rpd .-'
               .-*
          d .-'90'
         .-'       '
      .-'           '
   *-'               ' b
  rp                  '
                       '
                        '
            p *----------*-------------- (fv)
                          pm

  rpdx = rpx + d * pv.x
  rpdy = rpy + d * pv.y

  equation of line b

   y - rpdy = pvns * (x- rpdx)

   y = p.y

   x = rpdx + ( p.y - rpdy ) / pvns


case freedom vector == y-axis:
------------------------------

    * pm
    |\
    | \
    |  \
    |   \
    |    \
    |     \
    |      \
    |       \
    |        \
    |         \ b
    |          \
    |           \
    |            \    .-' (pv)
    |         90 \.-'
    |           .-'* rpd
    |        .-'
    *     *-'  d
    p     rp

  rpdx = rpx + d * pv.x
  rpdy = rpy + d * pv.y

  equation of line b:
           pvns ... normal slope to pv

   y - rpdy = pvns * (x - rpdx)

   x = p.x

   y = rpdy +  pvns * (p.x - rpdx)



generic case:
-------------


                              .'(fv)
                            .'
                          .* pm
                        .' !
                      .'    .
                    .'      !
                  .'         . b
                .'           !
               *              .
              p               !
                         90   .    ... (pv)
                           ...-*-'''
                  ...---'''    rpd
         ...---'''   d
   *--'''
  rp

    rpdx = rpx + d * pv.x
    rpdy = rpy + d * pv.y

 equation of line b:
    pvns... normal slope to pv

    y - rpdy = pvns * (x - rpdx)

 equation of freedom vector line:
    fvs ... slope of freedom vector (=fy/fx)

    y - py = fvs * (x - px)


  on pm both equations are true for same x/y

    y - rpdy = pvns * (x - rpdx)

    y - py = fvs * (x - px)

  form to y and set equal:

    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py

  expand:

    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py

  switch:

    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy

  solve for x:

    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy



          fvs * px - pvns * rpdx + rpdy - py
    x =  -----------------------------------
                 fvs - pvns

  and:

    y = fvs * (x - px) + py



INTERPOLATE:
============

Examples of point interpolation.

The weight of the movement of the reference point gets bigger
the further the other reference point is away, thus the safest
option (that is avoiding 0/0 divisions) is to weight the
original distance of the other point by the sum of both distances.

If the sum of both distances is 0, then move the point by the
arithmetic average of the movement of both reference points.




           (+6)
    rp1o *---->*rp1
         .     .                          (+12)
         .     .                  rp2o *---------->* rp2
         .     .                       .           .
         .     .                       .           .
         .    10          20           .           .
         |.........|...................|           .
               .   .                               .
               .   . (+8)                          .
                po *------>*p                      .
               .           .                       .
               .    12     .          24           .
               |...........|.......................|
                                  36


-------



           (+10)
    rp1o *-------->*rp1
         .         .                      (-10)
         .         .              rp2 *<---------* rpo2
         .         .                   .         .
         .         .                   .         .
         .    10   .          30       .         .
         |.........|.............................|
                   .                   .
                   . (+5)              .
                po *--->* p            .
                   .    .              .
                   .    .   20         .
                   |....|..............|
                     5        15


-------


           (+10)
    rp1o *-------->*rp1
         .         .
         .         .
    rp2o *-------->*rp2


                               (+10)
                          po *-------->* p

-------


           (+10)
    rp1o *-------->*rp1
         .         .
         .         .(+30)
    rp2o *---------------------------->*rp2


                                        (+25)
                          po *----------------------->* p



vim: set ts=4 sw=4 expandtab:
*****/

// The Font object

/**
 * @typedef FontOptions
 * @type Object
 * @property {Boolean} empty - whether to create a new empty font
 * @property {string} familyName
 * @property {string} styleName
 * @property {string=} fullName
 * @property {string=} postScriptName
 * @property {string=} designer
 * @property {string=} designerURL
 * @property {string=} manufacturer
 * @property {string=} manufacturerURL
 * @property {string=} license
 * @property {string=} licenseURL
 * @property {string=} version
 * @property {string=} description
 * @property {string=} copyright
 * @property {string=} trademark
 * @property {Number} unitsPerEm
 * @property {Number} ascender
 * @property {Number} descender
 * @property {Number} createdTimestamp
 * @property {string=} weightClass
 * @property {string=} widthClass
 * @property {string=} fsSelection
 */

/**
 * A Font represents a loaded OpenType font file.
 * It contains a set of glyphs and methods to draw text on a drawing context,
 * or to get a path representing the text.
 * @exports opentype.Font
 * @class
 * @param {FontOptions}
 * @constructor
 */
function Font(options) {
    options = options || {};

    if (!options.empty) {
        // Check that we've provided the minimum set of names.
        checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');
        checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');
        checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');
        checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');
        checkArgument(options.descender, 'When creating a new Font object, descender is required.');
        checkArgument(options.descender < 0, 'Descender should be negative (e.g. -512).');

        // OS X will complain if the names are empty, so we put a single space everywhere by default.
        this.names = {
            fontFamily: {en: options.familyName || ' '},
            fontSubfamily: {en: options.styleName || ' '},
            fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},
            postScriptName: {en: options.postScriptName || options.familyName + options.styleName},
            designer: {en: options.designer || ' '},
            designerURL: {en: options.designerURL || ' '},
            manufacturer: {en: options.manufacturer || ' '},
            manufacturerURL: {en: options.manufacturerURL || ' '},
            license: {en: options.license || ' '},
            licenseURL: {en: options.licenseURL || ' '},
            version: {en: options.version || 'Version 0.1'},
            description: {en: options.description || ' '},
            copyright: {en: options.copyright || ' '},
            trademark: {en: options.trademark || ' '}
        };
        this.unitsPerEm = options.unitsPerEm || 1000;
        this.ascender = options.ascender;
        this.descender = options.descender;
        this.createdTimestamp = options.createdTimestamp;
        this.tables = { os2: {
            usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
            usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
            fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR
        } };
    }

    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.
    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
    this.encoding = new DefaultEncoding(this);
    this.position = new Position(this);
    this.substitution = new Substitution(this);
    this.tables = this.tables || {};

    Object.defineProperty(this, 'hinting', {
        get: function() {
            if (this._hinting) { return this._hinting; }
            if (this.outlinesFormat === 'truetype') {
                return (this._hinting = new Hinting(this));
            }
        }
    });
}

/**
 * Check if the font has a glyph for the given character.
 * @param  {string}
 * @return {Boolean}
 */
Font.prototype.hasChar = function(c) {
    return this.encoding.charToGlyphIndex(c) !== null;
};

/**
 * Convert the given character to a single glyph index.
 * Note that this function assumes that there is a one-to-one mapping between
 * the given character and a glyph; for complex scripts this might not be the case.
 * @param  {string}
 * @return {Number}
 */
Font.prototype.charToGlyphIndex = function(s) {
    return this.encoding.charToGlyphIndex(s);
};

/**
 * Convert the given character to a single Glyph object.
 * Note that this function assumes that there is a one-to-one mapping between
 * the given character and a glyph; for complex scripts this might not be the case.
 * @param  {string}
 * @return {opentype.Glyph}
 */
Font.prototype.charToGlyph = function(c) {
    var glyphIndex = this.charToGlyphIndex(c);
    var glyph = this.glyphs.get(glyphIndex);
    if (!glyph) {
        // .notdef
        glyph = this.glyphs.get(0);
    }

    return glyph;
};

/**
 * Convert the given text to a list of Glyph objects.
 * Note that there is no strict one-to-one mapping between characters and
 * glyphs, so the list of returned glyphs can be larger or smaller than the
 * length of the given string.
 * @param  {string}
 * @param  {GlyphRenderOptions} [options]
 * @return {opentype.Glyph[]}
 */
Font.prototype.stringToGlyphs = function(s, options) {
    var this$1 = this;

    options = options || this.defaultRenderOptions;
    // Get glyph indexes
    var indexes = [];
    for (var i = 0; i < s.length; i += 1) {
        var c = s[i];
        indexes.push(this$1.charToGlyphIndex(c));
    }
    var length = indexes.length;

    // Apply substitutions on glyph indexes
    if (options.features) {
        var script = options.script || this.substitution.getDefaultScriptName();
        var manyToOne = [];
        if (options.features.liga) { manyToOne = manyToOne.concat(this.substitution.getFeature('liga', script, options.language)); }
        if (options.features.rlig) { manyToOne = manyToOne.concat(this.substitution.getFeature('rlig', script, options.language)); }
        for (var i$1 = 0; i$1 < length; i$1 += 1) {
            for (var j = 0; j < manyToOne.length; j++) {
                var ligature = manyToOne[j];
                var components = ligature.sub;
                var compCount = components.length;
                var k = 0;
                while (k < compCount && components[k] === indexes[i$1 + k]) { k++; }
                if (k === compCount) {
                    indexes.splice(i$1, compCount, ligature.by);
                    length = length - compCount + 1;
                }
            }
        }
    }

    // convert glyph indexes to glyph objects
    var glyphs = new Array(length);
    var notdef = this.glyphs.get(0);
    for (var i$2 = 0; i$2 < length; i$2 += 1) {
        glyphs[i$2] = this$1.glyphs.get(indexes[i$2]) || notdef;
    }
    return glyphs;
};

/**
 * @param  {string}
 * @return {Number}
 */
Font.prototype.nameToGlyphIndex = function(name) {
    return this.glyphNames.nameToGlyphIndex(name);
};

/**
 * @param  {string}
 * @return {opentype.Glyph}
 */
Font.prototype.nameToGlyph = function(name) {
    var glyphIndex = this.nameToGlyphIndex(name);
    var glyph = this.glyphs.get(glyphIndex);
    if (!glyph) {
        // .notdef
        glyph = this.glyphs.get(0);
    }

    return glyph;
};

/**
 * @param  {Number}
 * @return {String}
 */
Font.prototype.glyphIndexToName = function(gid) {
    if (!this.glyphNames.glyphIndexToName) {
        return '';
    }

    return this.glyphNames.glyphIndexToName(gid);
};

/**
 * Retrieve the value of the kerning pair between the left glyph (or its index)
 * and the right glyph (or its index). If no kerning pair is found, return 0.
 * The kerning value gets added to the advance width when calculating the spacing
 * between glyphs.
 * @param  {opentype.Glyph} leftGlyph
 * @param  {opentype.Glyph} rightGlyph
 * @return {Number}
 */
Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
    leftGlyph = leftGlyph.index || leftGlyph;
    rightGlyph = rightGlyph.index || rightGlyph;
    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;
};

/**
 * @typedef GlyphRenderOptions
 * @type Object
 * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.
 *                               See https://www.microsoft.com/typography/otspec/scripttags.htm
 * @property {string} [language='dflt'] - language system used to determine which features to apply.
 *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx
 * @property {boolean} [kerning=true] - whether to include kerning values
 * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.
 *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm
 */
Font.prototype.defaultRenderOptions = {
    kerning: true,
    features: {
        liga: true,
        rlig: true
    }
};

/**
 * Helper function that invokes the given callback for each glyph in the given text.
 * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text
 * @param {string} text - The text to apply.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @param  {Function} callback
 */
Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
    var this$1 = this;

    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    options = options || this.defaultRenderOptions;
    var fontScale = 1 / this.unitsPerEm * fontSize;
    var glyphs = this.stringToGlyphs(text, options);
    var kerningLookups;
    if (options.kerning) {
        var script = options.script || this.position.getDefaultScriptName();
        kerningLookups = this.position.getKerningTables(script, options.language);
    }
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        callback.call(this$1, glyph, x, y, fontSize, options);
        if (glyph.advanceWidth) {
            x += glyph.advanceWidth * fontScale;
        }

        if (options.kerning && i < glyphs.length - 1) {
            // We should apply position adjustment lookups in a more generic way.
            // Here we only use the xAdvance value.
            var kerningValue = kerningLookups ?
                  this$1.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) :
                  this$1.getKerningValue(glyph, glyphs[i + 1]);
            x += kerningValue * fontScale;
        }

        if (options.letterSpacing) {
            x += options.letterSpacing * fontSize;
        } else if (options.tracking) {
            x += (options.tracking / 1000) * fontSize;
        }
    }
    return x;
};

/**
 * Create a Path object that represents the given text.
 * @param  {string} text - The text to create.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @return {opentype.Path}
 */
Font.prototype.getPath = function(text, x, y, fontSize, options) {
    var fullPath = new Path();
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
        fullPath.extend(glyphPath);
    });
    return fullPath;
};

/**
 * Create an array of Path objects that represent the glyphs of a given text.
 * @param  {string} text - The text to create.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @return {opentype.Path[]}
 */
Font.prototype.getPaths = function(text, x, y, fontSize, options) {
    var glyphPaths = [];
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
        glyphPaths.push(glyphPath);
    });

    return glyphPaths;
};

/**
 * Returns the advance width of a text.
 *
 * This is something different than Path.getBoundingBox() as for example a
 * suffixed whitespace increases the advanceWidth but not the bounding box
 * or an overhanging letter like a calligraphic 'f' might have a quite larger
 * bounding box than its advance width.
 *
 * This corresponds to canvas2dContext.measureText(text).width
 *
 * @param  {string} text - The text to create.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @return advance width
 */
Font.prototype.getAdvanceWidth = function(text, fontSize, options) {
    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});
};

/**
 * Draw the text on the given drawing context.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {string} text - The text to create.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 */
Font.prototype.draw = function(ctx, text, x, y, fontSize, options) {
    this.getPath(text, x, y, fontSize, options).draw(ctx);
};

/**
 * Draw the points of all glyphs in the text.
 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param {string} text - The text to create.
 * @param {number} [x=0] - Horizontal position of the beginning of the text.
 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param {GlyphRenderOptions=} options
 */
Font.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        glyph.drawPoints(ctx, gX, gY, gFontSize);
    });
};

/**
 * Draw lines indicating important font measurements for all glyphs in the text.
 * Black lines indicate the origin of the coordinate system (point 0,0).
 * Blue lines indicate the glyph bounding box.
 * Green line indicates the advance width of the glyph.
 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param {string} text - The text to create.
 * @param {number} [x=0] - Horizontal position of the beginning of the text.
 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param {GlyphRenderOptions=} options
 */
Font.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        glyph.drawMetrics(ctx, gX, gY, gFontSize);
    });
};

/**
 * @param  {string}
 * @return {string}
 */
Font.prototype.getEnglishName = function(name) {
    var translations = this.names[name];
    if (translations) {
        return translations.en;
    }
};

/**
 * Validate
 */
Font.prototype.validate = function() {
    var warnings = [];
    var _this = this;

    function assert(predicate, message) {
        if (!predicate) {
            warnings.push(message);
        }
    }

    function assertNamePresent(name) {
        var englishName = _this.getEnglishName(name);
        assert(englishName && englishName.trim().length > 0,
               'No English ' + name + ' specified.');
    }

    // Identification information
    assertNamePresent('fontFamily');
    assertNamePresent('weightName');
    assertNamePresent('manufacturer');
    assertNamePresent('copyright');
    assertNamePresent('version');

    // Dimension information
    assert(this.unitsPerEm > 0, 'No unitsPerEm specified.');
};

/**
 * Convert the font object to a SFNT data structure.
 * This structure contains all the necessary tables and metadata to create a binary OTF file.
 * @return {opentype.Table}
 */
Font.prototype.toTables = function() {
    return sfnt.fontToTable(this);
};
/**
 * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.
 */
Font.prototype.toBuffer = function() {
    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');
    return this.toArrayBuffer();
};
/**
 * Converts a `opentype.Font` into an `ArrayBuffer`
 * @return {ArrayBuffer}
 */
Font.prototype.toArrayBuffer = function() {
    var sfntTable = this.toTables();
    var bytes = sfntTable.encode();
    var buffer = new ArrayBuffer(bytes.length);
    var intArray = new Uint8Array(buffer);
    for (var i = 0; i < bytes.length; i++) {
        intArray[i] = bytes[i];
    }

    return buffer;
};

/**
 * Initiate a download of the OpenType font.
 */
Font.prototype.download = function(fileName) {
    var familyName = this.getEnglishName('fontFamily');
    var styleName = this.getEnglishName('fontSubfamily');
    fileName = fileName || familyName.replace(/\s/g, '') + '-' + styleName + '.otf';
    var arrayBuffer = this.toArrayBuffer();

    if (isBrowser()) {
        window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
        window.requestFileSystem(window.TEMPORARY, arrayBuffer.byteLength, function(fs) {
            fs.root.getFile(fileName, {create: true}, function(fileEntry) {
                fileEntry.createWriter(function(writer) {
                    var dataView = new DataView(arrayBuffer);
                    var blob = new Blob([dataView], {type: 'font/opentype'});
                    writer.write(blob);

                    writer.addEventListener('writeend', function() {
                        // Navigating to the file will download it.
                        location.href = fileEntry.toURL();
                    }, false);
                });
            });
        },
        function(err) {
            throw new Error(err.name + ': ' + err.message);
        });
    } else {
        var fs = require('fs');
        var buffer = arrayBufferToNodeBuffer(arrayBuffer);
        fs.writeFileSync(fileName, buffer);
    }
};
/**
 * @private
 */
Font.prototype.fsSelectionValues = {
    ITALIC:              0x001, //1
    UNDERSCORE:          0x002, //2
    NEGATIVE:            0x004, //4
    OUTLINED:            0x008, //8
    STRIKEOUT:           0x010, //16
    BOLD:                0x020, //32
    REGULAR:             0x040, //64
    USER_TYPO_METRICS:   0x080, //128
    WWS:                 0x100, //256
    OBLIQUE:             0x200  //512
};

/**
 * @private
 */
Font.prototype.usWidthClasses = {
    ULTRA_CONDENSED: 1,
    EXTRA_CONDENSED: 2,
    CONDENSED: 3,
    SEMI_CONDENSED: 4,
    MEDIUM: 5,
    SEMI_EXPANDED: 6,
    EXPANDED: 7,
    EXTRA_EXPANDED: 8,
    ULTRA_EXPANDED: 9
};

/**
 * @private
 */
Font.prototype.usWeightClasses = {
    THIN: 100,
    EXTRA_LIGHT: 200,
    LIGHT: 300,
    NORMAL: 400,
    MEDIUM: 500,
    SEMI_BOLD: 600,
    BOLD: 700,
    EXTRA_BOLD: 800,
    BLACK:    900
};

// The `fvar` table stores font variation axes and instances.
// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6fvar.html

function addName(name, names) {
    var nameString = JSON.stringify(name);
    var nameID = 256;
    for (var nameKey in names) {
        var n = parseInt(nameKey);
        if (!n || n < 256) {
            continue;
        }

        if (JSON.stringify(names[nameKey]) === nameString) {
            return n;
        }

        if (nameID <= n) {
            nameID = n + 1;
        }
    }

    names[nameID] = name;
    return nameID;
}

function makeFvarAxis(n, axis, names) {
    var nameID = addName(axis.name, names);
    return [
        {name: 'tag_' + n, type: 'TAG', value: axis.tag},
        {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},
        {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},
        {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},
        {name: 'flags_' + n, type: 'USHORT', value: 0},
        {name: 'nameID_' + n, type: 'USHORT', value: nameID}
    ];
}

function parseFvarAxis(data, start, names) {
    var axis = {};
    var p = new parse.Parser(data, start);
    axis.tag = p.parseTag();
    axis.minValue = p.parseFixed();
    axis.defaultValue = p.parseFixed();
    axis.maxValue = p.parseFixed();
    p.skip('uShort', 1);  // reserved for flags; no values defined
    axis.name = names[p.parseUShort()] || {};
    return axis;
}

function makeFvarInstance(n, inst, axes, names) {
    var nameID = addName(inst.name, names);
    var fields = [
        {name: 'nameID_' + n, type: 'USHORT', value: nameID},
        {name: 'flags_' + n, type: 'USHORT', value: 0}
    ];

    for (var i = 0; i < axes.length; ++i) {
        var axisTag = axes[i].tag;
        fields.push({
            name: 'axis_' + n + ' ' + axisTag,
            type: 'FIXED',
            value: inst.coordinates[axisTag] << 16
        });
    }

    return fields;
}

function parseFvarInstance(data, start, axes, names) {
    var inst = {};
    var p = new parse.Parser(data, start);
    inst.name = names[p.parseUShort()] || {};
    p.skip('uShort', 1);  // reserved for flags; no values defined

    inst.coordinates = {};
    for (var i = 0; i < axes.length; ++i) {
        inst.coordinates[axes[i].tag] = p.parseFixed();
    }

    return inst;
}

function makeFvarTable(fvar, names) {
    var result = new table.Table('fvar', [
        {name: 'version', type: 'ULONG', value: 0x10000},
        {name: 'offsetToData', type: 'USHORT', value: 0},
        {name: 'countSizePairs', type: 'USHORT', value: 2},
        {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},
        {name: 'axisSize', type: 'USHORT', value: 20},
        {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},
        {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}
    ]);
    result.offsetToData = result.sizeOf();

    for (var i = 0; i < fvar.axes.length; i++) {
        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));
    }

    for (var j = 0; j < fvar.instances.length; j++) {
        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));
    }

    return result;
}

function parseFvarTable(data, start, names) {
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseULong();
    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');
    var offsetToData = p.parseOffset16();
    // Skip countSizePairs.
    p.skip('uShort', 1);
    var axisCount = p.parseUShort();
    var axisSize = p.parseUShort();
    var instanceCount = p.parseUShort();
    var instanceSize = p.parseUShort();

    var axes = [];
    for (var i = 0; i < axisCount; i++) {
        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));
    }

    var instances = [];
    var instanceStart = start + offsetToData + axisCount * axisSize;
    for (var j = 0; j < instanceCount; j++) {
        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));
    }

    return {axes: axes, instances: instances};
}

var fvar = { make: makeFvarTable, parse: parseFvarTable };

// The `GPOS` table contains kerning pairs, among other things.
// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos

var subtableParsers$1 = new Array(10);         // subtableParsers[0] is unused

// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable
// this = Parser instance
subtableParsers$1[1] = function parseLookup1() {
    var start = this.offset + this.relativeOffset;
    var posformat = this.parseUShort();
    if (posformat === 1) {
        return {
            posFormat: 1,
            coverage: this.parsePointer(Parser.coverage),
            value: this.parseValueRecord()
        };
    } else if (posformat === 2) {
        return {
            posFormat: 2,
            coverage: this.parsePointer(Parser.coverage),
            values: this.parseValueRecordList()
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 1 format must be 1 or 2.');
};

// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable
subtableParsers$1[2] = function parseLookup2() {
    var start = this.offset + this.relativeOffset;
    var posFormat = this.parseUShort();
    var coverage = this.parsePointer(Parser.coverage);
    var valueFormat1 = this.parseUShort();
    var valueFormat2 = this.parseUShort();
    if (posFormat === 1) {
        // Adjustments for Glyph Pairs
        return {
            posFormat: posFormat,
            coverage: coverage,
            valueFormat1: valueFormat1,
            valueFormat2: valueFormat2,
            pairSets: this.parseList(Parser.pointer(Parser.list(function() {
                return {        // pairValueRecord
                    secondGlyph: this.parseUShort(),
                    value1: this.parseValueRecord(valueFormat1),
                    value2: this.parseValueRecord(valueFormat2)
                };
            })))
        };
    } else if (posFormat === 2) {
        var classDef1 = this.parsePointer(Parser.classDef);
        var classDef2 = this.parsePointer(Parser.classDef);
        var class1Count = this.parseUShort();
        var class2Count = this.parseUShort();
        return {
            // Class Pair Adjustment
            posFormat: posFormat,
            coverage: coverage,
            valueFormat1: valueFormat1,
            valueFormat2: valueFormat2,
            classDef1: classDef1,
            classDef2: classDef2,
            class1Count: class1Count,
            class2Count: class2Count,
            classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {
                return {
                    value1: this.parseValueRecord(valueFormat1),
                    value2: this.parseValueRecord(valueFormat2)
                };
            }))
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 2 format must be 1 or 2.');
};

subtableParsers$1[3] = function parseLookup3() { return { error: 'GPOS Lookup 3 not supported' }; };
subtableParsers$1[4] = function parseLookup4() { return { error: 'GPOS Lookup 4 not supported' }; };
subtableParsers$1[5] = function parseLookup5() { return { error: 'GPOS Lookup 5 not supported' }; };
subtableParsers$1[6] = function parseLookup6() { return { error: 'GPOS Lookup 6 not supported' }; };
subtableParsers$1[7] = function parseLookup7() { return { error: 'GPOS Lookup 7 not supported' }; };
subtableParsers$1[8] = function parseLookup8() { return { error: 'GPOS Lookup 8 not supported' }; };
subtableParsers$1[9] = function parseLookup9() { return { error: 'GPOS Lookup 9 not supported' }; };

// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos
function parseGposTable(data, start) {
    start = start || 0;
    var p = new Parser(data, start);
    var tableVersion = p.parseVersion(1);
    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GPOS table version ' + tableVersion);

    if (tableVersion === 1) {
        return {
            version: tableVersion,
            scripts: p.parseScriptList(),
            features: p.parseFeatureList(),
            lookups: p.parseLookupList(subtableParsers$1)
        };
    } else {
        return {
            version: tableVersion,
            scripts: p.parseScriptList(),
            features: p.parseFeatureList(),
            lookups: p.parseLookupList(subtableParsers$1),
            variations: p.parseFeatureVariationsList()
        };
    }

}

// GPOS Writing //////////////////////////////////////////////
// NOT SUPPORTED
var subtableMakers$1 = new Array(10);

function makeGposTable(gpos) {
    return new table.Table('GPOS', [
        {name: 'version', type: 'ULONG', value: 0x10000},
        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gpos.scripts)},
        {name: 'features', type: 'TABLE', value: new table.FeatureList(gpos.features)},
        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gpos.lookups, subtableMakers$1)}
    ]);
}

var gpos = { parse: parseGposTable, make: makeGposTable };

// The `kern` table contains kerning pairs.
// Note that some fonts use the GPOS OpenType layout table to specify kerning.
// https://www.microsoft.com/typography/OTSPEC/kern.htm

function parseWindowsKernTable(p) {
    var pairs = {};
    // Skip nTables.
    p.skip('uShort');
    var subtableVersion = p.parseUShort();
    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');
    // Skip subtableLength, subtableCoverage
    p.skip('uShort', 2);
    var nPairs = p.parseUShort();
    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);
    for (var i = 0; i < nPairs; i += 1) {
        var leftIndex = p.parseUShort();
        var rightIndex = p.parseUShort();
        var value = p.parseShort();
        pairs[leftIndex + ',' + rightIndex] = value;
    }
    return pairs;
}

function parseMacKernTable(p) {
    var pairs = {};
    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.
    // Skip the rest.
    p.skip('uShort');
    var nTables = p.parseULong();
    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');
    if (nTables > 1) {
        console.warn('Only the first kern subtable is supported.');
    }
    p.skip('uLong');
    var coverage = p.parseUShort();
    var subtableVersion = coverage & 0xFF;
    p.skip('uShort');
    if (subtableVersion === 0) {
        var nPairs = p.parseUShort();
        // Skip searchRange, entrySelector, rangeShift.
        p.skip('uShort', 3);
        for (var i = 0; i < nPairs; i += 1) {
            var leftIndex = p.parseUShort();
            var rightIndex = p.parseUShort();
            var value = p.parseShort();
            pairs[leftIndex + ',' + rightIndex] = value;
        }
    }
    return pairs;
}

// Parse the `kern` table which contains kerning pairs.
function parseKernTable(data, start) {
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseUShort();
    if (tableVersion === 0) {
        return parseWindowsKernTable(p);
    } else if (tableVersion === 1) {
        return parseMacKernTable(p);
    } else {
        throw new Error('Unsupported kern table version (' + tableVersion + ').');
    }
}

var kern = { parse: parseKernTable };

// The `loca` table stores the offsets to the locations of the glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/loca.htm

// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,
// relative to the beginning of the glyphData table.
// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)
// The loca table has two versions: a short version where offsets are stored as uShorts, and a long
// version where offsets are stored as uLongs. The `head` table specifies which version to use
// (under indexToLocFormat).
function parseLocaTable(data, start, numGlyphs, shortVersion) {
    var p = new parse.Parser(data, start);
    var parseFn = shortVersion ? p.parseUShort : p.parseULong;
    // There is an extra entry after the last index element to compute the length of the last glyph.
    // That's why we use numGlyphs + 1.
    var glyphOffsets = [];
    for (var i = 0; i < numGlyphs + 1; i += 1) {
        var glyphOffset = parseFn.call(p);
        if (shortVersion) {
            // The short table version stores the actual offset divided by 2.
            glyphOffset *= 2;
        }

        glyphOffsets.push(glyphOffset);
    }

    return glyphOffsets;
}

var loca = { parse: parseLocaTable };

// opentype.js
// https://github.com/nodebox/opentype.js
// (c) 2015 Frederik De Bleser
// opentype.js may be freely distributed under the MIT license.

/* global DataView, Uint8Array, XMLHttpRequest  */

/**
 * The opentype library.
 * @namespace opentype
 */

// File loaders /////////////////////////////////////////////////////////
/**
 * Loads a font from a file. The callback throws an error message as the first parameter if it fails
 * and the font as an ArrayBuffer in the second parameter if it succeeds.
 * @param  {string} path - The path of the file
 * @param  {Function} callback - The function to call when the font load completes
 */
function loadFromFile(path, callback) {
    var fs = require('fs');
    fs.readFile(path, function(err, buffer) {
        if (err) {
            return callback(err.message);
        }

        callback(null, nodeBufferToArrayBuffer(buffer));
    });
}
/**
 * Loads a font from a URL. The callback throws an error message as the first parameter if it fails
 * and the font as an ArrayBuffer in the second parameter if it succeeds.
 * @param  {string} url - The URL of the font file.
 * @param  {Function} callback - The function to call when the font load completes
 */
function loadFromUrl(url, callback) {
    var request = new XMLHttpRequest();
    request.open('get', url, true);
    request.responseType = 'arraybuffer';
    request.onload = function() {
        if (request.response) {
            return callback(null, request.response);
        } else {
            return callback('Font could not be loaded: ' + request.statusText);
        }
    };

    request.onerror = function () {
        callback('Font could not be loaded');
    };

    request.send();
}

// Table Directory Entries //////////////////////////////////////////////
/**
 * Parses OpenType table entries.
 * @param  {DataView}
 * @param  {Number}
 * @return {Object[]}
 */
function parseOpenTypeTableEntries(data, numTables) {
    var tableEntries = [];
    var p = 12;
    for (var i = 0; i < numTables; i += 1) {
        var tag = parse.getTag(data, p);
        var checksum = parse.getULong(data, p + 4);
        var offset = parse.getULong(data, p + 8);
        var length = parse.getULong(data, p + 12);
        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});
        p += 16;
    }

    return tableEntries;
}

/**
 * Parses WOFF table entries.
 * @param  {DataView}
 * @param  {Number}
 * @return {Object[]}
 */
function parseWOFFTableEntries(data, numTables) {
    var tableEntries = [];
    var p = 44; // offset to the first table directory entry.
    for (var i = 0; i < numTables; i += 1) {
        var tag = parse.getTag(data, p);
        var offset = parse.getULong(data, p + 4);
        var compLength = parse.getULong(data, p + 8);
        var origLength = parse.getULong(data, p + 12);
        var compression = (void 0);
        if (compLength < origLength) {
            compression = 'WOFF';
        } else {
            compression = false;
        }

        tableEntries.push({tag: tag, offset: offset, compression: compression,
            compressedLength: compLength, length: origLength});
        p += 20;
    }

    return tableEntries;
}

/**
 * @typedef TableData
 * @type Object
 * @property {DataView} data - The DataView
 * @property {number} offset - The data offset.
 */

/**
 * @param  {DataView}
 * @param  {Object}
 * @return {TableData}
 */
function uncompressTable(data, tableEntry) {
    if (tableEntry.compression === 'WOFF') {
        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
        var outBuffer = new Uint8Array(tableEntry.length);
        tinyInflate(inBuffer, outBuffer);
        if (outBuffer.byteLength !== tableEntry.length) {
            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\'t match recorded length');
        }

        var view = new DataView(outBuffer.buffer, 0);
        return {data: view, offset: 0};
    } else {
        return {data: data, offset: tableEntry.offset};
    }
}

// Public API ///////////////////////////////////////////////////////////

/**
 * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
 * Throws an error if the font could not be parsed.
 * @param  {ArrayBuffer}
 * @return {opentype.Font}
 */
function parseBuffer(buffer) {
    var indexToLocFormat;
    var ltagTable;

    // Since the constructor can also be called to create new fonts from scratch, we indicate this
    // should be an empty font that we'll fill with our own data.
    var font = new Font({empty: true});

    // OpenType fonts use big endian byte ordering.
    // We can't rely on typed array view types, because they operate with the endianness of the host computer.
    // Instead we use DataViews where we can specify endianness.
    var data = new DataView(buffer, 0);
    var numTables;
    var tableEntries = [];
    var signature = parse.getTag(data, 0);
    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {
        font.outlinesFormat = 'truetype';
        numTables = parse.getUShort(data, 4);
        tableEntries = parseOpenTypeTableEntries(data, numTables);
    } else if (signature === 'OTTO') {
        font.outlinesFormat = 'cff';
        numTables = parse.getUShort(data, 4);
        tableEntries = parseOpenTypeTableEntries(data, numTables);
    } else if (signature === 'wOFF') {
        var flavor = parse.getTag(data, 4);
        if (flavor === String.fromCharCode(0, 1, 0, 0)) {
            font.outlinesFormat = 'truetype';
        } else if (flavor === 'OTTO') {
            font.outlinesFormat = 'cff';
        } else {
            throw new Error('Unsupported OpenType flavor ' + signature);
        }

        numTables = parse.getUShort(data, 12);
        tableEntries = parseWOFFTableEntries(data, numTables);
    } else {
        throw new Error('Unsupported OpenType signature ' + signature);
    }

    var cffTableEntry;
    var fvarTableEntry;
    var glyfTableEntry;
    var gposTableEntry;
    var gsubTableEntry;
    var hmtxTableEntry;
    var kernTableEntry;
    var locaTableEntry;
    var nameTableEntry;
    var metaTableEntry;
    var p;

    for (var i = 0; i < numTables; i += 1) {
        var tableEntry = tableEntries[i];
        var table = (void 0);
        switch (tableEntry.tag) {
            case 'cmap':
                table = uncompressTable(data, tableEntry);
                font.tables.cmap = cmap.parse(table.data, table.offset);
                font.encoding = new CmapEncoding(font.tables.cmap);
                break;
            case 'cvt ' :
                table = uncompressTable(data, tableEntry);
                p = new parse.Parser(table.data, table.offset);
                font.tables.cvt = p.parseShortList(tableEntry.length / 2);
                break;
            case 'fvar':
                fvarTableEntry = tableEntry;
                break;
            case 'fpgm' :
                table = uncompressTable(data, tableEntry);
                p = new parse.Parser(table.data, table.offset);
                font.tables.fpgm = p.parseByteList(tableEntry.length);
                break;
            case 'head':
                table = uncompressTable(data, tableEntry);
                font.tables.head = head.parse(table.data, table.offset);
                font.unitsPerEm = font.tables.head.unitsPerEm;
                indexToLocFormat = font.tables.head.indexToLocFormat;
                break;
            case 'hhea':
                table = uncompressTable(data, tableEntry);
                font.tables.hhea = hhea.parse(table.data, table.offset);
                font.ascender = font.tables.hhea.ascender;
                font.descender = font.tables.hhea.descender;
                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
                break;
            case 'hmtx':
                hmtxTableEntry = tableEntry;
                break;
            case 'ltag':
                table = uncompressTable(data, tableEntry);
                ltagTable = ltag.parse(table.data, table.offset);
                break;
            case 'maxp':
                table = uncompressTable(data, tableEntry);
                font.tables.maxp = maxp.parse(table.data, table.offset);
                font.numGlyphs = font.tables.maxp.numGlyphs;
                break;
            case 'name':
                nameTableEntry = tableEntry;
                break;
            case 'OS/2':
                table = uncompressTable(data, tableEntry);
                font.tables.os2 = os2.parse(table.data, table.offset);
                break;
            case 'post':
                table = uncompressTable(data, tableEntry);
                font.tables.post = post.parse(table.data, table.offset);
                font.glyphNames = new GlyphNames(font.tables.post);
                break;
            case 'prep' :
                table = uncompressTable(data, tableEntry);
                p = new parse.Parser(table.data, table.offset);
                font.tables.prep = p.parseByteList(tableEntry.length);
                break;
            case 'glyf':
                glyfTableEntry = tableEntry;
                break;
            case 'loca':
                locaTableEntry = tableEntry;
                break;
            case 'CFF ':
                cffTableEntry = tableEntry;
                break;
            case 'kern':
                kernTableEntry = tableEntry;
                break;
            case 'GPOS':
                gposTableEntry = tableEntry;
                break;
            case 'GSUB':
                gsubTableEntry = tableEntry;
                break;
            case 'meta':
                metaTableEntry = tableEntry;
                break;
        }
    }

    var nameTable = uncompressTable(data, nameTableEntry);
    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);
    font.names = font.tables.name;

    if (glyfTableEntry && locaTableEntry) {
        var shortVersion = indexToLocFormat === 0;
        var locaTable = uncompressTable(data, locaTableEntry);
        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
        var glyfTable = uncompressTable(data, glyfTableEntry);
        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font);
    } else if (cffTableEntry) {
        var cffTable = uncompressTable(data, cffTableEntry);
        cff.parse(cffTable.data, cffTable.offset, font);
    } else {
        throw new Error('Font doesn\'t contain TrueType or CFF outlines.');
    }

    var hmtxTable = uncompressTable(data, hmtxTableEntry);
    hmtx.parse(hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);
    addGlyphNames(font);

    if (kernTableEntry) {
        var kernTable = uncompressTable(data, kernTableEntry);
        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);
    } else {
        font.kerningPairs = {};
    }

    if (gposTableEntry) {
        var gposTable = uncompressTable(data, gposTableEntry);
        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);
    }

    if (gsubTableEntry) {
        var gsubTable = uncompressTable(data, gsubTableEntry);
        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);
    }

    if (fvarTableEntry) {
        var fvarTable = uncompressTable(data, fvarTableEntry);
        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);
    }

    if (metaTableEntry) {
        var metaTable = uncompressTable(data, metaTableEntry);
        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);
        font.metas = font.tables.meta;
    }

    return font;
}

/**
 * Asynchronously load the font from a URL or a filesystem. When done, call the callback
 * with two arguments `(err, font)`. The `err` will be null on success,
 * the `font` is a Font object.
 * We use the node.js callback convention so that
 * opentype.js can integrate with frameworks like async.js.
 * @alias opentype.load
 * @param  {string} url - The URL of the font to load.
 * @param  {Function} callback - The callback.
 */
function load(url, callback) {
    var isNode$$1 = typeof window === 'undefined';
    var loadFn = isNode$$1 ? loadFromFile : loadFromUrl;
    loadFn(url, function(err, arrayBuffer) {
        if (err) {
            return callback(err);
        }
        var font;
        try {
            font = parseBuffer(arrayBuffer);
        } catch (e) {
            return callback(e, null);
        }
        return callback(null, font);
    });
}

/**
 * Synchronously load the font from a URL or file.
 * When done, returns the font object or throws an error.
 * @alias opentype.loadSync
 * @param  {string} url - The URL of the font to load.
 * @return {opentype.Font}
 */
function loadSync(url) {
    var fs = require('fs');
    var buffer = fs.readFileSync(url);
    return parseBuffer(nodeBufferToArrayBuffer(buffer));
}

exports.Font = Font;
exports.Glyph = Glyph;
exports.Path = Path;
exports.BoundingBox = BoundingBox;
exports._parse = parse;
exports.parse = parseBuffer;
exports.load = load;
exports.loadSync = loadSync;

Object.defineProperty(exports, '__esModule', { value: true });

})));


}).call(this,require("buffer").Buffer)

},{"buffer":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\node_modules\\buffer\\index.js","fs":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\node_modules\\browser-resolve\\empty.js"}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\glcat-path-gui.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _glcatPath = require('./glcat-path');

var _glcatPath2 = _interopRequireDefault(_glcatPath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var requiredFields = function requiredFields(object, nanithefuck, fields) {
  fields.map(function (field) {
    if (typeof object[field] === "undefined") {
      throw "GLCat-Path: " + field + " is required for " + nanithefuck;
    }
  });
};

var PathGUI = function (_Path) {
  _inherits(PathGUI, _Path);

  function PathGUI(glCat, params) {
    _classCallCheck(this, PathGUI);

    var _this = _possibleConstructorReturn(this, (PathGUI.__proto__ || Object.getPrototypeOf(PathGUI)).call(this, glCat, params));

    var it = _this;

    requiredFields(params, "params", ["canvas", "el"]);

    it.gui = { parent: it.params.el };

    it.gui.info = document.createElement("span");
    it.gui.parent.appendChild(it.gui.info);

    it.gui.range = document.createElement("input");
    it.gui.range.type = "range";
    it.gui.range.min = 0;
    it.gui.range.max = 0;
    it.gui.range.step = 1;
    it.gui.parent.appendChild(it.gui.range);

    it.dateList = new Array(30).fill(0);
    it.dateListIndex = 0;
    it.totalFrames = 0;
    it.fps = 0;
    it.currentIndex = 0;
    it.viewName = "";
    it.viewIndex = 0;

    var gl = glCat.gl;
    var vboQuad = glCat.createVertexbuffer([-1, -1, 1, -1, -1, 1, 1, 1]);
    it.add({
      __PathGuiReturn: {
        width: it.params.canvas.width,
        height: it.params.canvas.height,
        vert: "attribute vec2 p;void main(){gl_Position=vec4(p,0,1);}",
        frag: "precision highp float;uniform vec2 r;uniform sampler2D s;void main(){gl_FragColor=texture2D(s,gl_FragCoord.xy/r);}",
        blend: [gl.ONE, gl.ONE],
        clear: [0.0, 0.0, 0.0, 1.0],
        func: function func(_p, params) {
          gl.viewport(0, 0, it.params.canvas.width, it.params.canvas.height);
          glCat.uniform2fv('r', [it.params.canvas.width, it.params.canvas.height]);

          glCat.attribute('p', vboQuad, 2);
          glCat.uniformTexture('s', params.input, 0);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
      }
    });
    return _this;
  }

  _createClass(PathGUI, [{
    key: 'begin',
    value: function begin() {
      var it = this;

      it.currentIndex = 0;
    }
  }, {
    key: 'end',
    value: function end() {
      var it = this;

      it.gui.range.max = Math.max(it.gui.range.max, it.currentIndex);
      it.currentIndex = 0;

      var now = +new Date() * 1E-3;
      it.dateList[it.dateListIndex] = now;
      it.dateListIndex = (it.dateListIndex + 1) % it.dateList.length;
      it.fps = ((it.dateList.length - 1) / (now - it.dateList[it.dateListIndex])).toFixed(1);

      it.totalFrames++;

      it.gui.info.innerText = "Path: " + it.viewName + " (" + it.viewIndex + ")\n" + it.fps + " FPS\n" + it.totalFrames + " frames\n";
    }
  }, {
    key: 'render',
    value: function render(name, params) {
      var it = this;

      it.currentIndex++;
      var view = parseInt(it.gui.range.value);

      if (it.currentIndex <= view || view === 0) {
        it.viewName = view === 0 ? "*Full*" : name;
        it.viewIndex = it.currentIndex;

        _get(PathGUI.prototype.__proto__ || Object.getPrototypeOf(PathGUI.prototype), 'render', this).call(this, name, params);

        if (it.currentIndex === view) {
          var t = params && params.target ? params.target : it.paths[name].framebuffer;

          if (t && t.framebuffer) {
            var i = t.textures ? t.textures[0] : t.texture;
            if (it.params.stretch) {
              _get(PathGUI.prototype.__proto__ || Object.getPrototypeOf(PathGUI.prototype), 'render', this).call(this, "__PathGuiReturn", {
                target: PathGUI.nullFb,
                input: i,
                width: it.params.canvas.width,
                height: it.params.canvas.height
              });
            } else {
              it.params.canvas.width = (params ? params.width : 0) || it.paths[name].width || it.params.width;
              it.params.canvas.height = (params ? params.height : 0) || it.paths[name].height || it.params.height;
              _get(PathGUI.prototype.__proto__ || Object.getPrototypeOf(PathGUI.prototype), 'render', this).call(this, "__PathGuiReturn", {
                target: PathGUI.nullFb,
                input: i
              });
            }
          }
        }
      }
    }
  }]);

  return PathGUI;
}(_glcatPath2.default);

exports.default = PathGUI;

},{"./glcat-path":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\glcat-path.js"}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\glcat-path.js":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



var requiredFields = function requiredFields(object, nanithefuck, fields) {
  fields.map(function (field) {
    if (typeof object[field] === "undefined") {
      throw "GLCat-Path: " + field + " is required for " + nanithefuck;
    }
  });
};

var Path = function () {
  function Path(glCat, params) {
    _classCallCheck(this, Path);

    var it = this;

    it.glCat = glCat;
    it.gl = glCat.gl;

    it.paths = {};
    it.globalFunc = function () {};
    it.params = params || {};
  }

  _createClass(Path, [{
    key: "add",
    value: function add(paths) {
      var it = this;

      for (var name in paths) {
        var path = paths[name];
        requiredFields(path, "path object", ["vert", "frag"]);
        it.paths[name] = path;

        if (typeof path.depthTest === "undefined") {
          path.depthTest = true;
        }
        if (typeof path.depthWrite === "undefined") {
          path.depthWrite = true;
        }
        if (typeof path.blend === "undefined") {
          path.blend = [it.gl.SRC_ALPHA, it.gl.ONE_MINUS_SRC_ALPHA];
        }
        if (typeof path.cull === "undefined") {
          path.cull = true;
        }

        if (path.framebuffer) {
          if (path.drawbuffers) {
            path.framebuffer = it.glCat.createDrawBuffers(path.width, path.height, path.drawbuffers);
          } else if (path.float) {
            path.framebuffer = it.glCat.createFloatFramebuffer(path.width, path.height);
          } else {
            path.framebuffer = it.glCat.createFramebuffer(path.width, path.height);
          }
        }

        path.program = it.glCat.createProgram(path.vert, path.frag);
      }
    }
  }, {
    key: "render",
    value: function render(name, params) {
      var _it$gl;

      var it = this;

      var path = it.paths[name];
      if (!path) {
        throw "GLCat-Path: The path called " + name + " is not defined!";
      }

      if (!params) {
        params = {};
      }
      params.framebuffer = typeof params.target !== "undefined" ? params.target.framebuffer : path.framebuffer ? path.framebuffer.framebuffer : null;

      var width = params.width || path.width;
      var height = params.height || path.height;

      if (!width || !height) {
        throw 'GLCat-Path: width or height is invalid';
      }

      it.gl.viewport(0, 0, width, height);
      it.glCat.useProgram(path.program);
      path.cull ? it.gl.enable(it.gl.CULL_FACE) : it.gl.disable(it.gl.CULL_FACE);
      it.gl.bindFramebuffer(it.gl.FRAMEBUFFER, params.framebuffer);
      if (it.params.drawbuffers) {
        it.glCat.drawBuffers(path.drawbuffers ? path.drawbuffers : params.framebuffer === null ? [it.gl.BACK] : [it.gl.COLOR_ATTACHMENT0]);
      }
      (_it$gl = it.gl).blendFunc.apply(_it$gl, _toConsumableArray(path.blend));
      if (path.clear) {
        var _it$glCat;

        (_it$glCat = it.glCat).clear.apply(_it$glCat, _toConsumableArray(path.clear));
      }
      path.depthTest ? it.gl.enable(it.gl.DEPTH_TEST) : it.gl.disable(it.gl.DEPTH_TEST);
      path.depthWrite ? it.gl.depthMask(true) : it.gl.depthMask(false);

      it.glCat.uniform2fv('resolution', [width, height]);
      it.globalFunc(path, params);

      if (path.func) {
        path.func(path, params);
      }
    }
  }, {
    key: "resize",
    value: function resize(name, width, height) {
      var it = this;

      var path = it.paths[name];

      path.width = width;
      path.height = height;

      if (path.framebuffer) {
        if (it.params.drawbuffers && path.drawbuffers) {
          path.framebuffer = it.glCat.createDrawBuffers(path.width, path.height, path.drawbuffers);
        } else if (path.float) {
          it.glCat.resizeFloatFramebuffer(path.framebuffer, path.width, path.height);
        } else {
          it.glCat.resizeFramebuffer(path.framebuffer, path.width, path.height);
        }
      }

      if (typeof path.onresize === "function") {
        path.onresize(path, width, height);
      }
    }
  }, {
    key: "setGlobalFunc",
    value: function setGlobalFunc(func) {
      this.globalFunc = func;
    }
  }, {
    key: "fb",
    value: function fb(name) {
      if (!this.paths[name]) {
        throw "glcat-path.fb: path called " + name + " is not defined";
      }
      if (!this.paths[name].framebuffer) {
        throw "glcat-path.fb: there is no framebuffer for the path " + name;
      }

      return this.paths[name].framebuffer;
    }
  }]);

  return Path;
}();

Path.nullFb = { framebuffer: null };

exports.default = Path;

},{}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\glcat.js":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GLCat = function () {
	function GLCat(_gl) {
		_classCallCheck(this, GLCat);

		var it = this;

		it.gl = _gl;
		var gl = it.gl;

		gl.enable(gl.DEPTH_TEST);
		gl.depthFunc(gl.LEQUAL);
		gl.enable(gl.BLEND);
		gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

		it.extensions = {};

		it.currentProgram = null;
	}

	_createClass(GLCat, [{
		key: "getExtension",
		value: function getExtension(_name, _throw) {
			var it = this;
			var gl = it.gl;

			if ((typeof _name === "undefined" ? "undefined" : _typeof(_name)) === "object" && _name.isArray()) {
				return _name.every(function (name) {
					return it.getExtension(name, _throw);
				});
			} else if (typeof _name === "string") {
				if (it.extensions[_name]) {
					return it.extensions[_name];
				} else {
					it.extensions[_name] = gl.getExtension(_name);
					if (it.extensions[_name]) {
						return it.extensions[_name];
					} else {
						if (_throw) {
							throw console.error("The extension \"" + _name + "\" is not supported");
						}
						return false;
					}
				}
				return !!it.extensions[_name];
			} else {
				throw "GLCat.getExtension: _name must be string or array";
			}
		}
	}, {
		key: "createProgram",
		value: function createProgram(_vert, _frag, _onError) {
			var it = this;
			var gl = it.gl;

			var error = void 0;
			if (typeof _onError === 'function') {
				error = _onError;
			} else {
				error = function error(_str) {
					console.error(_str);
				};
			}

			var vert = gl.createShader(gl.VERTEX_SHADER);
			gl.shaderSource(vert, _vert);
			gl.compileShader(vert);
			if (!gl.getShaderParameter(vert, gl.COMPILE_STATUS)) {
				error(gl.getShaderInfoLog(vert));
				return null;
			}

			var frag = gl.createShader(gl.FRAGMENT_SHADER);
			gl.shaderSource(frag, _frag);
			gl.compileShader(frag);
			if (!gl.getShaderParameter(frag, gl.COMPILE_STATUS)) {
				error(gl.getShaderInfoLog(frag));
				return null;
			}

			var program = gl.createProgram();
			gl.attachShader(program, vert);
			gl.attachShader(program, frag);
			gl.linkProgram(program);
			if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
				program.locations = {};
				return program;
			} else {
				error(gl.getProgramInfoLog(program));
				return null;
			}
		}
	}, {
		key: "useProgram",
		value: function useProgram(_program) {
			var it = this;
			var gl = it.gl;

			gl.useProgram(_program);
			it.currentProgram = _program;
		}
	}, {
		key: "createVertexbuffer",
		value: function createVertexbuffer(_array) {
			var it = this;
			var gl = it.gl;

			var buffer = gl.createBuffer();

			if (_array) {
				it.setVertexbuffer(buffer, _array);
			}

			return buffer;
		}
	}, {
		key: "setVertexbuffer",
		value: function setVertexbuffer(_buffer, _array, _mode) {
			var it = this;
			var gl = it.gl;

			var mode = _mode || gl.STATIC_DRAW;

			gl.bindBuffer(gl.ARRAY_BUFFER, _buffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(_array), mode);
			gl.bindBuffer(gl.ARRAY_BUFFER, null);

			_buffer.length = _array.length;
		}
	}, {
		key: "createIndexbuffer",
		value: function createIndexbuffer(_array) {
			var it = this;
			var gl = it.gl;

			var buffer = gl.createBuffer();

			if (_array) {
				it.setIndexbuffer(buffer, _array);
			}

			return buffer;
		}
	}, {
		key: "setIndexbuffer",
		value: function setIndexbuffer(_buffer, _array, _mode) {
			var it = this;
			var gl = it.gl;

			var mode = _mode || gl.STATIC_DRAW;

			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _buffer);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int16Array(_array), mode);
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

			_buffer.length = _array.length;
		}
	}, {
		key: "getAttribLocation",
		value: function getAttribLocation(_name) {
			var it = this;
			var gl = it.gl;

			var location = void 0;
			if (it.currentProgram.locations[_name]) {
				location = it.currentProgram.locations[_name];
			} else {
				location = gl.getAttribLocation(it.currentProgram, _name);
				it.currentProgram.locations[_name] = location;
			}

			return location;
		}
	}, {
		key: "attribute",
		value: function attribute(_name, _buffer, _stride, _div) {
			var it = this;
			var gl = it.gl;

			if (_div) {
				it.getExtension("ANGLE_instanced_arrays", true);
			}

			var location = it.getAttribLocation(_name);

			gl.bindBuffer(gl.ARRAY_BUFFER, _buffer);
			gl.enableVertexAttribArray(location);
			gl.vertexAttribPointer(location, _stride, gl.FLOAT, false, 0, 0);

			var ext = it.getExtension("ANGLE_instanced_arrays");
			if (ext) {
				var div = _div || 0;
				ext.vertexAttribDivisorANGLE(location, div);
			}

			gl.bindBuffer(gl.ARRAY_BUFFER, null);
		}
	}, {
		key: "getUniformLocation",
		value: function getUniformLocation(_name) {
			var it = this;
			var gl = it.gl;

			var location = void 0;

			if (typeof it.currentProgram.locations[_name] !== "undefined") {
				location = it.currentProgram.locations[_name];
			} else {
				location = gl.getUniformLocation(it.currentProgram, _name);
				it.currentProgram.locations[_name] = location;
			}

			return location;
		}
	}, {
		key: "uniform1i",
		value: function uniform1i(_name, _value) {
			var it = this;
			var gl = it.gl;

			var location = it.getUniformLocation(_name);
			gl.uniform1i(location, _value);
		}
	}, {
		key: "uniform1f",
		value: function uniform1f(_name, _value) {
			var it = this;
			var gl = it.gl;

			var location = it.getUniformLocation(_name);
			gl.uniform1f(location, _value);
		}
	}, {
		key: "uniform2fv",
		value: function uniform2fv(_name, _value) {
			var it = this;
			var gl = it.gl;

			var location = it.getUniformLocation(_name);
			gl.uniform2fv(location, _value);
		}
	}, {
		key: "uniform3fv",
		value: function uniform3fv(_name, _value) {
			var it = this;
			var gl = it.gl;

			var location = it.getUniformLocation(_name);
			gl.uniform3fv(location, _value);
		}
	}, {
		key: "uniform4fv",
		value: function uniform4fv(_name, _value) {
			var it = this;
			var gl = it.gl;

			var location = it.getUniformLocation(_name);
			gl.uniform4fv(location, _value);
		}
	}, {
		key: "uniformMatrix4fv",
		value: function uniformMatrix4fv(_name, _value, _transpose) {
			var it = this;
			var gl = it.gl;

			var location = it.getUniformLocation(_name);
			gl.uniformMatrix4fv(location, _transpose || false, _value);
		}
	}, {
		key: "uniformCubemap",
		value: function uniformCubemap(_name, _texture, _number) {
			var it = this;
			var gl = it.gl;

			var location = it.getUniformLocation(_name);
			gl.activeTexture(gl.TEXTURE0 + _number);
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, _texture);
			gl.uniform1i(location, _number);
		}
	}, {
		key: "uniformTexture",
		value: function uniformTexture(_name, _texture, _number) {
			var it = this;
			var gl = it.gl;

			var location = it.getUniformLocation(_name);
			gl.activeTexture(gl.TEXTURE0 + _number);
			gl.bindTexture(gl.TEXTURE_2D, _texture);
			gl.uniform1i(location, _number);
		}
	}, {
		key: "createTexture",
		value: function createTexture() {
			var it = this;
			var gl = it.gl;

			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.bindTexture(gl.TEXTURE_2D, null);

			return texture;
		}
	}, {
		key: "textureFilter",
		value: function textureFilter(_texture, _filter) {
			var it = this;
			var gl = it.gl;

			gl.bindTexture(gl.TEXTURE_2D, _texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, _filter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, _filter);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: "textureWrap",
		value: function textureWrap(_texture, _wrap) {
			var it = this;
			var gl = it.gl;

			gl.bindTexture(gl.TEXTURE_2D, _texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, _wrap);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, _wrap);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: "setTexture",
		value: function setTexture(_texture, _image) {
			var it = this;
			var gl = it.gl;

			gl.bindTexture(gl.TEXTURE_2D, _texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, _image);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: "setTextureFromArray",
		value: function setTextureFromArray(_texture, _width, _height, _array) {
			var it = this;
			var gl = it.gl;

			gl.bindTexture(gl.TEXTURE_2D, _texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(_array));
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: "setTextureFromFloatArray",
		value: function setTextureFromFloatArray(_texture, _width, _height, _array) {
			var it = this;
			var gl = it.gl;

			it.getExtension("OES_texture_float", true);

			gl.bindTexture(gl.TEXTURE_2D, _texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, new Float32Array(_array));
			if (!it.getExtension("OES_texture_float_linear")) {
				it.textureFilter(_texture, gl.NEAREST);
			}
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: "copyTexture",
		value: function copyTexture(_texture, _width, _height) {
			var it = this;
			var gl = it.gl;

			gl.bindTexture(gl.TEXTURE_2D, _texture);
			gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, _width, _height, 0);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: "createCubemap",
		value: function createCubemap(_arrayOfImage) {
			var it = this;
			var gl = it.gl;

			// order : X+, X-, Y+, Y-, Z+, Z-
			var texture = gl.createTexture();

			gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
			for (var i = 0; i < 6; i++) {
				gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, _arrayOfImage[i]);
			}
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);

			return texture;
		}
	}, {
		key: "createFramebuffer",
		value: function createFramebuffer(_width, _height) {
			var it = this;
			var gl = it.gl;

			var framebuffer = {};
			framebuffer.framebuffer = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer.framebuffer);

			framebuffer.depth = gl.createRenderbuffer();
			gl.bindRenderbuffer(gl.RENDERBUFFER, framebuffer.depth);
			gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, framebuffer.depth);

			framebuffer.texture = it.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, framebuffer.texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
			gl.bindTexture(gl.TEXTURE_2D, null);

			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, framebuffer.texture, 0);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			return framebuffer;
		}
	}, {
		key: "resizeFramebuffer",
		value: function resizeFramebuffer(_framebuffer, _width, _height) {
			var it = this;
			var gl = it.gl;

			gl.bindFramebuffer(gl.FRAMEBUFFER, _framebuffer.framebuffer);

			gl.bindRenderbuffer(gl.RENDERBUFFER, _framebuffer.depth);
			gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
			gl.bindRenderbuffer(gl.RENDERBUFFER, null);

			gl.bindTexture(gl.TEXTURE_2D, _framebuffer.texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
			gl.bindTexture(gl.TEXTURE_2D, null);

			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
	}, {
		key: "createFloatFramebuffer",
		value: function createFloatFramebuffer(_width, _height) {
			var it = this;
			var gl = it.gl;

			it.getExtension("OES_texture_float", true);

			var framebuffer = {};
			framebuffer.framebuffer = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer.framebuffer);

			framebuffer.depth = gl.createRenderbuffer();
			gl.bindRenderbuffer(gl.RENDERBUFFER, framebuffer.depth);
			gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, framebuffer.depth);

			framebuffer.texture = it.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, framebuffer.texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, null);
			if (!it.getExtension("OES_texture_float_linear")) {
				it.textureFilter(framebuffer.texture, gl.NEAREST);
			}
			gl.bindTexture(gl.TEXTURE_2D, null);

			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, framebuffer.texture, 0);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			return framebuffer;
		}
	}, {
		key: "resizeFloatFramebuffer",
		value: function resizeFloatFramebuffer(_framebuffer, _width, _height) {
			var it = this;
			var gl = it.gl;

			gl.bindFramebuffer(gl.FRAMEBUFFER, _framebuffer.framebuffer);

			gl.bindRenderbuffer(gl.RENDERBUFFER, _framebuffer.depth);
			gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
			gl.bindRenderbuffer(gl.RENDERBUFFER, null);

			gl.bindTexture(gl.TEXTURE_2D, _framebuffer.texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, null);
			gl.bindTexture(gl.TEXTURE_2D, null);

			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
	}, {
		key: "createDrawBuffers",
		value: function createDrawBuffers(_width, _height, _numDrawBuffers) {
			var it = this;
			var gl = it.gl;

			it.getExtension('OES_texture_float', true);
			var ext = it.getExtension('WEBGL_draw_buffers', true);

			if (ext.MAX_DRAW_BUFFERS_WEBGL < _numDrawBuffers) {
				throw "createDrawBuffers: MAX_DRAW_BUFFERS_WEBGL is " + ext.MAX_DRAW_BUFFERS_WEBGL;
			}

			var framebuffer = {};
			framebuffer.framebuffer = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer.framebuffer);

			framebuffer.depth = gl.createRenderbuffer();
			gl.bindRenderbuffer(gl.RENDERBUFFER, framebuffer.depth);
			gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, framebuffer.depth);

			framebuffer.textures = [];
			for (var i = 0; i < _numDrawBuffers; i++) {
				framebuffer.textures[i] = it.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, framebuffer.textures[i]);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, null);
				if (!it.getExtension("OES_texture_float_linear")) {
					it.textureFilter(framebuffer.textures[i], gl.NEAREST);
				}
				gl.bindTexture(gl.TEXTURE_2D, null);

				gl.framebufferTexture2D(gl.FRAMEBUFFER, ext.COLOR_ATTACHMENT0_WEBGL + i, gl.TEXTURE_2D, framebuffer.textures[i], 0);
			}

			var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
			if (status !== gl.FRAMEBUFFER_COMPLETE) {
				throw "createDrawBuffers: gl.checkFramebufferStatus( gl.FRAMEBUFFER ) returns " + status;
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			return framebuffer;
		}
	}, {
		key: "resizeDrawBuffers",
		value: function resizeDrawBuffers(_framebuffer, _width, height) {
			var it = this;
			var gl = it.gl;

			gl.bindFramebuffer(gl.FRAMEBUFFER, _framebuffer.framebuffer);

			gl.bindRenderbuffer(gl.RENDERBUFFER, _framebuffer.depth);
			gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
			gl.bindRenderbuffer(gl.RENDERBUFFER, null);

			for (var i = 0; i < _framebuffer.textures.length; i++) {
				gl.bindTexture(gl.TEXTURE_2D, _framebuffer.textures[i]);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, null);
				gl.bindTexture(gl.TEXTURE_2D, null);
			}

			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
	}, {
		key: "drawBuffers",
		value: function drawBuffers(_numDrawBuffers) {
			var it = this;
			var gl = it.gl;

			var ext = it.getExtension("WEBGL_draw_buffers", true);

			var array = [];
			if (typeof _numDrawBuffers === "number") {
				for (var i = 0; i < _numDrawBuffers; i++) {
					array.push(ext.COLOR_ATTACHMENT0_WEBGL + i);
				}
			} else {
				array = array.concat(_numDrawBuffers);
			}
			ext.drawBuffersWEBGL(array);
		}
	}, {
		key: "clear",
		value: function clear(_r, _g, _b, _a, _d) {
			var it = this;
			var gl = it.gl;

			var r = _r || 0.0;
			var g = _g || 0.0;
			var b = _b || 0.0;
			var a = typeof _a === 'number' ? _a : 1.0;
			var d = typeof _d === 'number' ? _d : 1.0;

			gl.clearColor(r, g, b, a);
			gl.clearDepth(d);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		}
	}]);

	return GLCat;
}();

exports.default = GLCat;

},{}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\mathcat.js":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// 

var MathCat = {};

/**
 * adds a two vec
 * @param {array} a - vec
 * @param {array} b - vec
 */
MathCat.vecAdd = function (a, b) {
  return a.map(function (e, i) {
    return e + b[i];
  });
};

/**
 * substracts a vec from an another vec
 * @param {array} a - vec
 * @param {array} b - vec
 */
MathCat.vecSub = function (a, b) {
  return a.map(function (e, i) {
    return e - b[i];
  });
};

/**
 * returns a cross of two vec3s
 * @param {array} a - vec3
 * @param {array} b - vec3
 */
MathCat.vec3Cross = function (a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
};

/**
 * scales a vec by scalar
 * @param {number} s - scalar
 * @param {array} v - vec
 */
MathCat.vecScale = function (s, v) {
  return v.map(function (e) {
    return e * s;
  });
};

/**
 * returns length of a vec
 * @param {array} v - vec
 */
MathCat.vecLength = function (v) {
  return Math.sqrt(v.reduce(function (p, c) {
    return p + c * c;
  }, 0.0));
};

/**
 * normalizes a vec
 * @param {array} v - vec
 */
MathCat.vecNormalize = function (v) {
  return MathCat.vecScale(1.0 / MathCat.vecLength(v), v);
};

/**
 * applies two mat4s
 * @param {array} a - mat4
 * @param {array} b - mat4
 */
MathCat.mat4Apply = function (a, b) {
  return [a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3], a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3], a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3], a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3], a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7], a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7], a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7], a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7], a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11], a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11], a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11], a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11], a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15], a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15], a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15], a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]];
};

/**
 * transpose a mat4
 * @param {array} m - mat4
 */
MathCat.mat4Transpose = function (m) {
  return [m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]];
};

/**
 * returns an indentity mat4
 */
MathCat.mat4Identity = function () {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
};

MathCat.mat4Translate = function (v) {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, v[0], v[1], v[2], 1];
};

MathCat.mat4Scale = function (v) {
  return [v[0], 0, 0, 0, 0, v[1], 0, 0, 0, 0, v[2], 0, 0, 0, 0, 1];
};

MathCat.mat4ScaleXYZ = function (s) {
  return [s, 0, 0, 0, 0, s, 0, 0, 0, 0, s, 0, 0, 0, 0, 1];
};

MathCat.mat4RotateX = function (t) {
  return [1, 0, 0, 0, 0, Math.cos(t), -Math.sin(t), 0, 0, Math.sin(t), Math.cos(t), 0, 0, 0, 0, 1];
};

MathCat.mat4RotateY = function (t) {
  return [Math.cos(t), 0, Math.sin(t), 0, 0, 1, 0, 0, -Math.sin(t), 0, Math.cos(t), 0, 0, 0, 0, 1];
};

MathCat.mat4RotateZ = function (t) {
  return [Math.cos(t), -Math.sin(t), 0, 0, Math.sin(t), Math.cos(t), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
};

MathCat.mat4LookAt = function (pos, tar, air, rot) {
  var dir = MathCat.vecNormalize(MathCat.vecSub(tar, pos));
  var sid = MathCat.vecNormalize(MathCat.vec3Cross(dir, air));
  var top = MathCat.vec3Cross(sid, dir);
  sid = MathCat.vecAdd(MathCat.vecScale(Math.cos(rot), sid), MathCat.vecScale(Math.sin(rot), top));
  top = MathCat.vec3Cross(sid, dir);

  return [sid[0], top[0], dir[0], 0.0, sid[1], top[1], dir[1], 0.0, sid[2], top[2], dir[2], 0.0, -sid[0] * pos[0] - sid[1] * pos[1] - sid[2] * pos[2], -top[0] * pos[0] - top[1] * pos[1] - top[2] * pos[2], -dir[0] * pos[0] - dir[1] * pos[1] - dir[2] * pos[2], 1.0];
};

MathCat.mat4Perspective = function (fov, near, far) {
  var p = 1.0 / Math.tan(fov * Math.PI / 360.0);
  var d = far - near;
  return [p, 0.0, 0.0, 0.0, 0.0, p, 0.0, 0.0, 0.0, 0.0, (far + near) / d, 1.0, 0.0, 0.0, -2 * far * near / d, 0.0];
};

exports.default = MathCat;

},{}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\step.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var step = function step(_obj) {
  var obj = _obj;
  var count = -1;

  var func = function func() {
    count++;
    if (typeof obj[count] === 'function') {
      obj[count](func);
    }
  };
  func();
};

exports.default = step;

},{}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\tweak.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tweak = function () {
  function Tweak(_el) {
    _classCallCheck(this, Tweak);

    var it = this;

    it.parent = _el;
    it.values = {};
    it.elements = {};
  }

  _createClass(Tweak, [{
    key: 'button',
    value: function button(_name, _props) {
      var it = this;

      var props = _props || {};

      if (typeof it.values[_name] === 'undefined') {
        var div = document.createElement('div');
        it.parent.appendChild(div);

        var input = document.createElement('input');
        div.appendChild(input);
        input.type = 'button';
        input.value = _name;

        input.addEventListener('click', function () {
          it.values[_name] = true;
        });

        it.elements[_name] = {
          div: div,
          input: input
        };
      }

      var tempvalue = it.values[_name];
      it.values[_name] = false;
      if (typeof props.set === 'boolean') {
        it.values[_name] = props.set;
      }

      return tempvalue;
    }
  }, {
    key: 'checkbox',
    value: function checkbox(_name, _props) {
      var it = this;

      var props = _props || {};

      var value = void 0;

      if (typeof it.values[_name] === 'undefined') {
        value = props.value || false;

        var div = document.createElement('div');
        it.parent.appendChild(div);

        var name = document.createElement('span');
        div.appendChild(name);
        name.innerText = _name;

        var input = document.createElement('input');
        div.appendChild(input);
        input.type = 'checkbox';
        input.checked = value;

        it.elements[_name] = {
          div: div,
          name: name,
          input: input
        };
      } else {
        value = it.elements[_name].input.checked;
      }

      if (typeof props.set === 'boolean') {
        value = props.set;
      }

      it.elements[_name].input.checked = value;
      it.values[_name] = value;

      return it.values[_name];
    }
  }, {
    key: 'range',
    value: function range(_name, _props) {
      var it = this;

      var props = _props || {};

      var value = void 0;

      if (typeof it.values[_name] === 'undefined') {
        var min = props.min || 0.0;
        var max = props.max || 1.0;
        var step = props.step || 0.001;
        value = props.value || min;

        var div = document.createElement('div');
        it.parent.appendChild(div);

        var name = document.createElement('span');
        div.appendChild(name);
        name.innerText = _name;

        var input = document.createElement('input');
        div.appendChild(input);
        input.type = 'range';
        input.value = value;
        input.min = min;
        input.max = max;
        input.step = step;

        var val = document.createElement('span');
        val.innerText = value.toFixed(3);
        div.appendChild(val);
        input.addEventListener('input', function (_event) {
          var value = parseFloat(input.value);
          val.innerText = value.toFixed(3);
        });

        it.elements[_name] = {
          div: div,
          name: name,
          input: input,
          val: val
        };
      } else {
        value = parseFloat(it.elements[_name].input.value);
      }

      if (typeof props.set === 'number') {
        value = props.set;
      }

      it.values[_name] = value;
      it.elements[_name].input.value = value;

      return it.values[_name];
    }
  }]);

  return Tweak;
}();

exports.default = Tweak;

},{}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\xorshift.js":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var seed = void 0;
var xorshift = function xorshift(_seed) {
  seed = _seed || seed || 1;
  seed = seed ^ seed << 13;
  seed = seed ^ seed >>> 17;
  seed = seed ^ seed << 5;
  return seed / Math.pow(2, 32) + 0.5;
};

exports.default = xorshift;

},{}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\main.js":[function(require,module,exports){
'use strict';

var _xorshift = require('./libs/xorshift');

var _xorshift2 = _interopRequireDefault(_xorshift);

var _tweak = require('./libs/tweak');

var _tweak2 = _interopRequireDefault(_tweak);

var _glcat = require('./libs/glcat');

var _glcat2 = _interopRequireDefault(_glcat);

var _glcatPathGui = require('./libs/glcat-path-gui');

var _glcatPathGui2 = _interopRequireDefault(_glcatPathGui);

var _mathcat = require('./libs/mathcat');

var _mathcat2 = _interopRequireDefault(_mathcat);

var _step = require('./libs/step');

var _step2 = _interopRequireDefault(_step);

var _pathLofipath = require('./path-lofipath');

var _pathLofipath2 = _interopRequireDefault(_pathLofipath);

var _pathPieces = require('./path-pieces');

var _pathPieces2 = _interopRequireDefault(_pathPieces);

var _pathPostfx = require('./path-postfx');

var _pathPostfx2 = _interopRequireDefault(_pathPostfx);

var _pathConsole = require('./path-console');

var _pathConsole2 = _interopRequireDefault(_pathConsole);

var _pathGrid = require('./path-grid');

var _pathGrid2 = _interopRequireDefault(_pathGrid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }



// ------

(0, _xorshift2.default)(326789157890);

// ------

var width = canvas.width = 480;
var height = canvas.height = 480;

var renderA = document.createElement('a');

var saveFrame = function saveFrame() {
  renderA.href = canvas.toDataURL();
  renderA.download = ('0000' + totalFrame).slice(-5) + '.png';
  renderA.click();
};

// ------

var gl = canvas.getContext('webgl');
gl.enable(gl.CULL_FACE);

var glCat = new _glcat2.default(gl);

glCat.getExtension('OES_texture_float', true);
glCat.getExtension('OES_texture_float_linear', true);
glCat.getExtension('EXT_frag_depth', true);
glCat.getExtension('ANGLE_instanced_arrays', true);

var glCatPath = new _glcatPathGui2.default(glCat, {
  el: divPath,
  canvas: canvas,
  stretch: true
});

// ------

var tweak = new _tweak2.default(divTweak);

// ------

var totalFrame = 0;
var init = false;

var automaton = new Automaton({
  gui: divAutomaton,
  fps: 60,
  data: '\n  {"v":"1.1.1","length":3,"resolution":1000,"params":{"cameraPosX":[{"time":0,"value":0,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":0.5,"value":0,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]},{"time":1,"value":0.3685084541062791,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]},{"time":1.625,"value":-0.32850241545893955,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]},{"time":2,"value":0.3318236714975846,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]},{"time":3,"value":0,"mode":4,"params":{"rate":2000,"damp":1},"mods":[false,false,false,false]}],"pathBegin":[{"time":0,"value":0.2,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":3,"value":0,"mode":1,"params":{},"mods":[false,false,false,false]}],"pathSegs":[{"time":0,"value":30.000000000000007,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":1.25,"value":4,"mode":4,"params":{"rate":30,"damp":1},"mods":[false,false,false,false]},{"time":3,"value":30,"mode":4,"params":{"rate":30,"damp":1},"mods":[false,false,false,false]}],"deformAmp":[{"time":0,"value":5,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":1.25,"value":5.744800003243596,"mode":4,"params":{"rate":50,"damp":1},"mods":[false,false,false,false]},{"time":2.4314868804664727,"value":0,"mode":4,"params":{"rate":91,"damp":1},"mods":[false,false,false,false]},{"time":2.685131195335277,"value":1.7939176042416891,"mode":4,"params":{"rate":500,"damp":1},"mods":[false,false,false,false]},{"time":3,"value":5,"mode":4,"params":{"rate":500,"damp":1},"mods":[false,false,false,false]}],"deformFreq":[{"time":0,"value":1,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":1.25,"value":0.15161574064757133,"mode":4,"params":{"rate":50,"damp":1},"mods":[false,false,false,false]},{"time":3,"value":1,"mode":4,"params":{"rate":500,"damp":1},"mods":[false,false,false,false]}],"deformOffset":[{"time":0,"value":0,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":3,"value":1.0014573039186314,"mode":1,"params":{},"mods":[false,false,false,false]}],"cameraPosY":[{"time":0,"value":0,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":0.75,"value":0,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]},{"time":1.25,"value":0.40126811594202927,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]},{"time":1.875,"value":-0.735960144927537,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]},{"time":2,"value":0.4012681159420284,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]},{"time":3,"value":0,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]}],"cameraPosZ":[{"time":0,"value":10,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":1.25,"value":18.080519192055664,"mode":4,"params":{"rate":250,"damp":1},"mods":[false,false,false,false]},{"time":2,"value":9.572463768115943,"mode":4,"params":{"rate":250,"damp":1},"mods":[false,false,false,false]},{"time":3,"value":10,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]}],"glitch":[{"time":0,"value":0.3650542009991148,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":2.5,"value":0,"mode":4,"params":{"rate":190,"damp":1},"mods":[false,false,{"freq":1,"amp":0.024,"reso":8,"recursion":4,"seed":20.07},{"freq":19}]},{"time":3,"value":0.31146654065536417,"mode":2,"params":{},"mods":[{"velocity":0},false,false,false]}],"glitchSeed":[{"time":0,"value":0,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":0.04054054054054054,"value":0.053140096618357446,"mode":0,"params":{},"mods":[false,false,false,false]},{"time":0.4723032069970846,"value":0.18357487922705318,"mode":0,"params":{},"mods":[false,false,false,false]},{"time":2.5509810101646835,"value":0.7248830012077294,"mode":1,"params":{},"mods":[false,false,false,{"freq":31}]},{"time":2.921,"value":0.8840579710144932,"mode":0,"params":{},"mods":[false,false,false,false]},{"time":3,"value":1,"mode":1,"params":{},"mods":[false,false,false,false]}],"measurePhase1":[{"time":0,"value":1,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":1.25,"value":5.551115123125783e-17,"mode":4,"params":{"rate":500,"damp":1},"mods":[false,false,false,false]},{"time":3,"value":1,"mode":4,"params":{"rate":500,"damp":1},"mods":[false,false,false,false]}],"measurePhase2":[{"time":0,"value":1,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":1.5801158301158305,"value":0.004830917874396101,"mode":4,"params":{"rate":500,"damp":1},"mods":[false,false,false,false]},{"time":3,"value":1,"mode":4,"params":{"rate":500,"damp":1},"mods":[false,false,false,false]}]},"gui":{"snap":{"enable":true,"bpm":"60","offset":"0"}}}\n'
});
var auto = automaton.auto;

// ------

var cameraPos = [0.0, 0.0, 10.0];
var cameraTar = [0.0, 0.0, 0.0];
var cameraRoll = 0.0;
var cameraFov = 70.0;

var cameraNear = 0.1;
var cameraFar = 100.0;

var lightPos = [10.0, 8.0, 10.0];

var matP = void 0;
var matV = void 0;
var matPL = void 0;
var matVL = void 0;

var updateMatrices = function updateMatrices() {
  cameraPos[0] = auto('cameraPosX');
  cameraPos[1] = auto('cameraPosY');
  cameraPos[2] = auto('cameraPosZ');

  matP = _mathcat2.default.mat4Perspective(cameraFov, cameraNear, cameraFar);
  matV = _mathcat2.default.mat4LookAt(cameraPos, cameraTar, [0.0, 1.0, 0.0], cameraRoll);

  matPL = _mathcat2.default.mat4Perspective(cameraFov, cameraNear, cameraFar);
  matVL = _mathcat2.default.mat4LookAt(lightPos, cameraTar, [0.0, 1.0, 0.0], 0.0);
};
updateMatrices();

// ------

var mouseX = 0.0;
var mouseY = 0.0;

canvas.addEventListener('mousemove', function (event) {
  mouseX = event.offsetX;
  mouseY = event.offsetY;
});

// ------

var vboQuad = glCat.createVertexbuffer([-1, -1, 1, -1, -1, 1, 1, 1]);

// ------

var bgColor = [0.01, 0.01, 0.01, 1.0];

// ------

glCatPath.setGlobalFunc(function () {
  glCat.uniform1i('init', init);
  glCat.uniform1f('time', automaton.time);
  glCat.uniform1f('deltaTime', automaton.deltaTime);

  glCat.uniform1f('totalFrame', totalFrame);
  glCat.uniform2fv('mouse', [mouseX, mouseY]);

  glCat.uniform3fv('cameraPos', cameraPos);
  glCat.uniform3fv('cameraTar', cameraTar);
  glCat.uniform1f('cameraRoll', cameraRoll);
  glCat.uniform1f('cameraFov', cameraFov);
  glCat.uniform1f('cameraNear', cameraNear);
  glCat.uniform1f('cameraFar', cameraFar);
  glCat.uniform3fv('lightPos', lightPos);

  glCat.uniformMatrix4fv('matP', matP);
  glCat.uniformMatrix4fv('matV', matV);
  glCat.uniformMatrix4fv('matPL', matPL);
  glCat.uniformMatrix4fv('matVL', matVL);
  glCat.uniform4fv('bgColor', bgColor);
});

glCatPath.add({
  return: {
    width: width,
    height: height,
    vert: "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}\n",
    frag: "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform sampler2D sampler0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  gl_FragColor = texture2D( sampler0, uv );\n}\n",
    blend: [gl.ONE, gl.ZERO],
    clear: [0.0, 0.0, 0.0, 1.0],
    func: function func(path, params) {
      glCat.attribute('p', vboQuad, 2);
      glCat.uniformTexture('sampler0', params.input, 0);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
  },

  inspector: {
    width: width,
    height: height,
    vert: "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}\n",
    frag: "#define RADIUS 40.0\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec2 mouse;\nuniform vec3 circleColor;\nuniform sampler2D sampler0;\n\nbool print( in vec2 _coord, float _in ) {\n  vec2 coord = _coord;\n\n  // vertical restriction\n  if ( coord.y <= 0.0 || 5.0 <= coord.y ) { return false; }\n  \n  // dot\n  if ( 0.0 < coord.x && coord.x < 2.0 ) {\n    return coord.x < 1.0 && coord.y < 1.0;\n  }\n\n  // padded by dot\n  if ( 2.0 < coord.x ) { coord.x -= 2.0; }\n  \n  // determine digit\n  float ci = floor( coord.x / 5.0 ) + 1.0;\n\n  // too low / too high\n  if ( 4.0 < ci ) { return false; }\n  if ( ci < -4.0 ) { return false; }\n\n  // x of char\n  float cfx = floor( mod( coord.x, 5.0 ) );\n\n  // width is 4\n  if ( 4.0 == cfx ) { return false; }\n\n  // y of char\n  float cfy = floor( coord.y );\n\n  // bit of char\n  float cf = cfx + 4.0 * cfy;\n\n  // determine char  \n  float num = 0.0;\n  if ( 0.0 < ci ) {\n    float n = abs( _in );\n    for ( int i = 0; i < 6; i ++ ) {\n      if ( ci < float( i ) ) { break; }\n      \n      num = mod( floor( n ), 10.0 );\n      n -= num;\n      n *= 10.0;\n    }\n  } else {\n    float n = abs( _in );\n    for ( int i = 0; i < 6; i ++ ) {\n      if ( -ci < float( i ) ) { break; }\n      \n      if ( ci != 0.0 && n < 1.0 ) {\n        // minus\n        return float( i ) == -ci && _in < 0.0 && cfy == 2.0 && 0.0 < cfx;\n      }\n      num = mod( floor( n ), 10.0 );\n      n -= num;\n      n /= 10.0;\n    }\n  }\n\n  bool a;\n  a = 1.0 == mod( floor( (\n    num == 0.0 ? 432534.0 :\n    num == 1.0 ? 410692.0 :\n    num == 2.0 ? 493087.0 :\n    num == 3.0 ? 493191.0 :\n    num == 4.0 ? 630408.0 :\n    num == 5.0 ? 989063.0 :\n    num == 6.0 ? 399254.0 :\n    num == 7.0 ? 1016898.0 :\n    num == 8.0 ? 431766.0 :\n    433798.0\n  ) / pow( 2.0, cf ) ), 2.0 );\n  \n  return a ? true : false;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n\n  vec2 m = floor( vec2( 0.0, resolution.y ) + vec2( 1.0, -1.0 ) * mouse );\n  vec2 center = floor( m + vec2( 1.0, 0.7 ) * RADIUS );\n  float circle = length( gl_FragCoord.xy - center ) - RADIUS;\n\n  vec4 col = texture2D( sampler0, uv );\n  vec4 mcol = texture2D( sampler0, ( m + 0.5 ) / resolution );\n  vec4 bcol = vec4( circleColor, 1.0 );\n\n  col = mix(\n    col,\n    mix(\n      bcol,\n      mcol,\n      smoothstep( 1.0, 0.0, circle + 5.0 )\n    ),\n    smoothstep( 1.0, 0.0, circle )\n  );\n\n  if ( circle < 0.0 ) {\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, 8.0 ), mcol.x ) ? bcol : col;\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, 0.0 ), mcol.y ) ? bcol : col;\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, -8.0 ), mcol.z ) ? bcol : col;\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, -16.0 ), mcol.w ) ? bcol : col;\n  }\n\n  gl_FragColor = col;\n}",
    blend: [gl.ONE, gl.ZERO],
    clear: [0.0, 0.0, 0.0, 1.0],
    func: function func(path, params) {
      glCat.attribute('p', vboQuad, 2);
      glCat.uniform3fv('circleColor', [1.0, 1.0, 1.0]);
      glCat.uniformTexture('sampler0', params.input, 0);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
  },

  'target': {
    width: width,
    height: height,
    vert: "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}\n",
    frag: "precision highp float;\n#define GLSLIFY 1\n\nuniform vec4 bgColor;\n\n// ------\n\nvoid main() {\n  gl_FragColor = bgColor;\n}",
    blend: [gl.ONE, gl.ZERO],
    clear: [0.0, 0.0, 0.0, 1.0],
    framebuffer: true,
    float: true,
    depthWrite: false,
    func: function func() {
      glCat.attribute('p', vboQuad, 2);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
  }
});

// ------

var updateUI = function updateUI() {
  var now = new Date();
  var deadline = new Date(2018, 2, 16, 0, 0);

  divCountdown.innerText = 'Deadline: ' + Math.floor((deadline - now) / 1000);
};

// ------

var update = function update() {
  if (!tweak.checkbox('play', { value: true })) {
    setTimeout(update, 100);
    return;
  }

  automaton.update();

  updateUI();
  updateMatrices();

  // ------

  glCatPath.begin();

  glCatPath.render('target');

  glCatPath.render('piecesComputeReturn');
  glCatPath.render('piecesCompute');

  glCatPath.render('lofipath', {
    target: glCatPath.fb('target'),
    width: width,
    height: height,
    begin: auto('pathBegin'),
    segs: auto('pathSegs')
  });

  glCatPath.render('piecesRender', {
    target: glCatPath.fb('target'),
    width: width,
    height: height
  });

  glCatPath.render('console', {
    target: glCatPath.fb('target'),
    width: width,
    height: height,
    time: automaton.time,
    frame: automaton.frame,
    cameraX: cameraPos[0],
    cameraY: cameraPos[1],
    cameraZ: cameraPos[2]
  });

  glCatPath.render('measure', {
    target: glCatPath.fb('target'),
    width: width,
    height: height,
    phase1: auto('measurePhase1'),
    phase2: auto('measurePhase2')
  });

  glCatPath.render('grid', {
    target: glCatPath.fb('target'),
    width: width,
    height: height
  });

  glCatPath.render('glitch', {
    input: glCatPath.fb('target').texture,
    width: width,
    height: height,
    amp: auto('glitch'),
    seed: auto('glitchSeed')
  });

  glCatPath.render('post', {
    target: _glcatPathGui2.default.nullFb,
    input: glCatPath.fb('glitch').texture,
    width: width,
    height: height
  });

  glCatPath.end();

  init = false;
  totalFrame++;

  // ------

  if (tweak.checkbox('save', { value: false })) {
    saveFrame();
  }

  requestAnimationFrame(update);
};

(0, _step2.default)({
  0: function _(step) {
    (0, _pathLofipath2.default)(glCatPath, auto, step);
    (0, _pathPostfx2.default)(glCatPath, width, height);
    (0, _pathConsole2.default)(glCatPath, width, height);
    (0, _pathPieces2.default)(glCatPath, automaton);
    (0, _pathGrid2.default)(glCatPath);
  },

  1: function _(step) {
    update();
  }
});

// ------

window.addEventListener('keydown', function (_e) {
  if (_e.which === 27) {
    tweak.checkbox('play', { set: false });
  }
});

},{"./libs/glcat":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\glcat.js","./libs/glcat-path-gui":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\glcat-path-gui.js","./libs/mathcat":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\mathcat.js","./libs/step":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\step.js","./libs/tweak":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\tweak.js","./libs/xorshift":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\xorshift.js","./path-console":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\path-console.js","./path-grid":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\path-grid.js","./path-lofipath":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\path-lofipath.js","./path-pieces":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\path-pieces.js","./path-postfx":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\path-postfx.js"}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\path-console.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});


// ------

var canvas = document.createElement('canvas');
var context = canvas.getContext('2d');

// ------

var textWithBg = function textWithBg(text, x, y) {
  context.font = '500 20px Wt-Position';
  context.textAlign = 'left';
  context.textBaseline = 'hanging';

  var mt = context.measureText(text);

  context.fillStyle = '#fff';
  context.fillRect(x - 4, y - 4, mt.width + 8, 20);

  context.fillStyle = '#000';
  context.fillText(text, x, y);
};

var textBottom = function textBottom(text, size, x, y) {
  context.font = '900 ' + size + 'px Helvetica Neue';
  context.textAlign = 'right';
  context.textBaseline = 'alphabetic';

  context.fillStyle = '#fff';
  context.fillText(text, x, y);
};

// ------

var pathConsole = function pathConsole(glCatPath, width, height) {
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;

  // ------

  var w = canvas.width = width;
  var h = canvas.height = height;

  var vboQuad = glCat.createVertexbuffer([-1, -1, 1, -1, -1, 1, 1, 1]);
  var texture = glCat.createTexture();

  // ------

  glCatPath.add({
    console: {
      vert: "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}\n",
      frag: "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform sampler2D sampler0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  uv.y = 1.0 - uv.y;\n  gl_FragColor = texture2D( sampler0, uv );\n}\n",
      float: true,
      blend: [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA],
      depthWrite: false,
      depthTest: false,
      func: function func(path, params) {
        context.clearRect(0, 0, w, h);

        textWithBg('RANDOM F*%#ING NUMBER: ' + (256.0 * Math.random()).toFixed(3), 10, 10);
        textWithBg('CAMERA X: ' + params.cameraX.toFixed(3), 10, 40);
        textWithBg('CAMERA Y: ' + params.cameraY.toFixed(3), 10, 70);
        textWithBg('CAMERA Z: ' + params.cameraZ.toFixed(3), 10, 100);

        textBottom(params.time.toFixed(3), 30, width - 10, height - 80);
        textBottom('undefined', 30, width - 10, height - 50);
        textBottom('[Placeholder]', 40, width - 10, height - 10);

        glCat.setTexture(texture, canvas);

        glCat.attribute('p', vboQuad, 2);
        glCat.uniformTexture('sampler0', texture, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    }
  });
};

exports.default = pathConsole;

},{}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\path-grid.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mathcat = require('./libs/mathcat');

var _mathcat2 = _interopRequireDefault(_mathcat);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }



// ------

var pathGrid = function pathGrid(glCatPath) {
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;

  // ------

  var vboQuad = glCat.createVertexbuffer([-1, -1, 1, -1, -1, 1, 1, 1]);

  var layer = [];
  for (var i = -3; i < 0; i++) {
    layer.push((i + 0.5) * 0.05);
  }
  var vboLayer = glCat.createVertexbuffer(layer);

  // ------

  glCatPath.add({
    grid: {
      vert: "#define GLSLIFY 1\n#define HUGE 9E16\n#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n\n// ------\n\nattribute vec2 p;\nattribute float z;\n\nvarying vec3 vPos;\n\nuniform vec2 resolution;\n\nuniform mat4 matP;\nuniform mat4 matV;\nuniform mat4 matM;\n\n// ------\n\nvoid main() {\n  vec4 p = matM * vec4( p, z, 1.0 );\n  vPos = p.xyz;\n\n  vec4 outPos;\n  outPos = matP * matV * p;\n  outPos.x /= resolution.x / resolution.y;\n  \n  gl_Position = outPos;\n  gl_PointSize = resolution.y / 100.0;\n}",
      frag: "#define saturate(i) clamp(i,0.,1.)\n\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPos;\n\nuniform vec3 color;\n\n// ------\n\nvoid main() {\n  float intrv = 5.0;\n  vec2 p = mod( vPos.xy, intrv ) - intrv / 2.0;\n\n  float a = 1.0;\n  a *= smoothstep( 0.05, 0.00, min( abs( p.x ), abs( p.y ) ) );\n  a *= smoothstep( 0.40, 0.39, max( abs( p.x ), abs( p.y ) ) );\n\n  if ( a == 0.0 ) { discard; }\n  gl_FragColor = vec4( color, 0.1 * saturate( a ) );\n}",
      func: function func(path, params) {
        glCat.attribute('z', vboLayer, 1, 1);
        glCat.attribute('p', vboQuad, 2);

        var matM = _mathcat2.default.mat4Identity();
        matM = _mathcat2.default.mat4Apply(_mathcat2.default.mat4ScaleXYZ(100.0), matM);
        glCat.uniformMatrix4fv('matM', matM);

        glCat.uniform3fv('color', [1.0, 1.0, 1.0]);

        var ext = glCat.getExtension("ANGLE_instanced_arrays");
        ext.drawArraysInstancedANGLE(gl.TRIANGLE_STRIP, 0, 4, vboLayer.length);
      }
    },

    measure: {
      vert: "#define GLSLIFY 1\n#define HUGE 9E16\n#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n\n// ------\n\nattribute vec2 p;\n\nvarying vec3 vPos;\n\nuniform vec2 resolution;\n\nuniform mat4 matP;\nuniform mat4 matV;\nuniform mat4 matM;\n\n// ------\n\nvoid main() {\n  vec4 p = matM * vec4( p, 0.0, 1.0 );\n  vPos = p.xyz;\n\n  vec4 outPos;\n  outPos = matP * matV * p;\n  outPos.x /= resolution.x / resolution.y;\n  \n  gl_Position = outPos;\n  gl_PointSize = resolution.y / 100.0;\n}",
      frag: "#define saturate(i) clamp(i,0.,1.)\n\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPos;\n\nuniform float time;\nuniform vec3 color;\nuniform float phase1;\nuniform float phase2;\n\n// ------\n\nvoid main() {\n  float a = 0.0;\n\n  // line\n  a += (\n    smoothstep( 0.05, 0.04, abs( abs( vPos.y ) - 3.0 ) )\n  );\n\n  float scroll = vPos.y < 0.0 ? time : -time;\n\n  // dot1\n  {\n    float d = mod( vPos.x - 0.1 + scroll, 0.2 ) - 0.1;\n    a += (\n      smoothstep( 0.03, 0.02, abs( d ) )\n      * smoothstep( 2.9, 2.89, abs( vPos.y ) )\n      * smoothstep( 2.9, 2.91, abs( vPos.y ) + 0.1 * phase2 )\n    );\n  }\n\n  // dot2\n  {\n    float d = mod( vPos.x - 0.5 + scroll, 1.0 ) - 0.5;\n    a += (\n      smoothstep( 0.03, 0.02, abs( d ) )\n      * smoothstep( 2.9, 2.89, abs( vPos.y ) )\n      * smoothstep( 2.9, 2.91, abs( vPos.y ) + 0.2 * phase2 )\n    );\n  }\n\n  a *= smoothstep( 0.0, -0.01, abs( vPos.x ) - 6.02 * phase1 );\n\n  if ( a == 0.0 ) { discard; }\n  gl_FragColor = vec4( color, 0.3 * saturate( a ) );\n}",
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);

        var matM = _mathcat2.default.mat4Identity();
        matM = _mathcat2.default.mat4Apply(_mathcat2.default.mat4ScaleXYZ(100.0), matM);
        glCat.uniformMatrix4fv('matM', matM);

        glCat.uniform1f('phase1', params.phase1);
        glCat.uniform1f('phase2', params.phase2);
        glCat.uniform3fv('color', [1.0, 1.0, 1.0]);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    }
  });
};

exports.default = pathGrid;

},{"./libs/mathcat":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\mathcat.js"}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\path-lofipath.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svgPath = require('./svg-path');

var _svgPath2 = _interopRequireDefault(_svgPath);

var _mathcat = require('./libs/mathcat');

var _mathcat2 = _interopRequireDefault(_mathcat);

var _vertphaser = require('./vertphaser');

var _vertphaser2 = _interopRequireDefault(_vertphaser);

var _opentype = require('opentype.js');

var opentype = _interopRequireWildcard(_opentype);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }



// ------

var pathLofiPath = function pathLofiPath(glCatPath, auto, callback) {
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;

  // ------

  var phasers = void 0;

  opentype.load('fonts/Orbitron-Black.ttf', function (error, font) {
    if (error) {
      throw error;
    }

    var fontSize = 12.0;
    var text = 'Vec';
    var wid = font.getAdvanceWidth(text, fontSize);
    var path = font.getPath(text, 0, 0, fontSize).toPathData();
    var vs = (0, _svgPath2.default)(path, { curveSegs: 8 });
    phasers = vs.map(function (v) {
      for (var i = 0; i < v.length / 2; i++) {
        v[i * 2 + 0] = v[i * 2 + 0] - wid / 2;
        v[i * 2 + 1] = -(v[i * 2 + 1] + fontSize * 0.35);
      }
      return new _vertphaser2.default(v);
    });

    callback();
  });

  var vboPos = glCat.createVertexbuffer(false);

  // ------

  glCatPath.add({
    lofipath: {
      vert: "#define GLSLIFY 1\n#define HUGE 9E16\n#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n\n// ------\n\nattribute vec2 p;\n\nvarying vec3 vPos;\n\nuniform vec2 resolution;\nuniform float deformAmp;\nuniform float deformFreq;\nuniform float deformOffset;\n\nuniform mat4 matP;\nuniform mat4 matV;\nuniform mat4 matM;\n\n// ------\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\n// ------\n\nvoid main() {\n  vec4 p = matM * vec4( p, 0.0, 1.0 );\n  p.xyz += deformAmp * vec3(\n    snoise( vec4( p.xyz * deformFreq,   1.0 + deformOffset ) ),\n    snoise( vec4( p.xyz * deformFreq,  44.7 + deformOffset ) ),\n    snoise( vec4( p.xyz * deformFreq, 111.3 + deformOffset ) )\n  );\n  vPos = p.xyz;\n\n  vec4 outPos;\n  outPos = matP * matV * p;\n  outPos.x /= resolution.x / resolution.y;\n  \n  gl_Position = outPos;\n  gl_PointSize = resolution.y / 100.0;\n}",
      frag: "precision highp float;\n#define GLSLIFY 1\n\nuniform vec3 color;\n\n// ------\n\nvoid main() {\n  if ( 0.5 < length( gl_PointCoord - 0.5 ) ) { discard; }\n  gl_FragColor = vec4( color, 1.0 );\n}",
      float: true,
      depthWrite: false,
      depthTest: false,
      func: function func(path, params) {
        var matM = _mathcat2.default.mat4Identity();
        matM = _mathcat2.default.mat4Apply(_mathcat2.default.mat4ScaleXYZ(0.4), matM);
        glCat.uniformMatrix4fv('matM', matM);

        glCat.uniform3fv('color', [1.0, 1.0, 1.0]);

        // ------

        phasers.map(function (phaser) {
          var begin = params.begin || 0.0;
          var segs = Math.max(3, params.segs || 3);
          var arr = phaser.lofi(begin, segs);

          glCat.setVertexbuffer(vboPos, arr, gl.DYNAMIC_DRAW);

          glCat.attribute('p', vboPos, 2);

          glCat.uniform1f('deformAmp', auto('deformAmp'));
          glCat.uniform1f('deformFreq', auto('deformFreq'));
          glCat.uniform1f('deformOffset', auto('deformOffset'));

          gl.drawArrays(gl.LINE_STRIP, 0, arr.length / 2);
          gl.drawArrays(gl.POINTS, 0, arr.length / 2);
        });
      }
    }
  });
};

exports.default = pathLofiPath;

},{"./libs/mathcat":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\mathcat.js","./svg-path":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\svg-path.js","./vertphaser":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\vertphaser.js","opentype.js":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\node_modules\\opentype.js\\dist\\opentype.js"}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\path-pieces.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mathcat = require('./libs/mathcat');

var _mathcat2 = _interopRequireDefault(_mathcat);

var _xorshift = require('./libs/xorshift');

var _xorshift2 = _interopRequireDefault(_xorshift);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }



(0, _xorshift2.default)(487723);

// ------

var particlePixels = 2;
var particlesSqrt = 8;
var particles = particlesSqrt * particlesSqrt;
// let vertsPerParticle = lunaLen / 3;

// ------

var pathPieces = function pathPieces(glCatPath, automaton) {
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;

  // ------

  var vboQuad = glCat.createVertexbuffer([-1, -1, 1, -1, -1, 1, 1, 1]);

  var vboParticleUV = glCat.createVertexbuffer(function () {
    var ret = [];
    for (var i = 0; i < particles; i++) {
      var ix = i % particlesSqrt;
      var iy = Math.floor(i / particlesSqrt);

      ret.push(ix * particlePixels);
      ret.push(iy);
    }
    return ret;
  }());

  // ------

  var textureRandomSize = 32;
  var textureRandomUpdate = function textureRandomUpdate(_tex) {
    glCat.setTextureFromArray(_tex, textureRandomSize, textureRandomSize, function () {
      var len = textureRandomSize * textureRandomSize * 4;
      var ret = new Uint8Array(len);
      for (var i = 0; i < len; i++) {
        ret[i] = Math.floor((0, _xorshift2.default)() * 256.0);
      }
      return ret;
    }());
  };

  var textureRandomStatic = glCat.createTexture();
  glCat.textureWrap(textureRandomStatic, gl.REPEAT);
  textureRandomUpdate(textureRandomStatic);

  var textureRandom = glCat.createTexture();
  glCat.textureWrap(textureRandom, gl.REPEAT);

  // ------

  glCatPath.add({
    piecesComputeReturn: {
      width: particlesSqrt * particlePixels,
      height: particlesSqrt,
      vert: "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}\n",
      frag: "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform sampler2D sampler0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  gl_FragColor = texture2D( sampler0, uv );\n}\n",
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniformTexture('sampler0', glCatPath.fb("piecesCompute").texture, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },

    piecesCompute: {
      width: particlesSqrt * particlePixels,
      height: particlesSqrt,
      vert: "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}\n",
      frag: "#define PARTICLE_LIFE_LENGTH 0.5\n\n#define HUGE 9E16\n#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n#define lofir(i,m) (floor((i)/(m)+.5)*(m))\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float particlesSqrt;\nuniform float particlePixels;\nuniform float totalFrame;\nuniform float charShuffle;\nuniform bool init;\nuniform float deltaTime;\nuniform vec2 resolution;\nuniform vec3 cameraPos;\n\nuniform sampler2D samplerPcompute;\nuniform sampler2D samplerRandom;\n\n// ------\n\nvec2 vInvert( vec2 _uv ) {\n  return vec2( 0.0, 1.0 ) + vec2( 1.0, -1.0 ) * _uv;\n}\n\n// ------\n\nmat2 rotate2D( float _t ) {\n  return mat2( cos( _t ), sin( _t ), -sin( _t ), cos( _t ) );\n}\n\nvec4 random( vec2 _uv ) {\n  return texture2D( samplerRandom, _uv );\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\nfloat GPURnd(inout vec4 n)\n{\n\t// Based on the post http://gpgpu.org/forums/viewtopic.php?t=2591&sid=17051481b9f78fb49fba5b98a5e0f1f3\n\t// (The page no longer exists as of March 17th, 2015. Please let me know if you see why this code works.)\n\tconst vec4 q = vec4(   1225.0,    1585.0,    2457.0,    2098.0);\n\tconst vec4 r = vec4(   1112.0,     367.0,      92.0,     265.0);\n\tconst vec4 a = vec4(   3423.0,    2646.0,    1707.0,    1999.0);\n\tconst vec4 m = vec4(4194287.0, 4194277.0, 4194191.0, 4194167.0);\n\n\tvec4 beta = floor(n / q);\n\tvec4 p = a * (n - beta * q) - beta * r;\n\tbeta = (sign(-p) + vec4(1.0)) * vec4(0.5) * m;\n\tn = (p + beta);\n\n\treturn fract(dot(n / m, vec4(1.0, -1.0, 1.0, -1.0)));\n}\n\nvec3 randomSphere( inout vec4 seed ) {\n  vec3 v;\n  for ( int i = 0; i < 10; i ++ ) {\n    v = vec3(\n      GPURnd( seed ),\n      GPURnd( seed ),\n      GPURnd( seed )\n    ) * 2.0 - 1.0;\n    if ( length( v ) < 1.0 ) { break; }\n  }\n  return v;\n}\n\nvec2 randomCircle( inout vec4 seed ) {\n  vec2 v;\n  for ( int i = 0; i < 10; i ++ ) {\n    v = vec2(\n      GPURnd( seed ),\n      GPURnd( seed )\n    ) * 2.0 - 1.0;\n    if ( length( v ) < 1.0 ) { break; }\n  }\n  return v;\n}\n\nvec3 randomBox( inout vec4 seed ) {\n  vec3 v;\n  v = vec3(\n    GPURnd( seed ),\n    GPURnd( seed ),\n    GPURnd( seed )\n  ) * 2.0 - 1.0;\n  return v;\n}\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 puv = vec2( ( floor( gl_FragCoord.x / particlePixels ) * particlePixels + 0.5 ) / resolution.x, uv.y );\n  float number = ( ( gl_FragCoord.x - 0.5 ) / particlePixels ) + ( ( gl_FragCoord.y - 0.5 ) * particlesSqrt );\n  float mode = mod( gl_FragCoord.x, particlePixels );\n  vec2 dpix = vec2( 1.0 ) / resolution;\n\n  vec4 seed = texture2D( samplerRandom, puv );\n  GPURnd( seed );\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n  vec4 vel = texture2D( samplerPcompute, puv + dpix * vec2( 1.0, 0.0 ) );\n\n  float dt = deltaTime;\n\n  float timing = mix( 0.0, PARTICLE_LIFE_LENGTH, number / particlesSqrt / particlesSqrt );\n  timing += lofi( time, PARTICLE_LIFE_LENGTH );\n\n  if ( time - deltaTime < timing && timing < time ) {\n    pos.xyz = 20.0 * randomSphere( seed );\n    pos.xyz = lofir( pos.xyz, 1.0 );\n    pos.w = 1.0; // life\n\n    vel.xyz = vec3( 0.0 );\n    vel.w = GPURnd( seed ); // size\n\n    dt = time - timing;\n  }\n\n  // vel.xyz += 10.0 * dt * vec3(\n  //   noise( vec4( pos.xyz * 0.37 + 61.51 + 0.1 * sin( 2.0 * PI * time ), 20.04 ) ),\n  //   noise( vec4( pos.xyz * 0.37 + 15.31 + 0.1 * sin( 2.0 * PI * time ), 41.21 ) ),\n  //   noise( vec4( pos.xyz * 0.37 + 28.79 + 0.1 * sin( 2.0 * PI * time ), 32.95 ) )\n  // );\n\n  pos.xyz += vel.xyz * dt;\n  pos.w -= dt / PARTICLE_LIFE_LENGTH;\n\n  gl_FragColor = (\n    mode < 1.0 ? pos :\n    vel\n  );\n}",
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        if (automaton.frame === 1) {
          (0, _xorshift2.default)(487723);
        }
        textureRandomUpdate(textureRandom);

        glCat.attribute('p', vboQuad, 2);

        glCat.uniform1f('particlesSqrt', particlesSqrt);
        glCat.uniform1f('particlePixels', particlePixels);

        glCat.uniformTexture('samplerPcompute', glCatPath.fb("piecesComputeReturn").texture, 0);
        glCat.uniformTexture('samplerRandom', textureRandom, 1);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },

    piecesRender: {
      vert: "#define GLSLIFY 1\n#define HUGE 9E16\n#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n\n// ------\n\nattribute vec2 computeUV;\nattribute vec2 rect;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSize;\n\nuniform vec2 resolutionPcompute;\nuniform mat4 matP;\nuniform mat4 matV;\n\nuniform sampler2D samplerPcompute;\n\n// ------\n\nmat2 rotate2D( float _t ) {\n  return mat2( cos( _t ), sin( _t ), -sin( _t ), cos( _t ) );\n}\n\nvoid main() {\n  vec2 puv = ( computeUV.xy + 0.5 ) / resolutionPcompute;\n  vec2 dppix = vec2( 1.0 ) / resolutionPcompute;\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n  vec4 vel = texture2D( samplerPcompute, puv + dppix * vec2( 1.0, 0.0 ) );\n\n  pos.xy += vel.w * rect;\n\n  vLife = pos.w;\n  vSize = vel.w;\n\n  vUv = 0.5 + 0.5 * rect;\n\n  vec4 outPos = matP * matV * vec4( pos.xyz, 1.0 );\n  gl_Position = outPos;\n}",
      frag: "#define HUGE 9E16\n#define PI 3.14159265\n#define TAU 6.28318531\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n#define lofir(i,m) (floor((i)/(m)+.5)*(m))\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSize;\n\nuniform vec3 color;\nuniform vec3 cameraPos;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform vec3 lightPos;\nuniform float totalFrame;\nuniform float time;\n\n// ------\n\nmat2 rotate2D( float _t ) {\n  return mat2( cos( _t ), sin( _t ), -sin( _t ), cos( _t ) );\n}\n\n// ------\n\nvoid main() {\n  if ( vLife <= 0.0 ) { discard; }\n\n  vec2 p = vUv * 2.0 - 1.0;\n\n  float mode = floor( mod( vSize * 8573.51, 4.0 ) );\n  \n  if ( mode == 1.0 ) { // \n    if ( any( lessThan( abs( p ), vec2( 0.2 ) ) ) ) { discard; }\n\n    float ptn = floor( mod( vSize * 6499.85 + totalFrame / 4.0, 4.0 ) );\n    float pos = floor( p.x + 1.0 ) + 2.0 * floor( p.y + 1.0 );\n    if ( ptn != pos ) { discard; }\n\n  } else if ( mode == 2.0 ) { // c\n    if ( 0.2 < abs( length( p ) - 0.8 ) ) { discard; }\n\n    float ptn = floor( mod( vSize * 6499.85 - totalFrame / 4.0, 12.0 ) );\n    vec2 pp = rotate2D(ptn * TAU / 12.0 ) * p;\n    float th = atan( pp.y, pp.x );\n    if ( th < 0.0 ) { discard; }\n\n  } else if ( mode == 3.0 ) { // |\n    float ptn = floor( mod( vSize * 6499.85 + totalFrame / 3.0, 4.0 ) );\n    vec2 pp = rotate2D( ptn * TAU / 8.0 ) * p;\n    \n    if ( 0.2 < abs( pp.x ) || 0.9 < abs( pp.y ) ) { discard; }\n  } else { // \n    vec2 pp = p;\n    float ptn = floor( mod( vSize * 6499.85 + totalFrame / 3.0, 3.0 ) );\n    pp = rotate2D( -PI / 2.0 + ptn * TAU / 3.0 ) * pp;\n\n    float d = lofir( atan( pp.y, pp.x ), TAU / 3.0 );\n    pp = rotate2D( -d ) * pp;\n    pp -= vec2( 0.5, 0.0 );\n\n    if ( 0.5 < length( pp ) ) { discard; }\n    if ( d != 0.0 && length( pp ) < 0.3 ) { discard; }\n\n  }\n\n  gl_FragColor = vec4( vec3( 1.0 ), 0.3 );\n}",
      blend: [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA],
      func: function func(path, params) {
        glCat.attribute('computeUV', vboParticleUV, 2, 1);
        glCat.attribute('rect', vboQuad, 2);

        glCat.uniform1f('particlesSqrt', particlesSqrt);
        glCat.uniform1f('particlePixels', particlePixels);

        glCat.uniform2fv('resolutionPcompute', [particlesSqrt * particlePixels, particlesSqrt]);
        glCat.uniformTexture('samplerPcompute', glCatPath.fb("piecesCompute").texture, 1);

        var ext = glCat.getExtension("ANGLE_instanced_arrays");
        ext.drawArraysInstancedANGLE(gl.TRIANGLE_STRIP, 0, 4, particles);
      }
    }
  });
};

exports.default = pathPieces;

},{"./libs/mathcat":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\mathcat.js","./libs/xorshift":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\xorshift.js"}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\path-postfx.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mathcat = require('./libs/mathcat');

var _mathcat2 = _interopRequireDefault(_mathcat);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }



// ------

var pathPostfx = function pathPostfx(glCatPath, width, height) {
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;

  // ------

  var vboQuad = glCat.createVertexbuffer([-1, -1, 1, -1, -1, 1, 1, 1]);

  // ------

  glCatPath.add({
    fxaa: {
      width: width,
      height: height,
      vert: "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}\n",
      frag: "#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n\n#define FXAA_REDUCE_MIN (1.0 / 128.0)\n#define FXAA_REDUCE_MUL (1.0 / 8.0)\n#define FXAA_SPAN_MAX 16.0\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\n\nuniform sampler2D texture;\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n\n  #define T(v) texture2D( texture, (v) / resolution ).xyz\n  vec3 rgb11 = T( gl_FragCoord.xy );\n  vec3 rgb00 = T( gl_FragCoord.xy + V.zz );\n  vec3 rgb02 = T( gl_FragCoord.xy + V.zy );\n  vec3 rgb20 = T( gl_FragCoord.xy + V.yz );\n  vec3 rgb22 = T( gl_FragCoord.xy + V.yy );\n  #undef T\n\n  vec3 luma = vec3( 0.299, 0.587, 0.114 );\n  #define L(c) dot( c, luma )\n  float luma11 = L( rgb11 );\n  float luma00 = L( rgb00 );\n  float luma02 = L( rgb02 );\n  float luma20 = L( rgb20 );\n  float luma22 = L( rgb22 );\n  #undef L\n\n  float lumaMin = min( luma00, min( min( luma00, luma02 ), min( luma20, luma22 ) ) );\n  float lumaMax = max( luma00, max( max( luma00, luma02 ), max( luma20, luma22 ) ) );\n\n  vec2 dir = vec2(\n    -( ( luma00 + luma20 ) - ( luma02 + luma22 ) ),\n    ( ( luma00 + luma02 ) - ( luma20 + luma22 ) )\n  );\n\n  float dirReduce = max(\n    ( luma00 + luma02 + luma20 + luma22 ) * 0.25 * FXAA_REDUCE_MUL,\n    FXAA_REDUCE_MIN\n  );\n  float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );\n  dir = min(\n    vec2( FXAA_SPAN_MAX ),\n    max(\n      vec2( -FXAA_SPAN_MAX ),\n      dir * rcpDirMin\n    )\n  ) / resolution;\n\n  vec3 rgbA = 0.5 * (\n    texture2D( texture, uv + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz +\n    texture2D( texture, uv + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz\n  );\n  vec3 rgbB = rgbA * 0.5 + 0.25 * (\n    texture2D( texture, uv - dir * 0.5 ).xyz +\n    texture2D( texture, uv + dir * 0.5 ).xyz\n  );\n\n  float lumaB = dot( rgbB, luma );\n  gl_FragColor = (\n    ( ( lumaB < lumaMin ) || ( lumaMax < lumaB ) ) ?\n    vec4( rgbA, 1.0 ) :\n    vec4( rgbB, 1.0 )\n  );\n}",
      clear: [0.0, 0.0, 0.0, 1.0],
      framebuffer: true,
      float: true,
      blend: [gl.ONE, gl.ZERO],
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniformTexture('sampler0', params.input, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },

    post: {
      width: width,
      height: height,
      vert: "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}\n",
      frag: "#define BARREL_ITER 20\n#define BARREL_AMP 0.07\n#define BARREL_OFFSET 0.05\n\n#define HUGE 9E16\n#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec2 resolution;\n\nuniform sampler2D sampler0;\n\n// ------\n\nvec3 barrel( float amp, vec2 uv ) {\n\tfloat corn = length( vec2( 0.5 ) );\n\tfloat a = min( 3.0 * sqrt( amp ), corn * PI );\n\tfloat zoom = corn / ( tan( corn * a ) + corn );\n\tvec2 p = saturate(\n    ( uv + normalize( uv - 0.5 ) * tan( length( uv - 0.5 ) * a ) ) * zoom +\n    0.5 * ( 1.0 - zoom )\n  );\n\treturn texture2D( sampler0, vec2( p.x, p.y ) ).xyz;\n}\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 p = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution.y;\n  float vig = 1.14 - length( p ) * 0.6;\n\n  vec3 tex = vec3( 0.0 );\n\n  for ( int i = 0; i < BARREL_ITER; i ++ ) {\n    float fi = ( float( i ) + 0.5 ) / float( BARREL_ITER );\n    vec3 a = saturate( vec3(\n      1.0 - 3.0 * abs( 1.0 / 6.0 - fi ),\n      1.0 - 3.0 * abs( 1.0 / 2.0 - fi ),\n      1.0 - 3.0 * abs( 5.0 / 6.0 - fi )\n    ) ) / float( BARREL_ITER ) * 4.0;\n    tex += a * barrel( BARREL_OFFSET + BARREL_AMP * fi, uv );\n  }\n\n  tex = mix(\n    vec3( 0.0 ),\n    tex,\n    vig\n  );\n\n  vec3 col = pow( saturate( tex.xyz ), vec3( 1.0 / 2.2 ) );\n  col = vec3(\n    smoothstep( -0.1, 1.1, col.x ),\n    smoothstep( 0.0, 1.0, col.y ),\n    smoothstep( -0.3, 1.3, col.z )\n  );\n\n  gl_FragColor = vec4( col, 1.0 );\n}",
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniformTexture('sampler0', params.input, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },

    glitch: {
      width: width,
      height: height,
      vert: "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}\n",
      frag: "#define BARREL_ITER 20\n#define BARREL_AMP 0.1\n#define BARREL_OFFSET 0.05\n\n#define HUGE 9E16\n#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float totalFrame;\nuniform vec2 resolution;\nuniform vec2 mouse;\n\nuniform float amp;\nuniform float seed;\nuniform sampler2D sampler0;\n\n// ------\n\nfloat seg( vec2 uv, vec2 s ) {\n  return floor( s.x * uv.x ) + s.x * floor( s.y * uv.y );\n}\n\nfloat random( float v ) {\n  return fract( sin( 691.43 * v + seed ) * 571.54 );\n}\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n\n  vec2 displace = vec2( 0.0 );\n  for ( int i = 0; i < 4; i ++ ) {\n    float m = pow( 2.0, float( i ) );\n    bool b = random( 0.2 + seg( uv + 0.7 * float( i ), vec2( 3.0, 8.0 ) * m ) ) < amp;\n    displace += b ? vec2(\n      random( 0.5 + seg( uv + 0.7 * float( i ), vec2( 3.0, 8.0 ) * m ) ) * 2.0 - 1.0,\n      random( 0.8 + seg( uv + 0.7 * float( i ), vec2( 3.0, 8.0 ) * m ) ) * 2.0 - 1.0\n    ) / 2.0 / m : vec2( 0.0 );\n  }\n  displace = 0.4 * displace;\n\n  vec3 col = vec3(\n    texture2D( sampler0, uv + 1.00 * displace ).x,\n    texture2D( sampler0, uv + 1.05 * displace ).y,\n    texture2D( sampler0, uv + 1.10 * displace ).z\n  );\n  gl_FragColor = vec4( col, 1.0 );\n}",
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform1f('amp', params.amp);
        glCat.uniform1f('seed', params.seed);
        glCat.uniformTexture('sampler0', params.input, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    }
  });
};

exports.default = pathPostfx;

},{"./libs/mathcat":"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\libs\\mathcat.js"}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\svg-path.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var reMode = /([MmLlHhVvZzCcSsQqTtAa])/;
var reCommand = /([MmLlHhVvZzCcSsQqTtAa]|-?[\d]+(\.\d+)?)/g;

var svgPath = function svgPath(_str, _params) {
  var str = _str;
  var params = {
    curveSegs: 4
  };
  for (var key in _params) {
    params[key] = _params[key];
  }

  var arr = str.match(reCommand);

  var paths = [];

  var head = 0;
  var x = 0;
  var y = 0;
  var curPath = null;

  var refx = 0;
  var refy = 0;
  var prevMode = '';
  var prevModeU = '';

  while (head < arr.length) {
    var mode = arr[head];
    if (mode.match(reMode)) {
      head++;
    } else {
      // streak!
      mode = prevMode;
    }
    var modeU = mode.toUpperCase();
    var abs = mode === modeU;

    var ax = abs ? 0 : x;
    var ay = abs ? 0 : y;

    if (modeU === 'M') {
      // move
      x = parseFloat(arr[head + 0]) + ax;
      y = parseFloat(arr[head + 1]) + ay;

      curPath = [x, y];
      paths.push(curPath);

      head += 2;
    } else if (modeU === 'L') {
      // line
      x = parseFloat(arr[head + 0]) + ax;
      y = parseFloat(arr[head + 1]) + ay;

      curPath.push(x, y);

      head += 2;
    } else if (modeU === 'H') {
      // horizontal
      x = parseFloat(arr[head + 0]) + ax;

      curPath.push(x, y);

      head += 1;
    } else if (modeU === 'V') {
      // vertical
      y = parseFloat(arr[head + 0]) + ay;

      curPath.push(x, y);

      head += 1;
    } else if (modeU === 'Z') {
      // close path
      curPath.push(curPath[0], curPath[1]);
    } else if (modeU === 'C') {
      // cubic bezier
      var x0 = x;
      var y0 = y;
      var x1 = parseFloat(arr[head + 0]) + ax;
      var y1 = parseFloat(arr[head + 1]) + ay;
      var x2 = parseFloat(arr[head + 2]) + ax;
      var y2 = parseFloat(arr[head + 3]) + ay;
      x = parseFloat(arr[head + 4]) + ax;
      y = parseFloat(arr[head + 5]) + ay;

      for (var i = 0; i < params.curveSegs; i++) {
        var t = (i + 1) / params.curveSegs;
        var u = 1.0 - t;
        curPath.push(u * u * u * x0 + 3 * t * u * u * x1 + 3 * t * t * u * x2 + t * t * t * x, u * u * u * y0 + 3 * t * u * u * y1 + 3 * t * t * u * y2 + t * t * t * y);
      }

      refx = 2 * x - x2;
      refy = 2 * y - y2;

      head += 6;
    } else if (modeU === 'S') {
      // cubic bezier, with reflection
      var prevValid = prevModeU === 'C' || prevModeU === 'S';
      if (!prevValid) {
        console.warn('svgPath: Invalid S/s command use detected');
      }

      var _x = x;
      var _y = y;
      var _x2 = prevValid ? refx : x;
      var _y2 = prevValid ? refy : y;
      var _x3 = parseFloat(arr[head + 0]) + ax;
      var _y3 = parseFloat(arr[head + 1]) + ay;
      x = parseFloat(arr[head + 2]) + ax;
      y = parseFloat(arr[head + 3]) + ay;

      for (var _i = 0; _i < params.curveSegs; _i++) {
        var _t = (_i + 1) / params.curveSegs;
        var _u = 1.0 - _t;
        curPath.push(_u * _u * _u * _x + 3 * _t * _u * _u * _x2 + 3 * _t * _t * _u * _x3 + _t * _t * _t * x, _u * _u * _u * _y + 3 * _t * _u * _u * _y2 + 3 * _t * _t * _u * _y3 + _t * _t * _t * y);
      }

      refx = 2 * x - _x3;
      refy = 2 * y - _y3;

      head += 4;
    } else if (modeU === 'Q') {
      // quad bezier
      var _x4 = x;
      var _y4 = y;
      var _x5 = parseFloat(arr[head + 0]) + ax;
      var _y5 = parseFloat(arr[head + 1]) + ay;
      x = parseFloat(arr[head + 2]) + ax;
      y = parseFloat(arr[head + 3]) + ay;

      for (var _i2 = 0; _i2 < params.curveSegs; _i2++) {
        var _t2 = (_i2 + 1) / params.curveSegs;
        var _u2 = 1.0 - _t2;
        curPath.push(_u2 * _u2 * _x4 + 2 * _t2 * _u2 * _x5 + _t2 * _t2 * x, _u2 * _u2 * _y4 + 2 * _t2 * _u2 * _y5 + _t2 * _t2 * y);
      }

      refx = 2 * x - _x5;
      refy = 2 * y - _y5;

      head += 4;
    } else if (modeU === 'T') {
      // quad bezier, with reflection
      var _prevValid = prevModeU === 'Q' || prevModeU === 'T';
      if (!_prevValid) {
        console.warn('svgPath: Invalid T/t command use detected');
      }

      var _x6 = x;
      var _y6 = y;
      var _x7 = _prevValid ? refx : x;
      var _y7 = _prevValid ? refy : y;
      x = parseFloat(arr[head + 0]) + ax;
      y = parseFloat(arr[head + 1]) + ay;

      for (var _i3 = 0; _i3 < params.curveSegs; _i3++) {
        var _t3 = (_i3 + 1) / params.curveSegs;
        var _u3 = 1.0 - _t3;
        curPath.push(_u3 * _u3 * _x6 + 2 * _t3 * _u3 * _x7 + _t3 * _t3 * x, _u3 * _u3 * _y6 + 2 * _t3 * _u3 * _y7 + _t3 * _t3 * y);
      }

      refx = 2 * x - _x7;
      refy = 2 * y - _y7;

      head += 2;
    } else if (modeU === 'A') {
      // arc
      // THIS. IS. HELL.
      // ref: https://triple-underscore.github.io/SVG11/implnote.html#PathElementImplementationNotes

      var _x8 = x;
      var _y8 = y;
      var rx = Math.abs(parseFloat(arr[head + 0]));
      var ry = Math.abs(parseFloat(arr[head + 1]));
      var rot = parseFloat(arr[head + 2]);
      var large = arr[head + 3] !== "0";
      var sweep = arr[head + 4] !== "0";
      x = parseFloat(arr[head + 5]) + ax;
      y = parseFloat(arr[head + 6]) + ay;

      if (_x8 === x && _y8 === y) {// endpoints are same, will be omitted
        // do nothing
      } else if (rx === 0 || ry === 0) {
        // radius is 0, will be line
        curPath.push(x, y);
      } else {
        // hell
        var cosr = Math.cos(rot / 180 * Math.PI);
        var sinr = Math.sin(rot / 180 * Math.PI);

        var x0p = cosr * (_x8 - x) / 2 + sinr * (_y8 - y) / 2;
        var y0p = -sinr * (_x8 - x) / 2 + cosr * (_y8 - y) / 2;
        console.log(x0p, y0p);

        var lambda = x0p * x0p / (rx * rx) + y0p * y0p / (ry * ry);
        if (1.0 < lambda) {
          var k = Math.sqrt(lambda);
          rx *= rx;
          ry *= ry;
        }

        var t1 = rx * rx * y0p * y0p;
        var t2 = ry * ry * x0p * x0p;
        var ctp = Math.sqrt((rx * rx * ry * ry - t1 - t2) / (t1 + t2)) * (large === sweep ? -1 : 1);
        var cxp = ctp * rx * y0p / ry;
        var cyp = -ctp * ry * x0p / rx;
        console.log(cxp, cyp);

        var cx = cosr * cxp - sinr * cyp + (_x8 + x) / 2;
        var cy = sinr * cxp + cosr * cyp + (_y8 + y) / 2;
        console.log(cx, cy);

        var theta0 = Math.atan2((y0p - cyp) / ry, (x0p - cxp) / rx);
        var theta1 = Math.atan2((-y0p - cyp) / ry, (-x0p - cxp) / rx);
        if (theta1 < theta0 && sweep) {
          theta1 += Math.PI * 2.0;
        } else if (theta0 < theta1 && !sweep) {
          theta1 -= Math.PI * 2.0;
        }
        var dtheta = theta1 - theta0;
        console.log(theta0, theta1);

        for (var _i4 = 0; _i4 < params.curveSegs; _i4++) {
          var _t4 = (_i4 + 1) / params.curveSegs;
          var theta = theta0 + dtheta * _t4;

          var xf = rx * Math.cos(theta);
          var yf = ry * Math.sin(theta);

          curPath.push(cx + cosr * xf - sinr * yf, cy + sinr * xf + cosr * yf);
        }
      }

      head += 7;
    } else {
      // invalid
      console.warn('svgPath: Invalid command: ' + mode);
    }

    prevMode = mode;
    prevModeU = modeU;
  }

  return paths;
};

exports.default = svgPath;

},{}],"D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\vertphaser.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var lerp = function lerp(a, b, x) {
  return a + (b - a) * x;
};
var dist = function dist(ax, ay, bx, by) {
  return Math.sqrt((bx - ax) * (bx - ax) + (by - ay) * (by - ay));
};

var VertPhaser = function () {
  function VertPhaser(_vert) {
    _classCallCheck(this, VertPhaser);

    var it = this;

    it.vert = _vert.concat();
    it.totalLength = 0.0;
    it.lengthMap = [];

    it.calcLength();
  }

  _createClass(VertPhaser, [{
    key: 'calcLength',
    value: function calcLength() {
      var it = this;

      it.totalLength = 0.0;
      it.lengthMap = [];

      for (var i = 0; i < it.vert.length / 2 - 1; i++) {
        var _l = dist(it.vert[i * 2 + 0], it.vert[i * 2 + 1], it.vert[i * 2 + 2], it.vert[i * 2 + 3]);
        it.totalLength += _l;
        it.lengthMap.push(_l);
      }

      var l = dist(it.vert[it.vert.length - 2], it.vert[it.vert.length - 1], it.vert[0], it.vert[1]);
      it.totalLength += l;
      it.lengthMap.push(l);
    }
  }, {
    key: 'getPhaseInfo',
    value: function getPhaseInfo(_phase) {
      var it = this;

      var phase = _phase % 1.0;
      var len = phase * it.totalLength;

      var i = 0;
      var psum = 0.0;
      var sum = 0.0;
      while (sum <= len) {
        psum = sum;
        sum += it.lengthMap[i];
        i++;
      }

      var p = (len - psum) / (sum - psum);
      var x = lerp(it.vert[i * 2 - 2], it.vert[(i * 2 + 0) % it.vert.length], p);
      var y = lerp(it.vert[i * 2 - 1], it.vert[(i * 2 + 1) % it.vert.length], p);

      return {
        phase: phase,
        length: len,
        i: i,
        x: x,
        y: y,
        p: p
      };
    }
  }, {
    key: 'do',
    value: function _do(_begin, _phase) {
      var it = this;

      var begin = it.getPhaseInfo(_begin);
      var end = it.getPhaseInfo(_begin + _phase);

      var ret = [begin.x, begin.y];
      if (begin.phase <= end.phase) {
        ret = ret.concat(it.vert.slice(begin.i * 2, end.i * 2));
      } else {
        ret = ret.concat(it.vert.slice(begin.i * 2));
        ret = ret.concat(it.vert.slice(0, end.i * 2));
      }
      ret.push(end.x, end.y);

      return ret;
    }
  }, {
    key: 'lofi',
    value: function lofi(_begin, _segs) {
      var it = this;

      var segs = _segs;
      if (segs < 1) {
        throw 'VertPhaser.lofi: segs < 1, it\'s invalid';
      }

      var begin = it.getPhaseInfo(_begin);

      var ret = [begin.x, begin.y];
      for (var i = 1; i < Math.floor(segs + 1); i++) {
        var p = _begin + i / segs;
        var seg = it.getPhaseInfo(p);
        ret.push(seg.x, seg.y);
      }
      ret.push(begin.x, begin.y);

      return ret;
    }
  }]);

  return VertPhaser;
}();

exports.default = VertPhaser;

},{}]},{},["D:\\Dropbox\\pro\\_Projects\\_eom\\20180316\\src\\script\\main.js"])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvZGlzdC9vcGVudHlwZS5qcyIsInNyYy9zY3JpcHQvbGlicy9nbGNhdC1wYXRoLWd1aS5qcyIsInNyYy9zY3JpcHQvbGlicy9nbGNhdC1wYXRoLmpzIiwic3JjL3NjcmlwdC9saWJzL2dsY2F0LmpzIiwic3JjL3NjcmlwdC9saWJzL21hdGhjYXQuanMiLCJzcmMvc2NyaXB0L2xpYnMvc3RlcC5qcyIsInNyYy9zY3JpcHQvbGlicy90d2Vhay5qcyIsInNyYy9zY3JpcHQvbGlicy94b3JzaGlmdC5qcyIsInNyYy9zY3JpcHQvbWFpbi5qcyIsInNyYy9zY3JpcHQvcGF0aC1jb25zb2xlLmpzIiwic3JjL3NjcmlwdC9wYXRoLWdyaWQuanMiLCJzcmMvc2NyaXB0L3BhdGgtbG9maXBhdGguanMiLCJzcmMvc2NyaXB0L3BhdGgtcGllY2VzLmpzIiwic3JjL3NjcmlwdC9wYXRoLXBvc3RmeC5qcyIsInNyYy9zY3JpcHQvc3ZnLXBhdGguanMiLCJzcmMvc2NyaXB0L3ZlcnRwaGFzZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3dkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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OztBQUFBO0FBQUEsR0FBSjs7a0JBaUhlLFUiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gKGI2NC5sZW5ndGggKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIoKGxlbiAqIDMgLyA0KSAtIHBsYWNlSG9sZGVycylcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gIHZhciBMID0gMFxuXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDQpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9PSdcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz0nXG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dClcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIvKipcbiAqIGh0dHBzOi8vb3BlbnR5cGUuanMub3JnIHYwLjguMCB8IChjKSBGcmVkZXJpayBEZSBCbGVzZXIgYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyB8IE1JVCBMaWNlbnNlIHwgVXNlcyB0aW55LWluZmxhdGUgYnkgRGV2b24gR292ZXR0XG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG5cdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsLm9wZW50eXBlID0gZ2xvYmFsLm9wZW50eXBlIHx8IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG52YXIgVElORl9PSyA9IDA7XG52YXIgVElORl9EQVRBX0VSUk9SID0gLTM7XG5cbmZ1bmN0aW9uIFRyZWUoKSB7XG4gIHRoaXMudGFibGUgPSBuZXcgVWludDE2QXJyYXkoMTYpOyAgIC8qIHRhYmxlIG9mIGNvZGUgbGVuZ3RoIGNvdW50cyAqL1xuICB0aGlzLnRyYW5zID0gbmV3IFVpbnQxNkFycmF5KDI4OCk7ICAvKiBjb2RlIC0+IHN5bWJvbCB0cmFuc2xhdGlvbiB0YWJsZSAqL1xufVxuXG5mdW5jdGlvbiBEYXRhKHNvdXJjZSwgZGVzdCkge1xuICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgdGhpcy5zb3VyY2VJbmRleCA9IDA7XG4gIHRoaXMudGFnID0gMDtcbiAgdGhpcy5iaXRjb3VudCA9IDA7XG4gIFxuICB0aGlzLmRlc3QgPSBkZXN0O1xuICB0aGlzLmRlc3RMZW4gPSAwO1xuICBcbiAgdGhpcy5sdHJlZSA9IG5ldyBUcmVlKCk7ICAvKiBkeW5hbWljIGxlbmd0aC9zeW1ib2wgdHJlZSAqL1xuICB0aGlzLmR0cmVlID0gbmV3IFRyZWUoKTsgIC8qIGR5bmFtaWMgZGlzdGFuY2UgdHJlZSAqL1xufVxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuICogLS0gdW5pbml0aWFsaXplZCBnbG9iYWwgZGF0YSAoc3RhdGljIHN0cnVjdHVyZXMpIC0tICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG52YXIgc2x0cmVlID0gbmV3IFRyZWUoKTtcbnZhciBzZHRyZWUgPSBuZXcgVHJlZSgpO1xuXG4vKiBleHRyYSBiaXRzIGFuZCBiYXNlIHRhYmxlcyBmb3IgbGVuZ3RoIGNvZGVzICovXG52YXIgbGVuZ3RoX2JpdHMgPSBuZXcgVWludDhBcnJheSgzMCk7XG52YXIgbGVuZ3RoX2Jhc2UgPSBuZXcgVWludDE2QXJyYXkoMzApO1xuXG4vKiBleHRyYSBiaXRzIGFuZCBiYXNlIHRhYmxlcyBmb3IgZGlzdGFuY2UgY29kZXMgKi9cbnZhciBkaXN0X2JpdHMgPSBuZXcgVWludDhBcnJheSgzMCk7XG52YXIgZGlzdF9iYXNlID0gbmV3IFVpbnQxNkFycmF5KDMwKTtcblxuLyogc3BlY2lhbCBvcmRlcmluZyBvZiBjb2RlIGxlbmd0aCBjb2RlcyAqL1xudmFyIGNsY2lkeCA9IG5ldyBVaW50OEFycmF5KFtcbiAgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNixcbiAgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsXG4gIDE0LCAxLCAxNVxuXSk7XG5cbi8qIHVzZWQgYnkgdGluZl9kZWNvZGVfdHJlZXMsIGF2b2lkcyBhbGxvY2F0aW9ucyBldmVyeSBjYWxsICovXG52YXIgY29kZV90cmVlID0gbmV3IFRyZWUoKTtcbnZhciBsZW5ndGhzID0gbmV3IFVpbnQ4QXJyYXkoMjg4ICsgMzIpO1xuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG4gKiAtLSB1dGlsaXR5IGZ1bmN0aW9ucyAtLSAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKiBidWlsZCBleHRyYSBiaXRzIGFuZCBiYXNlIHRhYmxlcyAqL1xuZnVuY3Rpb24gdGluZl9idWlsZF9iaXRzX2Jhc2UoYml0cywgYmFzZSwgZGVsdGEsIGZpcnN0KSB7XG4gIHZhciBpLCBzdW07XG5cbiAgLyogYnVpbGQgYml0cyB0YWJsZSAqL1xuICBmb3IgKGkgPSAwOyBpIDwgZGVsdGE7ICsraSkgeyBiaXRzW2ldID0gMDsgfVxuICBmb3IgKGkgPSAwOyBpIDwgMzAgLSBkZWx0YTsgKytpKSB7IGJpdHNbaSArIGRlbHRhXSA9IGkgLyBkZWx0YSB8IDA7IH1cblxuICAvKiBidWlsZCBiYXNlIHRhYmxlICovXG4gIGZvciAoc3VtID0gZmlyc3QsIGkgPSAwOyBpIDwgMzA7ICsraSkge1xuICAgIGJhc2VbaV0gPSBzdW07XG4gICAgc3VtICs9IDEgPDwgYml0c1tpXTtcbiAgfVxufVxuXG4vKiBidWlsZCB0aGUgZml4ZWQgaHVmZm1hbiB0cmVlcyAqL1xuZnVuY3Rpb24gdGluZl9idWlsZF9maXhlZF90cmVlcyhsdCwgZHQpIHtcbiAgdmFyIGk7XG5cbiAgLyogYnVpbGQgZml4ZWQgbGVuZ3RoIHRyZWUgKi9cbiAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkgeyBsdC50YWJsZVtpXSA9IDA7IH1cblxuICBsdC50YWJsZVs3XSA9IDI0O1xuICBsdC50YWJsZVs4XSA9IDE1MjtcbiAgbHQudGFibGVbOV0gPSAxMTI7XG5cbiAgZm9yIChpID0gMDsgaSA8IDI0OyArK2kpIHsgbHQudHJhbnNbaV0gPSAyNTYgKyBpOyB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNDQ7ICsraSkgeyBsdC50cmFuc1syNCArIGldID0gaTsgfVxuICBmb3IgKGkgPSAwOyBpIDwgODsgKytpKSB7IGx0LnRyYW5zWzI0ICsgMTQ0ICsgaV0gPSAyODAgKyBpOyB9XG4gIGZvciAoaSA9IDA7IGkgPCAxMTI7ICsraSkgeyBsdC50cmFuc1syNCArIDE0NCArIDggKyBpXSA9IDE0NCArIGk7IH1cblxuICAvKiBidWlsZCBmaXhlZCBkaXN0YW5jZSB0cmVlICovXG4gIGZvciAoaSA9IDA7IGkgPCA1OyArK2kpIHsgZHQudGFibGVbaV0gPSAwOyB9XG5cbiAgZHQudGFibGVbNV0gPSAzMjtcblxuICBmb3IgKGkgPSAwOyBpIDwgMzI7ICsraSkgeyBkdC50cmFuc1tpXSA9IGk7IH1cbn1cblxuLyogZ2l2ZW4gYW4gYXJyYXkgb2YgY29kZSBsZW5ndGhzLCBidWlsZCBhIHRyZWUgKi9cbnZhciBvZmZzID0gbmV3IFVpbnQxNkFycmF5KDE2KTtcblxuZnVuY3Rpb24gdGluZl9idWlsZF90cmVlKHQsIGxlbmd0aHMsIG9mZiwgbnVtKSB7XG4gIHZhciBpLCBzdW07XG5cbiAgLyogY2xlYXIgY29kZSBsZW5ndGggY291bnQgdGFibGUgKi9cbiAgZm9yIChpID0gMDsgaSA8IDE2OyArK2kpIHsgdC50YWJsZVtpXSA9IDA7IH1cblxuICAvKiBzY2FuIHN5bWJvbCBsZW5ndGhzLCBhbmQgc3VtIGNvZGUgbGVuZ3RoIGNvdW50cyAqL1xuICBmb3IgKGkgPSAwOyBpIDwgbnVtOyArK2kpIHsgdC50YWJsZVtsZW5ndGhzW29mZiArIGldXSsrOyB9XG5cbiAgdC50YWJsZVswXSA9IDA7XG5cbiAgLyogY29tcHV0ZSBvZmZzZXQgdGFibGUgZm9yIGRpc3RyaWJ1dGlvbiBzb3J0ICovXG4gIGZvciAoc3VtID0gMCwgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgb2Zmc1tpXSA9IHN1bTtcbiAgICBzdW0gKz0gdC50YWJsZVtpXTtcbiAgfVxuXG4gIC8qIGNyZWF0ZSBjb2RlLT5zeW1ib2wgdHJhbnNsYXRpb24gdGFibGUgKHN5bWJvbHMgc29ydGVkIGJ5IGNvZGUpICovXG4gIGZvciAoaSA9IDA7IGkgPCBudW07ICsraSkge1xuICAgIGlmIChsZW5ndGhzW29mZiArIGldKSB7IHQudHJhbnNbb2Zmc1tsZW5ndGhzW29mZiArIGldXSsrXSA9IGk7IH1cbiAgfVxufVxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcbiAqIC0tIGRlY29kZSBmdW5jdGlvbnMgLS0gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKiBnZXQgb25lIGJpdCBmcm9tIHNvdXJjZSBzdHJlYW0gKi9cbmZ1bmN0aW9uIHRpbmZfZ2V0Yml0KGQpIHtcbiAgLyogY2hlY2sgaWYgdGFnIGlzIGVtcHR5ICovXG4gIGlmICghZC5iaXRjb3VudC0tKSB7XG4gICAgLyogbG9hZCBuZXh0IHRhZyAqL1xuICAgIGQudGFnID0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCsrXTtcbiAgICBkLmJpdGNvdW50ID0gNztcbiAgfVxuXG4gIC8qIHNoaWZ0IGJpdCBvdXQgb2YgdGFnICovXG4gIHZhciBiaXQgPSBkLnRhZyAmIDE7XG4gIGQudGFnID4+Pj0gMTtcblxuICByZXR1cm4gYml0O1xufVxuXG4vKiByZWFkIGEgbnVtIGJpdCB2YWx1ZSBmcm9tIGEgc3RyZWFtIGFuZCBhZGQgYmFzZSAqL1xuZnVuY3Rpb24gdGluZl9yZWFkX2JpdHMoZCwgbnVtLCBiYXNlKSB7XG4gIGlmICghbnVtKVxuICAgIHsgcmV0dXJuIGJhc2U7IH1cblxuICB3aGlsZSAoZC5iaXRjb3VudCA8IDI0KSB7XG4gICAgZC50YWcgfD0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCsrXSA8PCBkLmJpdGNvdW50O1xuICAgIGQuYml0Y291bnQgKz0gODtcbiAgfVxuXG4gIHZhciB2YWwgPSBkLnRhZyAmICgweGZmZmYgPj4+ICgxNiAtIG51bSkpO1xuICBkLnRhZyA+Pj49IG51bTtcbiAgZC5iaXRjb3VudCAtPSBudW07XG4gIHJldHVybiB2YWwgKyBiYXNlO1xufVxuXG4vKiBnaXZlbiBhIGRhdGEgc3RyZWFtIGFuZCBhIHRyZWUsIGRlY29kZSBhIHN5bWJvbCAqL1xuZnVuY3Rpb24gdGluZl9kZWNvZGVfc3ltYm9sKGQsIHQpIHtcbiAgd2hpbGUgKGQuYml0Y291bnQgPCAyNCkge1xuICAgIGQudGFnIHw9IGQuc291cmNlW2Quc291cmNlSW5kZXgrK10gPDwgZC5iaXRjb3VudDtcbiAgICBkLmJpdGNvdW50ICs9IDg7XG4gIH1cbiAgXG4gIHZhciBzdW0gPSAwLCBjdXIgPSAwLCBsZW4gPSAwO1xuICB2YXIgdGFnID0gZC50YWc7XG5cbiAgLyogZ2V0IG1vcmUgYml0cyB3aGlsZSBjb2RlIHZhbHVlIGlzIGFib3ZlIHN1bSAqL1xuICBkbyB7XG4gICAgY3VyID0gMiAqIGN1ciArICh0YWcgJiAxKTtcbiAgICB0YWcgPj4+PSAxO1xuICAgICsrbGVuO1xuXG4gICAgc3VtICs9IHQudGFibGVbbGVuXTtcbiAgICBjdXIgLT0gdC50YWJsZVtsZW5dO1xuICB9IHdoaWxlIChjdXIgPj0gMCk7XG4gIFxuICBkLnRhZyA9IHRhZztcbiAgZC5iaXRjb3VudCAtPSBsZW47XG5cbiAgcmV0dXJuIHQudHJhbnNbc3VtICsgY3VyXTtcbn1cblxuLyogZ2l2ZW4gYSBkYXRhIHN0cmVhbSwgZGVjb2RlIGR5bmFtaWMgdHJlZXMgZnJvbSBpdCAqL1xuZnVuY3Rpb24gdGluZl9kZWNvZGVfdHJlZXMoZCwgbHQsIGR0KSB7XG4gIHZhciBobGl0LCBoZGlzdCwgaGNsZW47XG4gIHZhciBpLCBudW0sIGxlbmd0aDtcblxuICAvKiBnZXQgNSBiaXRzIEhMSVQgKDI1Ny0yODYpICovXG4gIGhsaXQgPSB0aW5mX3JlYWRfYml0cyhkLCA1LCAyNTcpO1xuXG4gIC8qIGdldCA1IGJpdHMgSERJU1QgKDEtMzIpICovXG4gIGhkaXN0ID0gdGluZl9yZWFkX2JpdHMoZCwgNSwgMSk7XG5cbiAgLyogZ2V0IDQgYml0cyBIQ0xFTiAoNC0xOSkgKi9cbiAgaGNsZW4gPSB0aW5mX3JlYWRfYml0cyhkLCA0LCA0KTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMTk7ICsraSkgeyBsZW5ndGhzW2ldID0gMDsgfVxuXG4gIC8qIHJlYWQgY29kZSBsZW5ndGhzIGZvciBjb2RlIGxlbmd0aCBhbHBoYWJldCAqL1xuICBmb3IgKGkgPSAwOyBpIDwgaGNsZW47ICsraSkge1xuICAgIC8qIGdldCAzIGJpdHMgY29kZSBsZW5ndGggKDAtNykgKi9cbiAgICB2YXIgY2xlbiA9IHRpbmZfcmVhZF9iaXRzKGQsIDMsIDApO1xuICAgIGxlbmd0aHNbY2xjaWR4W2ldXSA9IGNsZW47XG4gIH1cblxuICAvKiBidWlsZCBjb2RlIGxlbmd0aCB0cmVlICovXG4gIHRpbmZfYnVpbGRfdHJlZShjb2RlX3RyZWUsIGxlbmd0aHMsIDAsIDE5KTtcblxuICAvKiBkZWNvZGUgY29kZSBsZW5ndGhzIGZvciB0aGUgZHluYW1pYyB0cmVlcyAqL1xuICBmb3IgKG51bSA9IDA7IG51bSA8IGhsaXQgKyBoZGlzdDspIHtcbiAgICB2YXIgc3ltID0gdGluZl9kZWNvZGVfc3ltYm9sKGQsIGNvZGVfdHJlZSk7XG5cbiAgICBzd2l0Y2ggKHN5bSkge1xuICAgICAgY2FzZSAxNjpcbiAgICAgICAgLyogY29weSBwcmV2aW91cyBjb2RlIGxlbmd0aCAzLTYgdGltZXMgKHJlYWQgMiBiaXRzKSAqL1xuICAgICAgICB2YXIgcHJldiA9IGxlbmd0aHNbbnVtIC0gMV07XG4gICAgICAgIGZvciAobGVuZ3RoID0gdGluZl9yZWFkX2JpdHMoZCwgMiwgMyk7IGxlbmd0aDsgLS1sZW5ndGgpIHtcbiAgICAgICAgICBsZW5ndGhzW251bSsrXSA9IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE3OlxuICAgICAgICAvKiByZXBlYXQgY29kZSBsZW5ndGggMCBmb3IgMy0xMCB0aW1lcyAocmVhZCAzIGJpdHMpICovXG4gICAgICAgIGZvciAobGVuZ3RoID0gdGluZl9yZWFkX2JpdHMoZCwgMywgMyk7IGxlbmd0aDsgLS1sZW5ndGgpIHtcbiAgICAgICAgICBsZW5ndGhzW251bSsrXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4OlxuICAgICAgICAvKiByZXBlYXQgY29kZSBsZW5ndGggMCBmb3IgMTEtMTM4IHRpbWVzIChyZWFkIDcgYml0cykgKi9cbiAgICAgICAgZm9yIChsZW5ndGggPSB0aW5mX3JlYWRfYml0cyhkLCA3LCAxMSk7IGxlbmd0aDsgLS1sZW5ndGgpIHtcbiAgICAgICAgICBsZW5ndGhzW251bSsrXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvKiB2YWx1ZXMgMC0xNSByZXByZXNlbnQgdGhlIGFjdHVhbCBjb2RlIGxlbmd0aHMgKi9cbiAgICAgICAgbGVuZ3Roc1tudW0rK10gPSBzeW07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8qIGJ1aWxkIGR5bmFtaWMgdHJlZXMgKi9cbiAgdGluZl9idWlsZF90cmVlKGx0LCBsZW5ndGhzLCAwLCBobGl0KTtcbiAgdGluZl9idWlsZF90cmVlKGR0LCBsZW5ndGhzLCBobGl0LCBoZGlzdCk7XG59XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcbiAqIC0tIGJsb2NrIGluZmxhdGUgZnVuY3Rpb25zIC0tICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qIGdpdmVuIGEgc3RyZWFtIGFuZCB0d28gdHJlZXMsIGluZmxhdGUgYSBibG9jayBvZiBkYXRhICovXG5mdW5jdGlvbiB0aW5mX2luZmxhdGVfYmxvY2tfZGF0YShkLCBsdCwgZHQpIHtcbiAgd2hpbGUgKDEpIHtcbiAgICB2YXIgc3ltID0gdGluZl9kZWNvZGVfc3ltYm9sKGQsIGx0KTtcblxuICAgIC8qIGNoZWNrIGZvciBlbmQgb2YgYmxvY2sgKi9cbiAgICBpZiAoc3ltID09PSAyNTYpIHtcbiAgICAgIHJldHVybiBUSU5GX09LO1xuICAgIH1cblxuICAgIGlmIChzeW0gPCAyNTYpIHtcbiAgICAgIGQuZGVzdFtkLmRlc3RMZW4rK10gPSBzeW07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsZW5ndGgsIGRpc3QsIG9mZnM7XG4gICAgICB2YXIgaTtcblxuICAgICAgc3ltIC09IDI1NztcblxuICAgICAgLyogcG9zc2libHkgZ2V0IG1vcmUgYml0cyBmcm9tIGxlbmd0aCBjb2RlICovXG4gICAgICBsZW5ndGggPSB0aW5mX3JlYWRfYml0cyhkLCBsZW5ndGhfYml0c1tzeW1dLCBsZW5ndGhfYmFzZVtzeW1dKTtcblxuICAgICAgZGlzdCA9IHRpbmZfZGVjb2RlX3N5bWJvbChkLCBkdCk7XG5cbiAgICAgIC8qIHBvc3NpYmx5IGdldCBtb3JlIGJpdHMgZnJvbSBkaXN0YW5jZSBjb2RlICovXG4gICAgICBvZmZzID0gZC5kZXN0TGVuIC0gdGluZl9yZWFkX2JpdHMoZCwgZGlzdF9iaXRzW2Rpc3RdLCBkaXN0X2Jhc2VbZGlzdF0pO1xuXG4gICAgICAvKiBjb3B5IG1hdGNoICovXG4gICAgICBmb3IgKGkgPSBvZmZzOyBpIDwgb2ZmcyArIGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGQuZGVzdFtkLmRlc3RMZW4rK10gPSBkLmRlc3RbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qIGluZmxhdGUgYW4gdW5jb21wcmVzc2VkIGJsb2NrIG9mIGRhdGEgKi9cbmZ1bmN0aW9uIHRpbmZfaW5mbGF0ZV91bmNvbXByZXNzZWRfYmxvY2soZCkge1xuICB2YXIgbGVuZ3RoLCBpbnZsZW5ndGg7XG4gIHZhciBpO1xuICBcbiAgLyogdW5yZWFkIGZyb20gYml0YnVmZmVyICovXG4gIHdoaWxlIChkLmJpdGNvdW50ID4gOCkge1xuICAgIGQuc291cmNlSW5kZXgtLTtcbiAgICBkLmJpdGNvdW50IC09IDg7XG4gIH1cblxuICAvKiBnZXQgbGVuZ3RoICovXG4gIGxlbmd0aCA9IGQuc291cmNlW2Quc291cmNlSW5kZXggKyAxXTtcbiAgbGVuZ3RoID0gMjU2ICogbGVuZ3RoICsgZC5zb3VyY2VbZC5zb3VyY2VJbmRleF07XG5cbiAgLyogZ2V0IG9uZSdzIGNvbXBsZW1lbnQgb2YgbGVuZ3RoICovXG4gIGludmxlbmd0aCA9IGQuc291cmNlW2Quc291cmNlSW5kZXggKyAzXTtcbiAgaW52bGVuZ3RoID0gMjU2ICogaW52bGVuZ3RoICsgZC5zb3VyY2VbZC5zb3VyY2VJbmRleCArIDJdO1xuXG4gIC8qIGNoZWNrIGxlbmd0aCAqL1xuICBpZiAobGVuZ3RoICE9PSAofmludmxlbmd0aCAmIDB4MDAwMGZmZmYpKVxuICAgIHsgcmV0dXJuIFRJTkZfREFUQV9FUlJPUjsgfVxuXG4gIGQuc291cmNlSW5kZXggKz0gNDtcblxuICAvKiBjb3B5IGJsb2NrICovXG4gIGZvciAoaSA9IGxlbmd0aDsgaTsgLS1pKVxuICAgIHsgZC5kZXN0W2QuZGVzdExlbisrXSA9IGQuc291cmNlW2Quc291cmNlSW5kZXgrK107IH1cblxuICAvKiBtYWtlIHN1cmUgd2Ugc3RhcnQgbmV4dCBibG9jayBvbiBhIGJ5dGUgYm91bmRhcnkgKi9cbiAgZC5iaXRjb3VudCA9IDA7XG5cbiAgcmV0dXJuIFRJTkZfT0s7XG59XG5cbi8qIGluZmxhdGUgc3RyZWFtIGZyb20gc291cmNlIHRvIGRlc3QgKi9cbmZ1bmN0aW9uIHRpbmZfdW5jb21wcmVzcyhzb3VyY2UsIGRlc3QpIHtcbiAgdmFyIGQgPSBuZXcgRGF0YShzb3VyY2UsIGRlc3QpO1xuICB2YXIgYmZpbmFsLCBidHlwZSwgcmVzO1xuXG4gIGRvIHtcbiAgICAvKiByZWFkIGZpbmFsIGJsb2NrIGZsYWcgKi9cbiAgICBiZmluYWwgPSB0aW5mX2dldGJpdChkKTtcblxuICAgIC8qIHJlYWQgYmxvY2sgdHlwZSAoMiBiaXRzKSAqL1xuICAgIGJ0eXBlID0gdGluZl9yZWFkX2JpdHMoZCwgMiwgMCk7XG5cbiAgICAvKiBkZWNvbXByZXNzIGJsb2NrICovXG4gICAgc3dpdGNoIChidHlwZSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICAvKiBkZWNvbXByZXNzIHVuY29tcHJlc3NlZCBibG9jayAqL1xuICAgICAgICByZXMgPSB0aW5mX2luZmxhdGVfdW5jb21wcmVzc2VkX2Jsb2NrKGQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgLyogZGVjb21wcmVzcyBibG9jayB3aXRoIGZpeGVkIGh1ZmZtYW4gdHJlZXMgKi9cbiAgICAgICAgcmVzID0gdGluZl9pbmZsYXRlX2Jsb2NrX2RhdGEoZCwgc2x0cmVlLCBzZHRyZWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgLyogZGVjb21wcmVzcyBibG9jayB3aXRoIGR5bmFtaWMgaHVmZm1hbiB0cmVlcyAqL1xuICAgICAgICB0aW5mX2RlY29kZV90cmVlcyhkLCBkLmx0cmVlLCBkLmR0cmVlKTtcbiAgICAgICAgcmVzID0gdGluZl9pbmZsYXRlX2Jsb2NrX2RhdGEoZCwgZC5sdHJlZSwgZC5kdHJlZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVzID0gVElORl9EQVRBX0VSUk9SO1xuICAgIH1cblxuICAgIGlmIChyZXMgIT09IFRJTkZfT0spXG4gICAgICB7IHRocm93IG5ldyBFcnJvcignRGF0YSBlcnJvcicpOyB9XG5cbiAgfSB3aGlsZSAoIWJmaW5hbCk7XG5cbiAgaWYgKGQuZGVzdExlbiA8IGQuZGVzdC5sZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIGQuZGVzdC5zbGljZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHsgcmV0dXJuIGQuZGVzdC5zbGljZSgwLCBkLmRlc3RMZW4pOyB9XG4gICAgZWxzZVxuICAgICAgeyByZXR1cm4gZC5kZXN0LnN1YmFycmF5KDAsIGQuZGVzdExlbik7IH1cbiAgfVxuICBcbiAgcmV0dXJuIGQuZGVzdDtcbn1cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuICogLS0gaW5pdGlhbGl6YXRpb24gLS0gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyogYnVpbGQgZml4ZWQgaHVmZm1hbiB0cmVlcyAqL1xudGluZl9idWlsZF9maXhlZF90cmVlcyhzbHRyZWUsIHNkdHJlZSk7XG5cbi8qIGJ1aWxkIGV4dHJhIGJpdHMgYW5kIGJhc2UgdGFibGVzICovXG50aW5mX2J1aWxkX2JpdHNfYmFzZShsZW5ndGhfYml0cywgbGVuZ3RoX2Jhc2UsIDQsIDMpO1xudGluZl9idWlsZF9iaXRzX2Jhc2UoZGlzdF9iaXRzLCBkaXN0X2Jhc2UsIDIsIDEpO1xuXG4vKiBmaXggYSBzcGVjaWFsIGNhc2UgKi9cbmxlbmd0aF9iaXRzWzI4XSA9IDA7XG5sZW5ndGhfYmFzZVsyOF0gPSAyNTg7XG5cbnZhciB0aW55SW5mbGF0ZSA9IHRpbmZfdW5jb21wcmVzcztcblxuLy8gVGhlIEJvdW5kaW5nIEJveCBvYmplY3RcblxuZnVuY3Rpb24gZGVyaXZlKHYwLCB2MSwgdjIsIHYzLCB0KSB7XG4gICAgcmV0dXJuIE1hdGgucG93KDEgLSB0LCAzKSAqIHYwICtcbiAgICAgICAgMyAqIE1hdGgucG93KDEgLSB0LCAyKSAqIHQgKiB2MSArXG4gICAgICAgIDMgKiAoMSAtIHQpICogTWF0aC5wb3codCwgMikgKiB2MiArXG4gICAgICAgIE1hdGgucG93KHQsIDMpICogdjM7XG59XG4vKipcbiAqIEEgYm91bmRpbmcgYm94IGlzIGFuIGVuY2xvc2luZyBib3ggdGhhdCBkZXNjcmliZXMgdGhlIHNtYWxsZXN0IG1lYXN1cmUgd2l0aGluIHdoaWNoIGFsbCB0aGUgcG9pbnRzIGxpZS5cbiAqIEl0IGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBib3VuZGluZyBib3ggb2YgYSBnbHlwaCBvciB0ZXh0IHBhdGguXG4gKlxuICogT24gaW5pdGlhbGl6YXRpb24sIHgxL3kxL3gyL3kyIHdpbGwgYmUgTmFOLiBDaGVjayBpZiB0aGUgYm91bmRpbmcgYm94IGlzIGVtcHR5IHVzaW5nIGBpc0VtcHR5KClgLlxuICpcbiAqIEBleHBvcnRzIG9wZW50eXBlLkJvdW5kaW5nQm94XG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCb3VuZGluZ0JveCgpIHtcbiAgICB0aGlzLngxID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnkxID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLngyID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnkyID0gTnVtYmVyLk5hTjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGJvdW5kaW5nIGJveCBpcyBlbXB0eSwgdGhhdCBpcywgbm8gcG9pbnRzIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgYm94IHlldC5cbiAqL1xuQm91bmRpbmdCb3gucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaXNOYU4odGhpcy54MSkgfHwgaXNOYU4odGhpcy55MSkgfHwgaXNOYU4odGhpcy54MikgfHwgaXNOYU4odGhpcy55Mik7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgcG9pbnQgdG8gdGhlIGJvdW5kaW5nIGJveC5cbiAqIFRoZSB4MS95MS94Mi95MiBjb29yZGluYXRlcyBvZiB0aGUgYm91bmRpbmcgYm94IHdpbGwgbm93IGVuY29tcGFzcyB0aGUgZ2l2ZW4gcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludC5cbiAqL1xuQm91bmRpbmdCb3gucHJvdG90eXBlLmFkZFBvaW50ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGlzTmFOKHRoaXMueDEpIHx8IGlzTmFOKHRoaXMueDIpKSB7XG4gICAgICAgICAgICB0aGlzLngxID0geDtcbiAgICAgICAgICAgIHRoaXMueDIgPSB4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh4IDwgdGhpcy54MSkge1xuICAgICAgICAgICAgdGhpcy54MSA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPiB0aGlzLngyKSB7XG4gICAgICAgICAgICB0aGlzLngyID0geDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChpc05hTih0aGlzLnkxKSB8fCBpc05hTih0aGlzLnkyKSkge1xuICAgICAgICAgICAgdGhpcy55MSA9IHk7XG4gICAgICAgICAgICB0aGlzLnkyID0geTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA8IHRoaXMueTEpIHtcbiAgICAgICAgICAgIHRoaXMueTEgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ID4gdGhpcy55Mikge1xuICAgICAgICAgICAgdGhpcy55MiA9IHk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBhIFggY29vcmRpbmF0ZSB0byB0aGUgYm91bmRpbmcgYm94LlxuICogVGhpcyBleHRlbmRzIHRoZSBib3VuZGluZyBib3ggdG8gaW5jbHVkZSB0aGUgWCBjb29yZGluYXRlLlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGludGVybmFsbHkgaW5zaWRlIG9mIGFkZEJlemllci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gKi9cbkJvdW5kaW5nQm94LnByb3RvdHlwZS5hZGRYID0gZnVuY3Rpb24oeCkge1xuICAgIHRoaXMuYWRkUG9pbnQoeCwgbnVsbCk7XG59O1xuXG4vKipcbiAqIEFkZCBhIFkgY29vcmRpbmF0ZSB0byB0aGUgYm91bmRpbmcgYm94LlxuICogVGhpcyBleHRlbmRzIHRoZSBib3VuZGluZyBib3ggdG8gaW5jbHVkZSB0aGUgWSBjb29yZGluYXRlLlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGludGVybmFsbHkgaW5zaWRlIG9mIGFkZEJlemllci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gKi9cbkJvdW5kaW5nQm94LnByb3RvdHlwZS5hZGRZID0gZnVuY3Rpb24oeSkge1xuICAgIHRoaXMuYWRkUG9pbnQobnVsbCwgeSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIELDqXppZXIgY3VydmUgdG8gdGhlIGJvdW5kaW5nIGJveC5cbiAqIFRoaXMgZXh0ZW5kcyB0aGUgYm91bmRpbmcgYm94IHRvIGluY2x1ZGUgdGhlIGVudGlyZSBCw6l6aWVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHgwIC0gVGhlIHN0YXJ0aW5nIFggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MCAtIFRoZSBzdGFydGluZyBZIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geDEgLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHkxIC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3QgY29udHJvbCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MiAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHNlY29uZCBjb250cm9sIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHkyIC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBlbmRpbmcgWCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgZW5kaW5nIFkgY29vcmRpbmF0ZS5cbiAqL1xuQm91bmRpbmdCb3gucHJvdG90eXBlLmFkZEJlemllciA9IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHkpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIC8vIFRoaXMgY29kZSBpcyBiYXNlZCBvbiBodHRwOi8vbmlzaGlvaGlyb2thenUuYmxvZ3Nwb3QuY29tLzIwMDkvMDYvaG93LXRvLWNhbGN1bGF0ZS1iZXppZXItY3VydmVzLWJvdW5kaW5nLmh0bWxcbiAgICAvLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL2ljb25zOC9zdmctcGF0aC1ib3VuZGluZy1ib3hcblxuICAgIHZhciBwMCA9IFt4MCwgeTBdO1xuICAgIHZhciBwMSA9IFt4MSwgeTFdO1xuICAgIHZhciBwMiA9IFt4MiwgeTJdO1xuICAgIHZhciBwMyA9IFt4LCB5XTtcblxuICAgIHRoaXMuYWRkUG9pbnQoeDAsIHkwKTtcbiAgICB0aGlzLmFkZFBvaW50KHgsIHkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBiID0gNiAqIHAwW2ldIC0gMTIgKiBwMVtpXSArIDYgKiBwMltpXTtcbiAgICAgICAgdmFyIGEgPSAtMyAqIHAwW2ldICsgOSAqIHAxW2ldIC0gOSAqIHAyW2ldICsgMyAqIHAzW2ldO1xuICAgICAgICB2YXIgYyA9IDMgKiBwMVtpXSAtIDMgKiBwMFtpXTtcblxuICAgICAgICBpZiAoYSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGIgPT09IDApIHsgY29udGludWU7IH1cbiAgICAgICAgICAgIHZhciB0ID0gLWMgLyBiO1xuICAgICAgICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHsgdGhpcyQxLmFkZFgoZGVyaXZlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0KSk7IH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMSkgeyB0aGlzJDEuYWRkWShkZXJpdmUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQpKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYjJhYyA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGMgKiBhO1xuICAgICAgICBpZiAoYjJhYyA8IDApIHsgY29udGludWU7IH1cbiAgICAgICAgdmFyIHQxID0gKC1iICsgTWF0aC5zcXJ0KGIyYWMpKSAvICgyICogYSk7XG4gICAgICAgIGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgeyB0aGlzJDEuYWRkWChkZXJpdmUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQxKSk7IH1cbiAgICAgICAgICAgIGlmIChpID09PSAxKSB7IHRoaXMkMS5hZGRZKGRlcml2ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdDEpKTsgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0MiA9ICgtYiAtIE1hdGguc3FydChiMmFjKSkgLyAoMiAqIGEpO1xuICAgICAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IDApIHsgdGhpcyQxLmFkZFgoZGVyaXZlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0MikpOyB9XG4gICAgICAgICAgICBpZiAoaSA9PT0gMSkgeyB0aGlzJDEuYWRkWShkZXJpdmUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQyKSk7IH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIGEgcXVhZHJhdGljIGN1cnZlIHRvIHRoZSBib3VuZGluZyBib3guXG4gKiBUaGlzIGV4dGVuZHMgdGhlIGJvdW5kaW5nIGJveCB0byBpbmNsdWRlIHRoZSBlbnRpcmUgcXVhZHJhdGljIGN1cnZlLlxuICogQHBhcmFtIHtudW1iZXJ9IHgwIC0gVGhlIHN0YXJ0aW5nIFggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5MCAtIFRoZSBzdGFydGluZyBZIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geDEgLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjb250cm9sIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHkxIC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY29udHJvbCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGVuZGluZyBYIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBlbmRpbmcgWSBjb29yZGluYXRlLlxuICovXG5Cb3VuZGluZ0JveC5wcm90b3R5cGUuYWRkUXVhZCA9IGZ1bmN0aW9uKHgwLCB5MCwgeDEsIHkxLCB4LCB5KSB7XG4gICAgdmFyIGNwMXggPSB4MCArIDIgLyAzICogKHgxIC0geDApO1xuICAgIHZhciBjcDF5ID0geTAgKyAyIC8gMyAqICh5MSAtIHkwKTtcbiAgICB2YXIgY3AyeCA9IGNwMXggKyAxIC8gMyAqICh4IC0geDApO1xuICAgIHZhciBjcDJ5ID0gY3AxeSArIDEgLyAzICogKHkgLSB5MCk7XG4gICAgdGhpcy5hZGRCZXppZXIoeDAsIHkwLCBjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcbn07XG5cbi8vIEdlb21ldHJpYyBvYmplY3RzXG5cbi8qKlxuICogQSBiw6l6aWVyIHBhdGggY29udGFpbmluZyBhIHNldCBvZiBwYXRoIGNvbW1hbmRzIHNpbWlsYXIgdG8gYSBTVkcgcGF0aC5cbiAqIFBhdGhzIGNhbiBiZSBkcmF3biBvbiBhIGNvbnRleHQgdXNpbmcgYGRyYXdgLlxuICogQGV4cG9ydHMgb3BlbnR5cGUuUGF0aFxuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUGF0aCgpIHtcbiAgICB0aGlzLmNvbW1hbmRzID0gW107XG4gICAgdGhpcy5maWxsID0gJ2JsYWNrJztcbiAgICB0aGlzLnN0cm9rZSA9IG51bGw7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDE7XG59XG5cbi8qKlxuICogQHBhcmFtICB7bnVtYmVyfSB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAqL1xuUGF0aC5wcm90b3R5cGUubW92ZVRvID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdNJyxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSAge251bWJlcn0geVxuICovXG5QYXRoLnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ0wnLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIERyYXdzIGN1YmljIGN1cnZlXG4gKiBAZnVuY3Rpb25cbiAqIGN1cnZlVG9cbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbCAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkxIC0geSBvZiBjb250cm9sIDFcbiAqIEBwYXJhbSAge251bWJlcn0geDIgLSB4IG9mIGNvbnRyb2wgMlxuICogQHBhcmFtICB7bnVtYmVyfSB5MiAtIHkgb2YgY29udHJvbCAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHggLSB4IG9mIHBhdGggcG9pbnRcbiAqIEBwYXJhbSAge251bWJlcn0geSAtIHkgb2YgcGF0aCBwb2ludFxuICovXG5cbi8qKlxuICogRHJhd3MgY3ViaWMgY3VydmVcbiAqIEBmdW5jdGlvblxuICogYmV6aWVyQ3VydmVUb1xuICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgxIC0geCBvZiBjb250cm9sIDFcbiAqIEBwYXJhbSAge251bWJlcn0geTEgLSB5IG9mIGNvbnRyb2wgMVxuICogQHBhcmFtICB7bnVtYmVyfSB4MiAtIHggb2YgY29udHJvbCAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkyIC0geSBvZiBjb250cm9sIDJcbiAqIEBwYXJhbSAge251bWJlcn0geCAtIHggb2YgcGF0aCBwb2ludFxuICogQHBhcmFtICB7bnVtYmVyfSB5IC0geSBvZiBwYXRoIHBvaW50XG4gKiBAc2VlIGN1cnZlVG9cbiAqL1xuUGF0aC5wcm90b3R5cGUuY3VydmVUbyA9IFBhdGgucHJvdG90eXBlLmJlemllckN1cnZlVG8gPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdDJyxcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB5MTogeTEsXG4gICAgICAgIHgyOiB4MixcbiAgICAgICAgeTI6IHkyLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIERyYXdzIHF1YWRyYXRpYyBjdXJ2ZVxuICogQGZ1bmN0aW9uXG4gKiBxdWFkcmF0aWNDdXJ2ZVRvXG4gKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcbiAqIEBwYXJhbSAge251bWJlcn0geDEgLSB4IG9mIGNvbnRyb2xcbiAqIEBwYXJhbSAge251bWJlcn0geTEgLSB5IG9mIGNvbnRyb2xcbiAqIEBwYXJhbSAge251bWJlcn0geCAtIHggb2YgcGF0aCBwb2ludFxuICogQHBhcmFtICB7bnVtYmVyfSB5IC0geSBvZiBwYXRoIHBvaW50XG4gKi9cblxuLyoqXG4gKiBEcmF3cyBxdWFkcmF0aWMgY3VydmVcbiAqIEBmdW5jdGlvblxuICogcXVhZFRvXG4gKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcbiAqIEBwYXJhbSAge251bWJlcn0geDEgLSB4IG9mIGNvbnRyb2xcbiAqIEBwYXJhbSAge251bWJlcn0geTEgLSB5IG9mIGNvbnRyb2xcbiAqIEBwYXJhbSAge251bWJlcn0geCAtIHggb2YgcGF0aCBwb2ludFxuICogQHBhcmFtICB7bnVtYmVyfSB5IC0geSBvZiBwYXRoIHBvaW50XG4gKi9cblBhdGgucHJvdG90eXBlLnF1YWRUbyA9IFBhdGgucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbih4MSwgeTEsIHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnUScsXG4gICAgICAgIHgxOiB4MSxcbiAgICAgICAgeTE6IHkxLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgcGF0aFxuICogQGZ1bmN0aW9uIGNsb3NlUGF0aFxuICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gKi9cblxuLyoqXG4gKiBDbG9zZSB0aGUgcGF0aFxuICogQGZ1bmN0aW9uIGNsb3NlXG4gKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcbiAqL1xuUGF0aC5wcm90b3R5cGUuY2xvc2UgPSBQYXRoLnByb3RvdHlwZS5jbG9zZVBhdGggPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnWidcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBnaXZlbiBwYXRoIG9yIGxpc3Qgb2YgY29tbWFuZHMgdG8gdGhlIGNvbW1hbmRzIG9mIHRoaXMgcGF0aC5cbiAqIEBwYXJhbSAge0FycmF5fSBwYXRoT3JDb21tYW5kcyAtIGFub3RoZXIgb3BlbnR5cGUuUGF0aCwgYW4gb3BlbnR5cGUuQm91bmRpbmdCb3gsIG9yIGFuIGFycmF5IG9mIGNvbW1hbmRzLlxuICovXG5QYXRoLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbihwYXRoT3JDb21tYW5kcykge1xuICAgIGlmIChwYXRoT3JDb21tYW5kcy5jb21tYW5kcykge1xuICAgICAgICBwYXRoT3JDb21tYW5kcyA9IHBhdGhPckNvbW1hbmRzLmNvbW1hbmRzO1xuICAgIH0gZWxzZSBpZiAocGF0aE9yQ29tbWFuZHMgaW5zdGFuY2VvZiBCb3VuZGluZ0JveCkge1xuICAgICAgICB2YXIgYm94ID0gcGF0aE9yQ29tbWFuZHM7XG4gICAgICAgIHRoaXMubW92ZVRvKGJveC54MSwgYm94LnkxKTtcbiAgICAgICAgdGhpcy5saW5lVG8oYm94LngyLCBib3gueTEpO1xuICAgICAgICB0aGlzLmxpbmVUbyhib3gueDIsIGJveC55Mik7XG4gICAgICAgIHRoaXMubGluZVRvKGJveC54MSwgYm94LnkyKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcy5jb21tYW5kcywgcGF0aE9yQ29tbWFuZHMpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgcGF0aC5cbiAqIEByZXR1cm5zIHtvcGVudHlwZS5Cb3VuZGluZ0JveH1cbiAqL1xuUGF0aC5wcm90b3R5cGUuZ2V0Qm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBib3ggPSBuZXcgQm91bmRpbmdCb3goKTtcblxuICAgIHZhciBzdGFydFggPSAwO1xuICAgIHZhciBzdGFydFkgPSAwO1xuICAgIHZhciBwcmV2WCA9IDA7XG4gICAgdmFyIHByZXZZID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29tbWFuZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNtZCA9IHRoaXMkMS5jb21tYW5kc1tpXTtcbiAgICAgICAgc3dpdGNoIChjbWQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICAgICAgYm94LmFkZFBvaW50KGNtZC54LCBjbWQueSk7XG4gICAgICAgICAgICAgICAgc3RhcnRYID0gcHJldlggPSBjbWQueDtcbiAgICAgICAgICAgICAgICBzdGFydFkgPSBwcmV2WSA9IGNtZC55O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICAgICAgYm94LmFkZFBvaW50KGNtZC54LCBjbWQueSk7XG4gICAgICAgICAgICAgICAgcHJldlggPSBjbWQueDtcbiAgICAgICAgICAgICAgICBwcmV2WSA9IGNtZC55O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUSc6XG4gICAgICAgICAgICAgICAgYm94LmFkZFF1YWQocHJldlgsIHByZXZZLCBjbWQueDEsIGNtZC55MSwgY21kLngsIGNtZC55KTtcbiAgICAgICAgICAgICAgICBwcmV2WCA9IGNtZC54O1xuICAgICAgICAgICAgICAgIHByZXZZID0gY21kLnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdDJzpcbiAgICAgICAgICAgICAgICBib3guYWRkQmV6aWVyKHByZXZYLCBwcmV2WSwgY21kLngxLCBjbWQueTEsIGNtZC54MiwgY21kLnkyLCBjbWQueCwgY21kLnkpO1xuICAgICAgICAgICAgICAgIHByZXZYID0gY21kLng7XG4gICAgICAgICAgICAgICAgcHJldlkgPSBjbWQueTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1onOlxuICAgICAgICAgICAgICAgIHByZXZYID0gc3RhcnRYO1xuICAgICAgICAgICAgICAgIHByZXZZID0gc3RhcnRZO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcGF0aCBjb21tYW5kICcgKyBjbWQudHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJveC5pc0VtcHR5KCkpIHtcbiAgICAgICAgYm94LmFkZFBvaW50KDAsIDApO1xuICAgIH1cbiAgICByZXR1cm4gYm94O1xufTtcblxuLyoqXG4gKiBEcmF3IHRoZSBwYXRoIHRvIGEgMkQgY29udGV4dC5cbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dC5cbiAqL1xuUGF0aC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY21kID0gdGhpcyQxLmNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdNJykge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnTCcpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhjbWQueDEsIGNtZC55MSwgY21kLngyLCBjbWQueTIsIGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdRJykge1xuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oY21kLngxLCBjbWQueTEsIGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdaJykge1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmlsbCkge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5maWxsO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0cm9rZSkge1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnN0cm9rZTtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMuc3Ryb2tlV2lkdGg7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIFBhdGggdG8gYSBzdHJpbmcgb2YgcGF0aCBkYXRhIGluc3RydWN0aW9uc1xuICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9wYXRocy5odG1sI1BhdGhEYXRhXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtkZWNpbWFsUGxhY2VzPTJdIC0gVGhlIGFtb3VudCBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgZmxvYXRpbmctcG9pbnQgdmFsdWVzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblBhdGgucHJvdG90eXBlLnRvUGF0aERhdGEgPSBmdW5jdGlvbihkZWNpbWFsUGxhY2VzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBkZWNpbWFsUGxhY2VzID0gZGVjaW1hbFBsYWNlcyAhPT0gdW5kZWZpbmVkID8gZGVjaW1hbFBsYWNlcyA6IDI7XG5cbiAgICBmdW5jdGlvbiBmbG9hdFRvU3RyaW5nKHYpIHtcbiAgICAgICAgaWYgKE1hdGgucm91bmQodikgPT09IHYpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIE1hdGgucm91bmQodik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdi50b0ZpeGVkKGRlY2ltYWxQbGFjZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFja1ZhbHVlcygpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgICAgIHZhciBzID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGFyZ3VtZW50cyQxW2ldO1xuICAgICAgICAgICAgaWYgKHYgPj0gMCAmJiBpID4gMCkge1xuICAgICAgICAgICAgICAgIHMgKz0gJyAnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzICs9IGZsb2F0VG9TdHJpbmcodik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICB2YXIgZCA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY21kID0gdGhpcyQxLmNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdNJykge1xuICAgICAgICAgICAgZCArPSAnTScgKyBwYWNrVmFsdWVzKGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgZCArPSAnTCcgKyBwYWNrVmFsdWVzKGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgZCArPSAnQycgKyBwYWNrVmFsdWVzKGNtZC54MSwgY21kLnkxLCBjbWQueDIsIGNtZC55MiwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG4gICAgICAgICAgICBkICs9ICdRJyArIHBhY2tWYWx1ZXMoY21kLngxLCBjbWQueTEsIGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdaJykge1xuICAgICAgICAgICAgZCArPSAnWic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgcGF0aCB0byBhbiBTVkcgPHBhdGg+IGVsZW1lbnQsIGFzIGEgc3RyaW5nLlxuICogQHBhcmFtICB7bnVtYmVyfSBbZGVjaW1hbFBsYWNlcz0yXSAtIFRoZSBhbW91bnQgb2YgZGVjaW1hbCBwbGFjZXMgZm9yIGZsb2F0aW5nLXBvaW50IHZhbHVlc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5QYXRoLnByb3RvdHlwZS50b1NWRyA9IGZ1bmN0aW9uKGRlY2ltYWxQbGFjZXMpIHtcbiAgICB2YXIgc3ZnID0gJzxwYXRoIGQ9XCInO1xuICAgIHN2ZyArPSB0aGlzLnRvUGF0aERhdGEoZGVjaW1hbFBsYWNlcyk7XG4gICAgc3ZnICs9ICdcIic7XG4gICAgaWYgKHRoaXMuZmlsbCAmJiB0aGlzLmZpbGwgIT09ICdibGFjaycpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3ZnICs9ICcgZmlsbD1cIm5vbmVcIic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdmcgKz0gJyBmaWxsPVwiJyArIHRoaXMuZmlsbCArICdcIic7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdHJva2UpIHtcbiAgICAgICAgc3ZnICs9ICcgc3Ryb2tlPVwiJyArIHRoaXMuc3Ryb2tlICsgJ1wiIHN0cm9rZS13aWR0aD1cIicgKyB0aGlzLnN0cm9rZVdpZHRoICsgJ1wiJztcbiAgICB9XG5cbiAgICBzdmcgKz0gJy8+JztcbiAgICByZXR1cm4gc3ZnO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBwYXRoIHRvIGEgRE9NIGVsZW1lbnQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtkZWNpbWFsUGxhY2VzPTJdIC0gVGhlIGFtb3VudCBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgZmxvYXRpbmctcG9pbnQgdmFsdWVzXG4gKiBAcmV0dXJuIHtTVkdQYXRoRWxlbWVudH1cbiAqL1xuUGF0aC5wcm90b3R5cGUudG9ET01FbGVtZW50ID0gZnVuY3Rpb24oZGVjaW1hbFBsYWNlcykge1xuICAgIHZhciB0ZW1wb3JhcnlQYXRoID0gdGhpcy50b1BhdGhEYXRhKGRlY2ltYWxQbGFjZXMpO1xuICAgIHZhciBuZXdQYXRoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdwYXRoJyk7XG5cbiAgICBuZXdQYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHRlbXBvcmFyeVBhdGgpO1xuXG4gICAgcmV0dXJuIG5ld1BhdGg7XG59O1xuXG4vLyBSdW4tdGltZSBjaGVja2luZyBvZiBwcmVjb25kaXRpb25zLlxuXG5mdW5jdGlvbiBmYWlsKG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbi8vIFByZWNvbmRpdGlvbiBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB0aGUgZ2l2ZW4gcHJlZGljYXRlIGlzIHRydWUuXG4vLyBJZiBub3QsIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3IuXG5mdW5jdGlvbiBhcmd1bWVudChwcmVkaWNhdGUsIG1lc3NhZ2UpIHtcbiAgICBpZiAoIXByZWRpY2F0ZSkge1xuICAgICAgICBmYWlsKG1lc3NhZ2UpO1xuICAgIH1cbn1cblxudmFyIGNoZWNrID0geyBmYWlsOiBmYWlsLCBhcmd1bWVudDogYXJndW1lbnQsIGFzc2VydDogYXJndW1lbnQgfTtcblxuLy8gRGF0YSB0eXBlcyB1c2VkIGluIHRoZSBPcGVuVHlwZSBmb250IGZpbGUuXG4vLyBBbGwgT3BlblR5cGUgZm9udHMgdXNlIE1vdG9yb2xhLXN0eWxlIGJ5dGUgb3JkZXJpbmcgKEJpZyBFbmRpYW4pXG5cbnZhciBMSU1JVDE2ID0gMzI3Njg7IC8vIFRoZSBsaW1pdCBhdCB3aGljaCBhIDE2LWJpdCBudW1iZXIgc3dpdGNoZXMgc2lnbnMgPT0gMl4xNVxudmFyIExJTUlUMzIgPSAyMTQ3NDgzNjQ4OyAvLyBUaGUgbGltaXQgYXQgd2hpY2ggYSAzMi1iaXQgbnVtYmVyIHN3aXRjaGVzIHNpZ25zID09IDIgXiAzMVxuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLmRlY29kZVxuICogQGNsYXNzXG4gKi9cbnZhciBkZWNvZGUgPSB7fTtcbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuZW5jb2RlXG4gKiBAY2xhc3NcbiAqL1xudmFyIGVuY29kZSA9IHt9O1xuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5zaXplT2ZcbiAqIEBjbGFzc1xuICovXG52YXIgc2l6ZU9mID0ge307XG5cbi8vIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgdmFsdWUuXG5mdW5jdGlvbiBjb25zdGFudCh2KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9O1xufVxuXG4vLyBPcGVuVHlwZSBkYXRhIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENvbnZlcnQgYW4gOC1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgMSBieXRlLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5CWVRFID0gZnVuY3Rpb24odikge1xuICAgIGNoZWNrLmFyZ3VtZW50KHYgPj0gMCAmJiB2IDw9IDI1NSwgJ0J5dGUgdmFsdWUgc2hvdWxkIGJlIGJldHdlZW4gMCBhbmQgMjU1LicpO1xuICAgIHJldHVybiBbdl07XG59O1xuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5CWVRFID0gY29uc3RhbnQoMSk7XG5cbi8qKlxuICogQ29udmVydCBhIDgtYml0IHNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAxIGJ5dGUuXG4gKiBAcGFyYW0ge3N0cmluZ31cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLkNIQVIgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIFt2LmNoYXJDb2RlQXQoMCldO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5DSEFSID0gY29uc3RhbnQoMSk7XG5cbi8qKlxuICogQ29udmVydCBhbiBBU0NJSSBzdHJpbmcgdG8gYSBsaXN0IG9mIGJ5dGVzLlxuICogQHBhcmFtIHtzdHJpbmd9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5DSEFSQVJSQVkgPSBmdW5jdGlvbih2KSB7XG4gICAgdmFyIGIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYltpXSA9IHYuY2hhckNvZGVBdChpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYjtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5DSEFSQVJSQVkgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHYubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgMTYtYml0IHVuc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDIgYnl0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLlVTSE9SVCA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gWyh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5VU0hPUlQgPSBjb25zdGFudCgyKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgMTYtYml0IHNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAyIGJ5dGVzLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5TSE9SVCA9IGZ1bmN0aW9uKHYpIHtcbiAgICAvLyBUd28ncyBjb21wbGVtZW50XG4gICAgaWYgKHYgPj0gTElNSVQxNikge1xuICAgICAgICB2ID0gLSgyICogTElNSVQxNiAtIHYpO1xuICAgIH1cblxuICAgIHJldHVybiBbKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLlNIT1JUID0gY29uc3RhbnQoMik7XG5cbi8qKlxuICogQ29udmVydCBhIDI0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAzIGJ5dGVzLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5VSU5UMjQgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIFsodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5zaXplT2YuVUlOVDI0ID0gY29uc3RhbnQoMyk7XG5cbi8qKlxuICogQ29udmVydCBhIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiA0IGJ5dGVzLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5VTE9ORyA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gWyh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5VTE9ORyA9IGNvbnN0YW50KDQpO1xuXG4vKipcbiAqIENvbnZlcnQgYSAzMi1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgNCBieXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuTE9ORyA9IGZ1bmN0aW9uKHYpIHtcbiAgICAvLyBUd28ncyBjb21wbGVtZW50XG4gICAgaWYgKHYgPj0gTElNSVQzMikge1xuICAgICAgICB2ID0gLSgyICogTElNSVQzMiAtIHYpO1xuICAgIH1cblxuICAgIHJldHVybiBbKHYgPj4gMjQpICYgMHhGRiwgKHYgPj4gMTYpICYgMHhGRiwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLkxPTkcgPSBjb25zdGFudCg0KTtcblxuZW5jb2RlLkZJWEVEID0gZW5jb2RlLlVMT05HO1xuc2l6ZU9mLkZJWEVEID0gc2l6ZU9mLlVMT05HO1xuXG5lbmNvZGUuRldPUkQgPSBlbmNvZGUuU0hPUlQ7XG5zaXplT2YuRldPUkQgPSBzaXplT2YuU0hPUlQ7XG5cbmVuY29kZS5VRldPUkQgPSBlbmNvZGUuVVNIT1JUO1xuc2l6ZU9mLlVGV09SRCA9IHNpemVPZi5VU0hPUlQ7XG5cbi8qKlxuICogQ29udmVydCBhIDMyLWJpdCBBcHBsZSBNYWMgdGltZXN0YW1wIGludGVnZXIgdG8gYSBsaXN0IG9mIDggYnl0ZXMsIDY0LWJpdCB0aW1lc3RhbXAuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLkxPTkdEQVRFVElNRSA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gWzAsIDAsIDAsIDAsICh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5MT05HREFURVRJTUUgPSBjb25zdGFudCg4KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgNC1jaGFyIHRhZyB0byBhIGxpc3Qgb2YgNCBieXRlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuVEFHID0gZnVuY3Rpb24odikge1xuICAgIGNoZWNrLmFyZ3VtZW50KHYubGVuZ3RoID09PSA0LCAnVGFnIHNob3VsZCBiZSBleGFjdGx5IDQgQVNDSUkgY2hhcmFjdGVycy4nKTtcbiAgICByZXR1cm4gW3YuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgICAgIHYuY2hhckNvZGVBdCgxKSxcbiAgICAgICAgICAgIHYuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgICAgIHYuY2hhckNvZGVBdCgzKV07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLlRBRyA9IGNvbnN0YW50KDQpO1xuXG4vLyBDRkYgZGF0YSB0eXBlcyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5lbmNvZGUuQ2FyZDggPSBlbmNvZGUuQllURTtcbnNpemVPZi5DYXJkOCA9IHNpemVPZi5CWVRFO1xuXG5lbmNvZGUuQ2FyZDE2ID0gZW5jb2RlLlVTSE9SVDtcbnNpemVPZi5DYXJkMTYgPSBzaXplT2YuVVNIT1JUO1xuXG5lbmNvZGUuT2ZmU2l6ZSA9IGVuY29kZS5CWVRFO1xuc2l6ZU9mLk9mZlNpemUgPSBzaXplT2YuQllURTtcblxuZW5jb2RlLlNJRCA9IGVuY29kZS5VU0hPUlQ7XG5zaXplT2YuU0lEID0gc2l6ZU9mLlVTSE9SVDtcblxuLy8gQ29udmVydCBhIG51bWVyaWMgb3BlcmFuZCBvciBjaGFyc3RyaW5nIG51bWJlciB0byBhIHZhcmlhYmxlLXNpemUgbGlzdCBvZiBieXRlcy5cbi8qKlxuICogQ29udmVydCBhIG51bWVyaWMgb3BlcmFuZCBvciBjaGFyc3RyaW5nIG51bWJlciB0byBhIHZhcmlhYmxlLXNpemUgbGlzdCBvZiBieXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuTlVNQkVSID0gZnVuY3Rpb24odikge1xuICAgIGlmICh2ID49IC0xMDcgJiYgdiA8PSAxMDcpIHtcbiAgICAgICAgcmV0dXJuIFt2ICsgMTM5XTtcbiAgICB9IGVsc2UgaWYgKHYgPj0gMTA4ICYmIHYgPD0gMTEzMSkge1xuICAgICAgICB2ID0gdiAtIDEwODtcbiAgICAgICAgcmV0dXJuIFsodiA+PiA4KSArIDI0NywgdiAmIDB4RkZdO1xuICAgIH0gZWxzZSBpZiAodiA+PSAtMTEzMSAmJiB2IDw9IC0xMDgpIHtcbiAgICAgICAgdiA9IC12IC0gMTA4O1xuICAgICAgICByZXR1cm4gWyh2ID4+IDgpICsgMjUxLCB2ICYgMHhGRl07XG4gICAgfSBlbHNlIGlmICh2ID49IC0zMjc2OCAmJiB2IDw9IDMyNzY3KSB7XG4gICAgICAgIHJldHVybiBlbmNvZGUuTlVNQkVSMTYodik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZS5OVU1CRVIzMih2KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLk5VTUJFUiA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gZW5jb2RlLk5VTUJFUih2KS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBzaWduZWQgbnVtYmVyIGJldHdlZW4gLTMyNzY4IGFuZCArMzI3NjcgdG8gYSB0aHJlZS1ieXRlIHZhbHVlLlxuICogVGhpcyBlbnN1cmVzIHdlIGFsd2F5cyB1c2UgdGhyZWUgYnl0ZXMsIGJ1dCBpcyBub3QgdGhlIG1vc3QgY29tcGFjdCBmb3JtYXQuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLk5VTUJFUjE2ID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBbMjgsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5OVU1CRVIxNiA9IGNvbnN0YW50KDMpO1xuXG4vKipcbiAqIENvbnZlcnQgYSBzaWduZWQgbnVtYmVyIGJldHdlZW4gLSgyXjMxKSBhbmQgKygyXjMxLTEpIHRvIGEgZml2ZS1ieXRlIHZhbHVlLlxuICogVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gYmUgc3VyZSB5b3UgYWx3YXlzIHVzZSBmb3VyIGJ5dGVzLFxuICogYXQgdGhlIGV4cGVuc2Ugb2Ygd2FzdGluZyBhIGZldyBieXRlcyBmb3Igc21hbGxlciBudW1iZXJzLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5OVU1CRVIzMiA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gWzI5LCAodiA+PiAyNCkgJiAweEZGLCAodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5zaXplT2YuTlVNQkVSMzIgPSBjb25zdGFudCg1KTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLlJFQUwgPSBmdW5jdGlvbih2KSB7XG4gICAgdmFyIHZhbHVlID0gdi50b1N0cmluZygpO1xuXG4gICAgLy8gU29tZSBudW1iZXJzIHVzZSBhbiBlcHNpbG9uIHRvIGVuY29kZSB0aGUgdmFsdWUuIChlLmcuIEphdmFTY3JpcHQgd2lsbCBzdG9yZSAwLjAwMDAwMDEgYXMgMWUtNylcbiAgICAvLyBUaGlzIGNvZGUgY29udmVydHMgaXQgYmFjayB0byBhIG51bWJlciB3aXRob3V0IHRoZSBlcHNpbG9uLlxuICAgIHZhciBtID0gL1xcLihcXGQqPykoPzo5ezUsMjB9fDB7NSwyMH0pXFxkezAsMn0oPzplKC4rKXwkKS8uZXhlYyh2YWx1ZSk7XG4gICAgaWYgKG0pIHtcbiAgICAgICAgdmFyIGVwc2lsb24gPSBwYXJzZUZsb2F0KCcxZScgKyAoKG1bMl0gPyArbVsyXSA6IDApICsgbVsxXS5sZW5ndGgpKTtcbiAgICAgICAgdmFsdWUgPSAoTWF0aC5yb3VuZCh2ICogZXBzaWxvbikgLyBlcHNpbG9uKS50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHZhciBuaWJibGVzID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdmFsdWUubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMSkge1xuICAgICAgICB2YXIgYyA9IHZhbHVlW2ldO1xuICAgICAgICBpZiAoYyA9PT0gJ2UnKSB7XG4gICAgICAgICAgICBuaWJibGVzICs9IHZhbHVlWysraV0gPT09ICctJyA/ICdjJyA6ICdiJztcbiAgICAgICAgfSBlbHNlIGlmIChjID09PSAnLicpIHtcbiAgICAgICAgICAgIG5pYmJsZXMgKz0gJ2EnO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICctJykge1xuICAgICAgICAgICAgbmliYmxlcyArPSAnZSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuaWJibGVzICs9IGM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuaWJibGVzICs9IChuaWJibGVzLmxlbmd0aCAmIDEpID8gJ2YnIDogJ2ZmJztcbiAgICB2YXIgb3V0ID0gWzMwXTtcbiAgICBmb3IgKHZhciBpJDEgPSAwLCBpaSQxID0gbmliYmxlcy5sZW5ndGg7IGkkMSA8IGlpJDE7IGkkMSArPSAyKSB7XG4gICAgICAgIG91dC5wdXNoKHBhcnNlSW50KG5pYmJsZXMuc3Vic3RyKGkkMSwgMiksIDE2KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuUkVBTCA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gZW5jb2RlLlJFQUwodikubGVuZ3RoO1xufTtcblxuZW5jb2RlLk5BTUUgPSBlbmNvZGUuQ0hBUkFSUkFZO1xuc2l6ZU9mLk5BTUUgPSBzaXplT2YuQ0hBUkFSUkFZO1xuXG5lbmNvZGUuU1RSSU5HID0gZW5jb2RlLkNIQVJBUlJBWTtcbnNpemVPZi5TVFJJTkcgPSBzaXplT2YuQ0hBUkFSUkFZO1xuXG4vKipcbiAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1CeXRlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZGVjb2RlLlVURjggPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIG51bUJ5dGVzKSB7XG4gICAgdmFyIGNvZGVQb2ludHMgPSBbXTtcbiAgICB2YXIgbnVtQ2hhcnMgPSBudW1CeXRlcztcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bUNoYXJzOyBqKyssIG9mZnNldCArPSAxKSB7XG4gICAgICAgIGNvZGVQb2ludHNbal0gPSBkYXRhLmdldFVpbnQ4KG9mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY29kZVBvaW50cyk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1CeXRlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZGVjb2RlLlVURjE2ID0gZnVuY3Rpb24oZGF0YSwgb2Zmc2V0LCBudW1CeXRlcykge1xuICAgIHZhciBjb2RlUG9pbnRzID0gW107XG4gICAgdmFyIG51bUNoYXJzID0gbnVtQnl0ZXMgLyAyO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtQ2hhcnM7IGorKywgb2Zmc2V0ICs9IDIpIHtcbiAgICAgICAgY29kZVBvaW50c1tqXSA9IGRhdGEuZ2V0VWludDE2KG9mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY29kZVBvaW50cyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBKYXZhU2NyaXB0IHN0cmluZyB0byBVVEYxNi1CRS5cbiAqIEBwYXJhbSB7c3RyaW5nfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuVVRGMTYgPSBmdW5jdGlvbih2KSB7XG4gICAgdmFyIGIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNvZGVwb2ludCA9IHYuY2hhckNvZGVBdChpKTtcbiAgICAgICAgYltiLmxlbmd0aF0gPSAoY29kZXBvaW50ID4+IDgpICYgMHhGRjtcbiAgICAgICAgYltiLmxlbmd0aF0gPSBjb2RlcG9pbnQgJiAweEZGO1xuICAgIH1cblxuICAgIHJldHVybiBiO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ31cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5VVEYxNiA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdi5sZW5ndGggKiAyO1xufTtcblxuLy8gRGF0YSBmb3IgY29udmVydGluZyBvbGQgZWlnaHQtYml0IE1hY2ludG9zaCBlbmNvZGluZ3MgdG8gVW5pY29kZS5cbi8vIFRoaXMgcmVwcmVzZW50YXRpb24gaXMgb3B0aW1pemVkIGZvciBkZWNvZGluZzsgZW5jb2RpbmcgaXMgc2xvd2VyXG4vLyBhbmQgbmVlZHMgbW9yZSBtZW1vcnkuIFRoZSBhc3N1bXB0aW9uIGlzIHRoYXQgYWxsIG9wZW50eXBlLmpzIHVzZXJzXG4vLyB3YW50IHRvIG9wZW4gZm9udHMsIGJ1dCBzYXZpbmcgYSBmb250IHdpbGwgYmUgY29tcGFyYXRpdmVseSByYXJlXG4vLyBzbyBpdCBjYW4gYmUgbW9yZSBleHBlbnNpdmUuIEtleWVkIGJ5IElBTkEgY2hhcmFjdGVyIHNldCBuYW1lLlxuLy9cbi8vIFB5dGhvbiBzY3JpcHQgZm9yIGdlbmVyYXRpbmcgdGhlc2Ugc3RyaW5nczpcbi8vXG4vLyAgICAgcyA9IHUnJy5qb2luKFtjaHIoYykuZGVjb2RlKCdtYWNfZ3JlZWsnKSBmb3IgYyBpbiByYW5nZSgxMjgsIDI1NildKVxuLy8gICAgIHByaW50KHMuZW5jb2RlKCd1dGYtOCcpKVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZWlnaHRCaXRNYWNFbmNvZGluZ3MgPSB7XG4gICAgJ3gtbWFjLWNyb2F0aWFuJzogIC8vIFB5dGhvbjogJ21hY19jcm9hdGlhbidcbiAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuxaDihKLCtMKo4omgxb3DmOKInsKx4omk4oml4oiGwrXiiILiiJHiiI/FoeKIq8KqwrrOqcW+w7gnICtcbiAgICAnwr/CocKs4oiaxpLiiYjEhsKrxIzigKbCoMOAw4PDlcWSxZPEkOKAlOKAnOKAneKAmOKAmcO34peK76O/wqnigYTigqzigLnigLrDhsK74oCTwrfigJrigJ7igLDDgsSHw4HEjcOIw43DjsOPw4zDk8OUxJHDksOaw5vDmcSxy4bLnMKvz4DDi8uawrjDisOmy4cnLFxuICAgICd4LW1hYy1jeXJpbGxpYyc6ICAvLyBQeXRob246ICdtYWNfY3lyaWxsaWMnXG4gICAgJ9CQ0JHQktCT0JTQldCW0JfQmNCZ0JrQm9Cc0J3QntCf0KDQodCi0KPQpNCl0KbQp9Co0KnQqtCr0KzQrdCu0K/igKDCsNKQwqPCp+KAosK20IbCrsKp4oSi0ILRkuKJoNCD0ZPiiJ7CseKJpOKJpdGWwrXSkdCI0ITRlNCH0ZfQidGZ0IrRmicgK1xuICAgICfRmNCFwqziiJrGkuKJiOKIhsKrwrvigKbCoNCL0ZvQjNGc0ZXigJPigJTigJzigJ3igJjigJnDt+KAntCO0Z7Qj9Gf4oSW0IHRkdGP0LDQsdCy0LPQtNC10LbQt9C40LnQutC70LzQvdC+0L/RgNGB0YLRg9GE0YXRhtGH0YjRidGK0YvRjNGN0Y4nLFxuICAgICd4LW1hYy1nYWVsaWMnOiAvLyBodHRwOi8vdW5pY29kZS5vcmcvUHVibGljL01BUFBJTkdTL1ZFTkRPUlMvQVBQTEUvR0FFTElDLlRYVFxuICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDDhsOY4biCwrHiiaTiiaXhuIPEisSL4biK4biL4bie4bifxKDEoeG5gMOmw7gnICtcbiAgICAn4bmB4bmW4bmXybzGksW/4bmgwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmeG5oeG6m8O/xbjhuarigqzigLnigLrFtsW34bmrwrfhu7Lhu7PigYrDgsOKw4HDi8OIw43DjsOPw4zDk8OU4pmjw5LDmsObw5nEscOdw73FtMW14bqE4bqF4bqA4bqB4bqC4bqDJyxcbiAgICAneC1tYWMtZ3JlZWsnOiAgLy8gUHl0aG9uOiAnbWFjX2dyZWVrJ1xuICAgICfDhMK5wrLDicKzw5bDnM6Fw6DDosOkzoTCqMOnw6nDqMOqw6vCo+KEosOuw6/igKLCveKAsMO0w7bCpuKCrMO5w7vDvOKAoM6TzpTOmM6bzp7OoMOfwq7Cqc6jzqrCp+KJoMKwwrfOkcKx4omk4omlwqXOks6VzpbOl86ZzprOnM6mzqvOqM6pJyArXG4gICAgJ86szp3CrM6fzqHiiYjOpMKrwrvigKbCoM6lzqfOhs6IxZPigJPigJXigJzigJ3igJjigJnDt86JzorOjM6Ozq3Ors6vz4zOj8+NzrHOss+IzrTOtc+GzrPOt865zr7Ous67zrzOvc6/z4DPjs+Bz4PPhM64z4nPgs+Hz4XOts+Kz4vOkM6wXFx1MDBBRCcsXG4gICAgJ3gtbWFjLWljZWxhbmRpYyc6ICAvLyBQeXRob246ICdtYWNfaWNlbGFuZCdcbiAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvMOdwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDDhsOY4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK6zqnDpsO4JyArXG4gICAgJ8K/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhOKCrMOQw7DDnsO+w73Ct+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvo7/DksOaw5vDmcSxy4bLnMKvy5jLmcuawrjLncuby4cnLFxuICAgICd4LW1hYy1pbnVpdCc6IC8vIGh0dHA6Ly91bmljb2RlLm9yZy9QdWJsaWMvTUFQUElOR1MvVkVORE9SUy9BUFBMRS9JTlVJVC5UWFRcbiAgICAn4ZCD4ZCE4ZCF4ZCG4ZCK4ZCL4ZCx4ZCy4ZCz4ZC04ZC44ZC54ZGJ4ZGO4ZGP4ZGQ4ZGR4ZGV4ZGW4ZGm4ZGt4ZGu4ZGv4ZGw4ZGy4ZGz4ZKD4ZKL4ZKM4ZKN4ZKO4ZKQ4ZKRwrDhkqHhkqXhkqbigKLCtuGSp8KuwqnihKLhkqjhkqrhkqvhkrvhk4Lhk4Phk4Thk4Xhk4fhk4jhk5Dhk6/hk7Dhk7Hhk7Lhk7Thk7XhlIXhk5Xhk5bhk5cnICtcbiAgICAn4ZOY4ZOa4ZOb4ZOq4ZSo4ZSp4ZSq4ZSr4ZSt4oCmwqDhlK7hlL7hlZXhlZbhlZfigJPigJTigJzigJ3igJjigJnhlZjhlZnhlZrhlZ3hlYbhlYfhlYjhlYnhlYvhlYzhlZDhlb/hloDhloHhloLhloPhloThloXhlo/hlpDhlpHhlpLhlpPhlpThlpXhmbHhmbLhmbPhmbThmbXhmbbhlpbhlqDhlqHhlqLhlqPhlqThlqXhlqbhlbzFgcWCJyxcbiAgICAneC1tYWMtY2UnOiAgLy8gUHl0aG9uOiAnbWFjX2xhdGluMidcbiAgICAnw4TEgMSBw4nEhMOWw5zDocSFxIzDpMSNxIbEh8OpxbnFusSOw63Ej8SSxJPElsOzxJfDtMO2w7XDusSaxJvDvOKAoMKwxJjCo8Kn4oCiwrbDn8KuwqnihKLEmcKo4omgxKPErsSvxKriiaTiiaXEq8S24oiC4oiRxYLEu8S8xL3EvsS5xLrFhScgK1xuICAgICfFhsWDwqziiJrFhMWH4oiGwqvCu+KApsKgxYjFkMOVxZHFjOKAk+KAlOKAnOKAneKAmOKAmcO34peKxY3FlMWVxZjigLnigLrFmcWWxZfFoOKAmuKAnsWhxZrFm8OBxaTFpcONxb3FvsWqw5PDlMWrxa7DmsWvxbDFscWyxbPDncO9xLfFu8WBxbzEosuHJyxcbiAgICBtYWNpbnRvc2g6ICAvLyBQeXRob246ICdtYWNfcm9tYW4nXG4gICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMOGw5jiiJ7CseKJpOKJpcKlwrXiiILiiJHiiI/PgOKIq8KqwrrOqcOmw7gnICtcbiAgICAnwr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W44oGE4oKs4oC54oC676yB76yC4oChwrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU76O/w5LDmsObw5nEscuGy5zCr8uYy5nLmsK4y53Lm8uHJyxcbiAgICAneC1tYWMtcm9tYW5pYW4nOiAgLy8gUHl0aG9uOiAnbWFjX3JvbWFuaWFuJ1xuICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDEgsiY4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK6zqnEg8iZJyArXG4gICAgJ8K/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuOKBhOKCrOKAueKAusiayJvigKHCt+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvo7/DksOaw5vDmcSxy4bLnMKvy5jLmcuawrjLncuby4cnLFxuICAgICd4LW1hYy10dXJraXNoJzogIC8vIFB5dGhvbjogJ21hY190dXJraXNoJ1xuICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7CqeKEosK0wqjiiaDDhsOY4oiewrHiiaTiiaXCpcK14oiC4oiR4oiPz4DiiKvCqsK6zqnDpsO4JyArXG4gICAgJ8K/wqHCrOKImsaS4omI4oiGwqvCu+KApsKgw4DDg8OVxZLFk+KAk+KAlOKAnOKAneKAmOKAmcO34peKw7/FuMSexJ/EsMSxxZ7Fn+KAocK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+jv8OSw5rDm8OZ76Kgy4bLnMKvy5jLmcuawrjLncuby4cnXG59O1xuXG4vKipcbiAqIERlY29kZXMgYW4gb2xkLXN0eWxlIE1hY2ludG9zaCBzdHJpbmcuIFJldHVybnMgZWl0aGVyIGEgVW5pY29kZSBKYXZhU2NyaXB0XG4gKiBzdHJpbmcsIG9yICd1bmRlZmluZWQnIGlmIHRoZSBlbmNvZGluZyBpcyB1bnN1cHBvcnRlZC4gRm9yIGV4YW1wbGUsIHdlIGRvXG4gKiBub3Qgc3VwcG9ydCBDaGluZXNlLCBKYXBhbmVzZSBvciBLb3JlYW4gYmVjYXVzZSB0aGVzZSB3b3VsZCBuZWVkIGxhcmdlXG4gKiBtYXBwaW5nIHRhYmxlcy5cbiAqIEBwYXJhbSB7RGF0YVZpZXd9IGRhdGFWaWV3XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge251bWJlcn0gZGF0YUxlbmd0aFxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5kZWNvZGUuTUFDU1RSSU5HID0gZnVuY3Rpb24oZGF0YVZpZXcsIG9mZnNldCwgZGF0YUxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgICB2YXIgdGFibGUgPSBlaWdodEJpdE1hY0VuY29kaW5nc1tlbmNvZGluZ107XG4gICAgaWYgKHRhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyBpKTtcbiAgICAgICAgLy8gSW4gYWxsIGVpZ2h0LWJpdCBNYWMgZW5jb2RpbmdzLCB0aGUgY2hhcmFjdGVycyAweDAwLi4weDdGIGFyZVxuICAgICAgICAvLyBtYXBwZWQgdG8gVSswMDAwLi5VKzAwN0Y7IHdlIG9ubHkgbmVlZCB0byBsb29rIHVwIHRoZSBvdGhlcnMuXG4gICAgICAgIGlmIChjIDw9IDB4N0YpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRhYmxlW2MgJiAweDdGXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGVuY29kZS5NQUNTVFJJTkcuIFJldHVybnMgYSBkaWN0aW9uYXJ5IGZvciBtYXBwaW5nXG4vLyBVbmljb2RlIGNoYXJhY3RlciBjb2RlcyB0byB0aGVpciA4LWJpdCBNYWNPUyBlcXVpdmFsZW50LiBUaGlzIHRhYmxlXG4vLyBpcyBub3QgZXhhY3RseSBhIHN1cGVyIGNoZWFwIGRhdGEgc3RydWN0dXJlLCBidXQgd2UgZG8gbm90IGNhcmUgYmVjYXVzZVxuLy8gZW5jb2RpbmcgTWFjaW50b3NoIHN0cmluZ3MgaXMgb25seSByYXJlbHkgbmVlZGVkIGluIHR5cGljYWwgYXBwbGljYXRpb25zLlxudmFyIG1hY0VuY29kaW5nVGFibGVDYWNoZSA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nICYmIG5ldyBXZWFrTWFwKCk7XG52YXIgbWFjRW5jb2RpbmdDYWNoZUtleXM7XG52YXIgZ2V0TWFjRW5jb2RpbmdUYWJsZSA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICAgIC8vIFNpbmNlIHdlIHVzZSBlbmNvZGluZyBhcyBhIGNhY2hlIGtleSBmb3IgV2Vha01hcCwgaXQgaGFzIHRvIGJlXG4gICAgLy8gYSBTdHJpbmcgb2JqZWN0IGFuZCBub3QgYSBsaXRlcmFsLiBBbmQgYXQgbGVhc3Qgb24gTm9kZUpTIDIuMTAuMSxcbiAgICAvLyBXZWFrTWFwIHJlcXVpcmVzIHRoYXQgdGhlIHNhbWUgU3RyaW5nIGluc3RhbmNlIGlzIHBhc3NlZCBmb3IgY2FjaGUgaGl0cy5cbiAgICBpZiAoIW1hY0VuY29kaW5nQ2FjaGVLZXlzKSB7XG4gICAgICAgIG1hY0VuY29kaW5nQ2FjaGVLZXlzID0ge307XG4gICAgICAgIGZvciAodmFyIGUgaW4gZWlnaHRCaXRNYWNFbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIC8qanNoaW50IC1XMDUzICovICAvLyBTdXBwcmVzcyBcIkRvIG5vdCB1c2UgU3RyaW5nIGFzIGEgY29uc3RydWN0b3IuXCJcbiAgICAgICAgICAgIG1hY0VuY29kaW5nQ2FjaGVLZXlzW2VdID0gbmV3IFN0cmluZyhlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjYWNoZUtleSA9IG1hY0VuY29kaW5nQ2FjaGVLZXlzW2VuY29kaW5nXTtcbiAgICBpZiAoY2FjaGVLZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbid0IGRvIFwiaWYgKGNhY2hlLmhhcyhrZXkpKSB7cmV0dXJuIGNhY2hlLmdldChrZXkpfVwiIGhlcmU6XG4gICAgLy8gc2luY2UgZ2FyYmFnZSBjb2xsZWN0aW9uIG1heSBydW4gYXQgYW55IHRpbWUsIGl0IGNvdWxkIGFsc28ga2ljayBpblxuICAgIC8vIGJldHdlZW4gdGhlIGNhbGxzIHRvIGNhY2hlLmhhcygpIGFuZCBjYWNoZS5nZXQoKS4gSW4gdGhhdCBjYXNlLFxuICAgIC8vIHdlIHdvdWxkIHJldHVybiAndW5kZWZpbmVkJyBldmVuIHRob3VnaCB3ZSBkbyBzdXBwb3J0IHRoZSBlbmNvZGluZy5cbiAgICBpZiAobWFjRW5jb2RpbmdUYWJsZUNhY2hlKSB7XG4gICAgICAgIHZhciBjYWNoZWRUYWJsZSA9IG1hY0VuY29kaW5nVGFibGVDYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgICBpZiAoY2FjaGVkVGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFRhYmxlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlY29kaW5nVGFibGUgPSBlaWdodEJpdE1hY0VuY29kaW5nc1tlbmNvZGluZ107XG4gICAgaWYgKGRlY29kaW5nVGFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciBlbmNvZGluZ1RhYmxlID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWNvZGluZ1RhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVuY29kaW5nVGFibGVbZGVjb2RpbmdUYWJsZS5jaGFyQ29kZUF0KGkpXSA9IGkgKyAweDgwO1xuICAgIH1cblxuICAgIGlmIChtYWNFbmNvZGluZ1RhYmxlQ2FjaGUpIHtcbiAgICAgICAgbWFjRW5jb2RpbmdUYWJsZUNhY2hlLnNldChjYWNoZUtleSwgZW5jb2RpbmdUYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY29kaW5nVGFibGU7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYW4gb2xkLXN0eWxlIE1hY2ludG9zaCBzdHJpbmcuIFJldHVybnMgYSBieXRlIGFycmF5IHVwb24gc3VjY2Vzcy5cbiAqIElmIHRoZSByZXF1ZXN0ZWQgZW5jb2RpbmcgaXMgdW5zdXBwb3J0ZWQsIG9yIGlmIHRoZSBpbnB1dCBzdHJpbmcgY29udGFpbnNcbiAqIGEgY2hhcmFjdGVyIHRoYXQgY2Fubm90IGJlIGV4cHJlc3NlZCBpbiB0aGUgZW5jb2RpbmcsIHRoZSBmdW5jdGlvbiByZXR1cm5zXG4gKiAndW5kZWZpbmVkJy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuTUFDU1RSSU5HID0gZnVuY3Rpb24oc3RyLCBlbmNvZGluZykge1xuICAgIHZhciB0YWJsZSA9IGdldE1hY0VuY29kaW5nVGFibGUoZW5jb2RpbmcpO1xuICAgIGlmICh0YWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgLy8gSW4gYWxsIGVpZ2h0LWJpdCBNYWMgZW5jb2RpbmdzLCB0aGUgY2hhcmFjdGVycyAweDAwLi4weDdGIGFyZVxuICAgICAgICAvLyBtYXBwZWQgdG8gVSswMDAwLi5VKzAwN0Y7IHdlIG9ubHkgbmVlZCB0byBsb29rIHVwIHRoZSBvdGhlcnMuXG4gICAgICAgIGlmIChjID49IDB4ODApIHtcbiAgICAgICAgICAgIGMgPSB0YWJsZVtjXTtcbiAgICAgICAgICAgIGlmIChjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdHIgY29udGFpbnMgYSBVbmljb2RlIGNoYXJhY3RlciB0aGF0IGNhbm5vdCBiZSBlbmNvZGVkXG4gICAgICAgICAgICAgICAgLy8gaW4gdGhlIHJlcXVlc3RlZCBlbmNvZGluZy5cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtpXSA9IGM7XG4gICAgICAgIC8vIHJlc3VsdC5wdXNoKGMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZ1xuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLk1BQ1NUUklORyA9IGZ1bmN0aW9uKHN0ciwgZW5jb2RpbmcpIHtcbiAgICB2YXIgYiA9IGVuY29kZS5NQUNTVFJJTkcoc3RyLCBlbmNvZGluZyk7XG4gICAgaWYgKGIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYi5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufTtcblxuLy8gSGVscGVyIGZvciBlbmNvZGUuVkFSREVMVEFTXG5mdW5jdGlvbiBpc0J5dGVFbmNvZGFibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPj0gLTEyOCAmJiB2YWx1ZSA8PSAxMjc7XG59XG5cbi8vIEhlbHBlciBmb3IgZW5jb2RlLlZBUkRFTFRBU1xuZnVuY3Rpb24gZW5jb2RlVmFyRGVsdGFSdW5Bc1plcm9lcyhkZWx0YXMsIHBvcywgcmVzdWx0KSB7XG4gICAgdmFyIHJ1bkxlbmd0aCA9IDA7XG4gICAgdmFyIG51bURlbHRhcyA9IGRlbHRhcy5sZW5ndGg7XG4gICAgd2hpbGUgKHBvcyA8IG51bURlbHRhcyAmJiBydW5MZW5ndGggPCA2NCAmJiBkZWx0YXNbcG9zXSA9PT0gMCkge1xuICAgICAgICArK3BvcztcbiAgICAgICAgKytydW5MZW5ndGg7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKDB4ODAgfCAocnVuTGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBwb3M7XG59XG5cbi8vIEhlbHBlciBmb3IgZW5jb2RlLlZBUkRFTFRBU1xuZnVuY3Rpb24gZW5jb2RlVmFyRGVsdGFSdW5Bc0J5dGVzKGRlbHRhcywgb2Zmc2V0LCByZXN1bHQpIHtcbiAgICB2YXIgcnVuTGVuZ3RoID0gMDtcbiAgICB2YXIgbnVtRGVsdGFzID0gZGVsdGFzLmxlbmd0aDtcbiAgICB2YXIgcG9zID0gb2Zmc2V0O1xuICAgIHdoaWxlIChwb3MgPCBudW1EZWx0YXMgJiYgcnVuTGVuZ3RoIDwgNjQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZGVsdGFzW3Bvc107XG4gICAgICAgIGlmICghaXNCeXRlRW5jb2RhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXaXRoaW4gYSBieXRlLWVuY29kZWQgcnVuIG9mIGRlbHRhcywgYSBzaW5nbGUgemVybyBpcyBiZXN0XG4gICAgICAgIC8vIHN0b3JlZCBsaXRlcmFsbHkgYXMgMHgwMCB2YWx1ZS4gSG93ZXZlciwgaWYgd2UgaGF2ZSB0d28gb3JcbiAgICAgICAgLy8gbW9yZSB6ZXJvZXMgaW4gYSBzZXF1ZW5jZSwgaXQgaXMgYmV0dGVyIHRvIHN0YXJ0IGEgbmV3IHJ1bi5cbiAgICAgICAgLy8gRm9yZSBleGFtcGxlLCB0aGUgc2VxdWVuY2Ugb2YgZGVsdGFzIFsxNSwgMTUsIDAsIDE1LCAxNV1cbiAgICAgICAgLy8gYmVjb21lcyA2IGJ5dGVzICgwNCAwRiAwRiAwMCAwRiAwRikgd2hlbiBzdG9yaW5nIHRoZSB6ZXJvXG4gICAgICAgIC8vIHdpdGhpbiB0aGUgY3VycmVudCBydW4sIGJ1dCA3IGJ5dGVzICgwMSAwRiAwRiA4MCAwMSAwRiAwRilcbiAgICAgICAgLy8gd2hlbiBzdGFydGluZyBhIG5ldyBydW4uXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCAmJiBwb3MgKyAxIDwgbnVtRGVsdGFzICYmIGRlbHRhc1twb3MgKyAxXSA9PT0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK3BvcztcbiAgICAgICAgKytydW5MZW5ndGg7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHJ1bkxlbmd0aCAtIDEpO1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBwb3M7ICsraSkge1xuICAgICAgICByZXN1bHQucHVzaCgoZGVsdGFzW2ldICsgMjU2KSAmIDB4ZmYpO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xufVxuXG4vLyBIZWxwZXIgZm9yIGVuY29kZS5WQVJERUxUQVNcbmZ1bmN0aW9uIGVuY29kZVZhckRlbHRhUnVuQXNXb3JkcyhkZWx0YXMsIG9mZnNldCwgcmVzdWx0KSB7XG4gICAgdmFyIHJ1bkxlbmd0aCA9IDA7XG4gICAgdmFyIG51bURlbHRhcyA9IGRlbHRhcy5sZW5ndGg7XG4gICAgdmFyIHBvcyA9IG9mZnNldDtcbiAgICB3aGlsZSAocG9zIDwgbnVtRGVsdGFzICYmIHJ1bkxlbmd0aCA8IDY0KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRlbHRhc1twb3NdO1xuXG4gICAgICAgIC8vIFdpdGhpbiBhIHdvcmQtZW5jb2RlZCBydW4gb2YgZGVsdGFzLCBpdCBpcyBlYXNpZXN0IHRvIHN0YXJ0XG4gICAgICAgIC8vIGEgbmV3IHJ1biAod2l0aCBhIGRpZmZlcmVudCBlbmNvZGluZykgd2hlbmV2ZXIgd2UgZW5jb3VudGVyXG4gICAgICAgIC8vIGEgemVybyB2YWx1ZS4gRm9yIGV4YW1wbGUsIHRoZSBzZXF1ZW5jZSBbMHg2NjY2LCAwLCAweDc3NzddXG4gICAgICAgIC8vIG5lZWRzIDcgYnl0ZXMgd2hlbiBzdG9yaW5nIHRoZSB6ZXJvIGluc2lkZSB0aGUgY3VycmVudCBydW5cbiAgICAgICAgLy8gKDQyIDY2IDY2IDAwIDAwIDc3IDc3KSwgYW5kIGVxdWFsbHkgNyBieXRlcyB3aGVuIHN0YXJ0aW5nIGFcbiAgICAgICAgLy8gbmV3IHJ1biAoNDAgNjYgNjYgODAgNDAgNzcgNzcpLlxuICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2l0aGluIGEgd29yZC1lbmNvZGVkIHJ1biBvZiBkZWx0YXMsIGEgc2luZ2xlIHZhbHVlIGluIHRoZVxuICAgICAgICAvLyByYW5nZSAoLTEyOC4uMTI3KSBzaG91bGQgYmUgZW5jb2RlZCB3aXRoaW4gdGhlIGN1cnJlbnQgcnVuXG4gICAgICAgIC8vIGJlY2F1c2UgaXQgaXMgbW9yZSBjb21wYWN0LiBGb3IgZXhhbXBsZSwgdGhlIHNlcXVlbmNlXG4gICAgICAgIC8vIFsweDY2NjYsIDIsIDB4Nzc3N10gYmVjb21lcyA3IGJ5dGVzIHdoZW4gc3RvcmluZyB0aGUgdmFsdWVcbiAgICAgICAgLy8gbGl0ZXJhbGx5ICg0MiA2NiA2NiAwMCAwMiA3NyA3NyksIGJ1dCA4IGJ5dGVzIHdoZW4gc3RhcnRpbmdcbiAgICAgICAgLy8gYSBuZXcgcnVuICg0MCA2NiA2NiAwMCAwMiA0MCA3NyA3NykuXG4gICAgICAgIGlmIChpc0J5dGVFbmNvZGFibGUodmFsdWUpICYmIHBvcyArIDEgPCBudW1EZWx0YXMgJiYgaXNCeXRlRW5jb2RhYmxlKGRlbHRhc1twb3MgKyAxXSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgKytwb3M7XG4gICAgICAgICsrcnVuTGVuZ3RoO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCgweDQwIHwgKHJ1bkxlbmd0aCAtIDEpKTtcbiAgICBmb3IgKHZhciBpID0gb2Zmc2V0OyBpIDwgcG9zOyArK2kpIHtcbiAgICAgICAgdmFyIHZhbCA9IGRlbHRhc1tpXTtcbiAgICAgICAgcmVzdWx0LnB1c2goKCh2YWwgKyAweDEwMDAwKSA+PiA4KSAmIDB4ZmYsICh2YWwgKyAweDEwMCkgJiAweGZmKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcztcbn1cblxuLyoqXG4gKiBFbmNvZGUgYSBsaXN0IG9mIHZhcmlhdGlvbiBhZGp1c3RtZW50IGRlbHRhcy5cbiAqXG4gKiBWYXJpYXRpb24gYWRqdXN0bWVudCBkZWx0YXMgYXJlIHVzZWQgaW4g4oCYZ3ZhcuKAmSBhbmQg4oCYY3ZhcuKAmSB0YWJsZXMuXG4gKiBUaGV5IGluZGljYXRlIGhvdyBwb2ludHMgKGluIOKAmGd2YXLigJkpIG9yIHZhbHVlcyAoaW4g4oCYY3ZhcuKAmSkgZ2V0IGFkanVzdGVkXG4gKiB3aGVuIGdlbmVyYXRpbmcgaW5zdGFuY2VzIG9mIHZhcmlhdGlvbiBmb250cy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9vdHNwZWMvZ3Zhci5odG1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2ZvbnRzL1RydWVUeXBlLVJlZmVyZW5jZS1NYW51YWwvUk0wNi9DaGFwNmd2YXIuaHRtbFxuICogQHBhcmFtIHtBcnJheX1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5lbmNvZGUuVkFSREVMVEFTID0gZnVuY3Rpb24oZGVsdGFzKSB7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChwb3MgPCBkZWx0YXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGRlbHRhc1twb3NdO1xuICAgICAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgICAgICAgIHBvcyA9IGVuY29kZVZhckRlbHRhUnVuQXNaZXJvZXMoZGVsdGFzLCBwb3MsIHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPj0gLTEyOCAmJiB2YWx1ZSA8PSAxMjcpIHtcbiAgICAgICAgICAgIHBvcyA9IGVuY29kZVZhckRlbHRhUnVuQXNCeXRlcyhkZWx0YXMsIHBvcywgcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcyA9IGVuY29kZVZhckRlbHRhUnVuQXNXb3JkcyhkZWx0YXMsIHBvcywgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gQ29udmVydCBhIGxpc3Qgb2YgdmFsdWVzIHRvIGEgQ0ZGIElOREVYIHN0cnVjdHVyZS5cbi8vIFRoZSB2YWx1ZXMgc2hvdWxkIGJlIG9iamVjdHMgY29udGFpbmluZyBuYW1lIC8gdHlwZSAvIHZhbHVlLlxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBsXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5JTkRFWCA9IGZ1bmN0aW9uKGwpIHtcbiAgICAvL3ZhciBvZmZzZXQsIG9mZnNldHMsIG9mZnNldEVuY29kZXIsIGVuY29kZWRPZmZzZXRzLCBlbmNvZGVkT2Zmc2V0LCBkYXRhLFxuICAgIC8vICAgIGksIHY7XG4gICAgLy8gQmVjYXVzZSB3ZSBoYXZlIHRvIGtub3cgd2hpY2ggZGF0YSB0eXBlIHRvIHVzZSB0byBlbmNvZGUgdGhlIG9mZnNldHMsXG4gICAgLy8gd2UgaGF2ZSB0byBnbyB0aHJvdWdoIHRoZSB2YWx1ZXMgdHdpY2U6IG9uY2UgdG8gZW5jb2RlIHRoZSBkYXRhIGFuZFxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgb2Zmc2V0cywgdGhlbiBhZ2FpbiB0byBlbmNvZGUgdGhlIG9mZnNldHMgdXNpbmcgdGhlIGZpdHRpbmcgZGF0YSB0eXBlLlxuICAgIHZhciBvZmZzZXQgPSAxOyAvLyBGaXJzdCBvZmZzZXQgaXMgYWx3YXlzIDEuXG4gICAgdmFyIG9mZnNldHMgPSBbb2Zmc2V0XTtcbiAgICB2YXIgZGF0YSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdiA9IGVuY29kZS5PQkpFQ1QobFtpXSk7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGRhdGEsIHYpO1xuICAgICAgICBvZmZzZXQgKz0gdi5sZW5ndGg7XG4gICAgICAgIG9mZnNldHMucHVzaChvZmZzZXQpO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH1cblxuICAgIHZhciBlbmNvZGVkT2Zmc2V0cyA9IFtdO1xuICAgIHZhciBvZmZTaXplID0gKDEgKyBNYXRoLmZsb29yKE1hdGgubG9nKG9mZnNldCkgLyBNYXRoLmxvZygyKSkgLyA4KSB8IDA7XG4gICAgdmFyIG9mZnNldEVuY29kZXIgPSBbdW5kZWZpbmVkLCBlbmNvZGUuQllURSwgZW5jb2RlLlVTSE9SVCwgZW5jb2RlLlVJTlQyNCwgZW5jb2RlLlVMT05HXVtvZmZTaXplXTtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBvZmZzZXRzLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgdmFyIGVuY29kZWRPZmZzZXQgPSBvZmZzZXRFbmNvZGVyKG9mZnNldHNbaSQxXSk7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVuY29kZWRPZmZzZXRzLCBlbmNvZGVkT2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdChlbmNvZGUuQ2FyZDE2KGwubGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZS5PZmZTaXplKG9mZlNpemUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlZE9mZnNldHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5JTkRFWCA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gZW5jb2RlLklOREVYKHYpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ29udmVydCBhbiBvYmplY3QgdG8gYSBDRkYgRElDVCBzdHJ1Y3R1cmUuXG4gKiBUaGUga2V5cyBzaG91bGQgYmUgbnVtZXJpYy5cbiAqIFRoZSB2YWx1ZXMgc2hvdWxkIGJlIG9iamVjdHMgY29udGFpbmluZyBuYW1lIC8gdHlwZSAvIHZhbHVlLlxuICogQHBhcmFtIHtPYmplY3R9IG1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLkRJQ1QgPSBmdW5jdGlvbihtKSB7XG4gICAgdmFyIGQgPSBbXTtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG0pO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgLy8gT2JqZWN0LmtleXMoKSByZXR1cm4gc3RyaW5nIGtleXMsIGJ1dCBvdXIga2V5cyBhcmUgYWx3YXlzIG51bWVyaWMuXG4gICAgICAgIHZhciBrID0gcGFyc2VJbnQoa2V5c1tpXSwgMCk7XG4gICAgICAgIHZhciB2ID0gbVtrXTtcbiAgICAgICAgLy8gVmFsdWUgY29tZXMgYmVmb3JlIHRoZSBrZXkuXG4gICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuT1BFUkFORCh2LnZhbHVlLCB2LnR5cGUpKTtcbiAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5PUEVSQVRPUihrKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLkRJQ1QgPSBmdW5jdGlvbihtKSB7XG4gICAgcmV0dXJuIGVuY29kZS5ESUNUKG0pLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5PUEVSQVRPUiA9IGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAodiA8IDEyMDApIHtcbiAgICAgICAgcmV0dXJuIFt2XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gWzEyLCB2IC0gMTIwMF07XG4gICAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSB2XG4gKiBAcGFyYW0ge3N0cmluZ31cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLk9QRVJBTkQgPSBmdW5jdGlvbih2LCB0eXBlKSB7XG4gICAgdmFyIGQgPSBbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNoZWNrLmFyZ3VtZW50KHYubGVuZ3RoID09PSB0eXBlLmxlbmd0aCwgJ05vdCBlbm91Z2ggYXJndW1lbnRzIGdpdmVuIGZvciB0eXBlJyArIHR5cGUpO1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5PUEVSQU5EKHZbaV0sIHR5cGVbaV0pKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnU0lEJykge1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5OVU1CRVIodikpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvZmZzZXQnKSB7XG4gICAgICAgICAgICAvLyBXZSBtYWtlIGl0IGVhc3kgZm9yIG91cnNlbHZlcyBhbmQgYWx3YXlzIGVuY29kZSBvZmZzZXRzIGFzXG4gICAgICAgICAgICAvLyA0IGJ5dGVzLiBUaGlzIG1ha2VzIG9mZnNldCBjYWxjdWxhdGlvbiBmb3IgdGhlIHRvcCBkaWN0IGVhc2llci5cbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuTlVNQkVSMzIodikpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk5VTUJFUih2KSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3JlYWwnKSB7XG4gICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLlJFQUwodikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG9wZXJhbmQgdHlwZSAnICsgdHlwZSk7XG4gICAgICAgICAgICAvLyBGSVhNRSBBZGQgc3VwcG9ydCBmb3IgYm9vbGVhbnNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkO1xufTtcblxuZW5jb2RlLk9QID0gZW5jb2RlLkJZVEU7XG5zaXplT2YuT1AgPSBzaXplT2YuQllURTtcblxuLy8gbWVtb2l6ZSBjaGFyc3RyaW5nIGVuY29kaW5nIHVzaW5nIFdlYWtNYXAgaWYgYXZhaWxhYmxlXG52YXIgd21tID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgJiYgbmV3IFdlYWtNYXAoKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgbGlzdCBvZiBDaGFyU3RyaW5nIG9wZXJhdGlvbnMgdG8gYnl0ZXMuXG4gKiBAcGFyYW0ge0FycmF5fVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuQ0hBUlNUUklORyA9IGZ1bmN0aW9uKG9wcykge1xuICAgIC8vIFNlZSBlbmNvZGUuTUFDU1RSSU5HIGZvciB3aHkgd2UgZG9uJ3QgZG8gXCJpZiAod21tICYmIHdtbS5oYXMob3BzKSlcIi5cbiAgICBpZiAod21tKSB7XG4gICAgICAgIHZhciBjYWNoZWRWYWx1ZSA9IHdtbS5nZXQob3BzKTtcbiAgICAgICAgaWYgKGNhY2hlZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkID0gW107XG4gICAgdmFyIGxlbmd0aCA9IG9wcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBvcCA9IG9wc1tpXTtcbiAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZVtvcC50eXBlXShvcC52YWx1ZSkpO1xuICAgIH1cblxuICAgIGlmICh3bW0pIHtcbiAgICAgICAgd21tLnNldChvcHMsIGQpO1xuICAgIH1cblxuICAgIHJldHVybiBkO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLkNIQVJTVFJJTkcgPSBmdW5jdGlvbihvcHMpIHtcbiAgICByZXR1cm4gZW5jb2RlLkNIQVJTVFJJTkcob3BzKS5sZW5ndGg7XG59O1xuXG4vLyBVdGlsaXR5IGZ1bmN0aW9ucyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIENvbnZlcnQgYW4gb2JqZWN0IGNvbnRhaW5pbmcgbmFtZSAvIHR5cGUgLyB2YWx1ZSB0byBieXRlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuT0JKRUNUID0gZnVuY3Rpb24odikge1xuICAgIHZhciBlbmNvZGluZ0Z1bmN0aW9uID0gZW5jb2RlW3YudHlwZV07XG4gICAgY2hlY2suYXJndW1lbnQoZW5jb2RpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkLCAnTm8gZW5jb2RpbmcgZnVuY3Rpb24gZm9yIHR5cGUgJyArIHYudHlwZSk7XG4gICAgcmV0dXJuIGVuY29kaW5nRnVuY3Rpb24odi52YWx1ZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLk9CSkVDVCA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgc2l6ZU9mRnVuY3Rpb24gPSBzaXplT2Zbdi50eXBlXTtcbiAgICBjaGVjay5hcmd1bWVudChzaXplT2ZGdW5jdGlvbiAhPT0gdW5kZWZpbmVkLCAnTm8gc2l6ZU9mIGZ1bmN0aW9uIGZvciB0eXBlICcgKyB2LnR5cGUpO1xuICAgIHJldHVybiBzaXplT2ZGdW5jdGlvbih2LnZhbHVlKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHRhYmxlIG9iamVjdCB0byBieXRlcy5cbiAqIEEgdGFibGUgY29udGFpbnMgYSBsaXN0IG9mIGZpZWxkcyBjb250YWluaW5nIHRoZSBtZXRhZGF0YSAobmFtZSwgdHlwZSBhbmQgZGVmYXVsdCB2YWx1ZSkuXG4gKiBUaGUgdGFibGUgaXRzZWxmIGhhcyB0aGUgZmllbGQgdmFsdWVzIHNldCBhcyBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtvcGVudHlwZS5UYWJsZX1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLlRBQkxFID0gZnVuY3Rpb24odGFibGUpIHtcbiAgICB2YXIgZCA9IFtdO1xuICAgIHZhciBsZW5ndGggPSB0YWJsZS5maWVsZHMubGVuZ3RoO1xuICAgIHZhciBzdWJ0YWJsZXMgPSBbXTtcbiAgICB2YXIgc3VidGFibGVPZmZzZXRzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IHRhYmxlLmZpZWxkc1tpXTtcbiAgICAgICAgdmFyIGVuY29kaW5nRnVuY3Rpb24gPSBlbmNvZGVbZmllbGQudHlwZV07XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KGVuY29kaW5nRnVuY3Rpb24gIT09IHVuZGVmaW5lZCwgJ05vIGVuY29kaW5nIGZ1bmN0aW9uIGZvciBmaWVsZCB0eXBlICcgKyBmaWVsZC50eXBlICsgJyAoJyArIGZpZWxkLm5hbWUgKyAnKScpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0YWJsZVtmaWVsZC5uYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnl0ZXMgPSBlbmNvZGluZ0Z1bmN0aW9uKHZhbHVlKTtcblxuICAgICAgICBpZiAoZmllbGQudHlwZSA9PT0gJ1RBQkxFJykge1xuICAgICAgICAgICAgc3VidGFibGVPZmZzZXRzLnB1c2goZC5sZW5ndGgpO1xuICAgICAgICAgICAgZCA9IGQuY29uY2F0KFswLCAwXSk7XG4gICAgICAgICAgICBzdWJ0YWJsZXMucHVzaChieXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkID0gZC5jb25jYXQoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgc3VidGFibGVzLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgdmFyIG8gPSBzdWJ0YWJsZU9mZnNldHNbaSQxXTtcbiAgICAgICAgdmFyIG9mZnNldCA9IGQubGVuZ3RoO1xuICAgICAgICBjaGVjay5hcmd1bWVudChvZmZzZXQgPCA2NTUzNiwgJ1RhYmxlICcgKyB0YWJsZS50YWJsZU5hbWUgKyAnIHRvbyBiaWcuJyk7XG4gICAgICAgIGRbb10gPSBvZmZzZXQgPj4gODtcbiAgICAgICAgZFtvICsgMV0gPSBvZmZzZXQgJiAweGZmO1xuICAgICAgICBkID0gZC5jb25jYXQoc3VidGFibGVzW2kkMV0pO1xuICAgIH1cblxuICAgIHJldHVybiBkO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge29wZW50eXBlLlRhYmxlfVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLlRBQkxFID0gZnVuY3Rpb24odGFibGUpIHtcbiAgICB2YXIgbnVtQnl0ZXMgPSAwO1xuICAgIHZhciBsZW5ndGggPSB0YWJsZS5maWVsZHMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZmllbGQgPSB0YWJsZS5maWVsZHNbaV07XG4gICAgICAgIHZhciBzaXplT2ZGdW5jdGlvbiA9IHNpemVPZltmaWVsZC50eXBlXTtcbiAgICAgICAgY2hlY2suYXJndW1lbnQoc2l6ZU9mRnVuY3Rpb24gIT09IHVuZGVmaW5lZCwgJ05vIHNpemVPZiBmdW5jdGlvbiBmb3IgZmllbGQgdHlwZSAnICsgZmllbGQudHlwZSArICcgKCcgKyBmaWVsZC5uYW1lICsgJyknKTtcbiAgICAgICAgdmFyIHZhbHVlID0gdGFibGVbZmllbGQubmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZpZWxkLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbnVtQnl0ZXMgKz0gc2l6ZU9mRnVuY3Rpb24odmFsdWUpO1xuXG4gICAgICAgIC8vIFN1YnRhYmxlcyB0YWtlIDIgbW9yZSBieXRlcyBmb3Igb2Zmc2V0cy5cbiAgICAgICAgaWYgKGZpZWxkLnR5cGUgPT09ICdUQUJMRScpIHtcbiAgICAgICAgICAgIG51bUJ5dGVzICs9IDI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVtQnl0ZXM7XG59O1xuXG5lbmNvZGUuUkVDT1JEID0gZW5jb2RlLlRBQkxFO1xuc2l6ZU9mLlJFQ09SRCA9IHNpemVPZi5UQUJMRTtcblxuLy8gTWVyZ2UgaW4gYSBsaXN0IG9mIGJ5dGVzLlxuZW5jb2RlLkxJVEVSQUwgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5zaXplT2YuTElURVJBTCA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdi5sZW5ndGg7XG59O1xuXG4vLyBUYWJsZSBtZXRhZGF0YVxuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLlRhYmxlXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWJsZU5hbWVcbiAqIEBwYXJhbSB7QXJyYXl9IGZpZWxkc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBUYWJsZSh0YWJsZU5hbWUsIGZpZWxkcywgb3B0aW9ucykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuICAgICAgICB0aGlzJDFbZmllbGQubmFtZV0gPSBmaWVsZC52YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnRhYmxlTmFtZSA9IHRhYmxlTmFtZTtcbiAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICB2YXIgb3B0aW9uS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBvcHRpb25LZXlzLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBrID0gb3B0aW9uS2V5c1tpJDFdO1xuICAgICAgICAgICAgdmFyIHYgPSBvcHRpb25zW2tdO1xuICAgICAgICAgICAgaWYgKHRoaXMkMVtrXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcyQxW2tdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBFbmNvZGVzIHRoZSB0YWJsZSBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBieXRlc1xuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblRhYmxlLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZW5jb2RlLlRBQkxFKHRoaXMpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHNpemUgb2YgdGhlIHRhYmxlLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5UYWJsZS5wcm90b3R5cGUuc2l6ZU9mID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNpemVPZi5UQUJMRSh0aGlzKTtcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXNob3J0TGlzdChpdGVtTmFtZSwgbGlzdCwgY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb3VudCA9IGxpc3QubGVuZ3RoO1xuICAgIH1cbiAgICB2YXIgZmllbGRzID0gbmV3IEFycmF5KGxpc3QubGVuZ3RoICsgMSk7XG4gICAgZmllbGRzWzBdID0ge25hbWU6IGl0ZW1OYW1lICsgJ0NvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBjb3VudH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZpZWxkc1tpICsgMV0gPSB7bmFtZTogaXRlbU5hbWUgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxpc3RbaV19O1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRhYmxlTGlzdChpdGVtTmFtZSwgcmVjb3JkcywgaXRlbUNhbGxiYWNrKSB7XG4gICAgdmFyIGNvdW50ID0gcmVjb3Jkcy5sZW5ndGg7XG4gICAgdmFyIGZpZWxkcyA9IG5ldyBBcnJheShjb3VudCArIDEpO1xuICAgIGZpZWxkc1swXSA9IHtuYW1lOiBpdGVtTmFtZSArICdDb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogY291bnR9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBmaWVsZHNbaSArIDFdID0ge25hbWU6IGl0ZW1OYW1lICsgaSwgdHlwZTogJ1RBQkxFJywgdmFsdWU6IGl0ZW1DYWxsYmFjayhyZWNvcmRzW2ldLCBpKX07XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHM7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb3JkTGlzdChpdGVtTmFtZSwgcmVjb3JkcywgaXRlbUNhbGxiYWNrKSB7XG4gICAgdmFyIGNvdW50ID0gcmVjb3Jkcy5sZW5ndGg7XG4gICAgdmFyIGZpZWxkcyA9IFtdO1xuICAgIGZpZWxkc1swXSA9IHtuYW1lOiBpdGVtTmFtZSArICdDb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogY291bnR9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBmaWVsZHMgPSBmaWVsZHMuY29uY2F0KGl0ZW1DYWxsYmFjayhyZWNvcmRzW2ldLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHM7XG59XG5cbi8vIENvbW1vbiBMYXlvdXQgVGFibGVzXG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuQ292ZXJhZ2VcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtvcGVudHlwZS5UYWJsZX1cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgb3BlbnR5cGUuVGFibGVcbiAqL1xuZnVuY3Rpb24gQ292ZXJhZ2UoY292ZXJhZ2VUYWJsZSkge1xuICAgIGlmIChjb3ZlcmFnZVRhYmxlLmZvcm1hdCA9PT0gMSkge1xuICAgICAgICBUYWJsZS5jYWxsKHRoaXMsICdjb3ZlcmFnZVRhYmxlJyxcbiAgICAgICAgICAgIFt7bmFtZTogJ2NvdmVyYWdlRm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxfV1cbiAgICAgICAgICAgIC5jb25jYXQodXNob3J0TGlzdCgnZ2x5cGgnLCBjb3ZlcmFnZVRhYmxlLmdseXBocykpXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2suYXNzZXJ0KGZhbHNlLCAnQ2FuXFwndCBjcmVhdGUgY292ZXJhZ2UgdGFibGUgZm9ybWF0IDIgeWV0LicpO1xuICAgIH1cbn1cbkNvdmVyYWdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGFibGUucHJvdG90eXBlKTtcbkNvdmVyYWdlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvdmVyYWdlO1xuXG5mdW5jdGlvbiBTY3JpcHRMaXN0KHNjcmlwdExpc3RUYWJsZSkge1xuICAgIFRhYmxlLmNhbGwodGhpcywgJ3NjcmlwdExpc3RUYWJsZScsXG4gICAgICAgIHJlY29yZExpc3QoJ3NjcmlwdFJlY29yZCcsIHNjcmlwdExpc3RUYWJsZSwgZnVuY3Rpb24oc2NyaXB0UmVjb3JkLCBpKSB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gc2NyaXB0UmVjb3JkLnNjcmlwdDtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0TGFuZ1N5cyA9IHNjcmlwdC5kZWZhdWx0TGFuZ1N5cztcbiAgICAgICAgICAgIGNoZWNrLmFzc2VydCghIWRlZmF1bHRMYW5nU3lzLCAnVW5hYmxlIHRvIHdyaXRlIEdTVUI6IHNjcmlwdCAnICsgc2NyaXB0UmVjb3JkLnRhZyArICcgaGFzIG5vIGRlZmF1bHQgbGFuZ3VhZ2Ugc3lzdGVtLicpO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7bmFtZTogJ3NjcmlwdFRhZycgKyBpLCB0eXBlOiAnVEFHJywgdmFsdWU6IHNjcmlwdFJlY29yZC50YWd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnc2NyaXB0JyArIGksIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgVGFibGUoJ3NjcmlwdFRhYmxlJywgW1xuICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2RlZmF1bHRMYW5nU3lzJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyBUYWJsZSgnZGVmYXVsdExhbmdTeXMnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2xvb2t1cE9yZGVyJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAncmVxRmVhdHVyZUluZGV4JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBkZWZhdWx0TGFuZ1N5cy5yZXFGZWF0dXJlSW5kZXh9XVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdCh1c2hvcnRMaXN0KCdmZWF0dXJlSW5kZXgnLCBkZWZhdWx0TGFuZ1N5cy5mZWF0dXJlSW5kZXhlcykpKX1cbiAgICAgICAgICAgICAgICAgICAgXS5jb25jYXQocmVjb3JkTGlzdCgnbGFuZ1N5cycsIHNjcmlwdC5sYW5nU3lzUmVjb3JkcywgZnVuY3Rpb24obGFuZ1N5c1JlY29yZCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmdTeXMgPSBsYW5nU3lzUmVjb3JkLmxhbmdTeXM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnbGFuZ1N5c1RhZycgKyBpLCB0eXBlOiAnVEFHJywgdmFsdWU6IGxhbmdTeXNSZWNvcmQudGFnfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2xhbmdTeXMnICsgaSwgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyBUYWJsZSgnbGFuZ1N5cycsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdsb29rdXBPcmRlcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAncmVxRmVhdHVyZUluZGV4JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsYW5nU3lzLnJlcUZlYXR1cmVJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXS5jb25jYXQodXNob3J0TGlzdCgnZmVhdHVyZUluZGV4JywgbGFuZ1N5cy5mZWF0dXJlSW5kZXhlcykpKX1cbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIH0pKSl9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9KVxuICAgICk7XG59XG5TY3JpcHRMaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVGFibGUucHJvdG90eXBlKTtcblNjcmlwdExpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NyaXB0TGlzdDtcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5GZWF0dXJlTGlzdFxuICogQGNsYXNzXG4gKiBAcGFyYW0ge29wZW50eXBlLlRhYmxlfVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBvcGVudHlwZS5UYWJsZVxuICovXG5mdW5jdGlvbiBGZWF0dXJlTGlzdChmZWF0dXJlTGlzdFRhYmxlKSB7XG4gICAgVGFibGUuY2FsbCh0aGlzLCAnZmVhdHVyZUxpc3RUYWJsZScsXG4gICAgICAgIHJlY29yZExpc3QoJ2ZlYXR1cmVSZWNvcmQnLCBmZWF0dXJlTGlzdFRhYmxlLCBmdW5jdGlvbihmZWF0dXJlUmVjb3JkLCBpKSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVSZWNvcmQuZmVhdHVyZTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge25hbWU6ICdmZWF0dXJlVGFnJyArIGksIHR5cGU6ICdUQUcnLCB2YWx1ZTogZmVhdHVyZVJlY29yZC50YWd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnZmVhdHVyZScgKyBpLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IFRhYmxlKCdmZWF0dXJlVGFibGUnLCBbXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnZmVhdHVyZVBhcmFtcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZmVhdHVyZS5mZWF0dXJlUGFyYW1zfSBdLmNvbmNhdCh1c2hvcnRMaXN0KCdsb29rdXBMaXN0SW5kZXgnLCBmZWF0dXJlLmxvb2t1cExpc3RJbmRleGVzKSkpfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSlcbiAgICApO1xufVxuRmVhdHVyZUxpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUYWJsZS5wcm90b3R5cGUpO1xuRmVhdHVyZUxpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmVhdHVyZUxpc3Q7XG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuTG9va3VwTGlzdFxuICogQGNsYXNzXG4gKiBAcGFyYW0ge29wZW50eXBlLlRhYmxlfVxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG9wZW50eXBlLlRhYmxlXG4gKi9cbmZ1bmN0aW9uIExvb2t1cExpc3QobG9va3VwTGlzdFRhYmxlLCBzdWJ0YWJsZU1ha2Vycykge1xuICAgIFRhYmxlLmNhbGwodGhpcywgJ2xvb2t1cExpc3RUYWJsZScsIHRhYmxlTGlzdCgnbG9va3VwJywgbG9va3VwTGlzdFRhYmxlLCBmdW5jdGlvbihsb29rdXBUYWJsZSkge1xuICAgICAgICB2YXIgc3VidGFibGVDYWxsYmFjayA9IHN1YnRhYmxlTWFrZXJzW2xvb2t1cFRhYmxlLmxvb2t1cFR5cGVdO1xuICAgICAgICBjaGVjay5hc3NlcnQoISFzdWJ0YWJsZUNhbGxiYWNrLCAnVW5hYmxlIHRvIHdyaXRlIEdTVUIgbG9va3VwIHR5cGUgJyArIGxvb2t1cFRhYmxlLmxvb2t1cFR5cGUgKyAnIHRhYmxlcy4nKTtcbiAgICAgICAgcmV0dXJuIG5ldyBUYWJsZSgnbG9va3VwVGFibGUnLCBbXG4gICAgICAgICAgICB7bmFtZTogJ2xvb2t1cFR5cGUnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxvb2t1cFRhYmxlLmxvb2t1cFR5cGV9LFxuICAgICAgICAgICAge25hbWU6ICdsb29rdXBGbGFnJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsb29rdXBUYWJsZS5sb29rdXBGbGFnfVxuICAgICAgICBdLmNvbmNhdCh0YWJsZUxpc3QoJ3N1YnRhYmxlJywgbG9va3VwVGFibGUuc3VidGFibGVzLCBzdWJ0YWJsZUNhbGxiYWNrKSkpO1xuICAgIH0pKTtcbn1cbkxvb2t1cExpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUYWJsZS5wcm90b3R5cGUpO1xuTG9va3VwTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb29rdXBMaXN0O1xuXG4vLyBSZWNvcmQgPSBzYW1lIGFzIFRhYmxlLCBidXQgaW5saW5lZCAoYSBUYWJsZSBoYXMgYW4gb2Zmc2V0IGFuZCBpdHMgZGF0YSBpcyBmdXJ0aGVyIGluIHRoZSBzdHJlYW0pXG4vLyBEb24ndCB1c2Ugb2Zmc2V0cyBpbnNpZGUgUmVjb3JkcyAocHJvYmFibGUgYnVnKSwgb25seSBpbiBUYWJsZXMuXG52YXIgdGFibGUgPSB7XG4gICAgVGFibGU6IFRhYmxlLFxuICAgIFJlY29yZDogVGFibGUsXG4gICAgQ292ZXJhZ2U6IENvdmVyYWdlLFxuICAgIFNjcmlwdExpc3Q6IFNjcmlwdExpc3QsXG4gICAgRmVhdHVyZUxpc3Q6IEZlYXR1cmVMaXN0LFxuICAgIExvb2t1cExpc3Q6IExvb2t1cExpc3QsXG4gICAgdXNob3J0TGlzdDogdXNob3J0TGlzdCxcbiAgICB0YWJsZUxpc3Q6IHRhYmxlTGlzdCxcbiAgICByZWNvcmRMaXN0OiByZWNvcmRMaXN0LFxufTtcblxuLy8gUGFyc2luZyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG4vLyBSZXRyaWV2ZSBhbiB1bnNpZ25lZCBieXRlIGZyb20gdGhlIERhdGFWaWV3LlxuZnVuY3Rpb24gZ2V0Qnl0ZShkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCk7XG59XG5cbi8vIFJldHJpZXZlIGFuIHVuc2lnbmVkIDE2LWJpdCBzaG9ydCBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbmZ1bmN0aW9uIGdldFVTaG9ydChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQsIGZhbHNlKTtcbn1cblxuLy8gUmV0cmlldmUgYSBzaWduZWQgMTYtYml0IHNob3J0IGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZnVuY3Rpb24gZ2V0U2hvcnQoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHJldHVybiBkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQsIGZhbHNlKTtcbn1cblxuLy8gUmV0cmlldmUgYW4gdW5zaWduZWQgMzItYml0IGxvbmcgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5mdW5jdGlvbiBnZXRVTG9uZyhkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbn1cblxuLy8gUmV0cmlldmUgYSAzMi1iaXQgc2lnbmVkIGZpeGVkLXBvaW50IG51bWJlciAoMTYuMTYpIGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZnVuY3Rpb24gZ2V0Rml4ZWQoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHZhciBkZWNpbWFsID0gZGF0YVZpZXcuZ2V0SW50MTYob2Zmc2V0LCBmYWxzZSk7XG4gICAgdmFyIGZyYWN0aW9uID0gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCArIDIsIGZhbHNlKTtcbiAgICByZXR1cm4gZGVjaW1hbCArIGZyYWN0aW9uIC8gNjU1MzU7XG59XG5cbi8vIFJldHJpZXZlIGEgNC1jaGFyYWN0ZXIgdGFnIGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGFncyBhcmUgdXNlZCB0byBpZGVudGlmeSB0YWJsZXMuXG5mdW5jdGlvbiBnZXRUYWcoZGF0YVZpZXcsIG9mZnNldCkge1xuICAgIHZhciB0YWcgPSAnJztcbiAgICBmb3IgKHZhciBpID0gb2Zmc2V0OyBpIDwgb2Zmc2V0ICsgNDsgaSArPSAxKSB7XG4gICAgICAgIHRhZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRhdGFWaWV3LmdldEludDgoaSkpO1xuICAgIH1cblxuICAgIHJldHVybiB0YWc7XG59XG5cbi8vIFJldHJpZXZlIGFuIG9mZnNldCBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIE9mZnNldHMgYXJlIDEgdG8gNCBieXRlcyBpbiBsZW5ndGgsIGRlcGVuZGluZyBvbiB0aGUgb2ZmU2l6ZSBhcmd1bWVudC5cbmZ1bmN0aW9uIGdldE9mZnNldChkYXRhVmlldywgb2Zmc2V0LCBvZmZTaXplKSB7XG4gICAgdmFyIHYgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2ZmU2l6ZTsgaSArPSAxKSB7XG4gICAgICAgIHYgPDw9IDg7XG4gICAgICAgIHYgKz0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHY7XG59XG5cbi8vIFJldHJpZXZlIGEgbnVtYmVyIG9mIGJ5dGVzIGZyb20gc3RhcnQgb2Zmc2V0IHRvIHRoZSBlbmQgb2Zmc2V0IGZyb20gdGhlIERhdGFWaWV3LlxuZnVuY3Rpb24gZ2V0Qnl0ZXMoZGF0YVZpZXcsIHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpIHtcbiAgICB2YXIgYnl0ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRPZmZzZXQ7IGkgPCBlbmRPZmZzZXQ7IGkgKz0gMSkge1xuICAgICAgICBieXRlcy5wdXNoKGRhdGFWaWV3LmdldFVpbnQ4KGkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5cbi8vIENvbnZlcnQgdGhlIGxpc3Qgb2YgYnl0ZXMgdG8gYSBzdHJpbmcuXG5mdW5jdGlvbiBieXRlc1RvU3RyaW5nKGJ5dGVzKSB7XG4gICAgdmFyIHMgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHM7XG59XG5cbnZhciB0eXBlT2Zmc2V0cyA9IHtcbiAgICBieXRlOiAxLFxuICAgIHVTaG9ydDogMixcbiAgICBzaG9ydDogMixcbiAgICB1TG9uZzogNCxcbiAgICBmaXhlZDogNCxcbiAgICBsb25nRGF0ZVRpbWU6IDgsXG4gICAgdGFnOiA0XG59O1xuXG4vLyBBIHN0YXRlZnVsIHBhcnNlciB0aGF0IGNoYW5nZXMgdGhlIG9mZnNldCB3aGVuZXZlciBhIHZhbHVlIGlzIHJldHJpZXZlZC5cbi8vIFRoZSBkYXRhIGlzIGEgRGF0YVZpZXcuXG5mdW5jdGlvbiBQYXJzZXIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ID0gMDtcbn1cblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRVaW50OCh0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMTtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VDaGFyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0SW50OCh0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gMTtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VDYXJkOCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VCeXRlO1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNhcmQxNiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU0lEID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblBhcnNlci5wcm90b3R5cGUucGFyc2VPZmZzZXQxNiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQ7XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VTaG9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldEludDE2KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUYyRG90MTQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRJbnQxNih0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpIC8gMTYzODQ7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAyO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSBnZXRVTG9uZyh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9mZnNldDMyID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nO1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlRml4ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IGdldEZpeGVkKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU3RyaW5nID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIHN0cmluZyA9ICcnO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gbGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0ICsgaSkpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmc7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVGFnID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdHJpbmcoNCk7XG59O1xuXG4vLyBMT05HREFURVRJTUUgaXMgYSA2NC1iaXQgaW50ZWdlci5cbi8vIEphdmFTY3JpcHQgYW5kIHVuaXggdGltZXN0YW1wcyB0cmFkaXRpb25hbGx5IHVzZSAzMiBiaXRzLCBzbyB3ZVxuLy8gb25seSB0YWtlIHRoZSBsYXN0IDMyIGJpdHMuXG4vLyArIFNpbmNlIHVudGlsIDIwMzggdGhvc2UgYml0cyB3aWxsIGJlIGZpbGxlZCBieSB6ZXJvcyB3ZSBjYW4gaWdub3JlIHRoZW0uXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTG9uZ0RhdGVUaW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSBnZXRVTG9uZyh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCArIDQpO1xuICAgIC8vIFN1YnRyYWN0IHNlY29uZHMgYmV0d2VlbiAwMS8wMS8xOTA0IGFuZCAwMS8wMS8xOTcwXG4gICAgLy8gdG8gY29udmVydCBBcHBsZSBNYWMgdGltZXN0YW1wIHRvIFN0YW5kYXJkIFVuaXggdGltZXN0YW1wXG4gICAgdiAtPSAyMDgyODQ0ODAwO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gODtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VWZXJzaW9uID0gZnVuY3Rpb24obWlub3JCYXNlKSB7XG4gICAgdmFyIG1ham9yID0gZ2V0VVNob3J0KHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcblxuICAgIC8vIEhvdyB0byBpbnRlcnByZXQgdGhlIG1pbm9yIHZlcnNpb24gaXMgdmVyeSB2YWd1ZSBpbiB0aGUgc3BlYy4gMHg1MDAwIGlzIDUsIDB4MTAwMCBpcyAxXG4gICAgLy8gRGVmYXVsdCByZXR1cm5zIHRoZSBjb3JyZWN0IG51bWJlciBpZiBtaW5vciA9IDB4TjAwMCB3aGVyZSBOIGlzIDAtOVxuICAgIC8vIFNldCBtaW5vckJhc2UgdG8gMSBmb3IgdGFibGVzIHRoYXQgdXNlIG1pbm9yID0gTiB3aGVyZSBOIGlzIDAtOVxuICAgIHZhciBtaW5vciA9IGdldFVTaG9ydCh0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCArIDIpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gNDtcbiAgICBpZiAobWlub3JCYXNlID09PSB1bmRlZmluZWQpIHsgbWlub3JCYXNlID0gMHgxMDAwOyB9XG4gICAgcmV0dXJuIG1ham9yICsgbWlub3IgLyBtaW5vckJhc2UgLyAxMDtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uKHR5cGUsIGFtb3VudCkge1xuICAgIGlmIChhbW91bnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhbW91bnQgPSAxO1xuICAgIH1cblxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gdHlwZU9mZnNldHNbdHlwZV0gKiBhbW91bnQ7XG59O1xuXG4vLy8vLyBQYXJzaW5nIGxpc3RzIGFuZCByZWNvcmRzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLy8gUGFyc2UgYSBsaXN0IG9mIDMyIGJpdCB1bnNpZ25lZCBpbnRlZ2Vycy5cblBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZ0xpc3QgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gdW5kZWZpbmVkKSB7IGNvdW50ID0gdGhpcy5wYXJzZVVMb25nKCk7IH1cbiAgICB2YXIgb2Zmc2V0cyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIG9mZnNldHNbaV0gPSBkYXRhVmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDQ7XG4gICAgfVxuXG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBjb3VudCAqIDQ7XG4gICAgcmV0dXJuIG9mZnNldHM7XG59O1xuXG4vLyBQYXJzZSBhIGxpc3Qgb2YgMTYgYml0IHVuc2lnbmVkIGludGVnZXJzLiBUaGUgbGVuZ3RoIG9mIHRoZSBsaXN0IGNhbiBiZSByZWFkIG9uIHRoZSBzdHJlYW1cbi8vIG9yIHByb3ZpZGVkIGFzIGFuIGFyZ3VtZW50LlxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9mZnNldDE2TGlzdCA9XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0TGlzdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQpIHsgY291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7IH1cbiAgICB2YXIgb2Zmc2V0cyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIG9mZnNldHNbaV0gPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IDI7XG4gICAgfVxuXG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBjb3VudCAqIDI7XG4gICAgcmV0dXJuIG9mZnNldHM7XG59O1xuXG4vLyBQYXJzZXMgYSBsaXN0IG9mIDE2IGJpdCBzaWduZWQgaW50ZWdlcnMuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU2hvcnRMaXN0ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgdmFyIGRhdGFWaWV3ID0gdGhpcy5kYXRhO1xuICAgIHZhciBvZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGxpc3RbaV0gPSBkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICB9XG5cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGNvdW50ICogMjtcbiAgICByZXR1cm4gbGlzdDtcbn07XG5cbi8vIFBhcnNlcyBhIGxpc3Qgb2YgYnl0ZXMuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZUxpc3QgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgbGlzdFtpXSA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCsrKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGNvdW50O1xuICAgIHJldHVybiBsaXN0O1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIGxpc3Qgb2YgaXRlbXMuXG4gKiBSZWNvcmQgY291bnQgaXMgb3B0aW9uYWwsIGlmIG9taXR0ZWQgaXQgaXMgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gKiBpdGVtQ2FsbGJhY2sgaXMgb25lIG9mIHRoZSBQYXJzZXIgbWV0aG9kcy5cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpc3QgPSBmdW5jdGlvbihjb3VudCwgaXRlbUNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoIWl0ZW1DYWxsYmFjaykge1xuICAgICAgICBpdGVtQ2FsbGJhY2sgPSBjb3VudDtcbiAgICAgICAgY291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgbGlzdFtpXSA9IGl0ZW1DYWxsYmFjay5jYWxsKHRoaXMkMSk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUxpc3QzMiA9IGZ1bmN0aW9uKGNvdW50LCBpdGVtQ2FsbGJhY2spIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICghaXRlbUNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZW1DYWxsYmFjayA9IGNvdW50O1xuICAgICAgICBjb3VudCA9IHRoaXMucGFyc2VVTG9uZygpO1xuICAgIH1cbiAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGxpc3RbaV0gPSBpdGVtQ2FsbGJhY2suY2FsbCh0aGlzJDEpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBsaXN0IG9mIHJlY29yZHMuXG4gKiBSZWNvcmQgY291bnQgaXMgb3B0aW9uYWwsIGlmIG9taXR0ZWQgaXQgaXMgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gKiBFeGFtcGxlIG9mIHJlY29yZERlc2NyaXB0aW9uOiB7IHNlcXVlbmNlSW5kZXg6IFBhcnNlci51U2hvcnQsIGxvb2t1cExpc3RJbmRleDogUGFyc2VyLnVTaG9ydCB9XG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VSZWNvcmRMaXN0ID0gZnVuY3Rpb24oY291bnQsIHJlY29yZERlc2NyaXB0aW9uKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAvLyBJZiB0aGUgY291bnQgYXJndW1lbnQgaXMgYWJzZW50LCByZWFkIGl0IGluIHRoZSBzdHJlYW0uXG4gICAgaWYgKCFyZWNvcmREZXNjcmlwdGlvbikge1xuICAgICAgICByZWNvcmREZXNjcmlwdGlvbiA9IGNvdW50O1xuICAgICAgICBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB9XG4gICAgdmFyIHJlY29yZHMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyhyZWNvcmREZXNjcmlwdGlvbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciByZWMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZHNbal07XG4gICAgICAgICAgICB2YXIgZmllbGRUeXBlID0gcmVjb3JkRGVzY3JpcHRpb25bZmllbGROYW1lXTtcbiAgICAgICAgICAgIHJlY1tmaWVsZE5hbWVdID0gZmllbGRUeXBlLmNhbGwodGhpcyQxKTtcbiAgICAgICAgfVxuICAgICAgICByZWNvcmRzW2ldID0gcmVjO1xuICAgIH1cbiAgICByZXR1cm4gcmVjb3Jkcztcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VSZWNvcmRMaXN0MzIgPSBmdW5jdGlvbihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIC8vIElmIHRoZSBjb3VudCBhcmd1bWVudCBpcyBhYnNlbnQsIHJlYWQgaXQgaW4gdGhlIHN0cmVhbS5cbiAgICBpZiAoIXJlY29yZERlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJlY29yZERlc2NyaXB0aW9uID0gY291bnQ7XG4gICAgICAgIGNvdW50ID0gdGhpcy5wYXJzZVVMb25nKCk7XG4gICAgfVxuICAgIHZhciByZWNvcmRzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICB2YXIgZmllbGRzID0gT2JqZWN0LmtleXMocmVjb3JkRGVzY3JpcHRpb24pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgcmVjID0ge307XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgZmllbGROYW1lID0gZmllbGRzW2pdO1xuICAgICAgICAgICAgdmFyIGZpZWxkVHlwZSA9IHJlY29yZERlc2NyaXB0aW9uW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICByZWNbZmllbGROYW1lXSA9IGZpZWxkVHlwZS5jYWxsKHRoaXMkMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3Jkc1tpXSA9IHJlYztcbiAgICB9XG4gICAgcmV0dXJuIHJlY29yZHM7XG59O1xuXG4vLyBQYXJzZSBhIGRhdGEgc3RydWN0dXJlIGludG8gYW4gb2JqZWN0XG4vLyBFeGFtcGxlIG9mIGRlc2NyaXB0aW9uOiB7IHNlcXVlbmNlSW5kZXg6IFBhcnNlci51U2hvcnQsIGxvb2t1cExpc3RJbmRleDogUGFyc2VyLnVTaG9ydCB9XG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU3RydWN0ID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uLmNhbGwodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZpZWxkcyA9IE9iamVjdC5rZXlzKGRlc2NyaXB0aW9uKTtcbiAgICAgICAgdmFyIHN0cnVjdCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkc1tqXTtcbiAgICAgICAgICAgIHZhciBmaWVsZFR5cGUgPSBkZXNjcmlwdGlvbltmaWVsZE5hbWVdO1xuICAgICAgICAgICAgc3RydWN0W2ZpZWxkTmFtZV0gPSBmaWVsZFR5cGUuY2FsbCh0aGlzJDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJ1Y3Q7XG4gICAgfVxufTtcblxuLyoqXG4gKiBQYXJzZSBhIEdQT1MgdmFsdWVSZWNvcmRcbiAqIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9ncG9zI3ZhbHVlLXJlY29yZFxuICogdmFsdWVGb3JtYXQgaXMgb3B0aW9uYWwsIGlmIG9taXR0ZWQgaXQgaXMgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VWYWx1ZVJlY29yZCA9IGZ1bmN0aW9uKHZhbHVlRm9ybWF0KSB7XG4gICAgaWYgKHZhbHVlRm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWVGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuICAgIGlmICh2YWx1ZUZvcm1hdCA9PT0gMCkge1xuICAgICAgICAvLyB2YWx1ZUZvcm1hdDIgaW4ga2VybmluZyBwYWlycyBpcyBtb3N0IG9mdGVuIDBcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHJldHVybiB1bmRlZmluZWQgaW5zdGVhZCBvZiBhbiBlbXB0eSBvYmplY3QsIHRvIHNhdmUgc3BhY2VcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmFsdWVSZWNvcmQgPSB7fTtcblxuICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAwMSkgeyB2YWx1ZVJlY29yZC54UGxhY2VtZW50ID0gdGhpcy5wYXJzZVNob3J0KCk7IH1cbiAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMDIpIHsgdmFsdWVSZWNvcmQueVBsYWNlbWVudCA9IHRoaXMucGFyc2VTaG9ydCgpOyB9XG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDA0KSB7IHZhbHVlUmVjb3JkLnhBZHZhbmNlID0gdGhpcy5wYXJzZVNob3J0KCk7IH1cbiAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMDgpIHsgdmFsdWVSZWNvcmQueUFkdmFuY2UgPSB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuXG4gICAgLy8gRGV2aWNlIHRhYmxlIChub24tdmFyaWFibGUgZm9udCkgLyBWYXJpYXRpb25JbmRleCB0YWJsZSAodmFyaWFibGUgZm9udCkgbm90IHN1cHBvcnRlZFxuICAgIC8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2ZyLWZyL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9jaGFwdGVyMiNkZXZWYXJJZHhUYmxzXG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDEwKSB7IHZhbHVlUmVjb3JkLnhQbGFEZXZpY2UgPSB1bmRlZmluZWQ7IHRoaXMucGFyc2VTaG9ydCgpOyB9XG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDIwKSB7IHZhbHVlUmVjb3JkLnlQbGFEZXZpY2UgPSB1bmRlZmluZWQ7IHRoaXMucGFyc2VTaG9ydCgpOyB9XG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDQwKSB7IHZhbHVlUmVjb3JkLnhBZHZEZXZpY2UgPSB1bmRlZmluZWQ7IHRoaXMucGFyc2VTaG9ydCgpOyB9XG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDgwKSB7IHZhbHVlUmVjb3JkLnlBZHZEZXZpY2UgPSB1bmRlZmluZWQ7IHRoaXMucGFyc2VTaG9ydCgpOyB9XG5cbiAgICByZXR1cm4gdmFsdWVSZWNvcmQ7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCBvZiBHUE9TIHZhbHVlUmVjb3Jkc1xuICogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2dwb3MjdmFsdWUtcmVjb3JkXG4gKiB2YWx1ZUZvcm1hdCBhbmQgdmFsdWVDb3VudCBhcmUgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VWYWx1ZVJlY29yZExpc3QgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciB2YWx1ZUZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgdmFsdWVDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgdmFsdWVzID0gbmV3IEFycmF5KHZhbHVlQ291bnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgICAgIHZhbHVlc1tpXSA9IHRoaXMkMS5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VQb2ludGVyID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICB2YXIgc3RydWN0T2Zmc2V0ID0gdGhpcy5wYXJzZU9mZnNldDE2KCk7XG4gICAgaWYgKHN0cnVjdE9mZnNldCA+IDApIHtcbiAgICAgICAgLy8gTlVMTCBvZmZzZXQgPT4gcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlcih0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgc3RydWN0T2Zmc2V0KS5wYXJzZVN0cnVjdChkZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlUG9pbnRlcjMyID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICB2YXIgc3RydWN0T2Zmc2V0ID0gdGhpcy5wYXJzZU9mZnNldDMyKCk7XG4gICAgaWYgKHN0cnVjdE9mZnNldCA+IDApIHtcbiAgICAgICAgLy8gTlVMTCBvZmZzZXQgPT4gcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gbmV3IFBhcnNlcih0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgc3RydWN0T2Zmc2V0KS5wYXJzZVN0cnVjdChkZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCBvZiBvZmZzZXRzIHRvIGxpc3RzIG9mIDE2LWJpdCBpbnRlZ2VycyxcbiAqIG9yIGEgbGlzdCBvZiBvZmZzZXRzIHRvIGxpc3RzIG9mIG9mZnNldHMgdG8gYW55IGtpbmQgb2YgaXRlbXMuXG4gKiBJZiBpdGVtQ2FsbGJhY2sgaXMgbm90IHByb3ZpZGVkLCBhIGxpc3Qgb2YgbGlzdCBvZiBVU2hvcnQgaXMgYXNzdW1lZC5cbiAqIElmIHByb3ZpZGVkLCBpdGVtQ2FsbGJhY2sgaXMgY2FsbGVkIG9uIGVhY2ggaXRlbSBhbmQgbXVzdCBwYXJzZSB0aGUgaXRlbS5cbiAqIFNlZSBleGFtcGxlcyBpbiB0YWJsZXMvZ3N1Yi5qc1xuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTGlzdE9mTGlzdHMgPSBmdW5jdGlvbihpdGVtQ2FsbGJhY2spIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBvZmZzZXRzID0gdGhpcy5wYXJzZU9mZnNldDE2TGlzdCgpO1xuICAgIHZhciBjb3VudCA9IG9mZnNldHMubGVuZ3RoO1xuICAgIHZhciByZWxhdGl2ZU9mZnNldCA9IHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXRzW2ldO1xuICAgICAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgICAgICAgIC8vIE5VTEwgb2Zmc2V0XG4gICAgICAgICAgICAvLyBBZGQgaSBhcyBvd25lZCBwcm9wZXJ0eSB0byBsaXN0LiBDb252ZW5pZW50IHdpdGggYXNzZXJ0LlxuICAgICAgICAgICAgbGlzdFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMkMS5yZWxhdGl2ZU9mZnNldCA9IHN0YXJ0O1xuICAgICAgICBpZiAoaXRlbUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgc3ViT2Zmc2V0cyA9IHRoaXMkMS5wYXJzZU9mZnNldDE2TGlzdCgpO1xuICAgICAgICAgICAgdmFyIHN1Ykxpc3QgPSBuZXcgQXJyYXkoc3ViT2Zmc2V0cy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdWJPZmZzZXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcyQxLnJlbGF0aXZlT2Zmc2V0ID0gc3RhcnQgKyBzdWJPZmZzZXRzW2pdO1xuICAgICAgICAgICAgICAgIHN1Ykxpc3Rbal0gPSBpdGVtQ2FsbGJhY2suY2FsbCh0aGlzJDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdFtpXSA9IHN1Ykxpc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaXN0W2ldID0gdGhpcyQxLnBhcnNlVVNob3J0TGlzdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgPSByZWxhdGl2ZU9mZnNldDtcbiAgICByZXR1cm4gbGlzdDtcbn07XG5cbi8vLy8vIENvbXBsZXggdGFibGVzIHBhcnNpbmcgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBQYXJzZSBhIGNvdmVyYWdlIHRhYmxlIGluIGEgR1NVQiwgR1BPUyBvciBHREVGIHRhYmxlLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFwdGVyMi5odG1cbi8vIHBhcnNlci5vZmZzZXQgbXVzdCBwb2ludCB0byB0aGUgc3RhcnQgb2YgdGhlIHRhYmxlIGNvbnRhaW5pbmcgdGhlIGNvdmVyYWdlLlxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvdmVyYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgY291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiAxLFxuICAgICAgICAgICAgZ2x5cGhzOiB0aGlzLnBhcnNlVVNob3J0TGlzdChjb3VudClcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICB2YXIgcmFuZ2VzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICByYW5nZXNbaV0gPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMkMS5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgICAgIGVuZDogdGhpcyQxLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMkMS5wYXJzZVVTaG9ydCgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6IDIsXG4gICAgICAgICAgICByYW5nZXM6IHJhbmdlc1xuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJzB4JyArIHN0YXJ0T2Zmc2V0LnRvU3RyaW5nKDE2KSArICc6IENvdmVyYWdlIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nKTtcbn07XG5cbi8vIFBhcnNlIGEgQ2xhc3MgRGVmaW5pdGlvbiBUYWJsZSBpbiBhIEdTVUIsIEdQT1Mgb3IgR0RFRiB0YWJsZS5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY2hhcHRlcjIuaHRtXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NEZWYgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhcnRPZmZzZXQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIGZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6IDEsXG4gICAgICAgICAgICBzdGFydEdseXBoOiB0aGlzLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICBjbGFzc2VzOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogMixcbiAgICAgICAgICAgIHJhbmdlczogdGhpcy5wYXJzZVJlY29yZExpc3Qoe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBQYXJzZXIudVNob3J0LFxuICAgICAgICAgICAgICAgIGVuZDogUGFyc2VyLnVTaG9ydCxcbiAgICAgICAgICAgICAgICBjbGFzc0lkOiBQYXJzZXIudVNob3J0XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJzB4JyArIHN0YXJ0T2Zmc2V0LnRvU3RyaW5nKDE2KSArICc6IENsYXNzRGVmIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nKTtcbn07XG5cbi8vLy8vIFN0YXRpYyBtZXRob2RzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBUaGVzZSBjb252ZW5pZW5jZSBtZXRob2RzIGNhbiBiZSB1c2VkIGFzIGNhbGxiYWNrcyBhbmQgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIFwidGhpc1wiIGNvbnRleHQgc2V0IHRvIGEgUGFyc2VyIGluc3RhbmNlLlxuXG5QYXJzZXIubGlzdCA9IGZ1bmN0aW9uKGNvdW50LCBpdGVtQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGlzdChjb3VudCwgaXRlbUNhbGxiYWNrKTtcbiAgICB9O1xufTtcblxuUGFyc2VyLmxpc3QzMiA9IGZ1bmN0aW9uKGNvdW50LCBpdGVtQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGlzdDMyKGNvdW50LCBpdGVtQ2FsbGJhY2spO1xuICAgIH07XG59O1xuXG5QYXJzZXIucmVjb3JkTGlzdCA9IGZ1bmN0aW9uKGNvdW50LCByZWNvcmREZXNjcmlwdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSZWNvcmRMaXN0KGNvdW50LCByZWNvcmREZXNjcmlwdGlvbik7XG4gICAgfTtcbn07XG5cblBhcnNlci5yZWNvcmRMaXN0MzIgPSBmdW5jdGlvbihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUmVjb3JkTGlzdDMyKGNvdW50LCByZWNvcmREZXNjcmlwdGlvbik7XG4gICAgfTtcbn07XG5cblBhcnNlci5wb2ludGVyID0gZnVuY3Rpb24oZGVzY3JpcHRpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcihkZXNjcmlwdGlvbik7XG4gICAgfTtcbn07XG5cblBhcnNlci5wb2ludGVyMzIgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyMzIoZGVzY3JpcHRpb24pO1xuICAgIH07XG59O1xuXG5QYXJzZXIudGFnID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVRhZztcblBhcnNlci5ieXRlID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGU7XG5QYXJzZXIudVNob3J0ID0gUGFyc2VyLm9mZnNldDE2ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblBhcnNlci51U2hvcnRMaXN0ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydExpc3Q7XG5QYXJzZXIudUxvbmcgPSBQYXJzZXIub2Zmc2V0MzIgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVUxvbmc7XG5QYXJzZXIudUxvbmdMaXN0ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nTGlzdDtcblBhcnNlci5zdHJ1Y3QgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlU3RydWN0O1xuUGFyc2VyLmNvdmVyYWdlID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNvdmVyYWdlO1xuUGFyc2VyLmNsYXNzRGVmID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNsYXNzRGVmO1xuXG4vLy8vLyBTY3JpcHQsIEZlYXR1cmUsIExvb2t1cCBsaXN0cyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFwdGVyMi5odG1cblxudmFyIGxhbmdTeXNUYWJsZSA9IHtcbiAgICByZXNlcnZlZDogUGFyc2VyLnVTaG9ydCxcbiAgICByZXFGZWF0dXJlSW5kZXg6IFBhcnNlci51U2hvcnQsXG4gICAgZmVhdHVyZUluZGV4ZXM6IFBhcnNlci51U2hvcnRMaXN0XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlU2NyaXB0TGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIucmVjb3JkTGlzdCh7XG4gICAgICAgIHRhZzogUGFyc2VyLnRhZyxcbiAgICAgICAgc2NyaXB0OiBQYXJzZXIucG9pbnRlcih7XG4gICAgICAgICAgICBkZWZhdWx0TGFuZ1N5czogUGFyc2VyLnBvaW50ZXIobGFuZ1N5c1RhYmxlKSxcbiAgICAgICAgICAgIGxhbmdTeXNSZWNvcmRzOiBQYXJzZXIucmVjb3JkTGlzdCh7XG4gICAgICAgICAgICAgICAgdGFnOiBQYXJzZXIudGFnLFxuICAgICAgICAgICAgICAgIGxhbmdTeXM6IFBhcnNlci5wb2ludGVyKGxhbmdTeXNUYWJsZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfSkpIHx8IFtdO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUZlYXR1cmVMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5yZWNvcmRMaXN0KHtcbiAgICAgICAgdGFnOiBQYXJzZXIudGFnLFxuICAgICAgICBmZWF0dXJlOiBQYXJzZXIucG9pbnRlcih7XG4gICAgICAgICAgICBmZWF0dXJlUGFyYW1zOiBQYXJzZXIub2Zmc2V0MTYsXG4gICAgICAgICAgICBsb29rdXBMaXN0SW5kZXhlczogUGFyc2VyLnVTaG9ydExpc3RcbiAgICAgICAgfSlcbiAgICB9KSkgfHwgW107XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTG9va3VwTGlzdCA9IGZ1bmN0aW9uKGxvb2t1cFRhYmxlUGFyc2Vycykge1xuICAgIHJldHVybiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIubGlzdChQYXJzZXIucG9pbnRlcihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxvb2t1cFR5cGUgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KDEgPD0gbG9va3VwVHlwZSAmJiBsb29rdXBUeXBlIDw9IDksICdHUE9TL0dTVUIgbG9va3VwIHR5cGUgJyArIGxvb2t1cFR5cGUgKyAnIHVua25vd24uJyk7XG4gICAgICAgIHZhciBsb29rdXBGbGFnID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgdXNlTWFya0ZpbHRlcmluZ1NldCA9IGxvb2t1cEZsYWcgJiAweDEwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9va3VwVHlwZTogbG9va3VwVHlwZSxcbiAgICAgICAgICAgIGxvb2t1cEZsYWc6IGxvb2t1cEZsYWcsXG4gICAgICAgICAgICBzdWJ0YWJsZXM6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKGxvb2t1cFRhYmxlUGFyc2Vyc1tsb29rdXBUeXBlXSkpLFxuICAgICAgICAgICAgbWFya0ZpbHRlcmluZ1NldDogdXNlTWFya0ZpbHRlcmluZ1NldCA/IHRoaXMucGFyc2VVU2hvcnQoKSA6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgIH0pKSkgfHwgW107XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlRmVhdHVyZVZhcmlhdGlvbnNMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyMzIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtYWpvclZlcnNpb24gPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBtaW5vclZlcnNpb24gPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KG1ham9yVmVyc2lvbiA9PT0gMSAmJiBtaW5vclZlcnNpb24gPCAxLCAnR1BPUy9HU1VCIGZlYXR1cmUgdmFyaWF0aW9ucyB0YWJsZSB1bmtub3duLicpO1xuICAgICAgICB2YXIgZmVhdHVyZVZhcmlhdGlvbnMgPSB0aGlzLnBhcnNlUmVjb3JkTGlzdDMyKHtcbiAgICAgICAgICAgIGNvbmRpdGlvblNldE9mZnNldDogUGFyc2VyLm9mZnNldDMyLFxuICAgICAgICAgICAgZmVhdHVyZVRhYmxlU3Vic3RpdHV0aW9uT2Zmc2V0OiBQYXJzZXIub2Zmc2V0MzJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmZWF0dXJlVmFyaWF0aW9ucztcbiAgICB9KSB8fCBbXTtcbn07XG5cbnZhciBwYXJzZSA9IHtcbiAgICBnZXRCeXRlOiBnZXRCeXRlLFxuICAgIGdldENhcmQ4OiBnZXRCeXRlLFxuICAgIGdldFVTaG9ydDogZ2V0VVNob3J0LFxuICAgIGdldENhcmQxNjogZ2V0VVNob3J0LFxuICAgIGdldFNob3J0OiBnZXRTaG9ydCxcbiAgICBnZXRVTG9uZzogZ2V0VUxvbmcsXG4gICAgZ2V0Rml4ZWQ6IGdldEZpeGVkLFxuICAgIGdldFRhZzogZ2V0VGFnLFxuICAgIGdldE9mZnNldDogZ2V0T2Zmc2V0LFxuICAgIGdldEJ5dGVzOiBnZXRCeXRlcyxcbiAgICBieXRlc1RvU3RyaW5nOiBieXRlc1RvU3RyaW5nLFxuICAgIFBhcnNlcjogUGFyc2VyLFxufTtcblxuLy8gVGhlIGBjbWFwYCB0YWJsZSBzdG9yZXMgdGhlIG1hcHBpbmdzIGZyb20gY2hhcmFjdGVycyB0byBnbHlwaHMuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NtYXAuaHRtXG5cbmZ1bmN0aW9uIHBhcnNlQ21hcFRhYmxlRm9ybWF0MTIoY21hcCwgcCkge1xuICAgIC8vU2tpcCByZXNlcnZlZC5cbiAgICBwLnBhcnNlVVNob3J0KCk7XG5cbiAgICAvLyBMZW5ndGggaW4gYnl0ZXMgb2YgdGhlIHN1Yi10YWJsZXMuXG4gICAgY21hcC5sZW5ndGggPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjbWFwLmxhbmd1YWdlID0gcC5wYXJzZVVMb25nKCk7XG5cbiAgICB2YXIgZ3JvdXBDb3VudDtcbiAgICBjbWFwLmdyb3VwQ291bnQgPSBncm91cENvdW50ID0gcC5wYXJzZVVMb25nKCk7XG4gICAgY21hcC5nbHlwaEluZGV4TWFwID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICB2YXIgc3RhcnRDaGFyQ29kZSA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgICB2YXIgZW5kQ2hhckNvZGUgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICAgICAgdmFyIHN0YXJ0R2x5cGhJZCA9IHAucGFyc2VVTG9uZygpO1xuXG4gICAgICAgIGZvciAodmFyIGMgPSBzdGFydENoYXJDb2RlOyBjIDw9IGVuZENoYXJDb2RlOyBjICs9IDEpIHtcbiAgICAgICAgICAgIGNtYXAuZ2x5cGhJbmRleE1hcFtjXSA9IHN0YXJ0R2x5cGhJZDtcbiAgICAgICAgICAgIHN0YXJ0R2x5cGhJZCsrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZUNtYXBUYWJsZUZvcm1hdDQoY21hcCwgcCwgZGF0YSwgc3RhcnQsIG9mZnNldCkge1xuICAgIC8vIExlbmd0aCBpbiBieXRlcyBvZiB0aGUgc3ViLXRhYmxlcy5cbiAgICBjbWFwLmxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBjbWFwLmxhbmd1YWdlID0gcC5wYXJzZVVTaG9ydCgpO1xuXG4gICAgLy8gc2VnQ291bnQgaXMgc3RvcmVkIHggMi5cbiAgICB2YXIgc2VnQ291bnQ7XG4gICAgY21hcC5zZWdDb3VudCA9IHNlZ0NvdW50ID0gcC5wYXJzZVVTaG9ydCgpID4+IDE7XG5cbiAgICAvLyBTa2lwIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0LlxuICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG5cbiAgICAvLyBUaGUgXCJ1bnJvbGxlZFwiIG1hcHBpbmcgZnJvbSBjaGFyYWN0ZXIgY29kZXMgdG8gZ2x5cGggaW5kaWNlcy5cbiAgICBjbWFwLmdseXBoSW5kZXhNYXAgPSB7fTtcbiAgICB2YXIgZW5kQ291bnRQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0ICsgMTQpO1xuICAgIHZhciBzdGFydENvdW50UGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiAyKTtcbiAgICB2YXIgaWREZWx0YVBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogNCk7XG4gICAgdmFyIGlkUmFuZ2VPZmZzZXRQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDYpO1xuICAgIHZhciBnbHlwaEluZGV4T2Zmc2V0ID0gc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogODtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ0NvdW50IC0gMTsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaEluZGV4ID0gKHZvaWQgMCk7XG4gICAgICAgIHZhciBlbmRDb3VudCA9IGVuZENvdW50UGFyc2VyLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBzdGFydENvdW50ID0gc3RhcnRDb3VudFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgaWREZWx0YSA9IGlkRGVsdGFQYXJzZXIucGFyc2VTaG9ydCgpO1xuICAgICAgICB2YXIgaWRSYW5nZU9mZnNldCA9IGlkUmFuZ2VPZmZzZXRQYXJzZXIucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgZm9yICh2YXIgYyA9IHN0YXJ0Q291bnQ7IGMgPD0gZW5kQ291bnQ7IGMgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGlkUmFuZ2VPZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgaWRSYW5nZU9mZnNldCBpcyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgaWRSYW5nZU9mZnNldCBhcnJheS5cbiAgICAgICAgICAgICAgICAvLyBUYWtlIHRoZSBjdXJyZW50IG9mZnNldCBpbiB0aGUgaWRSYW5nZU9mZnNldCBhcnJheS5cbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ID0gKGlkUmFuZ2VPZmZzZXRQYXJzZXIub2Zmc2V0ICsgaWRSYW5nZU9mZnNldFBhcnNlci5yZWxhdGl2ZU9mZnNldCAtIDIpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSB2YWx1ZSBvZiB0aGUgaWRSYW5nZU9mZnNldCwgd2hpY2ggd2lsbCBtb3ZlIHVzIGludG8gdGhlIGdseXBoSW5kZXggYXJyYXkuXG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleE9mZnNldCArPSBpZFJhbmdlT2Zmc2V0O1xuXG4gICAgICAgICAgICAgICAgLy8gVGhlbiBhZGQgdGhlIGNoYXJhY3RlciBpbmRleCBvZiB0aGUgY3VycmVudCBzZWdtZW50LCBtdWx0aXBsaWVkIGJ5IDIgZm9yIFVTSE9SVHMuXG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleE9mZnNldCArPSAoYyAtIHN0YXJ0Q291bnQpICogMjtcbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4ID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIGdseXBoSW5kZXhPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaEluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdseXBoSW5kZXggPSAoZ2x5cGhJbmRleCArIGlkRGVsdGEpICYgMHhGRkZGO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleCA9IChjICsgaWREZWx0YSkgJiAweEZGRkY7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNtYXAuZ2x5cGhJbmRleE1hcFtjXSA9IGdseXBoSW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFBhcnNlIHRoZSBgY21hcGAgdGFibGUuIFRoaXMgdGFibGUgc3RvcmVzIHRoZSBtYXBwaW5ncyBmcm9tIGNoYXJhY3RlcnMgdG8gZ2x5cGhzLlxuLy8gVGhlcmUgYXJlIG1hbnkgYXZhaWxhYmxlIGZvcm1hdHMsIGJ1dCB3ZSBvbmx5IHN1cHBvcnQgdGhlIFdpbmRvd3MgZm9ybWF0IDQgYW5kIDEyLlxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgYENtYXBFbmNvZGluZ2Agb2JqZWN0IG9yIG51bGwgaWYgbm8gc3VwcG9ydGVkIGZvcm1hdCBjb3VsZCBiZSBmb3VuZC5cbmZ1bmN0aW9uIHBhcnNlQ21hcFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIGNtYXAgPSB7fTtcbiAgICBjbWFwLnZlcnNpb24gPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQpO1xuICAgIGNoZWNrLmFyZ3VtZW50KGNtYXAudmVyc2lvbiA9PT0gMCwgJ2NtYXAgdGFibGUgdmVyc2lvbiBzaG91bGQgYmUgMC4nKTtcblxuICAgIC8vIFRoZSBjbWFwIHRhYmxlIGNhbiBjb250YWluIG1hbnkgc3ViLXRhYmxlcywgZWFjaCB3aXRoIHRoZWlyIG93biBmb3JtYXQuXG4gICAgLy8gV2UncmUgb25seSBpbnRlcmVzdGVkIGluIGEgXCJwbGF0Zm9ybSAzXCIgdGFibGUuIFRoaXMgaXMgYSBXaW5kb3dzIGZvcm1hdC5cbiAgICBjbWFwLm51bVRhYmxlcyA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCArIDIpO1xuICAgIHZhciBvZmZzZXQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gY21hcC5udW1UYWJsZXMgLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICB2YXIgcGxhdGZvcm1JZCA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCArIDQgKyAoaSAqIDgpKTtcbiAgICAgICAgdmFyIGVuY29kaW5nSWQgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgc3RhcnQgKyA0ICsgKGkgKiA4KSArIDIpO1xuICAgICAgICBpZiAocGxhdGZvcm1JZCA9PT0gMyAmJiAoZW5jb2RpbmdJZCA9PT0gMCB8fCBlbmNvZGluZ0lkID09PSAxIHx8IGVuY29kaW5nSWQgPT09IDEwKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgc3RhcnQgKyA0ICsgKGkgKiA4KSArIDQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ID09PSAtMSkge1xuICAgICAgICAvLyBUaGVyZSBpcyBubyBjbWFwIHRhYmxlIGluIHRoZSBmb250IHRoYXQgd2Ugc3VwcG9ydC5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCBjbWFwIHN1Yi10YWJsZXMgZm91bmQuJyk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0KTtcbiAgICBjbWFwLmZvcm1hdCA9IHAucGFyc2VVU2hvcnQoKTtcblxuICAgIGlmIChjbWFwLmZvcm1hdCA9PT0gMTIpIHtcbiAgICAgICAgcGFyc2VDbWFwVGFibGVGb3JtYXQxMihjbWFwLCBwKTtcbiAgICB9IGVsc2UgaWYgKGNtYXAuZm9ybWF0ID09PSA0KSB7XG4gICAgICAgIHBhcnNlQ21hcFRhYmxlRm9ybWF0NChjbWFwLCBwLCBkYXRhLCBzdGFydCwgb2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgZm9ybWF0IDQgYW5kIDEyIGNtYXAgdGFibGVzIGFyZSBzdXBwb3J0ZWQgKGZvdW5kIGZvcm1hdCAnICsgY21hcC5mb3JtYXQgKyAnKS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY21hcDtcbn1cblxuZnVuY3Rpb24gYWRkU2VnbWVudCh0LCBjb2RlLCBnbHlwaEluZGV4KSB7XG4gICAgdC5zZWdtZW50cy5wdXNoKHtcbiAgICAgICAgZW5kOiBjb2RlLFxuICAgICAgICBzdGFydDogY29kZSxcbiAgICAgICAgZGVsdGE6IC0oY29kZSAtIGdseXBoSW5kZXgpLFxuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGdseXBoSW5kZXg6IGdseXBoSW5kZXhcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkVGVybWluYXRvclNlZ21lbnQodCkge1xuICAgIHQuc2VnbWVudHMucHVzaCh7XG4gICAgICAgIGVuZDogMHhGRkZGLFxuICAgICAgICBzdGFydDogMHhGRkZGLFxuICAgICAgICBkZWx0YTogMSxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgfSk7XG59XG5cbi8vIE1ha2UgY21hcCB0YWJsZSwgZm9ybWF0IDQgYnkgZGVmYXVsdCwgMTIgaWYgbmVlZGVkIG9ubHlcbmZ1bmN0aW9uIG1ha2VDbWFwVGFibGUoZ2x5cGhzKSB7XG4gICAgLy8gUGxhbiAwIGlzIHRoZSBiYXNlIFVuaWNvZGUgUGxhbiBidXQgZW1vamlzLCBmb3IgZXhhbXBsZSBhcmUgb24gYW5vdGhlciBwbGFuLCBhbmQgbmVlZHMgY21hcCAxMiBmb3JtYXQgKHdpdGggMzJiaXQpXG4gICAgdmFyIGlzUGxhbjBPbmx5ID0gdHJ1ZTtcbiAgICB2YXIgaTtcblxuICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gYWRkIGNtYXAgZm9ybWF0IDEyIG9yIGlmIGZvcm1hdCA0IG9ubHkgaXMgZmluZVxuICAgIGZvciAoaSA9IGdseXBocy5sZW5ndGggLSAxOyBpID4gMDsgaSAtPSAxKSB7XG4gICAgICAgIHZhciBnID0gZ2x5cGhzLmdldChpKTtcbiAgICAgICAgaWYgKGcudW5pY29kZSA+IDY1NTM1KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQWRkaW5nIENNQVAgZm9ybWF0IDEyIChuZWVkZWQhKScpO1xuICAgICAgICAgICAgaXNQbGFuME9ubHkgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNtYXBUYWJsZSA9IFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdudW1UYWJsZXMnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGlzUGxhbjBPbmx5ID8gMSA6IDJ9LFxuXG4gICAgICAgIC8vIENNQVAgNCBoZWFkZXJcbiAgICAgICAge25hbWU6ICdwbGF0Zm9ybUlEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAzfSxcbiAgICAgICAge25hbWU6ICdlbmNvZGluZ0lEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxfSxcbiAgICAgICAge25hbWU6ICdvZmZzZXQnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogaXNQbGFuME9ubHkgPyAxMiA6ICgxMiArIDgpfVxuICAgIF07XG5cbiAgICBpZiAoIWlzUGxhbjBPbmx5KVxuICAgICAgICB7IGNtYXBUYWJsZSA9IGNtYXBUYWJsZS5jb25jYXQoW1xuICAgICAgICAgICAgLy8gQ01BUCAxMiBoZWFkZXJcbiAgICAgICAgICAgIHtuYW1lOiAnY21hcDEyUGxhdGZvcm1JRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogM30sIC8vIFdlIGVuY29kZSBvbmx5IGZvciBQbGF0Zm9ybUlEID0gMyAoV2luZG93cykgYmVjYXVzZSBpdCBpcyBzdXBwb3J0ZWQgZXZlcnl3aGVyZVxuICAgICAgICAgICAge25hbWU6ICdjbWFwMTJFbmNvZGluZ0lEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxMH0sXG4gICAgICAgICAgICB7bmFtZTogJ2NtYXAxMk9mZnNldCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfVxuICAgICAgICBdKTsgfVxuXG4gICAgY21hcFRhYmxlID0gY21hcFRhYmxlLmNvbmNhdChbXG4gICAgICAgIC8vIENNQVAgNCBTdWJ0YWJsZVxuICAgICAgICB7bmFtZTogJ2Zvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogNH0sXG4gICAgICAgIHtuYW1lOiAnY21hcDRMZW5ndGgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2xhbmd1YWdlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzZWdDb3VudFgyJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzZWFyY2hSYW5nZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZW50cnlTZWxlY3RvcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmFuZ2VTaGlmdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdKTtcblxuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdjbWFwJywgY21hcFRhYmxlKTtcblxuICAgIHQuc2VnbWVudHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2x5cGgudW5pY29kZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGFkZFNlZ21lbnQodCwgZ2x5cGgudW5pY29kZXNbal0sIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdC5zZWdtZW50cyA9IHQuc2VnbWVudHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnQgLSBiLnN0YXJ0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhZGRUZXJtaW5hdG9yU2VnbWVudCh0KTtcblxuICAgIHZhciBzZWdDb3VudCA9IHQuc2VnbWVudHMubGVuZ3RoO1xuICAgIHZhciBzZWdDb3VudFRvUmVtb3ZlID0gMDtcblxuICAgIC8vIENNQVAgNFxuICAgIC8vIFNldCB1cCBwYXJhbGxlbCBzZWdtZW50IGFycmF5cy5cbiAgICB2YXIgZW5kQ291bnRzID0gW107XG4gICAgdmFyIHN0YXJ0Q291bnRzID0gW107XG4gICAgdmFyIGlkRGVsdGFzID0gW107XG4gICAgdmFyIGlkUmFuZ2VPZmZzZXRzID0gW107XG4gICAgdmFyIGdseXBoSWRzID0gW107XG5cbiAgICAvLyBDTUFQIDEyXG4gICAgdmFyIGNtYXAxMkdyb3VwcyA9IFtdO1xuXG4gICAgLy8gUmVtaW5kZXIgdGhpcyBsb29wIGlzIG5vdCBmb2xsb3dpbmcgdGhlIHNwZWNpZmljYXRpb24gYXQgMTAwJVxuICAgIC8vIFRoZSBzcGVjaWZpY2F0aW9uIC0+IGZpbmQgc3VpdGVzIG9mIGNoYXJhY3RlcnMgYW5kIG1ha2UgYSBncm91cFxuICAgIC8vIEhlcmUgd2UncmUgZG9pbmcgb25lIGdyb3VwIGZvciBlYWNoIGxldHRlclxuICAgIC8vIERvaW5nIGFzIHRoZSBzcGVjIGNhbiBzYXZlIDggdGltZXMgKG9yIG1vcmUpIHNwYWNlXG4gICAgZm9yIChpID0gMDsgaSA8IHNlZ0NvdW50OyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSB0LnNlZ21lbnRzW2ldO1xuXG4gICAgICAgIC8vIENNQVAgNFxuICAgICAgICBpZiAoc2VnbWVudC5lbmQgPD0gNjU1MzUgJiYgc2VnbWVudC5zdGFydCA8PSA2NTUzNSkge1xuICAgICAgICAgICAgZW5kQ291bnRzID0gZW5kQ291bnRzLmNvbmNhdCh7bmFtZTogJ2VuZF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzZWdtZW50LmVuZH0pO1xuICAgICAgICAgICAgc3RhcnRDb3VudHMgPSBzdGFydENvdW50cy5jb25jYXQoe25hbWU6ICdzdGFydF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzZWdtZW50LnN0YXJ0fSk7XG4gICAgICAgICAgICBpZERlbHRhcyA9IGlkRGVsdGFzLmNvbmNhdCh7bmFtZTogJ2lkRGVsdGFfJyArIGksIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiBzZWdtZW50LmRlbHRhfSk7XG4gICAgICAgICAgICBpZFJhbmdlT2Zmc2V0cyA9IGlkUmFuZ2VPZmZzZXRzLmNvbmNhdCh7bmFtZTogJ2lkUmFuZ2VPZmZzZXRfJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5vZmZzZXR9KTtcbiAgICAgICAgICAgIGlmIChzZWdtZW50LmdseXBoSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGdseXBoSWRzID0gZ2x5cGhJZHMuY29uY2F0KHtuYW1lOiAnZ2x5cGhfJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc2VnbWVudC5nbHlwaElkfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTa2lwIFVuaWNvZGUgPiA2NTUzNSAoMTZiaXQgdW5zaWduZWQgbWF4KSBmb3IgQ01BUCA0LCB3aWxsIGJlIGFkZGVkIGluIENNQVAgMTJcbiAgICAgICAgICAgIHNlZ0NvdW50VG9SZW1vdmUgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENNQVAgMTJcbiAgICAgICAgLy8gU2tpcCBUZXJtaW5hdG9yIFNlZ21lbnRcbiAgICAgICAgaWYgKCFpc1BsYW4wT25seSAmJiBzZWdtZW50LmdseXBoSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY21hcDEyR3JvdXBzID0gY21hcDEyR3JvdXBzLmNvbmNhdCh7bmFtZTogJ2NtYXAxMlN0YXJ0XycgKyBpLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogc2VnbWVudC5zdGFydH0pO1xuICAgICAgICAgICAgY21hcDEyR3JvdXBzID0gY21hcDEyR3JvdXBzLmNvbmNhdCh7bmFtZTogJ2NtYXAxMkVuZF8nICsgaSwgdHlwZTogJ1VMT05HJywgdmFsdWU6IHNlZ21lbnQuZW5kfSk7XG4gICAgICAgICAgICBjbWFwMTJHcm91cHMgPSBjbWFwMTJHcm91cHMuY29uY2F0KHtuYW1lOiAnY21hcDEyR2x5cGhfJyArIGksIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBzZWdtZW50LmdseXBoSW5kZXh9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENNQVAgNCBTdWJ0YWJsZVxuICAgIHQuc2VnQ291bnRYMiA9IChzZWdDb3VudCAtIHNlZ0NvdW50VG9SZW1vdmUpICogMjtcbiAgICB0LnNlYXJjaFJhbmdlID0gTWF0aC5wb3coMiwgTWF0aC5mbG9vcihNYXRoLmxvZygoc2VnQ291bnQgLSBzZWdDb3VudFRvUmVtb3ZlKSkgLyBNYXRoLmxvZygyKSkpICogMjtcbiAgICB0LmVudHJ5U2VsZWN0b3IgPSBNYXRoLmxvZyh0LnNlYXJjaFJhbmdlIC8gMikgLyBNYXRoLmxvZygyKTtcbiAgICB0LnJhbmdlU2hpZnQgPSB0LnNlZ0NvdW50WDIgLSB0LnNlYXJjaFJhbmdlO1xuXG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoZW5kQ291bnRzKTtcbiAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAncmVzZXJ2ZWRQYWQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9KTtcbiAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChzdGFydENvdW50cyk7XG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoaWREZWx0YXMpO1xuICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGlkUmFuZ2VPZmZzZXRzKTtcbiAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChnbHlwaElkcyk7XG5cbiAgICB0LmNtYXA0TGVuZ3RoID0gMTQgKyAvLyBTdWJ0YWJsZSBoZWFkZXJcbiAgICAgICAgZW5kQ291bnRzLmxlbmd0aCAqIDIgK1xuICAgICAgICAyICsgLy8gcmVzZXJ2ZWRQYWRcbiAgICAgICAgc3RhcnRDb3VudHMubGVuZ3RoICogMiArXG4gICAgICAgIGlkRGVsdGFzLmxlbmd0aCAqIDIgK1xuICAgICAgICBpZFJhbmdlT2Zmc2V0cy5sZW5ndGggKiAyICtcbiAgICAgICAgZ2x5cGhJZHMubGVuZ3RoICogMjtcblxuICAgIGlmICghaXNQbGFuME9ubHkpIHtcbiAgICAgICAgLy8gQ01BUCAxMiBTdWJ0YWJsZVxuICAgICAgICB2YXIgY21hcDEyTGVuZ3RoID0gMTYgKyAvLyBTdWJ0YWJsZSBoZWFkZXJcbiAgICAgICAgICAgIGNtYXAxMkdyb3Vwcy5sZW5ndGggKiA0O1xuXG4gICAgICAgIHQuY21hcDEyT2Zmc2V0ID0gMTIgKyAoMiAqIDIpICsgNCArIHQuY21hcDRMZW5ndGg7XG4gICAgICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KFtcbiAgICAgICAgICAgIHtuYW1lOiAnY21hcDEyRm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxMn0sXG4gICAgICAgICAgICB7bmFtZTogJ2NtYXAxMlJlc2VydmVkJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAgICAgIHtuYW1lOiAnY21hcDEyTGVuZ3RoJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IGNtYXAxMkxlbmd0aH0sXG4gICAgICAgICAgICB7bmFtZTogJ2NtYXAxMkxhbmd1YWdlJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICAgICAge25hbWU6ICdjbWFwMTJuR3JvdXBzJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IGNtYXAxMkdyb3Vwcy5sZW5ndGggLyAzfVxuICAgICAgICBdKTtcblxuICAgICAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChjbWFwMTJHcm91cHMpO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG52YXIgY21hcCA9IHsgcGFyc2U6IHBhcnNlQ21hcFRhYmxlLCBtYWtlOiBtYWtlQ21hcFRhYmxlIH07XG5cbi8vIEdseXBoIGVuY29kaW5nXG5cbnZhciBjZmZTdGFuZGFyZFN0cmluZ3MgPSBbXG4gICAgJy5ub3RkZWYnLCAnc3BhY2UnLCAnZXhjbGFtJywgJ3F1b3RlZGJsJywgJ251bWJlcnNpZ24nLCAnZG9sbGFyJywgJ3BlcmNlbnQnLCAnYW1wZXJzYW5kJywgJ3F1b3RlcmlnaHQnLFxuICAgICdwYXJlbmxlZnQnLCAncGFyZW5yaWdodCcsICdhc3RlcmlzaycsICdwbHVzJywgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnc2xhc2gnLCAnemVybycsICdvbmUnLCAndHdvJyxcbiAgICAndGhyZWUnLCAnZm91cicsICdmaXZlJywgJ3NpeCcsICdzZXZlbicsICdlaWdodCcsICduaW5lJywgJ2NvbG9uJywgJ3NlbWljb2xvbicsICdsZXNzJywgJ2VxdWFsJywgJ2dyZWF0ZXInLFxuICAgICdxdWVzdGlvbicsICdhdCcsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsICdQJywgJ1EnLCAnUicsICdTJyxcbiAgICAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdicmFja2V0bGVmdCcsICdiYWNrc2xhc2gnLCAnYnJhY2tldHJpZ2h0JywgJ2FzY2lpY2lyY3VtJywgJ3VuZGVyc2NvcmUnLFxuICAgICdxdW90ZWxlZnQnLCAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJywgJ28nLCAncCcsICdxJywgJ3InLCAncycsICd0JyxcbiAgICAndScsICd2JywgJ3cnLCAneCcsICd5JywgJ3onLCAnYnJhY2VsZWZ0JywgJ2JhcicsICdicmFjZXJpZ2h0JywgJ2FzY2lpdGlsZGUnLCAnZXhjbGFtZG93bicsICdjZW50JywgJ3N0ZXJsaW5nJyxcbiAgICAnZnJhY3Rpb24nLCAneWVuJywgJ2Zsb3JpbicsICdzZWN0aW9uJywgJ2N1cnJlbmN5JywgJ3F1b3Rlc2luZ2xlJywgJ3F1b3RlZGJsbGVmdCcsICdndWlsbGVtb3RsZWZ0JyxcbiAgICAnZ3VpbHNpbmdsbGVmdCcsICdndWlsc2luZ2xyaWdodCcsICdmaScsICdmbCcsICdlbmRhc2gnLCAnZGFnZ2VyJywgJ2RhZ2dlcmRibCcsICdwZXJpb2RjZW50ZXJlZCcsICdwYXJhZ3JhcGgnLFxuICAgICdidWxsZXQnLCAncXVvdGVzaW5nbGJhc2UnLCAncXVvdGVkYmxiYXNlJywgJ3F1b3RlZGJscmlnaHQnLCAnZ3VpbGxlbW90cmlnaHQnLCAnZWxsaXBzaXMnLCAncGVydGhvdXNhbmQnLFxuICAgICdxdWVzdGlvbmRvd24nLCAnZ3JhdmUnLCAnYWN1dGUnLCAnY2lyY3VtZmxleCcsICd0aWxkZScsICdtYWNyb24nLCAnYnJldmUnLCAnZG90YWNjZW50JywgJ2RpZXJlc2lzJywgJ3JpbmcnLFxuICAgICdjZWRpbGxhJywgJ2h1bmdhcnVtbGF1dCcsICdvZ29uZWsnLCAnY2Fyb24nLCAnZW1kYXNoJywgJ0FFJywgJ29yZGZlbWluaW5lJywgJ0xzbGFzaCcsICdPc2xhc2gnLCAnT0UnLFxuICAgICdvcmRtYXNjdWxpbmUnLCAnYWUnLCAnZG90bGVzc2knLCAnbHNsYXNoJywgJ29zbGFzaCcsICdvZScsICdnZXJtYW5kYmxzJywgJ29uZXN1cGVyaW9yJywgJ2xvZ2ljYWxub3QnLCAnbXUnLFxuICAgICd0cmFkZW1hcmsnLCAnRXRoJywgJ29uZWhhbGYnLCAncGx1c21pbnVzJywgJ1Rob3JuJywgJ29uZXF1YXJ0ZXInLCAnZGl2aWRlJywgJ2Jyb2tlbmJhcicsICdkZWdyZWUnLCAndGhvcm4nLFxuICAgICd0aHJlZXF1YXJ0ZXJzJywgJ3R3b3N1cGVyaW9yJywgJ3JlZ2lzdGVyZWQnLCAnbWludXMnLCAnZXRoJywgJ211bHRpcGx5JywgJ3RocmVlc3VwZXJpb3InLCAnY29weXJpZ2h0JyxcbiAgICAnQWFjdXRlJywgJ0FjaXJjdW1mbGV4JywgJ0FkaWVyZXNpcycsICdBZ3JhdmUnLCAnQXJpbmcnLCAnQXRpbGRlJywgJ0NjZWRpbGxhJywgJ0VhY3V0ZScsICdFY2lyY3VtZmxleCcsXG4gICAgJ0VkaWVyZXNpcycsICdFZ3JhdmUnLCAnSWFjdXRlJywgJ0ljaXJjdW1mbGV4JywgJ0lkaWVyZXNpcycsICdJZ3JhdmUnLCAnTnRpbGRlJywgJ09hY3V0ZScsICdPY2lyY3VtZmxleCcsXG4gICAgJ09kaWVyZXNpcycsICdPZ3JhdmUnLCAnT3RpbGRlJywgJ1NjYXJvbicsICdVYWN1dGUnLCAnVWNpcmN1bWZsZXgnLCAnVWRpZXJlc2lzJywgJ1VncmF2ZScsICdZYWN1dGUnLFxuICAgICdZZGllcmVzaXMnLCAnWmNhcm9uJywgJ2FhY3V0ZScsICdhY2lyY3VtZmxleCcsICdhZGllcmVzaXMnLCAnYWdyYXZlJywgJ2FyaW5nJywgJ2F0aWxkZScsICdjY2VkaWxsYScsICdlYWN1dGUnLFxuICAgICdlY2lyY3VtZmxleCcsICdlZGllcmVzaXMnLCAnZWdyYXZlJywgJ2lhY3V0ZScsICdpY2lyY3VtZmxleCcsICdpZGllcmVzaXMnLCAnaWdyYXZlJywgJ250aWxkZScsICdvYWN1dGUnLFxuICAgICdvY2lyY3VtZmxleCcsICdvZGllcmVzaXMnLCAnb2dyYXZlJywgJ290aWxkZScsICdzY2Fyb24nLCAndWFjdXRlJywgJ3VjaXJjdW1mbGV4JywgJ3VkaWVyZXNpcycsICd1Z3JhdmUnLFxuICAgICd5YWN1dGUnLCAneWRpZXJlc2lzJywgJ3pjYXJvbicsICdleGNsYW1zbWFsbCcsICdIdW5nYXJ1bWxhdXRzbWFsbCcsICdkb2xsYXJvbGRzdHlsZScsICdkb2xsYXJzdXBlcmlvcicsXG4gICAgJ2FtcGVyc2FuZHNtYWxsJywgJ0FjdXRlc21hbGwnLCAncGFyZW5sZWZ0c3VwZXJpb3InLCAncGFyZW5yaWdodHN1cGVyaW9yJywgJzI2NiBmZicsICdvbmVkb3RlbmxlYWRlcicsXG4gICAgJ3plcm9vbGRzdHlsZScsICdvbmVvbGRzdHlsZScsICd0d29vbGRzdHlsZScsICd0aHJlZW9sZHN0eWxlJywgJ2ZvdXJvbGRzdHlsZScsICdmaXZlb2xkc3R5bGUnLCAnc2l4b2xkc3R5bGUnLFxuICAgICdzZXZlbm9sZHN0eWxlJywgJ2VpZ2h0b2xkc3R5bGUnLCAnbmluZW9sZHN0eWxlJywgJ2NvbW1hc3VwZXJpb3InLCAndGhyZWVxdWFydGVyc2VtZGFzaCcsICdwZXJpb2RzdXBlcmlvcicsXG4gICAgJ3F1ZXN0aW9uc21hbGwnLCAnYXN1cGVyaW9yJywgJ2JzdXBlcmlvcicsICdjZW50c3VwZXJpb3InLCAnZHN1cGVyaW9yJywgJ2VzdXBlcmlvcicsICdpc3VwZXJpb3InLCAnbHN1cGVyaW9yJyxcbiAgICAnbXN1cGVyaW9yJywgJ25zdXBlcmlvcicsICdvc3VwZXJpb3InLCAncnN1cGVyaW9yJywgJ3NzdXBlcmlvcicsICd0c3VwZXJpb3InLCAnZmYnLCAnZmZpJywgJ2ZmbCcsXG4gICAgJ3BhcmVubGVmdGluZmVyaW9yJywgJ3BhcmVucmlnaHRpbmZlcmlvcicsICdDaXJjdW1mbGV4c21hbGwnLCAnaHlwaGVuc3VwZXJpb3InLCAnR3JhdmVzbWFsbCcsICdBc21hbGwnLFxuICAgICdCc21hbGwnLCAnQ3NtYWxsJywgJ0RzbWFsbCcsICdFc21hbGwnLCAnRnNtYWxsJywgJ0dzbWFsbCcsICdIc21hbGwnLCAnSXNtYWxsJywgJ0pzbWFsbCcsICdLc21hbGwnLCAnTHNtYWxsJyxcbiAgICAnTXNtYWxsJywgJ05zbWFsbCcsICdPc21hbGwnLCAnUHNtYWxsJywgJ1FzbWFsbCcsICdSc21hbGwnLCAnU3NtYWxsJywgJ1RzbWFsbCcsICdVc21hbGwnLCAnVnNtYWxsJywgJ1dzbWFsbCcsXG4gICAgJ1hzbWFsbCcsICdZc21hbGwnLCAnWnNtYWxsJywgJ2NvbG9ubW9uZXRhcnknLCAnb25lZml0dGVkJywgJ3J1cGlhaCcsICdUaWxkZXNtYWxsJywgJ2V4Y2xhbWRvd25zbWFsbCcsXG4gICAgJ2NlbnRvbGRzdHlsZScsICdMc2xhc2hzbWFsbCcsICdTY2Fyb25zbWFsbCcsICdaY2Fyb25zbWFsbCcsICdEaWVyZXNpc3NtYWxsJywgJ0JyZXZlc21hbGwnLCAnQ2Fyb25zbWFsbCcsXG4gICAgJ0RvdGFjY2VudHNtYWxsJywgJ01hY3JvbnNtYWxsJywgJ2ZpZ3VyZWRhc2gnLCAnaHlwaGVuaW5mZXJpb3InLCAnT2dvbmVrc21hbGwnLCAnUmluZ3NtYWxsJywgJ0NlZGlsbGFzbWFsbCcsXG4gICAgJ3F1ZXN0aW9uZG93bnNtYWxsJywgJ29uZWVpZ2h0aCcsICd0aHJlZWVpZ2h0aHMnLCAnZml2ZWVpZ2h0aHMnLCAnc2V2ZW5laWdodGhzJywgJ29uZXRoaXJkJywgJ3R3b3RoaXJkcycsXG4gICAgJ3plcm9zdXBlcmlvcicsICdmb3Vyc3VwZXJpb3InLCAnZml2ZXN1cGVyaW9yJywgJ3NpeHN1cGVyaW9yJywgJ3NldmVuc3VwZXJpb3InLCAnZWlnaHRzdXBlcmlvcicsICduaW5lc3VwZXJpb3InLFxuICAgICd6ZXJvaW5mZXJpb3InLCAnb25laW5mZXJpb3InLCAndHdvaW5mZXJpb3InLCAndGhyZWVpbmZlcmlvcicsICdmb3VyaW5mZXJpb3InLCAnZml2ZWluZmVyaW9yJywgJ3NpeGluZmVyaW9yJyxcbiAgICAnc2V2ZW5pbmZlcmlvcicsICdlaWdodGluZmVyaW9yJywgJ25pbmVpbmZlcmlvcicsICdjZW50aW5mZXJpb3InLCAnZG9sbGFyaW5mZXJpb3InLCAncGVyaW9kaW5mZXJpb3InLFxuICAgICdjb21tYWluZmVyaW9yJywgJ0FncmF2ZXNtYWxsJywgJ0FhY3V0ZXNtYWxsJywgJ0FjaXJjdW1mbGV4c21hbGwnLCAnQXRpbGRlc21hbGwnLCAnQWRpZXJlc2lzc21hbGwnLFxuICAgICdBcmluZ3NtYWxsJywgJ0FFc21hbGwnLCAnQ2NlZGlsbGFzbWFsbCcsICdFZ3JhdmVzbWFsbCcsICdFYWN1dGVzbWFsbCcsICdFY2lyY3VtZmxleHNtYWxsJywgJ0VkaWVyZXNpc3NtYWxsJyxcbiAgICAnSWdyYXZlc21hbGwnLCAnSWFjdXRlc21hbGwnLCAnSWNpcmN1bWZsZXhzbWFsbCcsICdJZGllcmVzaXNzbWFsbCcsICdFdGhzbWFsbCcsICdOdGlsZGVzbWFsbCcsICdPZ3JhdmVzbWFsbCcsXG4gICAgJ09hY3V0ZXNtYWxsJywgJ09jaXJjdW1mbGV4c21hbGwnLCAnT3RpbGRlc21hbGwnLCAnT2RpZXJlc2lzc21hbGwnLCAnT0VzbWFsbCcsICdPc2xhc2hzbWFsbCcsICdVZ3JhdmVzbWFsbCcsXG4gICAgJ1VhY3V0ZXNtYWxsJywgJ1VjaXJjdW1mbGV4c21hbGwnLCAnVWRpZXJlc2lzc21hbGwnLCAnWWFjdXRlc21hbGwnLCAnVGhvcm5zbWFsbCcsICdZZGllcmVzaXNzbWFsbCcsICcwMDEuMDAwJyxcbiAgICAnMDAxLjAwMScsICcwMDEuMDAyJywgJzAwMS4wMDMnLCAnQmxhY2snLCAnQm9sZCcsICdCb29rJywgJ0xpZ2h0JywgJ01lZGl1bScsICdSZWd1bGFyJywgJ1JvbWFuJywgJ1NlbWlib2xkJ107XG5cbnZhciBjZmZTdGFuZGFyZEVuY29kaW5nID0gW1xuICAgICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICcnLCAnJywgJycsICcnLCAnc3BhY2UnLCAnZXhjbGFtJywgJ3F1b3RlZGJsJywgJ251bWJlcnNpZ24nLCAnZG9sbGFyJywgJ3BlcmNlbnQnLCAnYW1wZXJzYW5kJywgJ3F1b3RlcmlnaHQnLFxuICAgICdwYXJlbmxlZnQnLCAncGFyZW5yaWdodCcsICdhc3RlcmlzaycsICdwbHVzJywgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnc2xhc2gnLCAnemVybycsICdvbmUnLCAndHdvJyxcbiAgICAndGhyZWUnLCAnZm91cicsICdmaXZlJywgJ3NpeCcsICdzZXZlbicsICdlaWdodCcsICduaW5lJywgJ2NvbG9uJywgJ3NlbWljb2xvbicsICdsZXNzJywgJ2VxdWFsJywgJ2dyZWF0ZXInLFxuICAgICdxdWVzdGlvbicsICdhdCcsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsICdQJywgJ1EnLCAnUicsICdTJyxcbiAgICAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdicmFja2V0bGVmdCcsICdiYWNrc2xhc2gnLCAnYnJhY2tldHJpZ2h0JywgJ2FzY2lpY2lyY3VtJywgJ3VuZGVyc2NvcmUnLFxuICAgICdxdW90ZWxlZnQnLCAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJywgJ28nLCAncCcsICdxJywgJ3InLCAncycsICd0JyxcbiAgICAndScsICd2JywgJ3cnLCAneCcsICd5JywgJ3onLCAnYnJhY2VsZWZ0JywgJ2JhcicsICdicmFjZXJpZ2h0JywgJ2FzY2lpdGlsZGUnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICdleGNsYW1kb3duJywgJ2NlbnQnLCAnc3RlcmxpbmcnLCAnZnJhY3Rpb24nLCAneWVuJywgJ2Zsb3JpbicsICdzZWN0aW9uJywgJ2N1cnJlbmN5JywgJ3F1b3Rlc2luZ2xlJyxcbiAgICAncXVvdGVkYmxsZWZ0JywgJ2d1aWxsZW1vdGxlZnQnLCAnZ3VpbHNpbmdsbGVmdCcsICdndWlsc2luZ2xyaWdodCcsICdmaScsICdmbCcsICcnLCAnZW5kYXNoJywgJ2RhZ2dlcicsXG4gICAgJ2RhZ2dlcmRibCcsICdwZXJpb2RjZW50ZXJlZCcsICcnLCAncGFyYWdyYXBoJywgJ2J1bGxldCcsICdxdW90ZXNpbmdsYmFzZScsICdxdW90ZWRibGJhc2UnLCAncXVvdGVkYmxyaWdodCcsXG4gICAgJ2d1aWxsZW1vdHJpZ2h0JywgJ2VsbGlwc2lzJywgJ3BlcnRob3VzYW5kJywgJycsICdxdWVzdGlvbmRvd24nLCAnJywgJ2dyYXZlJywgJ2FjdXRlJywgJ2NpcmN1bWZsZXgnLCAndGlsZGUnLFxuICAgICdtYWNyb24nLCAnYnJldmUnLCAnZG90YWNjZW50JywgJ2RpZXJlc2lzJywgJycsICdyaW5nJywgJ2NlZGlsbGEnLCAnJywgJ2h1bmdhcnVtbGF1dCcsICdvZ29uZWsnLCAnY2Fyb24nLFxuICAgICdlbWRhc2gnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJ0FFJywgJycsICdvcmRmZW1pbmluZScsICcnLCAnJywgJycsXG4gICAgJycsICdMc2xhc2gnLCAnT3NsYXNoJywgJ09FJywgJ29yZG1hc2N1bGluZScsICcnLCAnJywgJycsICcnLCAnJywgJ2FlJywgJycsICcnLCAnJywgJ2RvdGxlc3NpJywgJycsICcnLFxuICAgICdsc2xhc2gnLCAnb3NsYXNoJywgJ29lJywgJ2dlcm1hbmRibHMnXTtcblxudmFyIGNmZkV4cGVydEVuY29kaW5nID0gW1xuICAgICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICcnLCAnJywgJycsICcnLCAnc3BhY2UnLCAnZXhjbGFtc21hbGwnLCAnSHVuZ2FydW1sYXV0c21hbGwnLCAnJywgJ2RvbGxhcm9sZHN0eWxlJywgJ2RvbGxhcnN1cGVyaW9yJyxcbiAgICAnYW1wZXJzYW5kc21hbGwnLCAnQWN1dGVzbWFsbCcsICdwYXJlbmxlZnRzdXBlcmlvcicsICdwYXJlbnJpZ2h0c3VwZXJpb3InLCAndHdvZG90ZW5sZWFkZXInLCAnb25lZG90ZW5sZWFkZXInLFxuICAgICdjb21tYScsICdoeXBoZW4nLCAncGVyaW9kJywgJ2ZyYWN0aW9uJywgJ3plcm9vbGRzdHlsZScsICdvbmVvbGRzdHlsZScsICd0d29vbGRzdHlsZScsICd0aHJlZW9sZHN0eWxlJyxcbiAgICAnZm91cm9sZHN0eWxlJywgJ2ZpdmVvbGRzdHlsZScsICdzaXhvbGRzdHlsZScsICdzZXZlbm9sZHN0eWxlJywgJ2VpZ2h0b2xkc3R5bGUnLCAnbmluZW9sZHN0eWxlJywgJ2NvbG9uJyxcbiAgICAnc2VtaWNvbG9uJywgJ2NvbW1hc3VwZXJpb3InLCAndGhyZWVxdWFydGVyc2VtZGFzaCcsICdwZXJpb2RzdXBlcmlvcicsICdxdWVzdGlvbnNtYWxsJywgJycsICdhc3VwZXJpb3InLFxuICAgICdic3VwZXJpb3InLCAnY2VudHN1cGVyaW9yJywgJ2RzdXBlcmlvcicsICdlc3VwZXJpb3InLCAnJywgJycsICdpc3VwZXJpb3InLCAnJywgJycsICdsc3VwZXJpb3InLCAnbXN1cGVyaW9yJyxcbiAgICAnbnN1cGVyaW9yJywgJ29zdXBlcmlvcicsICcnLCAnJywgJ3JzdXBlcmlvcicsICdzc3VwZXJpb3InLCAndHN1cGVyaW9yJywgJycsICdmZicsICdmaScsICdmbCcsICdmZmknLCAnZmZsJyxcbiAgICAncGFyZW5sZWZ0aW5mZXJpb3InLCAnJywgJ3BhcmVucmlnaHRpbmZlcmlvcicsICdDaXJjdW1mbGV4c21hbGwnLCAnaHlwaGVuc3VwZXJpb3InLCAnR3JhdmVzbWFsbCcsICdBc21hbGwnLFxuICAgICdCc21hbGwnLCAnQ3NtYWxsJywgJ0RzbWFsbCcsICdFc21hbGwnLCAnRnNtYWxsJywgJ0dzbWFsbCcsICdIc21hbGwnLCAnSXNtYWxsJywgJ0pzbWFsbCcsICdLc21hbGwnLCAnTHNtYWxsJyxcbiAgICAnTXNtYWxsJywgJ05zbWFsbCcsICdPc21hbGwnLCAnUHNtYWxsJywgJ1FzbWFsbCcsICdSc21hbGwnLCAnU3NtYWxsJywgJ1RzbWFsbCcsICdVc21hbGwnLCAnVnNtYWxsJywgJ1dzbWFsbCcsXG4gICAgJ1hzbWFsbCcsICdZc21hbGwnLCAnWnNtYWxsJywgJ2NvbG9ubW9uZXRhcnknLCAnb25lZml0dGVkJywgJ3J1cGlhaCcsICdUaWxkZXNtYWxsJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnZXhjbGFtZG93bnNtYWxsJywgJ2NlbnRvbGRzdHlsZScsICdMc2xhc2hzbWFsbCcsICcnLCAnJywgJ1NjYXJvbnNtYWxsJywgJ1pjYXJvbnNtYWxsJywgJ0RpZXJlc2lzc21hbGwnLFxuICAgICdCcmV2ZXNtYWxsJywgJ0Nhcm9uc21hbGwnLCAnJywgJ0RvdGFjY2VudHNtYWxsJywgJycsICcnLCAnTWFjcm9uc21hbGwnLCAnJywgJycsICdmaWd1cmVkYXNoJywgJ2h5cGhlbmluZmVyaW9yJyxcbiAgICAnJywgJycsICdPZ29uZWtzbWFsbCcsICdSaW5nc21hbGwnLCAnQ2VkaWxsYXNtYWxsJywgJycsICcnLCAnJywgJ29uZXF1YXJ0ZXInLCAnb25laGFsZicsICd0aHJlZXF1YXJ0ZXJzJyxcbiAgICAncXVlc3Rpb25kb3duc21hbGwnLCAnb25lZWlnaHRoJywgJ3RocmVlZWlnaHRocycsICdmaXZlZWlnaHRocycsICdzZXZlbmVpZ2h0aHMnLCAnb25ldGhpcmQnLCAndHdvdGhpcmRzJywgJycsXG4gICAgJycsICd6ZXJvc3VwZXJpb3InLCAnb25lc3VwZXJpb3InLCAndHdvc3VwZXJpb3InLCAndGhyZWVzdXBlcmlvcicsICdmb3Vyc3VwZXJpb3InLCAnZml2ZXN1cGVyaW9yJyxcbiAgICAnc2l4c3VwZXJpb3InLCAnc2V2ZW5zdXBlcmlvcicsICdlaWdodHN1cGVyaW9yJywgJ25pbmVzdXBlcmlvcicsICd6ZXJvaW5mZXJpb3InLCAnb25laW5mZXJpb3InLCAndHdvaW5mZXJpb3InLFxuICAgICd0aHJlZWluZmVyaW9yJywgJ2ZvdXJpbmZlcmlvcicsICdmaXZlaW5mZXJpb3InLCAnc2l4aW5mZXJpb3InLCAnc2V2ZW5pbmZlcmlvcicsICdlaWdodGluZmVyaW9yJyxcbiAgICAnbmluZWluZmVyaW9yJywgJ2NlbnRpbmZlcmlvcicsICdkb2xsYXJpbmZlcmlvcicsICdwZXJpb2RpbmZlcmlvcicsICdjb21tYWluZmVyaW9yJywgJ0FncmF2ZXNtYWxsJyxcbiAgICAnQWFjdXRlc21hbGwnLCAnQWNpcmN1bWZsZXhzbWFsbCcsICdBdGlsZGVzbWFsbCcsICdBZGllcmVzaXNzbWFsbCcsICdBcmluZ3NtYWxsJywgJ0FFc21hbGwnLCAnQ2NlZGlsbGFzbWFsbCcsXG4gICAgJ0VncmF2ZXNtYWxsJywgJ0VhY3V0ZXNtYWxsJywgJ0VjaXJjdW1mbGV4c21hbGwnLCAnRWRpZXJlc2lzc21hbGwnLCAnSWdyYXZlc21hbGwnLCAnSWFjdXRlc21hbGwnLFxuICAgICdJY2lyY3VtZmxleHNtYWxsJywgJ0lkaWVyZXNpc3NtYWxsJywgJ0V0aHNtYWxsJywgJ050aWxkZXNtYWxsJywgJ09ncmF2ZXNtYWxsJywgJ09hY3V0ZXNtYWxsJyxcbiAgICAnT2NpcmN1bWZsZXhzbWFsbCcsICdPdGlsZGVzbWFsbCcsICdPZGllcmVzaXNzbWFsbCcsICdPRXNtYWxsJywgJ09zbGFzaHNtYWxsJywgJ1VncmF2ZXNtYWxsJywgJ1VhY3V0ZXNtYWxsJyxcbiAgICAnVWNpcmN1bWZsZXhzbWFsbCcsICdVZGllcmVzaXNzbWFsbCcsICdZYWN1dGVzbWFsbCcsICdUaG9ybnNtYWxsJywgJ1lkaWVyZXNpc3NtYWxsJ107XG5cbnZhciBzdGFuZGFyZE5hbWVzID0gW1xuICAgICcubm90ZGVmJywgJy5udWxsJywgJ25vbm1hcmtpbmdyZXR1cm4nLCAnc3BhY2UnLCAnZXhjbGFtJywgJ3F1b3RlZGJsJywgJ251bWJlcnNpZ24nLCAnZG9sbGFyJywgJ3BlcmNlbnQnLFxuICAgICdhbXBlcnNhbmQnLCAncXVvdGVzaW5nbGUnLCAncGFyZW5sZWZ0JywgJ3BhcmVucmlnaHQnLCAnYXN0ZXJpc2snLCAncGx1cycsICdjb21tYScsICdoeXBoZW4nLCAncGVyaW9kJywgJ3NsYXNoJyxcbiAgICAnemVybycsICdvbmUnLCAndHdvJywgJ3RocmVlJywgJ2ZvdXInLCAnZml2ZScsICdzaXgnLCAnc2V2ZW4nLCAnZWlnaHQnLCAnbmluZScsICdjb2xvbicsICdzZW1pY29sb24nLCAnbGVzcycsXG4gICAgJ2VxdWFsJywgJ2dyZWF0ZXInLCAncXVlc3Rpb24nLCAnYXQnLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnRycsICdIJywgJ0knLCAnSicsICdLJywgJ0wnLCAnTScsICdOJywgJ08nLFxuICAgICdQJywgJ1EnLCAnUicsICdTJywgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onLCAnYnJhY2tldGxlZnQnLCAnYmFja3NsYXNoJywgJ2JyYWNrZXRyaWdodCcsXG4gICAgJ2FzY2lpY2lyY3VtJywgJ3VuZGVyc2NvcmUnLCAnZ3JhdmUnLCAnYScsICdiJywgJ2MnLCAnZCcsICdlJywgJ2YnLCAnZycsICdoJywgJ2knLCAnaicsICdrJywgJ2wnLCAnbScsICduJywgJ28nLFxuICAgICdwJywgJ3EnLCAncicsICdzJywgJ3QnLCAndScsICd2JywgJ3cnLCAneCcsICd5JywgJ3onLCAnYnJhY2VsZWZ0JywgJ2JhcicsICdicmFjZXJpZ2h0JywgJ2FzY2lpdGlsZGUnLFxuICAgICdBZGllcmVzaXMnLCAnQXJpbmcnLCAnQ2NlZGlsbGEnLCAnRWFjdXRlJywgJ050aWxkZScsICdPZGllcmVzaXMnLCAnVWRpZXJlc2lzJywgJ2FhY3V0ZScsICdhZ3JhdmUnLFxuICAgICdhY2lyY3VtZmxleCcsICdhZGllcmVzaXMnLCAnYXRpbGRlJywgJ2FyaW5nJywgJ2NjZWRpbGxhJywgJ2VhY3V0ZScsICdlZ3JhdmUnLCAnZWNpcmN1bWZsZXgnLCAnZWRpZXJlc2lzJyxcbiAgICAnaWFjdXRlJywgJ2lncmF2ZScsICdpY2lyY3VtZmxleCcsICdpZGllcmVzaXMnLCAnbnRpbGRlJywgJ29hY3V0ZScsICdvZ3JhdmUnLCAnb2NpcmN1bWZsZXgnLCAnb2RpZXJlc2lzJyxcbiAgICAnb3RpbGRlJywgJ3VhY3V0ZScsICd1Z3JhdmUnLCAndWNpcmN1bWZsZXgnLCAndWRpZXJlc2lzJywgJ2RhZ2dlcicsICdkZWdyZWUnLCAnY2VudCcsICdzdGVybGluZycsICdzZWN0aW9uJyxcbiAgICAnYnVsbGV0JywgJ3BhcmFncmFwaCcsICdnZXJtYW5kYmxzJywgJ3JlZ2lzdGVyZWQnLCAnY29weXJpZ2h0JywgJ3RyYWRlbWFyaycsICdhY3V0ZScsICdkaWVyZXNpcycsICdub3RlcXVhbCcsXG4gICAgJ0FFJywgJ09zbGFzaCcsICdpbmZpbml0eScsICdwbHVzbWludXMnLCAnbGVzc2VxdWFsJywgJ2dyZWF0ZXJlcXVhbCcsICd5ZW4nLCAnbXUnLCAncGFydGlhbGRpZmYnLCAnc3VtbWF0aW9uJyxcbiAgICAncHJvZHVjdCcsICdwaScsICdpbnRlZ3JhbCcsICdvcmRmZW1pbmluZScsICdvcmRtYXNjdWxpbmUnLCAnT21lZ2EnLCAnYWUnLCAnb3NsYXNoJywgJ3F1ZXN0aW9uZG93bicsXG4gICAgJ2V4Y2xhbWRvd24nLCAnbG9naWNhbG5vdCcsICdyYWRpY2FsJywgJ2Zsb3JpbicsICdhcHByb3hlcXVhbCcsICdEZWx0YScsICdndWlsbGVtb3RsZWZ0JywgJ2d1aWxsZW1vdHJpZ2h0JyxcbiAgICAnZWxsaXBzaXMnLCAnbm9uYnJlYWtpbmdzcGFjZScsICdBZ3JhdmUnLCAnQXRpbGRlJywgJ090aWxkZScsICdPRScsICdvZScsICdlbmRhc2gnLCAnZW1kYXNoJywgJ3F1b3RlZGJsbGVmdCcsXG4gICAgJ3F1b3RlZGJscmlnaHQnLCAncXVvdGVsZWZ0JywgJ3F1b3RlcmlnaHQnLCAnZGl2aWRlJywgJ2xvemVuZ2UnLCAneWRpZXJlc2lzJywgJ1lkaWVyZXNpcycsICdmcmFjdGlvbicsXG4gICAgJ2N1cnJlbmN5JywgJ2d1aWxzaW5nbGxlZnQnLCAnZ3VpbHNpbmdscmlnaHQnLCAnZmknLCAnZmwnLCAnZGFnZ2VyZGJsJywgJ3BlcmlvZGNlbnRlcmVkJywgJ3F1b3Rlc2luZ2xiYXNlJyxcbiAgICAncXVvdGVkYmxiYXNlJywgJ3BlcnRob3VzYW5kJywgJ0FjaXJjdW1mbGV4JywgJ0VjaXJjdW1mbGV4JywgJ0FhY3V0ZScsICdFZGllcmVzaXMnLCAnRWdyYXZlJywgJ0lhY3V0ZScsXG4gICAgJ0ljaXJjdW1mbGV4JywgJ0lkaWVyZXNpcycsICdJZ3JhdmUnLCAnT2FjdXRlJywgJ09jaXJjdW1mbGV4JywgJ2FwcGxlJywgJ09ncmF2ZScsICdVYWN1dGUnLCAnVWNpcmN1bWZsZXgnLFxuICAgICdVZ3JhdmUnLCAnZG90bGVzc2knLCAnY2lyY3VtZmxleCcsICd0aWxkZScsICdtYWNyb24nLCAnYnJldmUnLCAnZG90YWNjZW50JywgJ3JpbmcnLCAnY2VkaWxsYScsICdodW5nYXJ1bWxhdXQnLFxuICAgICdvZ29uZWsnLCAnY2Fyb24nLCAnTHNsYXNoJywgJ2xzbGFzaCcsICdTY2Fyb24nLCAnc2Nhcm9uJywgJ1pjYXJvbicsICd6Y2Fyb24nLCAnYnJva2VuYmFyJywgJ0V0aCcsICdldGgnLFxuICAgICdZYWN1dGUnLCAneWFjdXRlJywgJ1Rob3JuJywgJ3Rob3JuJywgJ21pbnVzJywgJ211bHRpcGx5JywgJ29uZXN1cGVyaW9yJywgJ3R3b3N1cGVyaW9yJywgJ3RocmVlc3VwZXJpb3InLFxuICAgICdvbmVoYWxmJywgJ29uZXF1YXJ0ZXInLCAndGhyZWVxdWFydGVycycsICdmcmFuYycsICdHYnJldmUnLCAnZ2JyZXZlJywgJ0lkb3RhY2NlbnQnLCAnU2NlZGlsbGEnLCAnc2NlZGlsbGEnLFxuICAgICdDYWN1dGUnLCAnY2FjdXRlJywgJ0NjYXJvbicsICdjY2Fyb24nLCAnZGNyb2F0J107XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgZW5jb2RpbmcgdXNlZCBmb3IgZm9udHMgY3JlYXRlZCBmcm9tIHNjcmF0Y2guXG4gKiBJdCBsb29wcyB0aHJvdWdoIGFsbCBnbHlwaHMgYW5kIGZpbmRzIHRoZSBhcHByb3ByaWF0ZSB1bmljb2RlIHZhbHVlLlxuICogU2luY2UgaXQncyBsaW5lYXIgdGltZSwgb3RoZXIgZW5jb2RpbmdzIHdpbGwgYmUgZmFzdGVyLlxuICogQGV4cG9ydHMgb3BlbnR5cGUuRGVmYXVsdEVuY29kaW5nXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuICovXG5mdW5jdGlvbiBEZWZhdWx0RW5jb2RpbmcoZm9udCkge1xuICAgIHRoaXMuZm9udCA9IGZvbnQ7XG59XG5cbkRlZmF1bHRFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKGMpIHtcbiAgICB2YXIgY29kZSA9IGMuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgZ2x5cGhzID0gdGhpcy5mb250LmdseXBocztcbiAgICBpZiAoZ2x5cGhzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHMuZ2V0KGkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbHlwaC51bmljb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChnbHlwaC51bmljb2Rlc1tqXSA9PT0gY29kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkNtYXBFbmNvZGluZ1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBjbWFwIC0gYSBvYmplY3Qgd2l0aCB0aGUgY21hcCBlbmNvZGVkIGRhdGFcbiAqL1xuZnVuY3Rpb24gQ21hcEVuY29kaW5nKGNtYXApIHtcbiAgICB0aGlzLmNtYXAgPSBjbWFwO1xufVxuXG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30gYyAtIHRoZSBjaGFyYWN0ZXJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGdseXBoIGluZGV4LlxuICovXG5DbWFwRW5jb2RpbmcucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIHRoaXMuY21hcC5nbHlwaEluZGV4TWFwW2MuY2hhckNvZGVBdCgwKV0gfHwgMDtcbn07XG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuQ2ZmRW5jb2RpbmdcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmcgLSBUaGUgZW5jb2RpbmdcbiAqIEBwYXJhbSB7QXJyYXl9IGNoYXJzZXQgLSBUaGUgY2hhcmFjdGVyIHNldC5cbiAqL1xuZnVuY3Rpb24gQ2ZmRW5jb2RpbmcoZW5jb2RpbmcsIGNoYXJzZXQpIHtcbiAgICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgdGhpcy5jaGFyc2V0ID0gY2hhcnNldDtcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHMgLSBUaGUgY2hhcmFjdGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleC5cbiAqL1xuQ2ZmRW5jb2RpbmcucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbihzKSB7XG4gICAgdmFyIGNvZGUgPSBzLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGNoYXJOYW1lID0gdGhpcy5lbmNvZGluZ1tjb2RlXTtcbiAgICByZXR1cm4gdGhpcy5jaGFyc2V0LmluZGV4T2YoY2hhck5hbWUpO1xufTtcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5HbHlwaE5hbWVzXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IHBvc3RcbiAqL1xuZnVuY3Rpb24gR2x5cGhOYW1lcyhwb3N0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBzd2l0Y2ggKHBvc3QudmVyc2lvbikge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICB0aGlzLm5hbWVzID0gc3RhbmRhcmROYW1lcy5zbGljZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHRoaXMubmFtZXMgPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChwb3N0LmdseXBoTmFtZUluZGV4W2ldIDwgc3RhbmRhcmROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcyQxLm5hbWVzW2ldID0gc3RhbmRhcmROYW1lc1twb3N0LmdseXBoTmFtZUluZGV4W2ldXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzJDEubmFtZXNbaV0gPSBwb3N0Lm5hbWVzW3Bvc3QuZ2x5cGhOYW1lSW5kZXhbaV0gLSBzdGFuZGFyZE5hbWVzLmxlbmd0aF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyLjU6XG4gICAgICAgICAgICB0aGlzLm5hbWVzID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzJDEubmFtZXNbaSQxXSA9IHN0YW5kYXJkTmFtZXNbaSQxICsgcG9zdC5nbHlwaE5hbWVJbmRleFtpJDFdXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMubmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy5uYW1lcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IG9mIGEgZ2x5cGggYnkgbmFtZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSAtIFRoZSBnbHlwaCBuYW1lXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleFxuICovXG5HbHlwaE5hbWVzLnByb3RvdHlwZS5uYW1lVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm5hbWVzLmluZGV4T2YobmFtZSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0gZ2lkXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbkdseXBoTmFtZXMucHJvdG90eXBlLmdseXBoSW5kZXhUb05hbWUgPSBmdW5jdGlvbihnaWQpIHtcbiAgICByZXR1cm4gdGhpcy5uYW1lc1tnaWRdO1xufTtcblxuLyoqXG4gKiBAYWxpYXMgb3BlbnR5cGUuYWRkR2x5cGhOYW1lc1xuICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuICovXG5mdW5jdGlvbiBhZGRHbHlwaE5hbWVzKGZvbnQpIHtcbiAgICB2YXIgZ2x5cGg7XG4gICAgdmFyIGdseXBoSW5kZXhNYXAgPSBmb250LnRhYmxlcy5jbWFwLmdseXBoSW5kZXhNYXA7XG4gICAgdmFyIGNoYXJDb2RlcyA9IE9iamVjdC5rZXlzKGdseXBoSW5kZXhNYXApO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFyQ29kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSBjaGFyQ29kZXNbaV07XG4gICAgICAgIHZhciBnbHlwaEluZGV4ID0gZ2x5cGhJbmRleE1hcFtjXTtcbiAgICAgICAgZ2x5cGggPSBmb250LmdseXBocy5nZXQoZ2x5cGhJbmRleCk7XG4gICAgICAgIGdseXBoLmFkZFVuaWNvZGUocGFyc2VJbnQoYykpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGZvbnQuZ2x5cGhzLmxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgZ2x5cGggPSBmb250LmdseXBocy5nZXQoaSQxKTtcbiAgICAgICAgaWYgKGZvbnQuY2ZmRW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGlmIChmb250LmlzQ0lERm9udCkge1xuICAgICAgICAgICAgICAgIGdseXBoLm5hbWUgPSAnZ2lkJyArIGkkMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2x5cGgubmFtZSA9IGZvbnQuY2ZmRW5jb2RpbmcuY2hhcnNldFtpJDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZvbnQuZ2x5cGhOYW1lcy5uYW1lcykge1xuICAgICAgICAgICAgZ2x5cGgubmFtZSA9IGZvbnQuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKGkkMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIERyYXdpbmcgdXRpbGl0eSBmdW5jdGlvbnMuXG5cbi8vIERyYXcgYSBsaW5lIG9uIHRoZSBnaXZlbiBjb250ZXh0IGZyb20gcG9pbnQgYHgxLHkxYCB0byBwb2ludCBgeDIseTJgLlxuZnVuY3Rpb24gbGluZShjdHgsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgY3R4LnN0cm9rZSgpO1xufVxuXG52YXIgZHJhdyA9IHsgbGluZTogbGluZSB9O1xuXG4vLyBUaGUgYGdseWZgIHRhYmxlIGRlc2NyaWJlcyB0aGUgZ2x5cGhzIGluIFRydWVUeXBlIG91dGxpbmUgZm9ybWF0LlxuLy8gaHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL2dseWYuaHRtXG5cbi8vIFBhcnNlIHRoZSBjb29yZGluYXRlIGRhdGEgZm9yIGEgZ2x5cGguXG5mdW5jdGlvbiBwYXJzZUdseXBoQ29vcmRpbmF0ZShwLCBmbGFnLCBwcmV2aW91c1ZhbHVlLCBzaG9ydFZlY3RvckJpdE1hc2ssIHNhbWVCaXRNYXNrKSB7XG4gICAgdmFyIHY7XG4gICAgaWYgKChmbGFnICYgc2hvcnRWZWN0b3JCaXRNYXNrKSA+IDApIHtcbiAgICAgICAgLy8gVGhlIGNvb3JkaW5hdGUgaXMgMSBieXRlIGxvbmcuXG4gICAgICAgIHYgPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgICAvLyBUaGUgYHNhbWVgIGJpdCBpcyByZS11c2VkIGZvciBzaG9ydCB2YWx1ZXMgdG8gc2lnbmlmeSB0aGUgc2lnbiBvZiB0aGUgdmFsdWUuXG4gICAgICAgIGlmICgoZmxhZyAmIHNhbWVCaXRNYXNrKSA9PT0gMCkge1xuICAgICAgICAgICAgdiA9IC12O1xuICAgICAgICB9XG5cbiAgICAgICAgdiA9IHByZXZpb3VzVmFsdWUgKyB2O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vICBUaGUgY29vcmRpbmF0ZSBpcyAyIGJ5dGVzIGxvbmcuXG4gICAgICAgIC8vIElmIHRoZSBgc2FtZWAgYml0IGlzIHNldCwgdGhlIGNvb3JkaW5hdGUgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIGNvb3JkaW5hdGUuXG4gICAgICAgIGlmICgoZmxhZyAmIHNhbWVCaXRNYXNrKSA+IDApIHtcbiAgICAgICAgICAgIHYgPSBwcmV2aW91c1ZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGNvb3JkaW5hdGUgYXMgYSBzaWduZWQgMTYtYml0IGRlbHRhIHZhbHVlLlxuICAgICAgICAgICAgdiA9IHByZXZpb3VzVmFsdWUgKyBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2O1xufVxuXG4vLyBQYXJzZSBhIFRydWVUeXBlIGdseXBoLlxuZnVuY3Rpb24gcGFyc2VHbHlwaChnbHlwaCwgZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGdseXBoLm51bWJlck9mQ29udG91cnMgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC5feE1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGdseXBoLl95TWluID0gcC5wYXJzZVNob3J0KCk7XG4gICAgZ2x5cGguX3hNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC5feU1heCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHZhciBmbGFncztcbiAgICB2YXIgZmxhZztcblxuICAgIGlmIChnbHlwaC5udW1iZXJPZkNvbnRvdXJzID4gMCkge1xuICAgICAgICAvLyBUaGlzIGdseXBoIGlzIG5vdCBhIGNvbXBvc2l0ZS5cbiAgICAgICAgdmFyIGVuZFBvaW50SW5kaWNlcyA9IGdseXBoLmVuZFBvaW50SW5kaWNlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBoLm51bWJlck9mQ29udG91cnM7IGkgKz0gMSkge1xuICAgICAgICAgICAgZW5kUG9pbnRJbmRpY2VzLnB1c2gocC5wYXJzZVVTaG9ydCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdseXBoLmluc3RydWN0aW9uTGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgZ2x5cGguaW5zdHJ1Y3Rpb25MZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbnMucHVzaChwLnBhcnNlQnl0ZSgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBudW1iZXJPZkNvb3JkaW5hdGVzID0gZW5kUG9pbnRJbmRpY2VzW2VuZFBvaW50SW5kaWNlcy5sZW5ndGggLSAxXSArIDE7XG4gICAgICAgIGZsYWdzID0gW107XG4gICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkkMiArPSAxKSB7XG4gICAgICAgICAgICBmbGFnID0gcC5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgIGZsYWdzLnB1c2goZmxhZyk7XG4gICAgICAgICAgICAvLyBJZiBiaXQgMyBpcyBzZXQsIHdlIHJlcGVhdCB0aGlzIGZsYWcgbiB0aW1lcywgd2hlcmUgbiBpcyB0aGUgbmV4dCBieXRlLlxuICAgICAgICAgICAgaWYgKChmbGFnICYgOCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcGVhdENvdW50ID0gcC5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlcGVhdENvdW50OyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MucHVzaChmbGFnKTtcbiAgICAgICAgICAgICAgICAgICAgaSQyICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2hlY2suYXJndW1lbnQoZmxhZ3MubGVuZ3RoID09PSBudW1iZXJPZkNvb3JkaW5hdGVzLCAnQmFkIGZsYWdzLicpO1xuXG4gICAgICAgIGlmIChlbmRQb2ludEluZGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgdmFyIHBvaW50O1xuICAgICAgICAgICAgLy8gWC9ZIGNvb3JkaW5hdGVzIGFyZSByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgcG9pbnQsIGV4Y2VwdCBmb3IgdGhlIGZpcnN0IHBvaW50IHdoaWNoIGlzIHJlbGF0aXZlIHRvIDAsMC5cbiAgICAgICAgICAgIGlmIChudW1iZXJPZkNvb3JkaW5hdGVzID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkkMyArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmbGFnc1tpJDNdO1xuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBwb2ludC5vbkN1cnZlID0gISEoZmxhZyAmIDEpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludC5sYXN0UG9pbnRPZkNvbnRvdXIgPSBlbmRQb2ludEluZGljZXMuaW5kZXhPZihpJDMpID49IDA7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcHggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkNCA9IDA7IGkkNCA8IG51bWJlck9mQ29vcmRpbmF0ZXM7IGkkNCArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWcgPSBmbGFnc1tpJDRdO1xuICAgICAgICAgICAgICAgICAgICBwb2ludCA9IHBvaW50c1tpJDRdO1xuICAgICAgICAgICAgICAgICAgICBwb2ludC54ID0gcGFyc2VHbHlwaENvb3JkaW5hdGUocCwgZmxhZywgcHgsIDIsIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgcHggPSBwb2ludC54O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBweSA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQ1ID0gMDsgaSQ1IDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSQ1ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2kkNV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0gcG9pbnRzW2kkNV07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnkgPSBwYXJzZUdseXBoQ29vcmRpbmF0ZShwLCBmbGFnLCBweSwgNCwgMzIpO1xuICAgICAgICAgICAgICAgICAgICBweSA9IHBvaW50Lnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbHlwaC5wb2ludHMgPSBwb2ludHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbHlwaC5wb2ludHMgPSBbXTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZ2x5cGgubnVtYmVyT2ZDb250b3VycyA9PT0gMCkge1xuICAgICAgICBnbHlwaC5wb2ludHMgPSBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbHlwaC5pc0NvbXBvc2l0ZSA9IHRydWU7XG4gICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgICAgICBnbHlwaC5jb21wb25lbnRzID0gW107XG4gICAgICAgIHZhciBtb3JlQ29tcG9uZW50cyA9IHRydWU7XG4gICAgICAgIHdoaWxlIChtb3JlQ29tcG9uZW50cykge1xuICAgICAgICAgICAgZmxhZ3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0ge1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXg6IHAucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICB4U2NhbGU6IDEsXG4gICAgICAgICAgICAgICAgc2NhbGUwMTogMCxcbiAgICAgICAgICAgICAgICBzY2FsZTEwOiAwLFxuICAgICAgICAgICAgICAgIHlTY2FsZTogMSxcbiAgICAgICAgICAgICAgICBkeDogMCxcbiAgICAgICAgICAgICAgICBkeTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiAxKSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYXJndW1lbnRzIGFyZSB3b3Jkc1xuICAgICAgICAgICAgICAgIGlmICgoZmxhZ3MgJiAyKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGFyZSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmR4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5keSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBhcmUgbWF0Y2hlZCBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm1hdGNoZWRQb2ludHMgPSBbcC5wYXJzZVVTaG9ydCgpLCBwLnBhcnNlVVNob3J0KCldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYXJndW1lbnRzIGFyZSBieXRlc1xuICAgICAgICAgICAgICAgIGlmICgoZmxhZ3MgJiAyKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGFyZSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmR4ID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmR5ID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIG1hdGNoZWQgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzID0gW3AucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKChmbGFncyAmIDgpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBzY2FsZVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC54U2NhbGUgPSBjb21wb25lbnQueVNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgNjQpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYW4gWCAvIFkgc2NhbGVcbiAgICAgICAgICAgICAgICBjb21wb25lbnQueFNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQueVNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgMTI4KSA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgMngyIHRyYW5zZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnhTY2FsZSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnNjYWxlMDEgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5zY2FsZTEwID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQueVNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2x5cGguY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gICAgICAgICAgICBtb3JlQ29tcG9uZW50cyA9ICEhKGZsYWdzICYgMzIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFncyAmIDB4MTAwKSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGluc3RydWN0aW9uc1xuICAgICAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25MZW5ndGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkNiA9IDA7IGkkNiA8IGdseXBoLmluc3RydWN0aW9uTGVuZ3RoOyBpJDYgKz0gMSkge1xuICAgICAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9ucy5wdXNoKHAucGFyc2VCeXRlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBUcmFuc2Zvcm0gYW4gYXJyYXkgb2YgcG9pbnRzIGFuZCByZXR1cm4gYSBuZXcgYXJyYXkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludHMocG9pbnRzLCB0cmFuc2Zvcm0pIHtcbiAgICB2YXIgbmV3UG9pbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHB0ID0gcG9pbnRzW2ldO1xuICAgICAgICB2YXIgbmV3UHQgPSB7XG4gICAgICAgICAgICB4OiB0cmFuc2Zvcm0ueFNjYWxlICogcHQueCArIHRyYW5zZm9ybS5zY2FsZTAxICogcHQueSArIHRyYW5zZm9ybS5keCxcbiAgICAgICAgICAgIHk6IHRyYW5zZm9ybS5zY2FsZTEwICogcHQueCArIHRyYW5zZm9ybS55U2NhbGUgKiBwdC55ICsgdHJhbnNmb3JtLmR5LFxuICAgICAgICAgICAgb25DdXJ2ZTogcHQub25DdXJ2ZSxcbiAgICAgICAgICAgIGxhc3RQb2ludE9mQ29udG91cjogcHQubGFzdFBvaW50T2ZDb250b3VyXG4gICAgICAgIH07XG4gICAgICAgIG5ld1BvaW50cy5wdXNoKG5ld1B0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuXG5mdW5jdGlvbiBnZXRDb250b3Vycyhwb2ludHMpIHtcbiAgICB2YXIgY29udG91cnMgPSBbXTtcbiAgICB2YXIgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcHQgPSBwb2ludHNbaV07XG4gICAgICAgIGN1cnJlbnRDb250b3VyLnB1c2gocHQpO1xuICAgICAgICBpZiAocHQubGFzdFBvaW50T2ZDb250b3VyKSB7XG4gICAgICAgICAgICBjb250b3Vycy5wdXNoKGN1cnJlbnRDb250b3VyKTtcbiAgICAgICAgICAgIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVjay5hcmd1bWVudChjdXJyZW50Q29udG91ci5sZW5ndGggPT09IDAsICdUaGVyZSBhcmUgc3RpbGwgcG9pbnRzIGxlZnQgaW4gdGhlIGN1cnJlbnQgY29udG91ci4nKTtcbiAgICByZXR1cm4gY29udG91cnM7XG59XG5cbi8vIENvbnZlcnQgdGhlIFRydWVUeXBlIGdseXBoIG91dGxpbmUgdG8gYSBQYXRoLlxuZnVuY3Rpb24gZ2V0UGF0aChwb2ludHMpIHtcbiAgICB2YXIgcCA9IG5ldyBQYXRoKCk7XG4gICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgdmFyIGNvbnRvdXJzID0gZ2V0Q29udG91cnMocG9pbnRzKTtcblxuICAgIGZvciAodmFyIGNvbnRvdXJJbmRleCA9IDA7IGNvbnRvdXJJbmRleCA8IGNvbnRvdXJzLmxlbmd0aDsgKytjb250b3VySW5kZXgpIHtcbiAgICAgICAgdmFyIGNvbnRvdXIgPSBjb250b3Vyc1tjb250b3VySW5kZXhdO1xuXG4gICAgICAgIHZhciBwcmV2ID0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnIgPSBjb250b3VyW2NvbnRvdXIubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBuZXh0ID0gY29udG91clswXTtcblxuICAgICAgICBpZiAoY3Vyci5vbkN1cnZlKSB7XG4gICAgICAgICAgICBwLm1vdmVUbyhjdXJyLngsIGN1cnIueSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobmV4dC5vbkN1cnZlKSB7XG4gICAgICAgICAgICAgICAgcC5tb3ZlVG8obmV4dC54LCBuZXh0LnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBib3RoIGZpcnN0IGFuZCBsYXN0IHBvaW50cyBhcmUgb2ZmLWN1cnZlLCBzdGFydCBhdCB0aGVpciBtaWRkbGUuXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0ge3g6IChjdXJyLnggKyBuZXh0LngpICogMC41LCB5OiAoY3Vyci55ICsgbmV4dC55KSAqIDAuNX07XG4gICAgICAgICAgICAgICAgcC5tb3ZlVG8oc3RhcnQueCwgc3RhcnQueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRvdXIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHByZXYgPSBjdXJyO1xuICAgICAgICAgICAgY3VyciA9IG5leHQ7XG4gICAgICAgICAgICBuZXh0ID0gY29udG91clsoaSArIDEpICUgY29udG91ci5sZW5ndGhdO1xuXG4gICAgICAgICAgICBpZiAoY3Vyci5vbkN1cnZlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHN0cmFpZ2h0IGxpbmUuXG4gICAgICAgICAgICAgICAgcC5saW5lVG8oY3Vyci54LCBjdXJyLnkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldjIgPSBwcmV2O1xuICAgICAgICAgICAgICAgIHZhciBuZXh0MiA9IG5leHQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXByZXYub25DdXJ2ZSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2MiA9IHsgeDogKGN1cnIueCArIHByZXYueCkgKiAwLjUsIHk6IChjdXJyLnkgKyBwcmV2LnkpICogMC41IH07XG4gICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHByZXYyLngsIHByZXYyLnkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbmV4dC5vbkN1cnZlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQyID0geyB4OiAoY3Vyci54ICsgbmV4dC54KSAqIDAuNSwgeTogKGN1cnIueSArIG5leHQueSkgKiAwLjUgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwLmxpbmVUbyhwcmV2Mi54LCBwcmV2Mi55KTtcbiAgICAgICAgICAgICAgICBwLnF1YWRyYXRpY0N1cnZlVG8oY3Vyci54LCBjdXJyLnksIG5leHQyLngsIG5leHQyLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUGF0aChnbHlwaHMsIGdseXBoKSB7XG4gICAgaWYgKGdseXBoLmlzQ29tcG9zaXRlKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2x5cGguY29tcG9uZW50cy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGdseXBoLmNvbXBvbmVudHNbal07XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50R2x5cGggPSBnbHlwaHMuZ2V0KGNvbXBvbmVudC5nbHlwaEluZGV4KTtcbiAgICAgICAgICAgIC8vIEZvcmNlIHRoZSB0dGZHbHlwaExvYWRlciB0byBwYXJzZSB0aGUgZ2x5cGguXG4gICAgICAgICAgICBjb21wb25lbnRHbHlwaC5nZXRQYXRoKCk7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50R2x5cGgucG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gKHZvaWQgMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50IHBvc2l0aW9uZWQgYnkgb2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzKGNvbXBvbmVudEdseXBoLnBvaW50cywgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgcG9zaXRpb25lZCBieSBtYXRjaGVkIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGNvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzBdID4gZ2x5cGgucG9pbnRzLmxlbmd0aCAtIDEpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoY29tcG9uZW50Lm1hdGNoZWRQb2ludHNbMV0gPiBjb21wb25lbnRHbHlwaC5wb2ludHMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdNYXRjaGVkIHBvaW50cyBvdXQgb2YgcmFuZ2UgaW4gJyArIGdseXBoLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBmaXJzdFB0ID0gZ2x5cGgucG9pbnRzW2NvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzBdXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlY29uZFB0ID0gY29tcG9uZW50R2x5cGgucG9pbnRzW2NvbXBvbmVudC5tYXRjaGVkUG9pbnRzWzFdXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhTY2FsZTogY29tcG9uZW50LnhTY2FsZSwgc2NhbGUwMTogY29tcG9uZW50LnNjYWxlMDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FsZTEwOiBjb21wb25lbnQuc2NhbGUxMCwgeVNjYWxlOiBjb21wb25lbnQueVNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZHg6IDAsIGR5OiAwXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNlY29uZFB0ID0gdHJhbnNmb3JtUG9pbnRzKFtzZWNvbmRQdF0sIHRyYW5zZm9ybSlbMF07XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5keCA9IGZpcnN0UHQueCAtIHNlY29uZFB0Lng7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5keSA9IGZpcnN0UHQueSAtIHNlY29uZFB0Lnk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzID0gdHJhbnNmb3JtUG9pbnRzKGNvbXBvbmVudEdseXBoLnBvaW50cywgdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2x5cGgucG9pbnRzID0gZ2x5cGgucG9pbnRzLmNvbmNhdCh0cmFuc2Zvcm1lZFBvaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0UGF0aChnbHlwaC5wb2ludHMpO1xufVxuXG4vLyBQYXJzZSBhbGwgdGhlIGdseXBocyBhY2NvcmRpbmcgdG8gdGhlIG9mZnNldHMgZnJvbSB0aGUgYGxvY2FgIHRhYmxlLlxuZnVuY3Rpb24gcGFyc2VHbHlmVGFibGUoZGF0YSwgc3RhcnQsIGxvY2EsIGZvbnQpIHtcbiAgICB2YXIgZ2x5cGhzID0gbmV3IGdseXBoc2V0LkdseXBoU2V0KGZvbnQpO1xuXG4gICAgLy8gVGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgbG9jYSB0YWJsZSBpcyBpbnZhbGlkLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYS5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IGxvY2FbaV07XG4gICAgICAgIHZhciBuZXh0T2Zmc2V0ID0gbG9jYVtpICsgMV07XG4gICAgICAgIGlmIChvZmZzZXQgIT09IG5leHRPZmZzZXQpIHtcbiAgICAgICAgICAgIGdseXBocy5wdXNoKGksIGdseXBoc2V0LnR0ZkdseXBoTG9hZGVyKGZvbnQsIGksIHBhcnNlR2x5cGgsIGRhdGEsIHN0YXJ0ICsgb2Zmc2V0LCBidWlsZFBhdGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdseXBocy5wdXNoKGksIGdseXBoc2V0LmdseXBoTG9hZGVyKGZvbnQsIGkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnbHlwaHM7XG59XG5cbnZhciBnbHlmID0geyBnZXRQYXRoOiBnZXRQYXRoLCBwYXJzZTogcGFyc2VHbHlmVGFibGUgfTtcblxuLy8gVGhlIEdseXBoIG9iamVjdFxuXG5mdW5jdGlvbiBnZXRQYXRoRGVmaW5pdGlvbihnbHlwaCwgcGF0aCkge1xuICAgIHZhciBfcGF0aCA9IHBhdGggfHwgbmV3IFBhdGgoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgX3BhdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBfcGF0aCA9IF9wYXRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfcGF0aDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIF9wYXRoID0gcDtcbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIEB0eXBlZGVmIEdseXBoT3B0aW9uc1xuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIC0gVGhlIGdseXBoIG5hbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdW5pY29kZV1cbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IFt1bmljb2Rlc11cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeE1pbl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeU1pbl1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeE1heF1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeU1heF1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbYWR2YW5jZVdpZHRoXVxuICovXG5cbi8vIEEgR2x5cGggaXMgYW4gaW5kaXZpZHVhbCBtYXJrIHRoYXQgb2Z0ZW4gY29ycmVzcG9uZHMgdG8gYSBjaGFyYWN0ZXIuXG4vLyBTb21lIGdseXBocywgc3VjaCBhcyBsaWdhdHVyZXMsIGFyZSBhIGNvbWJpbmF0aW9uIG9mIG1hbnkgY2hhcmFjdGVycy5cbi8vIEdseXBocyBhcmUgdGhlIGJhc2ljIGJ1aWxkaW5nIGJsb2NrcyBvZiBhIGZvbnQuXG4vL1xuLy8gVGhlIGBHbHlwaGAgY2xhc3MgY29udGFpbnMgdXRpbGl0eSBtZXRob2RzIGZvciBkcmF3aW5nIHRoZSBwYXRoIGFuZCBpdHMgcG9pbnRzLlxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5HbHlwaFxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0dseXBoT3B0aW9uc31cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBHbHlwaChvcHRpb25zKSB7XG4gICAgLy8gQnkgcHV0dGluZyBhbGwgdGhlIGNvZGUgb24gYSBwcm90b3R5cGUgZnVuY3Rpb24gKHdoaWNoIGlzIG9ubHkgZGVjbGFyZWQgb25jZSlcbiAgICAvLyB3ZSByZWR1Y2UgdGhlIG1lbW9yeSByZXF1aXJlbWVudHMgZm9yIGxhcmdlciBmb250cyBieSBzb21lIDIlXG4gICAgdGhpcy5iaW5kQ29uc3RydWN0b3JWYWx1ZXMob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQHBhcmFtICB7R2x5cGhPcHRpb25zfVxuICovXG5HbHlwaC5wcm90b3R5cGUuYmluZENvbnN0cnVjdG9yVmFsdWVzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4IHx8IDA7XG5cbiAgICAvLyBUaGVzZSB0aHJlZSB2YWx1ZXMgY2Fubm90IGJlIGRlZmVycmVkIGZvciBtZW1vcnkgb3B0aW1pemF0aW9uOlxuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCBudWxsO1xuICAgIHRoaXMudW5pY29kZSA9IG9wdGlvbnMudW5pY29kZSB8fCB1bmRlZmluZWQ7XG4gICAgdGhpcy51bmljb2RlcyA9IG9wdGlvbnMudW5pY29kZXMgfHwgb3B0aW9ucy51bmljb2RlICE9PSB1bmRlZmluZWQgPyBbb3B0aW9ucy51bmljb2RlXSA6IFtdO1xuXG4gICAgLy8gQnV0IGJ5IGJpbmRpbmcgdGhlc2UgdmFsdWVzIG9ubHkgd2hlbiBuZWNlc3NhcnksIHdlIHJlZHVjZSBjYW5cbiAgICAvLyB0aGUgbWVtb3J5IHJlcXVpcmVtZW50cyBieSBhbG1vc3QgMyUgZm9yIGxhcmdlciBmb250cy5cbiAgICBpZiAob3B0aW9ucy54TWluKSB7XG4gICAgICAgIHRoaXMueE1pbiA9IG9wdGlvbnMueE1pbjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy55TWluKSB7XG4gICAgICAgIHRoaXMueU1pbiA9IG9wdGlvbnMueU1pbjtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy54TWF4KSB7XG4gICAgICAgIHRoaXMueE1heCA9IG9wdGlvbnMueE1heDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy55TWF4KSB7XG4gICAgICAgIHRoaXMueU1heCA9IG9wdGlvbnMueU1heDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5hZHZhbmNlV2lkdGgpIHtcbiAgICAgICAgdGhpcy5hZHZhbmNlV2lkdGggPSBvcHRpb25zLmFkdmFuY2VXaWR0aDtcbiAgICB9XG5cbiAgICAvLyBUaGUgcGF0aCBmb3IgYSBnbHlwaCBpcyB0aGUgbW9zdCBtZW1vcnkgaW50ZW5zaXZlLCBhbmQgaXMgYm91bmQgYXMgYSB2YWx1ZVxuICAgIC8vIHdpdGggYSBnZXR0ZXIvc2V0dGVyIHRvIGVuc3VyZSB3ZSBhY3R1YWxseSBkbyBwYXRoIHBhcnNpbmcgb25seSBvbmNlIHRoZVxuICAgIC8vIHBhdGggaXMgYWN0dWFsbHkgbmVlZGVkIGJ5IGFueXRoaW5nLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncGF0aCcsIGdldFBhdGhEZWZpbml0aW9uKHRoaXMsIG9wdGlvbnMucGF0aCkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqL1xuR2x5cGgucHJvdG90eXBlLmFkZFVuaWNvZGUgPSBmdW5jdGlvbih1bmljb2RlKSB7XG4gICAgaWYgKHRoaXMudW5pY29kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMudW5pY29kZSA9IHVuaWNvZGU7XG4gICAgfVxuXG4gICAgdGhpcy51bmljb2Rlcy5wdXNoKHVuaWNvZGUpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIG1pbmltdW0gYm91bmRpbmcgYm94IGZvciB0aGlzIGdseXBoLlxuICogQHJldHVybiB7b3BlbnR5cGUuQm91bmRpbmdCb3h9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnBhdGguZ2V0Qm91bmRpbmdCb3goKTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2x5cGggdG8gYSBQYXRoIHdlIGNhbiBkcmF3IG9uIGEgZHJhd2luZyBjb250ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zIC0geFNjYWxlLCB5U2NhbGUgdG8gc3RyZXRjaCB0aGUgZ2x5cGguXG4gKiBAcGFyYW0gIHtvcGVudHlwZS5Gb250fSBpZiBoaW50aW5nIGlzIHRvIGJlIHVzZWQsIHRoZSBmb250XG4gKiBAcmV0dXJuIHtvcGVudHlwZS5QYXRofVxuICovXG5HbHlwaC5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uKHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBmb250KSB7XG4gICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcbiAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDcyO1xuICAgIHZhciBjb21tYW5kcztcbiAgICB2YXIgaFBvaW50cztcbiAgICBpZiAoIW9wdGlvbnMpIHsgb3B0aW9ucyA9IHsgfTsgfVxuICAgIHZhciB4U2NhbGUgPSBvcHRpb25zLnhTY2FsZTtcbiAgICB2YXIgeVNjYWxlID0gb3B0aW9ucy55U2NhbGU7XG5cbiAgICBpZiAob3B0aW9ucy5oaW50aW5nICYmIGZvbnQgJiYgZm9udC5oaW50aW5nKSB7XG4gICAgICAgIC8vIGluIGNhc2Ugb2YgaGludGluZywgdGhlIGhpbnRpbmcgZW5naW5lIHRha2VzIGNhcmVcbiAgICAgICAgLy8gb2Ygc2NhbGluZyB0aGUgcG9pbnRzIChub3QgdGhlIHBhdGgpIGJlZm9yZSBoaW50aW5nLlxuICAgICAgICBoUG9pbnRzID0gdGhpcy5wYXRoICYmIGZvbnQuaGludGluZy5leGVjKHRoaXMsIGZvbnRTaXplKTtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgaGludGluZyBlbmdpbmUgZmFpbGVkIGhQb2ludHMgaXMgdW5kZWZpbmVkXG4gICAgICAgIC8vIGFuZCB0aHVzIHJldmVydHMgdG8gcGxhaW4gcmVuZGluZ1xuICAgIH1cblxuICAgIGlmIChoUG9pbnRzKSB7XG4gICAgICAgIGNvbW1hbmRzID0gZ2x5Zi5nZXRQYXRoKGhQb2ludHMpLmNvbW1hbmRzO1xuICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICAgICAgeSA9IE1hdGgucm91bmQoeSk7XG4gICAgICAgIC8vIFRPRE8gaW4gY2FzZSBvZiBoaW50aW5nIHh5U2NhbGluZyBpcyBub3QgeWV0IHN1cHBvcnRlZFxuICAgICAgICB4U2NhbGUgPSB5U2NhbGUgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbW1hbmRzID0gdGhpcy5wYXRoLmNvbW1hbmRzO1xuICAgICAgICB2YXIgc2NhbGUgPSAxIC8gdGhpcy5wYXRoLnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcbiAgICAgICAgaWYgKHhTY2FsZSA9PT0gdW5kZWZpbmVkKSB7IHhTY2FsZSA9IHNjYWxlOyB9XG4gICAgICAgIGlmICh5U2NhbGUgPT09IHVuZGVmaW5lZCkgeyB5U2NhbGUgPSBzY2FsZTsgfVxuICAgIH1cblxuICAgIHZhciBwID0gbmV3IFBhdGgoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjbWQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcbiAgICAgICAgICAgIHAubW92ZVRvKHggKyAoY21kLnggKiB4U2NhbGUpLCB5ICsgKC1jbWQueSAqIHlTY2FsZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnTCcpIHtcbiAgICAgICAgICAgIHAubGluZVRvKHggKyAoY21kLnggKiB4U2NhbGUpLCB5ICsgKC1jbWQueSAqIHlTY2FsZSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgIHAucXVhZHJhdGljQ3VydmVUbyh4ICsgKGNtZC54MSAqIHhTY2FsZSksIHkgKyAoLWNtZC55MSAqIHlTY2FsZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCArIChjbWQueCAqIHhTY2FsZSksIHkgKyAoLWNtZC55ICogeVNjYWxlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgcC5jdXJ2ZVRvKHggKyAoY21kLngxICogeFNjYWxlKSwgeSArICgtY21kLnkxICogeVNjYWxlKSxcbiAgICAgICAgICAgICAgICAgICAgICB4ICsgKGNtZC54MiAqIHhTY2FsZSksIHkgKyAoLWNtZC55MiAqIHlTY2FsZSksXG4gICAgICAgICAgICAgICAgICAgICAgeCArIChjbWQueCAqIHhTY2FsZSksIHkgKyAoLWNtZC55ICogeVNjYWxlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdaJykge1xuICAgICAgICAgICAgcC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwO1xufTtcblxuLyoqXG4gKiBTcGxpdCB0aGUgZ2x5cGggaW50byBjb250b3Vycy5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgaGVyZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGFuZCB0b1xuICogcHJvdmlkZSByYXcgYWNjZXNzIHRvIHRoZSBUcnVlVHlwZSBnbHlwaCBvdXRsaW5lcy5cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5HbHlwaC5wcm90b3R5cGUuZ2V0Q29udG91cnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLnBvaW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgY29udG91cnMgPSBbXTtcbiAgICB2YXIgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBwdCA9IHRoaXMkMS5wb2ludHNbaV07XG4gICAgICAgIGN1cnJlbnRDb250b3VyLnB1c2gocHQpO1xuICAgICAgICBpZiAocHQubGFzdFBvaW50T2ZDb250b3VyKSB7XG4gICAgICAgICAgICBjb250b3Vycy5wdXNoKGN1cnJlbnRDb250b3VyKTtcbiAgICAgICAgICAgIGN1cnJlbnRDb250b3VyID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGVjay5hcmd1bWVudChjdXJyZW50Q29udG91ci5sZW5ndGggPT09IDAsICdUaGVyZSBhcmUgc3RpbGwgcG9pbnRzIGxlZnQgaW4gdGhlIGN1cnJlbnQgY29udG91ci4nKTtcbiAgICByZXR1cm4gY29udG91cnM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgeE1pbi95TWluL3hNYXgveU1heC9sc2IvcnNiIGZvciBhIEdseXBoLlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5HbHlwaC5wcm90b3R5cGUuZ2V0TWV0cmljcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjb21tYW5kcyA9IHRoaXMucGF0aC5jb21tYW5kcztcbiAgICB2YXIgeENvb3JkcyA9IFtdO1xuICAgIHZhciB5Q29vcmRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY21kID0gY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSAhPT0gJ1onKSB7XG4gICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngpO1xuICAgICAgICAgICAgeUNvb3Jkcy5wdXNoKGNtZC55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ1EnIHx8IGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIHhDb29yZHMucHVzaChjbWQueDEpO1xuICAgICAgICAgICAgeUNvb3Jkcy5wdXNoKGNtZC55MSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54Mik7XG4gICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtZXRyaWNzID0ge1xuICAgICAgICB4TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB4Q29vcmRzKSxcbiAgICAgICAgeU1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgeUNvb3JkcyksXG4gICAgICAgIHhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHhDb29yZHMpLFxuICAgICAgICB5TWF4OiBNYXRoLm1heC5hcHBseShudWxsLCB5Q29vcmRzKSxcbiAgICAgICAgbGVmdFNpZGVCZWFyaW5nOiB0aGlzLmxlZnRTaWRlQmVhcmluZ1xuICAgIH07XG5cbiAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueE1pbikpIHtcbiAgICAgICAgbWV0cmljcy54TWluID0gMDtcbiAgICB9XG5cbiAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueE1heCkpIHtcbiAgICAgICAgbWV0cmljcy54TWF4ID0gdGhpcy5hZHZhbmNlV2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKCFpc0Zpbml0ZShtZXRyaWNzLnlNaW4pKSB7XG4gICAgICAgIG1ldHJpY3MueU1pbiA9IDA7XG4gICAgfVxuXG4gICAgaWYgKCFpc0Zpbml0ZShtZXRyaWNzLnlNYXgpKSB7XG4gICAgICAgIG1ldHJpY3MueU1heCA9IDA7XG4gICAgfVxuXG4gICAgbWV0cmljcy5yaWdodFNpZGVCZWFyaW5nID0gdGhpcy5hZHZhbmNlV2lkdGggLSBtZXRyaWNzLmxlZnRTaWRlQmVhcmluZyAtIChtZXRyaWNzLnhNYXggLSBtZXRyaWNzLnhNaW4pO1xuICAgIHJldHVybiBtZXRyaWNzO1xufTtcblxuLyoqXG4gKiBEcmF3IHRoZSBnbHlwaCBvbiB0aGUgZ2l2ZW4gY29udGV4dC5cbiAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zIC0geFNjYWxlLCB5U2NhbGUgdG8gc3RyZXRjaCB0aGUgZ2x5cGguXG4gKi9cbkdseXBoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHRoaXMuZ2V0UGF0aCh4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykuZHJhdyhjdHgpO1xufTtcblxuLyoqXG4gKiBEcmF3IHRoZSBwb2ludHMgb2YgdGhlIGdseXBoLlxuICogT24tY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gYmx1ZSwgb2ZmLWN1cnZlIHBvaW50cyB3aWxsIGJlIGRyYXduIGluIHJlZC5cbiAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKi9cbkdseXBoLnByb3RvdHlwZS5kcmF3UG9pbnRzID0gZnVuY3Rpb24oY3R4LCB4LCB5LCBmb250U2l6ZSkge1xuICAgIGZ1bmN0aW9uIGRyYXdDaXJjbGVzKGwsIHgsIHksIHNjYWxlKSB7XG4gICAgICAgIHZhciBQSV9TUSA9IE1hdGguUEkgKiAyO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgKGxbal0ueCAqIHNjYWxlKSwgeSArIChsW2pdLnkgKiBzY2FsZSkpO1xuICAgICAgICAgICAgY3R4LmFyYyh4ICsgKGxbal0ueCAqIHNjYWxlKSwgeSArIChsW2pdLnkgKiBzY2FsZSksIDIsIDAsIFBJX1NRLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuXG4gICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcbiAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDI0O1xuICAgIHZhciBzY2FsZSA9IDEgLyB0aGlzLnBhdGgudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuXG4gICAgdmFyIGJsdWVDaXJjbGVzID0gW107XG4gICAgdmFyIHJlZENpcmNsZXMgPSBbXTtcbiAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGguY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNtZCA9IHBhdGguY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQueCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBibHVlQ2lyY2xlcy5wdXNoKHt4OiBjbWQueCwgeTogLWNtZC55fSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY21kLngxICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZENpcmNsZXMucHVzaCh7eDogY21kLngxLCB5OiAtY21kLnkxfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY21kLngyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZENpcmNsZXMucHVzaCh7eDogY21kLngyLCB5OiAtY21kLnkyfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguZmlsbFN0eWxlID0gJ2JsdWUnO1xuICAgIGRyYXdDaXJjbGVzKGJsdWVDaXJjbGVzLCB4LCB5LCBzY2FsZSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9ICdyZWQnO1xuICAgIGRyYXdDaXJjbGVzKHJlZENpcmNsZXMsIHgsIHksIHNjYWxlKTtcbn07XG5cbi8qKlxuICogRHJhdyBsaW5lcyBpbmRpY2F0aW5nIGltcG9ydGFudCBmb250IG1lYXN1cmVtZW50cy5cbiAqIEJsYWNrIGxpbmVzIGluZGljYXRlIHRoZSBvcmlnaW4gb2YgdGhlIGNvb3JkaW5hdGUgc3lzdGVtIChwb2ludCAwLDApLlxuICogQmx1ZSBsaW5lcyBpbmRpY2F0ZSB0aGUgZ2x5cGggYm91bmRpbmcgYm94LlxuICogR3JlZW4gbGluZSBpbmRpY2F0ZXMgdGhlIGFkdmFuY2Ugd2lkdGggb2YgdGhlIGdseXBoLlxuICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqL1xuR2x5cGgucHJvdG90eXBlLmRyYXdNZXRyaWNzID0gZnVuY3Rpb24oY3R4LCB4LCB5LCBmb250U2l6ZSkge1xuICAgIHZhciBzY2FsZTtcbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogMjQ7XG4gICAgc2NhbGUgPSAxIC8gdGhpcy5wYXRoLnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcbiAgICBjdHgubGluZVdpZHRoID0gMTtcblxuICAgIC8vIERyYXcgdGhlIG9yaWdpblxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibGFjayc7XG4gICAgZHJhdy5saW5lKGN0eCwgeCwgLTEwMDAwLCB4LCAxMDAwMCk7XG4gICAgZHJhdy5saW5lKGN0eCwgLTEwMDAwLCB5LCAxMDAwMCwgeSk7XG5cbiAgICAvLyBUaGlzIGNvZGUgaXMgaGVyZSBkdWUgdG8gbWVtb3J5IG9wdGltaXphdGlvbjogYnkgbm90IHVzaW5nXG4gICAgLy8gZGVmYXVsdHMgaW4gdGhlIGNvbnN0cnVjdG9yLCB3ZSBzYXZlIGEgbm90YWJsZSBhbW91bnQgb2YgbWVtb3J5LlxuICAgIHZhciB4TWluID0gdGhpcy54TWluIHx8IDA7XG4gICAgdmFyIHlNaW4gPSB0aGlzLnlNaW4gfHwgMDtcbiAgICB2YXIgeE1heCA9IHRoaXMueE1heCB8fCAwO1xuICAgIHZhciB5TWF4ID0gdGhpcy55TWF4IHx8IDA7XG4gICAgdmFyIGFkdmFuY2VXaWR0aCA9IHRoaXMuYWR2YW5jZVdpZHRoIHx8IDA7XG5cbiAgICAvLyBEcmF3IHRoZSBnbHlwaCBib3hcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnYmx1ZSc7XG4gICAgZHJhdy5saW5lKGN0eCwgeCArICh4TWluICogc2NhbGUpLCAtMTAwMDAsIHggKyAoeE1pbiAqIHNjYWxlKSwgMTAwMDApO1xuICAgIGRyYXcubGluZShjdHgsIHggKyAoeE1heCAqIHNjYWxlKSwgLTEwMDAwLCB4ICsgKHhNYXggKiBzY2FsZSksIDEwMDAwKTtcbiAgICBkcmF3LmxpbmUoY3R4LCAtMTAwMDAsIHkgKyAoLXlNaW4gKiBzY2FsZSksIDEwMDAwLCB5ICsgKC15TWluICogc2NhbGUpKTtcbiAgICBkcmF3LmxpbmUoY3R4LCAtMTAwMDAsIHkgKyAoLXlNYXggKiBzY2FsZSksIDEwMDAwLCB5ICsgKC15TWF4ICogc2NhbGUpKTtcblxuICAgIC8vIERyYXcgdGhlIGFkdmFuY2Ugd2lkdGhcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuICAgIGRyYXcubGluZShjdHgsIHggKyAoYWR2YW5jZVdpZHRoICogc2NhbGUpLCAtMTAwMDAsIHggKyAoYWR2YW5jZVdpZHRoICogc2NhbGUpLCAxMDAwMCk7XG59O1xuXG4vLyBUaGUgR2x5cGhTZXQgb2JqZWN0XG5cbi8vIERlZmluZSBhIHByb3BlcnR5IG9uIHRoZSBnbHlwaCB0aGF0IGRlcGVuZHMgb24gdGhlIHBhdGggYmVpbmcgbG9hZGVkLlxuZnVuY3Rpb24gZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsIGV4dGVybmFsTmFtZSwgaW50ZXJuYWxOYW1lKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdseXBoLCBleHRlcm5hbE5hbWUsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFJlcXVlc3QgdGhlIHBhdGggcHJvcGVydHkgdG8gbWFrZSBzdXJlIHRoZSBwYXRoIGlzIGxvYWRlZC5cbiAgICAgICAgICAgIGdseXBoLnBhdGg7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgcmV0dXJuIGdseXBoW2ludGVybmFsTmFtZV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24obmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGdseXBoW2ludGVybmFsTmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG59XG5cbi8qKlxuICogQSBHbHlwaFNldCByZXByZXNlbnRzIGFsbCBnbHlwaHMgYXZhaWxhYmxlIGluIHRoZSBmb250LCBidXQgbW9kZWxsZWQgdXNpbmdcbiAqIGEgZGVmZXJyZWQgZ2x5cGggbG9hZGVyLCBmb3IgcmV0cmlldmluZyBnbHlwaHMgb25seSBvbmNlIHRoZXkgYXJlIGFic29sdXRlbHlcbiAqIG5lY2Vzc2FyeSwgdG8ga2VlcCB0aGUgbWVtb3J5IGZvb3RwcmludCBkb3duLlxuICogQGV4cG9ydHMgb3BlbnR5cGUuR2x5cGhTZXRcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuICogQHBhcmFtIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gR2x5cGhTZXQoZm9udCwgZ2x5cGhzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLmZvbnQgPSBmb250O1xuICAgIHRoaXMuZ2x5cGhzID0ge307XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZ2x5cGhzKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcyQxLmdseXBoc1tpXSA9IGdseXBoc1tpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gKGdseXBocyAmJiBnbHlwaHMubGVuZ3RoKSB8fCAwO1xufVxuXG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5HbHlwaFNldC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZ2x5cGhzW2luZGV4XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmdseXBoc1tpbmRleF0gPSB0aGlzLmdseXBoc1tpbmRleF0oKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nbHlwaHNbaW5kZXhdO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtPYmplY3R9XG4gKi9cbkdseXBoU2V0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oaW5kZXgsIGxvYWRlcikge1xuICAgIHRoaXMuZ2x5cGhzW2luZGV4XSA9IGxvYWRlcjtcbiAgICB0aGlzLmxlbmd0aCsrO1xufTtcblxuLyoqXG4gKiBAYWxpYXMgb3BlbnR5cGUuZ2x5cGhMb2FkZXJcbiAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5mdW5jdGlvbiBnbHlwaExvYWRlcihmb250LCBpbmRleCkge1xuICAgIHJldHVybiBuZXcgR2x5cGgoe2luZGV4OiBpbmRleCwgZm9udDogZm9udH0pO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgc3R1YiBnbHlwaCB0aGF0IGNhbiBiZSBmaWxsZWQgd2l0aCBhbGwgbWV0YWRhdGEgKmV4Y2VwdCpcbiAqIHRoZSBcInBvaW50c1wiIGFuZCBcInBhdGhcIiBwcm9wZXJ0aWVzLCB3aGljaCBtdXN0IGJlIGxvYWRlZCBvbmx5IG9uY2VcbiAqIHRoZSBnbHlwaCdzIHBhdGggaXMgYWN0dWFsbHkgcmVxdWVzdGVkIGZvciB0ZXh0IHNoYXBpbmcuXG4gKiBAYWxpYXMgb3BlbnR5cGUudHRmR2x5cGhMb2FkZXJcbiAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGZvbnRcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBwYXJzZUdseXBoXG4gKiBAcGFyYW0gIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSAge251bWJlcn0gcG9zaXRpb25cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBidWlsZFBhdGhcbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5mdW5jdGlvbiB0dGZHbHlwaExvYWRlcihmb250LCBpbmRleCwgcGFyc2VHbHlwaCwgZGF0YSwgcG9zaXRpb24sIGJ1aWxkUGF0aCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdseXBoID0gbmV3IEdseXBoKHtpbmRleDogaW5kZXgsIGZvbnQ6IGZvbnR9KTtcblxuICAgICAgICBnbHlwaC5wYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwYXJzZUdseXBoKGdseXBoLCBkYXRhLCBwb3NpdGlvbik7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IGJ1aWxkUGF0aChmb250LmdseXBocywgZ2x5cGgpO1xuICAgICAgICAgICAgcGF0aC51bml0c1BlckVtID0gZm9udC51bml0c1BlckVtO1xuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH07XG5cbiAgICAgICAgZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsICd4TWluJywgJ194TWluJyk7XG4gICAgICAgIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCAneE1heCcsICdfeE1heCcpO1xuICAgICAgICBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgJ3lNaW4nLCAnX3lNaW4nKTtcbiAgICAgICAgZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsICd5TWF4JywgJ195TWF4Jyk7XG5cbiAgICAgICAgcmV0dXJuIGdseXBoO1xuICAgIH07XG59XG4vKipcbiAqIEBhbGlhcyBvcGVudHlwZS5jZmZHbHlwaExvYWRlclxuICogQHBhcmFtICB7b3BlbnR5cGUuRm9udH0gZm9udFxuICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtICB7RnVuY3Rpb259IHBhcnNlQ0ZGQ2hhcnN0cmluZ1xuICogQHBhcmFtICB7c3RyaW5nfSBjaGFyc3RyaW5nXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cbiAqL1xuZnVuY3Rpb24gY2ZmR2x5cGhMb2FkZXIoZm9udCwgaW5kZXgsIHBhcnNlQ0ZGQ2hhcnN0cmluZywgY2hhcnN0cmluZykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdseXBoID0gbmV3IEdseXBoKHtpbmRleDogaW5kZXgsIGZvbnQ6IGZvbnR9KTtcblxuICAgICAgICBnbHlwaC5wYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHBhcnNlQ0ZGQ2hhcnN0cmluZyhmb250LCBnbHlwaCwgY2hhcnN0cmluZyk7XG4gICAgICAgICAgICBwYXRoLnVuaXRzUGVyRW0gPSBmb250LnVuaXRzUGVyRW07XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZ2x5cGg7XG4gICAgfTtcbn1cblxudmFyIGdseXBoc2V0ID0geyBHbHlwaFNldDogR2x5cGhTZXQsIGdseXBoTG9hZGVyOiBnbHlwaExvYWRlciwgdHRmR2x5cGhMb2FkZXI6IHR0ZkdseXBoTG9hZGVyLCBjZmZHbHlwaExvYWRlcjogY2ZmR2x5cGhMb2FkZXIgfTtcblxuLy8gVGhlIGBDRkZgIHRhYmxlIGNvbnRhaW5zIHRoZSBnbHlwaCBvdXRsaW5lcyBpbiBQb3N0U2NyaXB0IGZvcm1hdC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY2ZmLmh0bVxuLy8gaHR0cDovL2Rvd25sb2FkLm1pY3Jvc29mdC5jb20vZG93bmxvYWQvOC8wLzEvODAxYTE5MWMtMDI5ZC00YWYzLTk2NDItNTU1ZjZmZTUxNGVlL2NmZi5wZGZcbi8vIGh0dHA6Ly9kb3dubG9hZC5taWNyb3NvZnQuY29tL2Rvd25sb2FkLzgvMC8xLzgwMWExOTFjLTAyOWQtNGFmMy05NjQyLTU1NWY2ZmU1MTRlZS90eXBlMi5wZGZcblxuLy8gQ3VzdG9tIGVxdWFscyBmdW5jdGlvbiB0aGF0IGNhbiBhbHNvIGNoZWNrIGxpc3RzLlxuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICghZXF1YWxzKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLy8gU3Vicm91dGluZXMgYXJlIGVuY29kZWQgdXNpbmcgdGhlIG5lZ2F0aXZlIGhhbGYgb2YgdGhlIG51bWJlciBzcGFjZS5cbi8vIFNlZSB0eXBlIDIgY2hhcHRlciA0LjcgXCJTdWJyb3V0aW5lIG9wZXJhdG9yc1wiLlxuZnVuY3Rpb24gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKHN1YnJzKSB7XG4gICAgdmFyIGJpYXM7XG4gICAgaWYgKHN1YnJzLmxlbmd0aCA8IDEyNDApIHtcbiAgICAgICAgYmlhcyA9IDEwNztcbiAgICB9IGVsc2UgaWYgKHN1YnJzLmxlbmd0aCA8IDMzOTAwKSB7XG4gICAgICAgIGJpYXMgPSAxMTMxO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGJpYXMgPSAzMjc2ODtcbiAgICB9XG5cbiAgICByZXR1cm4gYmlhcztcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBJTkRFWCBhcnJheS5cbi8vIEFuIGluZGV4IGFycmF5IGNvbnNpc3RzIG9mIGEgbGlzdCBvZiBvZmZzZXRzLCB0aGVuIGEgbGlzdCBvZiBvYmplY3RzIGF0IHRob3NlIG9mZnNldHMuXG5mdW5jdGlvbiBwYXJzZUNGRkluZGV4KGRhdGEsIHN0YXJ0LCBjb252ZXJzaW9uRm4pIHtcbiAgICB2YXIgb2Zmc2V0cyA9IFtdO1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgdmFyIGNvdW50ID0gcGFyc2UuZ2V0Q2FyZDE2KGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgb2JqZWN0T2Zmc2V0O1xuICAgIHZhciBlbmRPZmZzZXQ7XG4gICAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgICAgIHZhciBvZmZzZXRTaXplID0gcGFyc2UuZ2V0Qnl0ZShkYXRhLCBzdGFydCArIDIpO1xuICAgICAgICBvYmplY3RPZmZzZXQgPSBzdGFydCArICgoY291bnQgKyAxKSAqIG9mZnNldFNpemUpICsgMjtcbiAgICAgICAgdmFyIHBvcyA9IHN0YXJ0ICsgMztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudCArIDE7IGkgKz0gMSkge1xuICAgICAgICAgICAgb2Zmc2V0cy5wdXNoKHBhcnNlLmdldE9mZnNldChkYXRhLCBwb3MsIG9mZnNldFNpemUpKTtcbiAgICAgICAgICAgIHBvcyArPSBvZmZzZXRTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHRvdGFsIHNpemUgb2YgdGhlIGluZGV4IGFycmF5IGlzIDQgaGVhZGVyIGJ5dGVzICsgdGhlIHZhbHVlIG9mIHRoZSBsYXN0IG9mZnNldC5cbiAgICAgICAgZW5kT2Zmc2V0ID0gb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tjb3VudF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZW5kT2Zmc2V0ID0gc3RhcnQgKyAyO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG9mZnNldHMubGVuZ3RoIC0gMTsgaSQxICs9IDEpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyc2UuZ2V0Qnl0ZXMoZGF0YSwgb2JqZWN0T2Zmc2V0ICsgb2Zmc2V0c1tpJDFdLCBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2kkMSArIDFdKTtcbiAgICAgICAgaWYgKGNvbnZlcnNpb25Gbikge1xuICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJzaW9uRm4odmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2JqZWN0cy5wdXNoKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge29iamVjdHM6IG9iamVjdHMsIHN0YXJ0T2Zmc2V0OiBzdGFydCwgZW5kT2Zmc2V0OiBlbmRPZmZzZXR9O1xufVxuXG4vLyBQYXJzZSBhIGBDRkZgIERJQ1QgcmVhbCB2YWx1ZS5cbmZ1bmN0aW9uIHBhcnNlRmxvYXRPcGVyYW5kKHBhcnNlcikge1xuICAgIHZhciBzID0gJyc7XG4gICAgdmFyIGVvZiA9IDE1O1xuICAgIHZhciBsb29rdXAgPSBbJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNycsICc4JywgJzknLCAnLicsICdFJywgJ0UtJywgbnVsbCwgJy0nXTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgYiA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgdmFyIG4xID0gYiA+PiA0O1xuICAgICAgICB2YXIgbjIgPSBiICYgMTU7XG5cbiAgICAgICAgaWYgKG4xID09PSBlb2YpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcyArPSBsb29rdXBbbjFdO1xuXG4gICAgICAgIGlmIChuMiA9PT0gZW9mKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHMgKz0gbG9va3VwW24yXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VGbG9hdChzKTtcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBESUNUIG9wZXJhbmQuXG5mdW5jdGlvbiBwYXJzZU9wZXJhbmQocGFyc2VyLCBiMCkge1xuICAgIHZhciBiMTtcbiAgICB2YXIgYjI7XG4gICAgdmFyIGIzO1xuICAgIHZhciBiNDtcbiAgICBpZiAoYjAgPT09IDI4KSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICBiMiA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgcmV0dXJuIGIxIDw8IDggfCBiMjtcbiAgICB9XG5cbiAgICBpZiAoYjAgPT09IDI5KSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICBiMiA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgYjMgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGI0ID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gYjEgPDwgMjQgfCBiMiA8PCAxNiB8IGIzIDw8IDggfCBiNDtcbiAgICB9XG5cbiAgICBpZiAoYjAgPT09IDMwKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0T3BlcmFuZChwYXJzZXIpO1xuICAgIH1cblxuICAgIGlmIChiMCA+PSAzMiAmJiBiMCA8PSAyNDYpIHtcbiAgICAgICAgcmV0dXJuIGIwIC0gMTM5O1xuICAgIH1cblxuICAgIGlmIChiMCA+PSAyNDcgJiYgYjAgPD0gMjUwKSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gKGIwIC0gMjQ3KSAqIDI1NiArIGIxICsgMTA4O1xuICAgIH1cblxuICAgIGlmIChiMCA+PSAyNTEgJiYgYjAgPD0gMjU0KSB7XG4gICAgICAgIGIxID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gLShiMCAtIDI1MSkgKiAyNTYgLSBiMSAtIDEwODtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYjAgJyArIGIwKTtcbn1cblxuLy8gQ29udmVydCB0aGUgZW50cmllcyByZXR1cm5lZCBieSBgcGFyc2VEaWN0YCB0byBhIHByb3BlciBkaWN0aW9uYXJ5LlxuLy8gSWYgYSB2YWx1ZSBpcyBhIGxpc3Qgb2Ygb25lLCBpdCBpcyB1bnBhY2tlZC5cbmZ1bmN0aW9uIGVudHJpZXNUb09iamVjdChlbnRyaWVzKSB7XG4gICAgdmFyIG8gPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGtleSA9IGVudHJpZXNbaV1bMF07XG4gICAgICAgIHZhciB2YWx1ZXMgPSBlbnRyaWVzW2ldWzFdO1xuICAgICAgICB2YXIgdmFsdWUgPSAodm9pZCAwKTtcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICFpc05hTihvW2tleV0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCAnICsgbyArICcgYWxyZWFkeSBoYXMga2V5ICcgKyBrZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgb1trZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG87XG59XG5cbi8vIFBhcnNlIGEgYENGRmAgRElDVCBvYmplY3QuXG4vLyBBIGRpY3Rpb25hcnkgY29udGFpbnMga2V5LXZhbHVlIHBhaXJzIGluIGEgY29tcGFjdCB0b2tlbml6ZWQgZm9ybWF0LlxuZnVuY3Rpb24gcGFyc2VDRkZEaWN0KGRhdGEsIHN0YXJ0LCBzaXplKSB7XG4gICAgc3RhcnQgPSBzdGFydCAhPT0gdW5kZWZpbmVkID8gc3RhcnQgOiAwO1xuICAgIHZhciBwYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgZW50cmllcyA9IFtdO1xuICAgIHZhciBvcGVyYW5kcyA9IFtdO1xuICAgIHNpemUgPSBzaXplICE9PSB1bmRlZmluZWQgPyBzaXplIDogZGF0YS5sZW5ndGg7XG5cbiAgICB3aGlsZSAocGFyc2VyLnJlbGF0aXZlT2Zmc2V0IDwgc2l6ZSkge1xuICAgICAgICB2YXIgb3AgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG5cbiAgICAgICAgLy8gVGhlIGZpcnN0IGJ5dGUgZm9yIGVhY2ggZGljdCBpdGVtIGRpc3Rpbmd1aXNoZXMgYmV0d2VlbiBvcGVyYXRvciAoa2V5KSBhbmQgb3BlcmFuZCAodmFsdWUpLlxuICAgICAgICAvLyBWYWx1ZXMgPD0gMjEgYXJlIG9wZXJhdG9ycy5cbiAgICAgICAgaWYgKG9wIDw9IDIxKSB7XG4gICAgICAgICAgICAvLyBUd28tYnl0ZSBvcGVyYXRvcnMgaGF2ZSBhbiBpbml0aWFsIGVzY2FwZSBieXRlIG9mIDEyLlxuICAgICAgICAgICAgaWYgKG9wID09PSAxMikge1xuICAgICAgICAgICAgICAgIG9wID0gMTIwMCArIHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW50cmllcy5wdXNoKFtvcCwgb3BlcmFuZHNdKTtcbiAgICAgICAgICAgIG9wZXJhbmRzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGUgb3BlcmFuZHMgKHZhbHVlcykgY29tZSBiZWZvcmUgdGhlIG9wZXJhdG9ycyAoa2V5cyksIHdlIHN0b3JlIGFsbCBvcGVyYW5kcyBpbiBhIGxpc3RcbiAgICAgICAgICAgIC8vIHVudGlsIHdlIGVuY291bnRlciBhbiBvcGVyYXRvci5cbiAgICAgICAgICAgIG9wZXJhbmRzLnB1c2gocGFyc2VPcGVyYW5kKHBhcnNlciwgb3ApKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBlbnRyaWVzVG9PYmplY3QoZW50cmllcyk7XG59XG5cbi8vIEdpdmVuIGEgU3RyaW5nIEluZGV4IChTSUQpLCByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBzdHJpbmcuXG4vLyBTdHJpbmdzIGJlbG93IGluZGV4IDM5MiBhcmUgc3RhbmRhcmQgQ0ZGIHN0cmluZ3MgYW5kIGFyZSBub3QgZW5jb2RlZCBpbiB0aGUgZm9udC5cbmZ1bmN0aW9uIGdldENGRlN0cmluZyhzdHJpbmdzLCBpbmRleCkge1xuICAgIGlmIChpbmRleCA8PSAzOTApIHtcbiAgICAgICAgaW5kZXggPSBjZmZTdGFuZGFyZFN0cmluZ3NbaW5kZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ID0gc3RyaW5nc1tpbmRleCAtIDM5MV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xufVxuXG4vLyBJbnRlcnByZXQgYSBkaWN0aW9uYXJ5IGFuZCByZXR1cm4gYSBuZXcgZGljdGlvbmFyeSB3aXRoIHJlYWRhYmxlIGtleXMgYW5kIHZhbHVlcyBmb3IgbWlzc2luZyBlbnRyaWVzLlxuLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyBgbWV0YWAgd2hpY2ggaXMgYSBsaXN0IG9mIG9iamVjdHMgY29udGFpbmluZyBgb3BlcmFuZGAsIGBuYW1lYCBhbmQgYGRlZmF1bHRgLlxuZnVuY3Rpb24gaW50ZXJwcmV0RGljdChkaWN0LCBtZXRhLCBzdHJpbmdzKSB7XG4gICAgdmFyIG5ld0RpY3QgPSB7fTtcbiAgICB2YXIgdmFsdWU7XG5cbiAgICAvLyBCZWNhdXNlIHdlIGFsc28gd2FudCB0byBpbmNsdWRlIG1pc3NpbmcgdmFsdWVzLCB3ZSBzdGFydCBvdXQgZnJvbSB0aGUgbWV0YSBsaXN0XG4gICAgLy8gYW5kIGxvb2t1cCB2YWx1ZXMgaW4gdGhlIGRpY3QuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBtID0gbWV0YVtpXTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtLnR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICAgICAgICB2YWx1ZXMubGVuZ3RoID0gbS50eXBlLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbS50eXBlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkaWN0W20ub3BdICE9PSB1bmRlZmluZWQgPyBkaWN0W20ub3BdW2pdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbS52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIG0udmFsdWVbal0gIT09IHVuZGVmaW5lZCA/IG0udmFsdWVbal0gOiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobS50eXBlW2pdID09PSAnU0lEJykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldENGRlN0cmluZyhzdHJpbmdzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlc1tqXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3RGljdFttLm5hbWVdID0gdmFsdWVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBkaWN0W20ub3BdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG0udmFsdWUgIT09IHVuZGVmaW5lZCA/IG0udmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobS50eXBlID09PSAnU0lEJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0RpY3RbbS5uYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0RpY3Q7XG59XG5cbi8vIFBhcnNlIHRoZSBDRkYgaGVhZGVyLlxuZnVuY3Rpb24gcGFyc2VDRkZIZWFkZXIoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgaGVhZGVyID0ge307XG4gICAgaGVhZGVyLmZvcm1hdE1ham9yID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQpO1xuICAgIGhlYWRlci5mb3JtYXRNaW5vciA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0ICsgMSk7XG4gICAgaGVhZGVyLnNpemUgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCArIDIpO1xuICAgIGhlYWRlci5vZmZzZXRTaXplID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQgKyAzKTtcbiAgICBoZWFkZXIuc3RhcnRPZmZzZXQgPSBzdGFydDtcbiAgICBoZWFkZXIuZW5kT2Zmc2V0ID0gc3RhcnQgKyA0O1xuICAgIHJldHVybiBoZWFkZXI7XG59XG5cbnZhciBUT1BfRElDVF9NRVRBID0gW1xuICAgIHtuYW1lOiAndmVyc2lvbicsIG9wOiAwLCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICdub3RpY2UnLCBvcDogMSwgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnY29weXJpZ2h0Jywgb3A6IDEyMDAsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2Z1bGxOYW1lJywgb3A6IDIsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2ZhbWlseU5hbWUnLCBvcDogMywgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnd2VpZ2h0Jywgb3A6IDQsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ2lzRml4ZWRQaXRjaCcsIG9wOiAxMjAxLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnaXRhbGljQW5nbGUnLCBvcDogMTIwMiwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ3VuZGVybGluZVBvc2l0aW9uJywgb3A6IDEyMDMsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogLTEwMH0sXG4gICAge25hbWU6ICd1bmRlcmxpbmVUaGlja25lc3MnLCBvcDogMTIwNCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiA1MH0sXG4gICAge25hbWU6ICdwYWludFR5cGUnLCBvcDogMTIwNSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2NoYXJzdHJpbmdUeXBlJywgb3A6IDEyMDYsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMn0sXG4gICAge1xuICAgICAgICBuYW1lOiAnZm9udE1hdHJpeCcsXG4gICAgICAgIG9wOiAxMjA3LFxuICAgICAgICB0eXBlOiBbJ3JlYWwnLCAncmVhbCcsICdyZWFsJywgJ3JlYWwnLCAncmVhbCcsICdyZWFsJ10sXG4gICAgICAgIHZhbHVlOiBbMC4wMDEsIDAsIDAsIDAuMDAxLCAwLCAwXVxuICAgIH0sXG4gICAge25hbWU6ICd1bmlxdWVJZCcsIG9wOiAxMywgdHlwZTogJ251bWJlcid9LFxuICAgIHtuYW1lOiAnZm9udEJCb3gnLCBvcDogNSwgdHlwZTogWydudW1iZXInLCAnbnVtYmVyJywgJ251bWJlcicsICdudW1iZXInXSwgdmFsdWU6IFswLCAwLCAwLCAwXX0sXG4gICAge25hbWU6ICdzdHJva2VXaWR0aCcsIG9wOiAxMjA4LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAneHVpZCcsIG9wOiAxNCwgdHlwZTogW10sIHZhbHVlOiBudWxsfSxcbiAgICB7bmFtZTogJ2NoYXJzZXQnLCBvcDogMTUsIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdlbmNvZGluZycsIG9wOiAxNiwgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2NoYXJTdHJpbmdzJywgb3A6IDE3LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAncHJpdmF0ZScsIG9wOiAxOCwgdHlwZTogWydudW1iZXInLCAnb2Zmc2V0J10sIHZhbHVlOiBbMCwgMF19LFxuICAgIHtuYW1lOiAncm9zJywgb3A6IDEyMzAsIHR5cGU6IFsnU0lEJywgJ1NJRCcsICdudW1iZXInXX0sXG4gICAge25hbWU6ICdjaWRGb250VmVyc2lvbicsIG9wOiAxMjMxLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnY2lkRm9udFJldmlzaW9uJywgb3A6IDEyMzIsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdjaWRGb250VHlwZScsIG9wOiAxMjMzLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnY2lkQ291bnQnLCBvcDogMTIzNCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiA4NzIwfSxcbiAgICB7bmFtZTogJ3VpZEJhc2UnLCBvcDogMTIzNSwgdHlwZTogJ251bWJlcid9LFxuICAgIHtuYW1lOiAnZmRBcnJheScsIG9wOiAxMjM2LCB0eXBlOiAnb2Zmc2V0J30sXG4gICAge25hbWU6ICdmZFNlbGVjdCcsIG9wOiAxMjM3LCB0eXBlOiAnb2Zmc2V0J30sXG4gICAge25hbWU6ICdmb250TmFtZScsIG9wOiAxMjM4LCB0eXBlOiAnU0lEJ31cbl07XG5cbnZhciBQUklWQVRFX0RJQ1RfTUVUQSA9IFtcbiAgICB7bmFtZTogJ3N1YnJzJywgb3A6IDE5LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnZGVmYXVsdFdpZHRoWCcsIG9wOiAyMCwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ25vbWluYWxXaWR0aFgnLCBvcDogMjEsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH1cbl07XG5cbi8vIFBhcnNlIHRoZSBDRkYgdG9wIGRpY3Rpb25hcnkuIEEgQ0ZGIHRhYmxlIGNhbiBjb250YWluIG11bHRpcGxlIGZvbnRzLCBlYWNoIHdpdGggdGhlaXIgb3duIHRvcCBkaWN0aW9uYXJ5LlxuLy8gVGhlIHRvcCBkaWN0aW9uYXJ5IGNvbnRhaW5zIHRoZSBlc3NlbnRpYWwgbWV0YWRhdGEgZm9yIHRoZSBmb250LCB0b2dldGhlciB3aXRoIHRoZSBwcml2YXRlIGRpY3Rpb25hcnkuXG5mdW5jdGlvbiBwYXJzZUNGRlRvcERpY3QoZGF0YSwgc3RyaW5ncykge1xuICAgIHZhciBkaWN0ID0gcGFyc2VDRkZEaWN0KGRhdGEsIDAsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIGludGVycHJldERpY3QoZGljdCwgVE9QX0RJQ1RfTUVUQSwgc3RyaW5ncyk7XG59XG5cbi8vIFBhcnNlIHRoZSBDRkYgcHJpdmF0ZSBkaWN0aW9uYXJ5LiBXZSBkb24ndCBmdWxseSBwYXJzZSBvdXQgYWxsIHRoZSB2YWx1ZXMsIG9ubHkgdGhlIG9uZXMgd2UgbmVlZC5cbmZ1bmN0aW9uIHBhcnNlQ0ZGUHJpdmF0ZURpY3QoZGF0YSwgc3RhcnQsIHNpemUsIHN0cmluZ3MpIHtcbiAgICB2YXIgZGljdCA9IHBhcnNlQ0ZGRGljdChkYXRhLCBzdGFydCwgc2l6ZSk7XG4gICAgcmV0dXJuIGludGVycHJldERpY3QoZGljdCwgUFJJVkFURV9ESUNUX01FVEEsIHN0cmluZ3MpO1xufVxuXG4vLyBSZXR1cm5zIGEgbGlzdCBvZiBcIlRvcCBESUNUXCJzIGZvdW5kIHVzaW5nIGFuIElOREVYIGxpc3QuXG4vLyBVc2VkIHRvIHJlYWQgYm90aCB0aGUgdXN1YWwgaGlnaC1sZXZlbCBUb3AgRElDVHMgYW5kIGFsc28gdGhlIEZEQXJyYXlcbi8vIGRpc2NvdmVyZWQgaW5zaWRlIENJRC1rZXllZCBmb250cy4gIFdoZW4gYSBUb3AgRElDVCBoYXMgYSByZWZlcmVuY2UgdG9cbi8vIGEgUHJpdmF0ZSBESUNUIHRoYXQgaXMgcmVhZCBhbmQgc2F2ZWQgaW50byB0aGUgVG9wIERJQ1QuXG4vL1xuLy8gSW4gYWRkaXRpb24gdG8gdGhlIGV4cGVjdGVkL29wdGlvbmFsIHZhbHVlcyBhcyBvdXRsaW5lZCBpbiBUT1BfRElDVF9NRVRBXG4vLyB0aGUgZm9sbG93aW5nIHZhbHVlcyBtaWdodCBiZSBzYXZlZCBpbnRvIHRoZSBUb3AgRElDVC5cbi8vXG4vLyAgICBfc3VicnMgW10gICAgICAgIGFycmF5IG9mIGxvY2FsIENGRiBzdWJyb3V0aW5lcyBmcm9tIFByaXZhdGUgRElDVFxuLy8gICAgX3N1YnJzQmlhcyAgICAgICBiaWFzIHZhbHVlIGNvbXB1dGVkIGZyb20gbnVtYmVyIG9mIHN1YnJvdXRpbmVzXG4vLyAgICAgICAgICAgICAgICAgICAgICAoc2VlIGNhbGNDRkZTdWJyb3V0aW5lQmlhcygpIGFuZCBwYXJzZUNGRkNoYXJzdHJpbmcoKSlcbi8vICAgIF9kZWZhdWx0V2lkdGhYICAgZGVmYXVsdCB3aWR0aHMgZm9yIENGRiBjaGFyYWN0ZXJzXG4vLyAgICBfbm9taW5hbFdpZHRoWCAgIGJpYXMgYWRkZWQgdG8gd2lkdGggZW1iZWRkZWQgd2l0aGluIGdseXBoIGRlc2NyaXB0aW9uXG4vL1xuLy8gICAgX3ByaXZhdGVEaWN0ICAgICBzYXZlZCBjb3B5IG9mIHBhcnNlZCBQcml2YXRlIERJQ1QgZnJvbSBUb3AgRElDVFxuZnVuY3Rpb24gZ2F0aGVyQ0ZGVG9wRGljdHMoZGF0YSwgc3RhcnQsIGNmZkluZGV4LCBzdHJpbmdzKSB7XG4gICAgdmFyIHRvcERpY3RBcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGlUb3BEaWN0ID0gMDsgaVRvcERpY3QgPCBjZmZJbmRleC5sZW5ndGg7IGlUb3BEaWN0ICs9IDEpIHtcbiAgICAgICAgdmFyIHRvcERpY3REYXRhID0gbmV3IERhdGFWaWV3KG5ldyBVaW50OEFycmF5KGNmZkluZGV4W2lUb3BEaWN0XSkuYnVmZmVyKTtcbiAgICAgICAgdmFyIHRvcERpY3QgPSBwYXJzZUNGRlRvcERpY3QodG9wRGljdERhdGEsIHN0cmluZ3MpO1xuICAgICAgICB0b3BEaWN0Ll9zdWJycyA9IFtdO1xuICAgICAgICB0b3BEaWN0Ll9zdWJyc0JpYXMgPSAwO1xuICAgICAgICB2YXIgcHJpdmF0ZVNpemUgPSB0b3BEaWN0LnByaXZhdGVbMF07XG4gICAgICAgIHZhciBwcml2YXRlT2Zmc2V0ID0gdG9wRGljdC5wcml2YXRlWzFdO1xuICAgICAgICBpZiAocHJpdmF0ZVNpemUgIT09IDAgJiYgcHJpdmF0ZU9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIHByaXZhdGVEaWN0ID0gcGFyc2VDRkZQcml2YXRlRGljdChkYXRhLCBwcml2YXRlT2Zmc2V0ICsgc3RhcnQsIHByaXZhdGVTaXplLCBzdHJpbmdzKTtcbiAgICAgICAgICAgIHRvcERpY3QuX2RlZmF1bHRXaWR0aFggPSBwcml2YXRlRGljdC5kZWZhdWx0V2lkdGhYO1xuICAgICAgICAgICAgdG9wRGljdC5fbm9taW5hbFdpZHRoWCA9IHByaXZhdGVEaWN0Lm5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICBpZiAocHJpdmF0ZURpY3Quc3VicnMgIT09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgc3Vick9mZnNldCA9IHByaXZhdGVPZmZzZXQgKyBwcml2YXRlRGljdC5zdWJycztcbiAgICAgICAgICAgICAgICB2YXIgc3VickluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdWJyT2Zmc2V0ICsgc3RhcnQpO1xuICAgICAgICAgICAgICAgIHRvcERpY3QuX3N1YnJzID0gc3VickluZGV4Lm9iamVjdHM7XG4gICAgICAgICAgICAgICAgdG9wRGljdC5fc3VicnNCaWFzID0gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKHRvcERpY3QuX3N1YnJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvcERpY3QuX3ByaXZhdGVEaWN0ID0gcHJpdmF0ZURpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgdG9wRGljdEFycmF5LnB1c2godG9wRGljdCk7XG4gICAgfVxuICAgIHJldHVybiB0b3BEaWN0QXJyYXk7XG59XG5cbi8vIFBhcnNlIHRoZSBDRkYgY2hhcnNldCB0YWJsZSwgd2hpY2ggY29udGFpbnMgaW50ZXJuYWwgbmFtZXMgZm9yIGFsbCB0aGUgZ2x5cGhzLlxuLy8gVGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBhIGxpc3Qgb2YgZ2x5cGggbmFtZXMuXG4vLyBTZWUgQWRvYmUgVE4gIzUxNzYgY2hhcHRlciAxMywgXCJDaGFyc2V0c1wiLlxuZnVuY3Rpb24gcGFyc2VDRkZDaGFyc2V0KGRhdGEsIHN0YXJ0LCBuR2x5cGhzLCBzdHJpbmdzKSB7XG4gICAgdmFyIHNpZDtcbiAgICB2YXIgY291bnQ7XG4gICAgdmFyIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuXG4gICAgLy8gVGhlIC5ub3RkZWYgZ2x5cGggaXMgbm90IGluY2x1ZGVkLCBzbyBzdWJ0cmFjdCAxLlxuICAgIG5HbHlwaHMgLT0gMTtcbiAgICB2YXIgY2hhcnNldCA9IFsnLm5vdGRlZiddO1xuXG4gICAgdmFyIGZvcm1hdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgaWYgKGZvcm1hdCA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5HbHlwaHM7IGkgKz0gMSkge1xuICAgICAgICAgICAgc2lkID0gcGFyc2VyLnBhcnNlU0lEKCk7XG4gICAgICAgICAgICBjaGFyc2V0LnB1c2goZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHNpZCkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgd2hpbGUgKGNoYXJzZXQubGVuZ3RoIDw9IG5HbHlwaHMpIHtcbiAgICAgICAgICAgIHNpZCA9IHBhcnNlci5wYXJzZVNJRCgpO1xuICAgICAgICAgICAgY291bnQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDw9IGNvdW50OyBpJDEgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNoYXJzZXQucHVzaChnZXRDRkZTdHJpbmcoc3RyaW5ncywgc2lkKSk7XG4gICAgICAgICAgICAgICAgc2lkICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICB3aGlsZSAoY2hhcnNldC5sZW5ndGggPD0gbkdseXBocykge1xuICAgICAgICAgICAgc2lkID0gcGFyc2VyLnBhcnNlU0lEKCk7XG4gICAgICAgICAgICBjb3VudCA9IHBhcnNlci5wYXJzZUNhcmQxNigpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDw9IGNvdW50OyBpJDIgKz0gMSkge1xuICAgICAgICAgICAgICAgIGNoYXJzZXQucHVzaChnZXRDRkZTdHJpbmcoc3RyaW5ncywgc2lkKSk7XG4gICAgICAgICAgICAgICAgc2lkICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2hhcnNldCBmb3JtYXQgJyArIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYXJzZXQ7XG59XG5cbi8vIFBhcnNlIHRoZSBDRkYgZW5jb2RpbmcgZGF0YS4gT25seSBvbmUgZW5jb2RpbmcgY2FuIGJlIHNwZWNpZmllZCBwZXIgZm9udC5cbi8vIFNlZSBBZG9iZSBUTiAjNTE3NiBjaGFwdGVyIDEyLCBcIkVuY29kaW5nc1wiLlxuZnVuY3Rpb24gcGFyc2VDRkZFbmNvZGluZyhkYXRhLCBzdGFydCwgY2hhcnNldCkge1xuICAgIHZhciBjb2RlO1xuICAgIHZhciBlbmMgPSB7fTtcbiAgICB2YXIgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIGZvcm1hdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgaWYgKGZvcm1hdCA9PT0gMCkge1xuICAgICAgICB2YXIgbkNvZGVzID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuQ29kZXM7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29kZSA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBlbmNbY29kZV0gPSBpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgdmFyIG5SYW5nZXMgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICBjb2RlID0gMTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgblJhbmdlczsgaSQxICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBmaXJzdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICB2YXIgbkxlZnQgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IGZpcnN0OyBqIDw9IGZpcnN0ICsgbkxlZnQ7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIGVuY1tqXSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgY29kZSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nIGZvcm1hdCAnICsgZm9ybWF0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENmZkVuY29kaW5nKGVuYywgY2hhcnNldCk7XG59XG5cbi8vIFRha2UgaW4gY2hhcnN0cmluZyBjb2RlIGFuZCByZXR1cm4gYSBHbHlwaCBvYmplY3QuXG4vLyBUaGUgZW5jb2RpbmcgaXMgZGVzY3JpYmVkIGluIHRoZSBUeXBlIDIgQ2hhcnN0cmluZyBGb3JtYXRcbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY2hhcnN0cjIuaHRtXG5mdW5jdGlvbiBwYXJzZUNGRkNoYXJzdHJpbmcoZm9udCwgZ2x5cGgsIGNvZGUpIHtcbiAgICB2YXIgYzF4O1xuICAgIHZhciBjMXk7XG4gICAgdmFyIGMyeDtcbiAgICB2YXIgYzJ5O1xuICAgIHZhciBwID0gbmV3IFBhdGgoKTtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgblN0ZW1zID0gMDtcbiAgICB2YXIgaGF2ZVdpZHRoID0gZmFsc2U7XG4gICAgdmFyIG9wZW4gPSBmYWxzZTtcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHkgPSAwO1xuICAgIHZhciBzdWJycztcbiAgICB2YXIgc3VicnNCaWFzO1xuICAgIHZhciBkZWZhdWx0V2lkdGhYO1xuICAgIHZhciBub21pbmFsV2lkdGhYO1xuICAgIGlmIChmb250LmlzQ0lERm9udCkge1xuICAgICAgICB2YXIgZmRJbmRleCA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9mZFNlbGVjdFtnbHlwaC5pbmRleF07XG4gICAgICAgIHZhciBmZERpY3QgPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fZmRBcnJheVtmZEluZGV4XTtcbiAgICAgICAgc3VicnMgPSBmZERpY3QuX3N1YnJzO1xuICAgICAgICBzdWJyc0JpYXMgPSBmZERpY3QuX3N1YnJzQmlhcztcbiAgICAgICAgZGVmYXVsdFdpZHRoWCA9IGZkRGljdC5fZGVmYXVsdFdpZHRoWDtcbiAgICAgICAgbm9taW5hbFdpZHRoWCA9IGZkRGljdC5fbm9taW5hbFdpZHRoWDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdWJycyA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9zdWJycztcbiAgICAgICAgc3VicnNCaWFzID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX3N1YnJzQmlhcztcbiAgICAgICAgZGVmYXVsdFdpZHRoWCA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9kZWZhdWx0V2lkdGhYO1xuICAgICAgICBub21pbmFsV2lkdGhYID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX25vbWluYWxXaWR0aFg7XG4gICAgfVxuICAgIHZhciB3aWR0aCA9IGRlZmF1bHRXaWR0aFg7XG5cbiAgICBmdW5jdGlvbiBuZXdDb250b3VyKHgsIHkpIHtcbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIHAuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBwLm1vdmVUbyh4LCB5KTtcbiAgICAgICAgb3BlbiA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTdGVtcygpIHtcbiAgICAgICAgdmFyIGhhc1dpZHRoQXJnO1xuXG4gICAgICAgIC8vIFRoZSBudW1iZXIgb2Ygc3RlbSBvcGVyYXRvcnMgb24gdGhlIHN0YWNrIGlzIGFsd2F5cyBldmVuLlxuICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgdW5ldmVuLCB0aGF0IG1lYW5zIGEgd2lkdGggaXMgc3BlY2lmaWVkLlxuICAgICAgICBoYXNXaWR0aEFyZyA9IHN0YWNrLmxlbmd0aCAlIDIgIT09IDA7XG4gICAgICAgIGlmIChoYXNXaWR0aEFyZyAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuICAgICAgICB9XG5cbiAgICAgICAgblN0ZW1zICs9IHN0YWNrLmxlbmd0aCA+PiAxO1xuICAgICAgICBzdGFjay5sZW5ndGggPSAwO1xuICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlJCQxKGNvZGUpIHtcbiAgICAgICAgdmFyIGIxO1xuICAgICAgICB2YXIgYjI7XG4gICAgICAgIHZhciBiMztcbiAgICAgICAgdmFyIGI0O1xuICAgICAgICB2YXIgY29kZUluZGV4O1xuICAgICAgICB2YXIgc3VickNvZGU7XG4gICAgICAgIHZhciBqcHg7XG4gICAgICAgIHZhciBqcHk7XG4gICAgICAgIHZhciBjM3g7XG4gICAgICAgIHZhciBjM3k7XG4gICAgICAgIHZhciBjNHg7XG4gICAgICAgIHZhciBjNHk7XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGNvZGUubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGNvZGVbaV07XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICBzd2l0Y2ggKHYpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6IC8vIGhzdGVtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiAvLyB2c3RlbVxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogLy8gdm1vdmV0b1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMSAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRvdXIoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNTogLy8gcmxpbmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDY6IC8vIGhsaW5ldG9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogLy8gdmxpbmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA4OiAvLyBycmN1cnZldG9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTA6IC8vIGNhbGxzdWJyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IHN0YWNrLnBvcCgpICsgc3VicnNCaWFzO1xuICAgICAgICAgICAgICAgICAgICBzdWJyQ29kZSA9IHN1YnJzW2NvZGVJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2UkJDEoc3VickNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMTogLy8gcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlIDEyOiAvLyBmbGV4IG9wZXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICB2ID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzU6IC8vIGZsZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB8LSBkeDEgZHkxIGR4MiBkeTIgZHgzIGR5MyBkeDQgZHk0IGR4NSBkeTUgZHg2IGR5NiBmZCBmbGV4ICgxMiAzNSkgfC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHggPSBjMnggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3kgPSBqcHkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHkgPSBjM3kgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzR4ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzR5ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5zaGlmdCgpOyAgICAgICAgICAgICAgICAvLyBmbGV4IGRlcHRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNDogLy8gaGZsZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB8LSBkeDEgZHgyIGR5MiBkeDMgZHg0IGR4NSBkeDYgaGZsZXggKDEyIDM0KSB8LVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7ICAgICAgICAgICAgICAgICAgICAgIC8vIGR5MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweSA9IGMyeTsgICAgICAgICAgICAgICAgICAgIC8vIGR5M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeSA9IGMyeTsgICAgICAgICAgICAgICAgICAgIC8vIGR5NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eSA9IHk7ICAgICAgICAgICAgICAgICAgICAgIC8vIGR5NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjNHggKyBzdGFjay5zaGlmdCgpOyAgICAgIC8vIGR4NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIGpweCwganB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzY6IC8vIGhmbGV4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwtIGR4MSBkeTEgZHgyIGR5MiBkeDMgZHg0IGR4NSBkeTUgZHg2IGhmbGV4MSAoMTIgMzYpIHwtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB5ID0gYzJ5OyAgICAgICAgICAgICAgICAgICAgLy8gZHkzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0gYzJ5OyAgICAgICAgICAgICAgICAgICAgLy8gZHk0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR4ID0gYzN4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR5ID0gYzN5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHk1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGM0eCArIHN0YWNrLnNoaWZ0KCk7ICAgICAgLy8gZHg2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNzogLy8gZmxleDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB8LSBkeDEgZHkxIGR4MiBkeTIgZHgzIGR5MyBkeDQgZHk0IGR4NSBkeTUgZDYgZmxleDEgKDEyIDM3KSB8LVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeSA9IGpweSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eSA9IGMzeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhjNHggLSB4KSA+IE1hdGguYWJzKGM0eSAtIHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjNHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjNHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIGpweCwganB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzN4LCBjM3ksIGM0eCwgYzR5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0dseXBoICcgKyBnbHlwaC5pbmRleCArICc6IHVua25vd24gb3BlcmF0b3IgJyArIDEyMDAgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTQ6IC8vIGVuZGNoYXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDAgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgbm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTg6IC8vIGhzdGVtaG1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE5OiAvLyBoaW50bWFza1xuICAgICAgICAgICAgICAgIGNhc2UgMjA6IC8vIGNudHJtYXNrXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAoblN0ZW1zICsgNykgPj4gMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMTogLy8gcm1vdmV0b1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMiAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRvdXIoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjI6IC8vIGhtb3ZldG9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA+IDEgJiYgIWhhdmVXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSBzdGFjay5zaGlmdCgpICsgbm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250b3VyKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIzOiAvLyB2c3RlbWhtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDogLy8gcmN1cnZlbGluZVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI1OiAvLyBybGluZWN1cnZlXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNjogLy8gdnZjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4O1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjc6IC8vIGhoY3VydmV0b1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI4OiAvLyBzaG9ydGludFxuICAgICAgICAgICAgICAgICAgICBiMSA9IGNvZGVbaV07XG4gICAgICAgICAgICAgICAgICAgIGIyID0gY29kZVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKChiMSA8PCAyNCkgfCAoYjIgPDwgMTYpKSA+PiAxNik7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOTogLy8gY2FsbGdzdWJyXG4gICAgICAgICAgICAgICAgICAgIGNvZGVJbmRleCA9IHN0YWNrLnBvcCgpICsgZm9udC5nc3VicnNCaWFzO1xuICAgICAgICAgICAgICAgICAgICBzdWJyQ29kZSA9IGZvbnQuZ3N1YnJzW2NvZGVJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2UkJDEoc3VickNvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzMDogLy8gdmhjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMxOiAvLyBodmN1cnZldG9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh2IDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHbHlwaCAnICsgZ2x5cGguaW5kZXggKyAnOiB1bmtub3duIG9wZXJhdG9yICcgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2IDwgMjQ3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHYgLSAxMzkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKHYgLSAyNDcpICogMjU2ICsgYjEgKyAxMDgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goLSh2IC0gMjUxKSAqIDI1NiAtIGIxIC0gMTA4KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIyID0gY29kZVtpICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBiMyA9IGNvZGVbaSArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYjQgPSBjb2RlW2kgKyAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goKChiMSA8PCAyNCkgfCAoYjIgPDwgMTYpIHwgKGIzIDw8IDgpIHwgYjQpIC8gNjU1MzYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwYXJzZSQkMShjb2RlKTtcblxuICAgIGdseXBoLmFkdmFuY2VXaWR0aCA9IHdpZHRoO1xuICAgIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNGRkZEU2VsZWN0KGRhdGEsIHN0YXJ0LCBuR2x5cGhzLCBmZEFycmF5Q291bnQpIHtcbiAgICB2YXIgZmRTZWxlY3QgPSBbXTtcbiAgICB2YXIgZmRJbmRleDtcbiAgICB2YXIgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIGZvcm1hdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgaWYgKGZvcm1hdCA9PT0gMCkge1xuICAgICAgICAvLyBTaW1wbGUgbGlzdCBvZiBuR2x5cGhzIGVsZW1lbnRzXG4gICAgICAgIGZvciAodmFyIGlHaWQgPSAwOyBpR2lkIDwgbkdseXBoczsgaUdpZCsrKSB7XG4gICAgICAgICAgICBmZEluZGV4ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIGlmIChmZEluZGV4ID49IGZkQXJyYXlDb3VudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIHRhYmxlIENJRCBGb250IEZEU2VsZWN0IGhhcyBiYWQgRkQgaW5kZXggdmFsdWUgJyArIGZkSW5kZXggKyAnIChGRCBjb3VudCAnICsgZmRBcnJheUNvdW50ICsgJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZkU2VsZWN0LnB1c2goZmRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMykge1xuICAgICAgICAvLyBSYW5nZXNcbiAgICAgICAgdmFyIG5SYW5nZXMgPSBwYXJzZXIucGFyc2VDYXJkMTYoKTtcbiAgICAgICAgdmFyIGZpcnN0ID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG4gICAgICAgIGlmIChmaXJzdCAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDRkYgVGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgZm9ybWF0IDMgcmFuZ2UgaGFzIGJhZCBpbml0aWFsIEdJRCAnICsgZmlyc3QpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0O1xuICAgICAgICBmb3IgKHZhciBpUmFuZ2UgPSAwOyBpUmFuZ2UgPCBuUmFuZ2VzOyBpUmFuZ2UrKykge1xuICAgICAgICAgICAgZmRJbmRleCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBuZXh0ID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG4gICAgICAgICAgICBpZiAoZmRJbmRleCA+PSBmZEFycmF5Q291bnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NGRiB0YWJsZSBDSUQgRm9udCBGRFNlbGVjdCBoYXMgYmFkIEZEIGluZGV4IHZhbHVlICcgKyBmZEluZGV4ICsgJyAoRkQgY291bnQgJyArIGZkQXJyYXlDb3VudCArICcpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA+IG5HbHlwaHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCBmb3JtYXQgMyByYW5nZSBoYXMgYmFkIEdJRCAnICsgbmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKDsgZmlyc3QgPCBuZXh0OyBmaXJzdCsrKSB7XG4gICAgICAgICAgICAgICAgZmRTZWxlY3QucHVzaChmZEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpcnN0ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dCAhPT0gbkdseXBocykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDRkYgVGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgZm9ybWF0IDMgcmFuZ2UgaGFzIGJhZCBmaW5hbCBHSUQgJyArIG5leHQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDRkYgVGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgdGFibGUgaGFzIHVuc3VwcG9ydGVkIGZvcm1hdCAnICsgZm9ybWF0KTtcbiAgICB9XG4gICAgcmV0dXJuIGZkU2VsZWN0O1xufVxuXG4vLyBQYXJzZSB0aGUgYENGRmAgdGFibGUsIHdoaWNoIGNvbnRhaW5zIHRoZSBnbHlwaCBvdXRsaW5lcyBpbiBQb3N0U2NyaXB0IGZvcm1hdC5cbmZ1bmN0aW9uIHBhcnNlQ0ZGVGFibGUoZGF0YSwgc3RhcnQsIGZvbnQpIHtcbiAgICBmb250LnRhYmxlcy5jZmYgPSB7fTtcbiAgICB2YXIgaGVhZGVyID0gcGFyc2VDRkZIZWFkZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBuYW1lSW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIGhlYWRlci5lbmRPZmZzZXQsIHBhcnNlLmJ5dGVzVG9TdHJpbmcpO1xuICAgIHZhciB0b3BEaWN0SW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIG5hbWVJbmRleC5lbmRPZmZzZXQpO1xuICAgIHZhciBzdHJpbmdJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgdG9wRGljdEluZGV4LmVuZE9mZnNldCwgcGFyc2UuYnl0ZXNUb1N0cmluZyk7XG4gICAgdmFyIGdsb2JhbFN1YnJJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3RyaW5nSW5kZXguZW5kT2Zmc2V0KTtcbiAgICBmb250LmdzdWJycyA9IGdsb2JhbFN1YnJJbmRleC5vYmplY3RzO1xuICAgIGZvbnQuZ3N1YnJzQmlhcyA9IGNhbGNDRkZTdWJyb3V0aW5lQmlhcyhmb250LmdzdWJycyk7XG5cbiAgICB2YXIgdG9wRGljdEFycmF5ID0gZ2F0aGVyQ0ZGVG9wRGljdHMoZGF0YSwgc3RhcnQsIHRvcERpY3RJbmRleC5vYmplY3RzLCBzdHJpbmdJbmRleC5vYmplY3RzKTtcbiAgICBpZiAodG9wRGljdEFycmF5Lmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NGRiB0YWJsZSBoYXMgdG9vIG1hbnkgZm9udHMgaW4gXFwnRm9udFNldFxcJyAtIGNvdW50IG9mIGZvbnRzIE5hbWVJbmRleC5sZW5ndGggPSAnICsgdG9wRGljdEFycmF5Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIHRvcERpY3QgPSB0b3BEaWN0QXJyYXlbMF07XG4gICAgZm9udC50YWJsZXMuY2ZmLnRvcERpY3QgPSB0b3BEaWN0O1xuXG4gICAgaWYgKHRvcERpY3QuX3ByaXZhdGVEaWN0KSB7XG4gICAgICAgIGZvbnQuZGVmYXVsdFdpZHRoWCA9IHRvcERpY3QuX3ByaXZhdGVEaWN0LmRlZmF1bHRXaWR0aFg7XG4gICAgICAgIGZvbnQubm9taW5hbFdpZHRoWCA9IHRvcERpY3QuX3ByaXZhdGVEaWN0Lm5vbWluYWxXaWR0aFg7XG4gICAgfVxuXG4gICAgaWYgKHRvcERpY3Qucm9zWzBdICE9PSB1bmRlZmluZWQgJiYgdG9wRGljdC5yb3NbMV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb250LmlzQ0lERm9udCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGZvbnQuaXNDSURGb250KSB7XG4gICAgICAgIHZhciBmZEFycmF5T2Zmc2V0ID0gdG9wRGljdC5mZEFycmF5O1xuICAgICAgICB2YXIgZmRTZWxlY3RPZmZzZXQgPSB0b3BEaWN0LmZkU2VsZWN0O1xuICAgICAgICBpZiAoZmRBcnJheU9mZnNldCA9PT0gMCB8fCBmZFNlbGVjdE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb250IGlzIG1hcmtlZCBhcyBhIENJRCBmb250LCBidXQgRkRBcnJheSBhbmQvb3IgRkRTZWxlY3QgaW5mb3JtYXRpb24gaXMgbWlzc2luZycpO1xuICAgICAgICB9XG4gICAgICAgIGZkQXJyYXlPZmZzZXQgKz0gc3RhcnQ7XG4gICAgICAgIHZhciBmZEFycmF5SW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIGZkQXJyYXlPZmZzZXQpO1xuICAgICAgICB2YXIgZmRBcnJheSA9IGdhdGhlckNGRlRvcERpY3RzKGRhdGEsIHN0YXJ0LCBmZEFycmF5SW5kZXgub2JqZWN0cywgc3RyaW5nSW5kZXgub2JqZWN0cyk7XG4gICAgICAgIHRvcERpY3QuX2ZkQXJyYXkgPSBmZEFycmF5O1xuICAgICAgICBmZFNlbGVjdE9mZnNldCArPSBzdGFydDtcbiAgICAgICAgdG9wRGljdC5fZmRTZWxlY3QgPSBwYXJzZUNGRkZEU2VsZWN0KGRhdGEsIGZkU2VsZWN0T2Zmc2V0LCBmb250Lm51bUdseXBocywgZmRBcnJheS5sZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciBwcml2YXRlRGljdE9mZnNldCA9IHN0YXJ0ICsgdG9wRGljdC5wcml2YXRlWzFdO1xuICAgIHZhciBwcml2YXRlRGljdCA9IHBhcnNlQ0ZGUHJpdmF0ZURpY3QoZGF0YSwgcHJpdmF0ZURpY3RPZmZzZXQsIHRvcERpY3QucHJpdmF0ZVswXSwgc3RyaW5nSW5kZXgub2JqZWN0cyk7XG4gICAgZm9udC5kZWZhdWx0V2lkdGhYID0gcHJpdmF0ZURpY3QuZGVmYXVsdFdpZHRoWDtcbiAgICBmb250Lm5vbWluYWxXaWR0aFggPSBwcml2YXRlRGljdC5ub21pbmFsV2lkdGhYO1xuXG4gICAgaWYgKHByaXZhdGVEaWN0LnN1YnJzICE9PSAwKSB7XG4gICAgICAgIHZhciBzdWJyT2Zmc2V0ID0gcHJpdmF0ZURpY3RPZmZzZXQgKyBwcml2YXRlRGljdC5zdWJycztcbiAgICAgICAgdmFyIHN1YnJJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3Vick9mZnNldCk7XG4gICAgICAgIGZvbnQuc3VicnMgPSBzdWJySW5kZXgub2JqZWN0cztcbiAgICAgICAgZm9udC5zdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoZm9udC5zdWJycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9udC5zdWJycyA9IFtdO1xuICAgICAgICBmb250LnN1YnJzQmlhcyA9IDA7XG4gICAgfVxuXG4gICAgLy8gT2Zmc2V0cyBpbiB0aGUgdG9wIGRpY3QgYXJlIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIENGRiBkYXRhLCBzbyBhZGQgdGhlIENGRiBzdGFydCBvZmZzZXQuXG4gICAgdmFyIGNoYXJTdHJpbmdzSW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5jaGFyU3RyaW5ncyk7XG4gICAgZm9udC5uR2x5cGhzID0gY2hhclN0cmluZ3NJbmRleC5vYmplY3RzLmxlbmd0aDtcblxuICAgIHZhciBjaGFyc2V0ID0gcGFyc2VDRkZDaGFyc2V0KGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5jaGFyc2V0LCBmb250Lm5HbHlwaHMsIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAwKSB7XG4gICAgICAgIC8vIFN0YW5kYXJkIGVuY29kaW5nXG4gICAgICAgIGZvbnQuY2ZmRW5jb2RpbmcgPSBuZXcgQ2ZmRW5jb2RpbmcoY2ZmU3RhbmRhcmRFbmNvZGluZywgY2hhcnNldCk7XG4gICAgfSBlbHNlIGlmICh0b3BEaWN0LmVuY29kaW5nID09PSAxKSB7XG4gICAgICAgIC8vIEV4cGVydCBlbmNvZGluZ1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gbmV3IENmZkVuY29kaW5nKGNmZkV4cGVydEVuY29kaW5nLCBjaGFyc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250LmNmZkVuY29kaW5nID0gcGFyc2VDRkZFbmNvZGluZyhkYXRhLCBzdGFydCArIHRvcERpY3QuZW5jb2RpbmcsIGNoYXJzZXQpO1xuICAgIH1cblxuICAgIC8vIFByZWZlciB0aGUgQ01BUCBlbmNvZGluZyB0byB0aGUgQ0ZGIGVuY29kaW5nLlxuICAgIGZvbnQuZW5jb2RpbmcgPSBmb250LmVuY29kaW5nIHx8IGZvbnQuY2ZmRW5jb2Rpbmc7XG5cbiAgICBmb250LmdseXBocyA9IG5ldyBnbHlwaHNldC5HbHlwaFNldChmb250KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvbnQubkdseXBoczsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjaGFyU3RyaW5nID0gY2hhclN0cmluZ3NJbmRleC5vYmplY3RzW2ldO1xuICAgICAgICBmb250LmdseXBocy5wdXNoKGksIGdseXBoc2V0LmNmZkdseXBoTG9hZGVyKGZvbnQsIGksIHBhcnNlQ0ZGQ2hhcnN0cmluZywgY2hhclN0cmluZykpO1xuICAgIH1cbn1cblxuLy8gQ29udmVydCBhIHN0cmluZyB0byBhIFN0cmluZyBJRCAoU0lEKS5cbi8vIFRoZSBsaXN0IG9mIHN0cmluZ3MgaXMgbW9kaWZpZWQgaW4gcGxhY2UuXG5mdW5jdGlvbiBlbmNvZGVTdHJpbmcocywgc3RyaW5ncykge1xuICAgIHZhciBzaWQ7XG5cbiAgICAvLyBJcyB0aGUgc3RyaW5nIGluIHRoZSBDRkYgc3RhbmRhcmQgc3RyaW5ncz9cbiAgICB2YXIgaSA9IGNmZlN0YW5kYXJkU3RyaW5ncy5pbmRleE9mKHMpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgICAgc2lkID0gaTtcbiAgICB9XG5cbiAgICAvLyBJcyB0aGUgc3RyaW5nIGFscmVhZHkgaW4gdGhlIHN0cmluZyBpbmRleD9cbiAgICBpID0gc3RyaW5ncy5pbmRleE9mKHMpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgICAgc2lkID0gaSArIGNmZlN0YW5kYXJkU3RyaW5ncy5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2lkID0gY2ZmU3RhbmRhcmRTdHJpbmdzLmxlbmd0aCArIHN0cmluZ3MubGVuZ3RoO1xuICAgICAgICBzdHJpbmdzLnB1c2gocyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpZDtcbn1cblxuZnVuY3Rpb24gbWFrZUhlYWRlcigpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlJlY29yZCgnSGVhZGVyJywgW1xuICAgICAgICB7bmFtZTogJ21ham9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ21pbm9yJywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2hkclNpemUnLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogNH0sXG4gICAgICAgIHtuYW1lOiAnbWFqb3InLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogMX1cbiAgICBdKTtcbn1cblxuZnVuY3Rpb24gbWFrZU5hbWVJbmRleChmb250TmFtZXMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5SZWNvcmQoJ05hbWUgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAnbmFtZXMnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgdC5uYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9udE5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHQubmFtZXMucHVzaCh7bmFtZTogJ25hbWVfJyArIGksIHR5cGU6ICdOQU1FJywgdmFsdWU6IGZvbnROYW1lc1tpXX0pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG4vLyBHaXZlbiBhIGRpY3Rpb25hcnkncyBtZXRhZGF0YSwgY3JlYXRlIGEgRElDVCBzdHJ1Y3R1cmUuXG5mdW5jdGlvbiBtYWtlRGljdChtZXRhLCBhdHRycywgc3RyaW5ncykge1xuICAgIHZhciBtID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IG1ldGFbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGF0dHJzW2VudHJ5Lm5hbWVdO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZXF1YWxzKHZhbHVlLCBlbnRyeS52YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS50eXBlID09PSAnU0lEJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZW5jb2RlU3RyaW5nKHZhbHVlLCBzdHJpbmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbVtlbnRyeS5vcF0gPSB7bmFtZTogZW50cnkubmFtZSwgdHlwZTogZW50cnkudHlwZSwgdmFsdWU6IHZhbHVlfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtO1xufVxuXG4vLyBUaGUgVG9wIERJQ1QgaG91c2VzIHRoZSBnbG9iYWwgZm9udCBhdHRyaWJ1dGVzLlxuZnVuY3Rpb24gbWFrZVRvcERpY3QoYXR0cnMsIHN0cmluZ3MpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5SZWNvcmQoJ1RvcCBESUNUJywgW1xuICAgICAgICB7bmFtZTogJ2RpY3QnLCB0eXBlOiAnRElDVCcsIHZhbHVlOiB7fX1cbiAgICBdKTtcbiAgICB0LmRpY3QgPSBtYWtlRGljdChUT1BfRElDVF9NRVRBLCBhdHRycywgc3RyaW5ncyk7XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCkge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlJlY29yZCgnVG9wIERJQ1QgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAndG9wRGljdHMnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG4gICAgdC50b3BEaWN0cyA9IFt7bmFtZTogJ3RvcERpY3RfMCcsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiB0b3BEaWN0fV07XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VTdHJpbmdJbmRleChzdHJpbmdzKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuUmVjb3JkKCdTdHJpbmcgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAnc3RyaW5ncycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbiAgICB0LnN0cmluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdC5zdHJpbmdzLnB1c2goe25hbWU6ICdzdHJpbmdfJyArIGksIHR5cGU6ICdTVFJJTkcnLCB2YWx1ZTogc3RyaW5nc1tpXX0pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlR2xvYmFsU3VickluZGV4KCkge1xuICAgIC8vIEN1cnJlbnRseSB3ZSBkb24ndCB1c2Ugc3Vicm91dGluZXMuXG4gICAgcmV0dXJuIG5ldyB0YWJsZS5SZWNvcmQoJ0dsb2JhbCBTdWJyIElOREVYJywgW1xuICAgICAgICB7bmFtZTogJ3N1YnJzJywgdHlwZTogJ0lOREVYJywgdmFsdWU6IFtdfVxuICAgIF0pO1xufVxuXG5mdW5jdGlvbiBtYWtlQ2hhcnNldHMoZ2x5cGhOYW1lcywgc3RyaW5ncykge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlJlY29yZCgnQ2hhcnNldHMnLCBbXG4gICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ0NhcmQ4JywgdmFsdWU6IDB9XG4gICAgXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaE5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaE5hbWUgPSBnbHlwaE5hbWVzW2ldO1xuICAgICAgICB2YXIgZ2x5cGhTSUQgPSBlbmNvZGVTdHJpbmcoZ2x5cGhOYW1lLCBzdHJpbmdzKTtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ2dseXBoXycgKyBpLCB0eXBlOiAnU0lEJywgdmFsdWU6IGdseXBoU0lEfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGdseXBoVG9PcHMoZ2x5cGgpIHtcbiAgICB2YXIgb3BzID0gW107XG4gICAgdmFyIHBhdGggPSBnbHlwaC5wYXRoO1xuICAgIG9wcy5wdXNoKHtuYW1lOiAnd2lkdGgnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGdseXBoLmFkdmFuY2VXaWR0aH0pO1xuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBkeCA9ICh2b2lkIDApO1xuICAgICAgICB2YXIgZHkgPSAodm9pZCAwKTtcbiAgICAgICAgdmFyIGNtZCA9IHBhdGguY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG4gICAgICAgICAgICAvLyBDRkYgb25seSBzdXBwb3J0cyBiw6l6aWVyIGN1cnZlcywgc28gY29udmVydCB0aGUgcXVhZCB0byBhIGLDqXppZXIuXG4gICAgICAgICAgICB2YXIgXzEzID0gMSAvIDM7XG4gICAgICAgICAgICB2YXIgXzIzID0gMiAvIDM7XG5cbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGNyZWF0ZSBhIG5ldyBjb21tYW5kIHNvIHdlIGRvbid0IGNoYW5nZSB0aGUgb3JpZ2luYWwgcGF0aC5cbiAgICAgICAgICAgIGNtZCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQycsXG4gICAgICAgICAgICAgICAgeDogY21kLngsXG4gICAgICAgICAgICAgICAgeTogY21kLnksXG4gICAgICAgICAgICAgICAgeDE6IF8xMyAqIHggKyBfMjMgKiBjbWQueDEsXG4gICAgICAgICAgICAgICAgeTE6IF8xMyAqIHkgKyBfMjMgKiBjbWQueTEsXG4gICAgICAgICAgICAgICAgeDI6IF8xMyAqIGNtZC54ICsgXzIzICogY21kLngxLFxuICAgICAgICAgICAgICAgIHkyOiBfMTMgKiBjbWQueSArIF8yMyAqIGNtZC55MVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBkeCA9IE1hdGgucm91bmQoY21kLnggLSB4KTtcbiAgICAgICAgICAgIGR5ID0gTWF0aC5yb3VuZChjbWQueSAtIHkpO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeCcsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHh9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHknLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ3Jtb3ZldG8nLCB0eXBlOiAnT1AnLCB2YWx1ZTogMjF9KTtcbiAgICAgICAgICAgIHggPSBNYXRoLnJvdW5kKGNtZC54KTtcbiAgICAgICAgICAgIHkgPSBNYXRoLnJvdW5kKGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICBkeCA9IE1hdGgucm91bmQoY21kLnggLSB4KTtcbiAgICAgICAgICAgIGR5ID0gTWF0aC5yb3VuZChjbWQueSAtIHkpO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeCcsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHh9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHknLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ3JsaW5ldG8nLCB0eXBlOiAnT1AnLCB2YWx1ZTogNX0pO1xuICAgICAgICAgICAgeCA9IE1hdGgucm91bmQoY21kLngpO1xuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQoY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIHZhciBkeDEgPSBNYXRoLnJvdW5kKGNtZC54MSAtIHgpO1xuICAgICAgICAgICAgdmFyIGR5MSA9IE1hdGgucm91bmQoY21kLnkxIC0geSk7XG4gICAgICAgICAgICB2YXIgZHgyID0gTWF0aC5yb3VuZChjbWQueDIgLSBjbWQueDEpO1xuICAgICAgICAgICAgdmFyIGR5MiA9IE1hdGgucm91bmQoY21kLnkyIC0gY21kLnkxKTtcbiAgICAgICAgICAgIGR4ID0gTWF0aC5yb3VuZChjbWQueCAtIGNtZC54Mik7XG4gICAgICAgICAgICBkeSA9IE1hdGgucm91bmQoY21kLnkgLSBjbWQueTIpO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeDEnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4MX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeTEnLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5MX0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeDInLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR4Mn0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeTInLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5Mn0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeCcsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHh9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAnZHknLCB0eXBlOiAnTlVNQkVSJywgdmFsdWU6IGR5fSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ3JyY3VydmV0bycsIHR5cGU6ICdPUCcsIHZhbHVlOiA4fSk7XG4gICAgICAgICAgICB4ID0gTWF0aC5yb3VuZChjbWQueCk7XG4gICAgICAgICAgICB5ID0gTWF0aC5yb3VuZChjbWQueSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb250b3VycyBhcmUgY2xvc2VkIGF1dG9tYXRpY2FsbHkuXG4gICAgfVxuXG4gICAgb3BzLnB1c2goe25hbWU6ICdlbmRjaGFyJywgdHlwZTogJ09QJywgdmFsdWU6IDE0fSk7XG4gICAgcmV0dXJuIG9wcztcbn1cblxuZnVuY3Rpb24gbWFrZUNoYXJTdHJpbmdzSW5kZXgoZ2x5cGhzKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuUmVjb3JkKCdDaGFyU3RyaW5ncyBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICdjaGFyU3RyaW5ncycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgIHZhciBvcHMgPSBnbHlwaFRvT3BzKGdseXBoKTtcbiAgICAgICAgdC5jaGFyU3RyaW5ncy5wdXNoKHtuYW1lOiBnbHlwaC5uYW1lLCB0eXBlOiAnQ0hBUlNUUklORycsIHZhbHVlOiBvcHN9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbWFrZVByaXZhdGVEaWN0KGF0dHJzLCBzdHJpbmdzKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuUmVjb3JkKCdQcml2YXRlIERJQ1QnLCBbXG4gICAgICAgIHtuYW1lOiAnZGljdCcsIHR5cGU6ICdESUNUJywgdmFsdWU6IHt9fVxuICAgIF0pO1xuICAgIHQuZGljdCA9IG1ha2VEaWN0KFBSSVZBVEVfRElDVF9NRVRBLCBhdHRycywgc3RyaW5ncyk7XG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VDRkZUYWJsZShnbHlwaHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnQ0ZGICcsIFtcbiAgICAgICAge25hbWU6ICdoZWFkZXInLCB0eXBlOiAnUkVDT1JEJ30sXG4gICAgICAgIHtuYW1lOiAnbmFtZUluZGV4JywgdHlwZTogJ1JFQ09SRCd9LFxuICAgICAgICB7bmFtZTogJ3RvcERpY3RJbmRleCcsIHR5cGU6ICdSRUNPUkQnfSxcbiAgICAgICAge25hbWU6ICdzdHJpbmdJbmRleCcsIHR5cGU6ICdSRUNPUkQnfSxcbiAgICAgICAge25hbWU6ICdnbG9iYWxTdWJySW5kZXgnLCB0eXBlOiAnUkVDT1JEJ30sXG4gICAgICAgIHtuYW1lOiAnY2hhcnNldHMnLCB0eXBlOiAnUkVDT1JEJ30sXG4gICAgICAgIHtuYW1lOiAnY2hhclN0cmluZ3NJbmRleCcsIHR5cGU6ICdSRUNPUkQnfSxcbiAgICAgICAge25hbWU6ICdwcml2YXRlRGljdCcsIHR5cGU6ICdSRUNPUkQnfVxuICAgIF0pO1xuXG4gICAgdmFyIGZvbnRTY2FsZSA9IDEgLyBvcHRpb25zLnVuaXRzUGVyRW07XG4gICAgLy8gV2UgdXNlIG5vbi16ZXJvIHZhbHVlcyBmb3IgdGhlIG9mZnNldHMgc28gdGhhdCB0aGUgRElDVCBlbmNvZGVzIHRoZW0uXG4gICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgYmVjYXVzZSB0aGUgc2l6ZSBvZiB0aGUgVG9wIERJQ1QgcGxheXMgYSByb2xlIGluIG9mZnNldCBjYWxjdWxhdGlvbixcbiAgICAvLyBhbmQgdGhlIHNpemUgc2hvdWxkbid0IGNoYW5nZSBhZnRlciB3ZSd2ZSB3cml0dGVuIGNvcnJlY3Qgb2Zmc2V0cy5cbiAgICB2YXIgYXR0cnMgPSB7XG4gICAgICAgIHZlcnNpb246IG9wdGlvbnMudmVyc2lvbixcbiAgICAgICAgZnVsbE5hbWU6IG9wdGlvbnMuZnVsbE5hbWUsXG4gICAgICAgIGZhbWlseU5hbWU6IG9wdGlvbnMuZmFtaWx5TmFtZSxcbiAgICAgICAgd2VpZ2h0OiBvcHRpb25zLndlaWdodE5hbWUsXG4gICAgICAgIGZvbnRCQm94OiBvcHRpb25zLmZvbnRCQm94IHx8IFswLCAwLCAwLCAwXSxcbiAgICAgICAgZm9udE1hdHJpeDogW2ZvbnRTY2FsZSwgMCwgMCwgZm9udFNjYWxlLCAwLCAwXSxcbiAgICAgICAgY2hhcnNldDogOTk5LFxuICAgICAgICBlbmNvZGluZzogMCxcbiAgICAgICAgY2hhclN0cmluZ3M6IDk5OSxcbiAgICAgICAgcHJpdmF0ZTogWzAsIDk5OV1cbiAgICB9O1xuXG4gICAgdmFyIHByaXZhdGVBdHRycyA9IHt9O1xuXG4gICAgdmFyIGdseXBoTmFtZXMgPSBbXTtcbiAgICB2YXIgZ2x5cGg7XG5cbiAgICAvLyBTa2lwIGZpcnN0IGdseXBoICgubm90ZGVmKVxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGdseXBoID0gZ2x5cGhzLmdldChpKTtcbiAgICAgICAgZ2x5cGhOYW1lcy5wdXNoKGdseXBoLm5hbWUpO1xuICAgIH1cblxuICAgIHZhciBzdHJpbmdzID0gW107XG5cbiAgICB0LmhlYWRlciA9IG1ha2VIZWFkZXIoKTtcbiAgICB0Lm5hbWVJbmRleCA9IG1ha2VOYW1lSW5kZXgoW29wdGlvbnMucG9zdFNjcmlwdE5hbWVdKTtcbiAgICB2YXIgdG9wRGljdCA9IG1ha2VUb3BEaWN0KGF0dHJzLCBzdHJpbmdzKTtcbiAgICB0LnRvcERpY3RJbmRleCA9IG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCk7XG4gICAgdC5nbG9iYWxTdWJySW5kZXggPSBtYWtlR2xvYmFsU3VickluZGV4KCk7XG4gICAgdC5jaGFyc2V0cyA9IG1ha2VDaGFyc2V0cyhnbHlwaE5hbWVzLCBzdHJpbmdzKTtcbiAgICB0LmNoYXJTdHJpbmdzSW5kZXggPSBtYWtlQ2hhclN0cmluZ3NJbmRleChnbHlwaHMpO1xuICAgIHQucHJpdmF0ZURpY3QgPSBtYWtlUHJpdmF0ZURpY3QocHJpdmF0ZUF0dHJzLCBzdHJpbmdzKTtcblxuICAgIC8vIE5lZWRzIHRvIGNvbWUgYXQgdGhlIGVuZCwgdG8gZW5jb2RlIGFsbCBjdXN0b20gc3RyaW5ncyB1c2VkIGluIHRoZSBmb250LlxuICAgIHQuc3RyaW5nSW5kZXggPSBtYWtlU3RyaW5nSW5kZXgoc3RyaW5ncyk7XG5cbiAgICB2YXIgc3RhcnRPZmZzZXQgPSB0LmhlYWRlci5zaXplT2YoKSArXG4gICAgICAgIHQubmFtZUluZGV4LnNpemVPZigpICtcbiAgICAgICAgdC50b3BEaWN0SW5kZXguc2l6ZU9mKCkgK1xuICAgICAgICB0LnN0cmluZ0luZGV4LnNpemVPZigpICtcbiAgICAgICAgdC5nbG9iYWxTdWJySW5kZXguc2l6ZU9mKCk7XG4gICAgYXR0cnMuY2hhcnNldCA9IHN0YXJ0T2Zmc2V0O1xuXG4gICAgLy8gV2UgdXNlIHRoZSBDRkYgc3RhbmRhcmQgZW5jb2Rpbmc7IHByb3BlciBlbmNvZGluZyB3aWxsIGJlIGhhbmRsZWQgaW4gY21hcC5cbiAgICBhdHRycy5lbmNvZGluZyA9IDA7XG4gICAgYXR0cnMuY2hhclN0cmluZ3MgPSBhdHRycy5jaGFyc2V0ICsgdC5jaGFyc2V0cy5zaXplT2YoKTtcbiAgICBhdHRycy5wcml2YXRlWzFdID0gYXR0cnMuY2hhclN0cmluZ3MgKyB0LmNoYXJTdHJpbmdzSW5kZXguc2l6ZU9mKCk7XG5cbiAgICAvLyBSZWNyZWF0ZSB0aGUgVG9wIERJQ1QgSU5ERVggd2l0aCB0aGUgY29ycmVjdCBvZmZzZXRzLlxuICAgIHRvcERpY3QgPSBtYWtlVG9wRGljdChhdHRycywgc3RyaW5ncyk7XG4gICAgdC50b3BEaWN0SW5kZXggPSBtYWtlVG9wRGljdEluZGV4KHRvcERpY3QpO1xuXG4gICAgcmV0dXJuIHQ7XG59XG5cbnZhciBjZmYgPSB7IHBhcnNlOiBwYXJzZUNGRlRhYmxlLCBtYWtlOiBtYWtlQ0ZGVGFibGUgfTtcblxuLy8gVGhlIGBoZWFkYCB0YWJsZSBjb250YWlucyBnbG9iYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGZvbnQuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2hlYWQuaHRtXG5cbi8vIFBhcnNlIHRoZSBoZWFkZXIgYGhlYWRgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZUhlYWRUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBoZWFkID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBoZWFkLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIGhlYWQuZm9udFJldmlzaW9uID0gTWF0aC5yb3VuZChwLnBhcnNlRml4ZWQoKSAqIDEwMDApIC8gMTAwMDtcbiAgICBoZWFkLmNoZWNrU3VtQWRqdXN0bWVudCA9IHAucGFyc2VVTG9uZygpO1xuICAgIGhlYWQubWFnaWNOdW1iZXIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjaGVjay5hcmd1bWVudChoZWFkLm1hZ2ljTnVtYmVyID09PSAweDVGMEYzQ0Y1LCAnRm9udCBoZWFkZXIgaGFzIHdyb25nIG1hZ2ljIG51bWJlci4nKTtcbiAgICBoZWFkLmZsYWdzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQudW5pdHNQZXJFbSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLmNyZWF0ZWQgPSBwLnBhcnNlTG9uZ0RhdGVUaW1lKCk7XG4gICAgaGVhZC5tb2RpZmllZCA9IHAucGFyc2VMb25nRGF0ZVRpbWUoKTtcbiAgICBoZWFkLnhNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnlNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnhNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLnlNYXggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLm1hY1N0eWxlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQubG93ZXN0UmVjUFBFTSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBoZWFkLmZvbnREaXJlY3Rpb25IaW50ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC5pbmRleFRvTG9jRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGVhZC5nbHlwaERhdGFGb3JtYXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICByZXR1cm4gaGVhZDtcbn1cblxuZnVuY3Rpb24gbWFrZUhlYWRUYWJsZShvcHRpb25zKSB7XG4gICAgLy8gQXBwbGUgTWFjIHRpbWVzdGFtcCBlcG9jaCBpcyAwMS8wMS8xOTA0IG5vdCAwMS8wMS8xOTcwXG4gICAgdmFyIHRpbWVzdGFtcCA9IE1hdGgucm91bmQobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKSArIDIwODI4NDQ4MDA7XG4gICAgdmFyIGNyZWF0ZWRUaW1lc3RhbXAgPSB0aW1lc3RhbXA7XG5cbiAgICBpZiAob3B0aW9ucy5jcmVhdGVkVGltZXN0YW1wKSB7XG4gICAgICAgIGNyZWF0ZWRUaW1lc3RhbXAgPSBvcHRpb25zLmNyZWF0ZWRUaW1lc3RhbXAgKyAyMDgyODQ0ODAwO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2hlYWQnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAweDAwMDEwMDAwfSxcbiAgICAgICAge25hbWU6ICdmb250UmV2aXNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnY2hlY2tTdW1BZGp1c3RtZW50JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21hZ2ljTnVtYmVyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB4NUYwRjNDRjV9LFxuICAgICAgICB7bmFtZTogJ2ZsYWdzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bml0c1BlckVtJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxMDAwfSxcbiAgICAgICAge25hbWU6ICdjcmVhdGVkJywgdHlwZTogJ0xPTkdEQVRFVElNRScsIHZhbHVlOiBjcmVhdGVkVGltZXN0YW1wfSxcbiAgICAgICAge25hbWU6ICdtb2RpZmllZCcsIHR5cGU6ICdMT05HREFURVRJTUUnLCB2YWx1ZTogdGltZXN0YW1wfSxcbiAgICAgICAge25hbWU6ICd4TWluJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lNaW4nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneE1heCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5TWF4JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21hY1N0eWxlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdsb3dlc3RSZWNQUEVNJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdmb250RGlyZWN0aW9uSGludCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAyfSxcbiAgICAgICAge25hbWU6ICdpbmRleFRvTG9jRm9ybWF0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2dseXBoRGF0YUZvcm1hdCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0sIG9wdGlvbnMpO1xufVxuXG52YXIgaGVhZCA9IHsgcGFyc2U6IHBhcnNlSGVhZFRhYmxlLCBtYWtlOiBtYWtlSGVhZFRhYmxlIH07XG5cbi8vIFRoZSBgaGhlYWAgdGFibGUgY29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGhvcml6b250YWwgbGF5b3V0LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9oaGVhLmh0bVxuXG4vLyBQYXJzZSB0aGUgaG9yaXpvbnRhbCBoZWFkZXIgYGhoZWFgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZUhoZWFUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBoaGVhID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBoaGVhLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIGhoZWEuYXNjZW5kZXIgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmRlc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEubGluZUdhcCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuYWR2YW5jZVdpZHRoTWF4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhoZWEubWluTGVmdFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5taW5SaWdodFNpZGVCZWFyaW5nID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS54TWF4RXh0ZW50ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5jYXJldFNsb3BlUmlzZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRTbG9wZVJ1biA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuY2FyZXRPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBwLnJlbGF0aXZlT2Zmc2V0ICs9IDg7XG4gICAgaGhlYS5tZXRyaWNEYXRhRm9ybWF0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5udW1iZXJPZkhNZXRyaWNzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHJldHVybiBoaGVhO1xufVxuXG5mdW5jdGlvbiBtYWtlSGhlYVRhYmxlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdoaGVhJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnYXNjZW5kZXInLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZGVzY2VuZGVyJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2xpbmVHYXAnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYWR2YW5jZVdpZHRoTWF4JywgdHlwZTogJ1VGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtaW5MZWZ0U2lkZUJlYXJpbmcnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWluUmlnaHRTaWRlQmVhcmluZycsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd4TWF4RXh0ZW50JywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2NhcmV0U2xvcGVSaXNlJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ2NhcmV0U2xvcGVSdW4nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnY2FyZXRPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmVzZXJ2ZWQxJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3Jlc2VydmVkMicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyZXNlcnZlZDMnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmVzZXJ2ZWQ0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21ldHJpY0RhdGFGb3JtYXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbnVtYmVyT2ZITWV0cmljcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdLCBvcHRpb25zKTtcbn1cblxudmFyIGhoZWEgPSB7IHBhcnNlOiBwYXJzZUhoZWFUYWJsZSwgbWFrZTogbWFrZUhoZWFUYWJsZSB9O1xuXG4vLyBUaGUgYGhtdHhgIHRhYmxlIGNvbnRhaW5zIHRoZSBob3Jpem9udGFsIG1ldHJpY3MgZm9yIGFsbCBnbHlwaHMuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2htdHguaHRtXG5cbi8vIFBhcnNlIHRoZSBgaG10eGAgdGFibGUsIHdoaWNoIGNvbnRhaW5zIHRoZSBob3Jpem9udGFsIG1ldHJpY3MgZm9yIGFsbCBnbHlwaHMuXG4vLyBUaGlzIGZ1bmN0aW9uIGF1Z21lbnRzIHRoZSBnbHlwaCBhcnJheSwgYWRkaW5nIHRoZSBhZHZhbmNlV2lkdGggYW5kIGxlZnRTaWRlQmVhcmluZyB0byBlYWNoIGdseXBoLlxuZnVuY3Rpb24gcGFyc2VIbXR4VGFibGUoZGF0YSwgc3RhcnQsIG51bU1ldHJpY3MsIG51bUdseXBocywgZ2x5cGhzKSB7XG4gICAgdmFyIGFkdmFuY2VXaWR0aDtcbiAgICB2YXIgbGVmdFNpZGVCZWFyaW5nO1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1HbHlwaHM7IGkgKz0gMSkge1xuICAgICAgICAvLyBJZiB0aGUgZm9udCBpcyBtb25vc3BhY2VkLCBvbmx5IG9uZSBlbnRyeSBpcyBuZWVkZWQuIFRoaXMgbGFzdCBlbnRyeSBhcHBsaWVzIHRvIGFsbCBzdWJzZXF1ZW50IGdseXBocy5cbiAgICAgICAgaWYgKGkgPCBudW1NZXRyaWNzKSB7XG4gICAgICAgICAgICBhZHZhbmNlV2lkdGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBsZWZ0U2lkZUJlYXJpbmcgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgIGdseXBoLmFkdmFuY2VXaWR0aCA9IGFkdmFuY2VXaWR0aDtcbiAgICAgICAgZ2x5cGgubGVmdFNpZGVCZWFyaW5nID0gbGVmdFNpZGVCZWFyaW5nO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gbWFrZUhtdHhUYWJsZShnbHlwaHMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnaG10eCcsIFtdKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHMuZ2V0KGkpO1xuICAgICAgICB2YXIgYWR2YW5jZVdpZHRoID0gZ2x5cGguYWR2YW5jZVdpZHRoIHx8IDA7XG4gICAgICAgIHZhciBsZWZ0U2lkZUJlYXJpbmcgPSBnbHlwaC5sZWZ0U2lkZUJlYXJpbmcgfHwgMDtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ2FkdmFuY2VXaWR0aF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBhZHZhbmNlV2lkdGh9KTtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ2xlZnRTaWRlQmVhcmluZ18nICsgaSwgdHlwZTogJ1NIT1JUJywgdmFsdWU6IGxlZnRTaWRlQmVhcmluZ30pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG52YXIgaG10eCA9IHsgcGFyc2U6IHBhcnNlSG10eFRhYmxlLCBtYWtlOiBtYWtlSG10eFRhYmxlIH07XG5cbi8vIFRoZSBgbHRhZ2AgdGFibGUgc3RvcmVzIElFVEYgQkNQLTQ3IGxhbmd1YWdlIHRhZ3MuIEl0IGFsbG93cyBzdXBwb3J0aW5nXG4vLyBsYW5ndWFnZXMgZm9yIHdoaWNoIFRydWVUeXBlIGRvZXMgbm90IGFzc2lnbiBhIG51bWVyaWMgY29kZS5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9mb250cy9UcnVlVHlwZS1SZWZlcmVuY2UtTWFudWFsL1JNMDYvQ2hhcDZsdGFnLmh0bWxcbi8vIGh0dHA6Ly93d3cudzMub3JnL0ludGVybmF0aW9uYWwvYXJ0aWNsZXMvbGFuZ3VhZ2UtdGFncy9cbi8vIGh0dHA6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvbGFuZ3VhZ2Utc3VidGFnLXJlZ2lzdHJ5L2xhbmd1YWdlLXN1YnRhZy1yZWdpc3RyeVxuXG5mdW5jdGlvbiBtYWtlTHRhZ1RhYmxlKHRhZ3MpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IHRhYmxlLlRhYmxlKCdsdGFnJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMX0sXG4gICAgICAgIHtuYW1lOiAnZmxhZ3MnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbnVtVGFncycsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiB0YWdzLmxlbmd0aH1cbiAgICBdKTtcblxuICAgIHZhciBzdHJpbmdQb29sID0gJyc7XG4gICAgdmFyIHN0cmluZ1Bvb2xPZmZzZXQgPSAxMiArIHRhZ3MubGVuZ3RoICogNDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHBvcyA9IHN0cmluZ1Bvb2wuaW5kZXhPZih0YWdzW2ldKTtcbiAgICAgICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgICAgIHBvcyA9IHN0cmluZ1Bvb2wubGVuZ3RoO1xuICAgICAgICAgICAgc3RyaW5nUG9vbCArPSB0YWdzW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0LmZpZWxkcy5wdXNoKHtuYW1lOiAnb2Zmc2V0ICcgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHN0cmluZ1Bvb2xPZmZzZXQgKyBwb3N9KTtcbiAgICAgICAgcmVzdWx0LmZpZWxkcy5wdXNoKHtuYW1lOiAnbGVuZ3RoICcgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHRhZ3NbaV0ubGVuZ3RofSk7XG4gICAgfVxuXG4gICAgcmVzdWx0LmZpZWxkcy5wdXNoKHtuYW1lOiAnc3RyaW5nUG9vbCcsIHR5cGU6ICdDSEFSQVJSQVknLCB2YWx1ZTogc3RyaW5nUG9vbH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTHRhZ1RhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVVMb25nKCk7XG4gICAgY2hlY2suYXJndW1lbnQodGFibGVWZXJzaW9uID09PSAxLCAnVW5zdXBwb3J0ZWQgbHRhZyB0YWJsZSB2ZXJzaW9uLicpO1xuICAgIC8vIFRoZSAnbHRhZycgc3BlY2lmaWNhdGlvbiBkb2VzIG5vdCBkZWZpbmUgYW55IGZsYWdzOyBza2lwIHRoZSBmaWVsZC5cbiAgICBwLnNraXAoJ3VMb25nJywgMSk7XG4gICAgdmFyIG51bVRhZ3MgPSBwLnBhcnNlVUxvbmcoKTtcblxuICAgIHZhciB0YWdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UYWdzOyBpKyspIHtcbiAgICAgICAgdmFyIHRhZyA9ICcnO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gc3RhcnQgKyBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGZvciAodmFyIGogPSBvZmZzZXQ7IGogPCBvZmZzZXQgKyBsZW5ndGg7ICsraikge1xuICAgICAgICAgICAgdGFnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YS5nZXRJbnQ4KGopKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhZ3MucHVzaCh0YWcpO1xuICAgIH1cblxuICAgIHJldHVybiB0YWdzO1xufVxuXG52YXIgbHRhZyA9IHsgbWFrZTogbWFrZUx0YWdUYWJsZSwgcGFyc2U6IHBhcnNlTHRhZ1RhYmxlIH07XG5cbi8vIFRoZSBgbWF4cGAgdGFibGUgZXN0YWJsaXNoZXMgdGhlIG1lbW9yeSByZXF1aXJlbWVudHMgZm9yIHRoZSBmb250LlxuLy8gV2UgbmVlZCBpdCBqdXN0IHRvIGdldCB0aGUgbnVtYmVyIG9mIGdseXBocyBpbiB0aGUgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvbWF4cC5odG1cblxuLy8gUGFyc2UgdGhlIG1heGltdW0gcHJvZmlsZSBgbWF4cGAgdGFibGUuXG5mdW5jdGlvbiBwYXJzZU1heHBUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBtYXhwID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBtYXhwLnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIG1heHAubnVtR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChtYXhwLnZlcnNpb24gPT09IDEuMCkge1xuICAgICAgICBtYXhwLm1heFBvaW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb250b3VycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb21wb3NpdGVQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29tcG9zaXRlQ29udG91cnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Wm9uZXMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4VHdpbGlnaHRQb2ludHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4U3RvcmFnZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhGdW5jdGlvbkRlZnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4SW5zdHJ1Y3Rpb25EZWZzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heFN0YWNrRWxlbWVudHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4U2l6ZU9mSW5zdHJ1Y3Rpb25zID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvbmVudEVsZW1lbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvbmVudERlcHRoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXhwO1xufVxuXG5mdW5jdGlvbiBtYWtlTWF4cFRhYmxlKG51bUdseXBocykge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ21heHAnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAweDAwMDA1MDAwfSxcbiAgICAgICAge25hbWU6ICdudW1HbHlwaHMnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IG51bUdseXBoc31cbiAgICBdKTtcbn1cblxudmFyIG1heHAgPSB7IHBhcnNlOiBwYXJzZU1heHBUYWJsZSwgbWFrZTogbWFrZU1heHBUYWJsZSB9O1xuXG4vLyBUaGUgYG5hbWVgIG5hbWluZyB0YWJsZS5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvbmFtZS5odG1cblxuLy8gTmFtZUlEcyBmb3IgdGhlIG5hbWUgdGFibGUuXG52YXIgbmFtZVRhYmxlTmFtZXMgPSBbXG4gICAgJ2NvcHlyaWdodCcsICAgICAgICAgICAgICAvLyAwXG4gICAgJ2ZvbnRGYW1pbHknLCAgICAgICAgICAgICAvLyAxXG4gICAgJ2ZvbnRTdWJmYW1pbHknLCAgICAgICAgICAvLyAyXG4gICAgJ3VuaXF1ZUlEJywgICAgICAgICAgICAgICAvLyAzXG4gICAgJ2Z1bGxOYW1lJywgICAgICAgICAgICAgICAvLyA0XG4gICAgJ3ZlcnNpb24nLCAgICAgICAgICAgICAgICAvLyA1XG4gICAgJ3Bvc3RTY3JpcHROYW1lJywgICAgICAgICAvLyA2XG4gICAgJ3RyYWRlbWFyaycsICAgICAgICAgICAgICAvLyA3XG4gICAgJ21hbnVmYWN0dXJlcicsICAgICAgICAgICAvLyA4XG4gICAgJ2Rlc2lnbmVyJywgICAgICAgICAgICAgICAvLyA5XG4gICAgJ2Rlc2NyaXB0aW9uJywgICAgICAgICAgICAvLyAxMFxuICAgICdtYW51ZmFjdHVyZXJVUkwnLCAgICAgICAgLy8gMTFcbiAgICAnZGVzaWduZXJVUkwnLCAgICAgICAgICAgIC8vIDEyXG4gICAgJ2xpY2Vuc2UnLCAgICAgICAgICAgICAgICAvLyAxM1xuICAgICdsaWNlbnNlVVJMJywgICAgICAgICAgICAgLy8gMTRcbiAgICAncmVzZXJ2ZWQnLCAgICAgICAgICAgICAgIC8vIDE1XG4gICAgJ3ByZWZlcnJlZEZhbWlseScsICAgICAgICAvLyAxNlxuICAgICdwcmVmZXJyZWRTdWJmYW1pbHknLCAgICAgLy8gMTdcbiAgICAnY29tcGF0aWJsZUZ1bGxOYW1lJywgICAgIC8vIDE4XG4gICAgJ3NhbXBsZVRleHQnLCAgICAgICAgICAgICAvLyAxOVxuICAgICdwb3N0U2NyaXB0RmluZEZvbnROYW1lJywgLy8gMjBcbiAgICAnd3dzRmFtaWx5JywgICAgICAgICAgICAgIC8vIDIxXG4gICAgJ3d3c1N1YmZhbWlseScgICAgICAgICAgICAvLyAyMlxuXTtcblxudmFyIG1hY0xhbmd1YWdlcyA9IHtcbiAgICAwOiAnZW4nLFxuICAgIDE6ICdmcicsXG4gICAgMjogJ2RlJyxcbiAgICAzOiAnaXQnLFxuICAgIDQ6ICdubCcsXG4gICAgNTogJ3N2JyxcbiAgICA2OiAnZXMnLFxuICAgIDc6ICdkYScsXG4gICAgODogJ3B0JyxcbiAgICA5OiAnbm8nLFxuICAgIDEwOiAnaGUnLFxuICAgIDExOiAnamEnLFxuICAgIDEyOiAnYXInLFxuICAgIDEzOiAnZmknLFxuICAgIDE0OiAnZWwnLFxuICAgIDE1OiAnaXMnLFxuICAgIDE2OiAnbXQnLFxuICAgIDE3OiAndHInLFxuICAgIDE4OiAnaHInLFxuICAgIDE5OiAnemgtSGFudCcsXG4gICAgMjA6ICd1cicsXG4gICAgMjE6ICdoaScsXG4gICAgMjI6ICd0aCcsXG4gICAgMjM6ICdrbycsXG4gICAgMjQ6ICdsdCcsXG4gICAgMjU6ICdwbCcsXG4gICAgMjY6ICdodScsXG4gICAgMjc6ICdlcycsXG4gICAgMjg6ICdsdicsXG4gICAgMjk6ICdzZScsXG4gICAgMzA6ICdmbycsXG4gICAgMzE6ICdmYScsXG4gICAgMzI6ICdydScsXG4gICAgMzM6ICd6aCcsXG4gICAgMzQ6ICdubC1CRScsXG4gICAgMzU6ICdnYScsXG4gICAgMzY6ICdzcScsXG4gICAgMzc6ICdybycsXG4gICAgMzg6ICdjeicsXG4gICAgMzk6ICdzaycsXG4gICAgNDA6ICdzaScsXG4gICAgNDE6ICd5aScsXG4gICAgNDI6ICdzcicsXG4gICAgNDM6ICdtaycsXG4gICAgNDQ6ICdiZycsXG4gICAgNDU6ICd1aycsXG4gICAgNDY6ICdiZScsXG4gICAgNDc6ICd1eicsXG4gICAgNDg6ICdraycsXG4gICAgNDk6ICdhei1DeXJsJyxcbiAgICA1MDogJ2F6LUFyYWInLFxuICAgIDUxOiAnaHknLFxuICAgIDUyOiAna2EnLFxuICAgIDUzOiAnbW8nLFxuICAgIDU0OiAna3knLFxuICAgIDU1OiAndGcnLFxuICAgIDU2OiAndGsnLFxuICAgIDU3OiAnbW4tQ04nLFxuICAgIDU4OiAnbW4nLFxuICAgIDU5OiAncHMnLFxuICAgIDYwOiAna3MnLFxuICAgIDYxOiAna3UnLFxuICAgIDYyOiAnc2QnLFxuICAgIDYzOiAnYm8nLFxuICAgIDY0OiAnbmUnLFxuICAgIDY1OiAnc2EnLFxuICAgIDY2OiAnbXInLFxuICAgIDY3OiAnYm4nLFxuICAgIDY4OiAnYXMnLFxuICAgIDY5OiAnZ3UnLFxuICAgIDcwOiAncGEnLFxuICAgIDcxOiAnb3InLFxuICAgIDcyOiAnbWwnLFxuICAgIDczOiAna24nLFxuICAgIDc0OiAndGEnLFxuICAgIDc1OiAndGUnLFxuICAgIDc2OiAnc2knLFxuICAgIDc3OiAnbXknLFxuICAgIDc4OiAna20nLFxuICAgIDc5OiAnbG8nLFxuICAgIDgwOiAndmknLFxuICAgIDgxOiAnaWQnLFxuICAgIDgyOiAndGwnLFxuICAgIDgzOiAnbXMnLFxuICAgIDg0OiAnbXMtQXJhYicsXG4gICAgODU6ICdhbScsXG4gICAgODY6ICd0aScsXG4gICAgODc6ICdvbScsXG4gICAgODg6ICdzbycsXG4gICAgODk6ICdzdycsXG4gICAgOTA6ICdydycsXG4gICAgOTE6ICdybicsXG4gICAgOTI6ICdueScsXG4gICAgOTM6ICdtZycsXG4gICAgOTQ6ICdlbycsXG4gICAgMTI4OiAnY3knLFxuICAgIDEyOTogJ2V1JyxcbiAgICAxMzA6ICdjYScsXG4gICAgMTMxOiAnbGEnLFxuICAgIDEzMjogJ3F1JyxcbiAgICAxMzM6ICdnbicsXG4gICAgMTM0OiAnYXknLFxuICAgIDEzNTogJ3R0JyxcbiAgICAxMzY6ICd1ZycsXG4gICAgMTM3OiAnZHonLFxuICAgIDEzODogJ2p2JyxcbiAgICAxMzk6ICdzdScsXG4gICAgMTQwOiAnZ2wnLFxuICAgIDE0MTogJ2FmJyxcbiAgICAxNDI6ICdicicsXG4gICAgMTQzOiAnaXUnLFxuICAgIDE0NDogJ2dkJyxcbiAgICAxNDU6ICdndicsXG4gICAgMTQ2OiAnZ2EnLFxuICAgIDE0NzogJ3RvJyxcbiAgICAxNDg6ICdlbC1wb2x5dG9uJyxcbiAgICAxNDk6ICdrbCcsXG4gICAgMTUwOiAnYXonLFxuICAgIDE1MTogJ25uJ1xufTtcblxuLy8gTWFjT1MgbGFuZ3VhZ2UgSUQg4oaSIE1hY09TIHNjcmlwdCBJRFxuLy9cbi8vIE5vdGUgdGhhdCB0aGUgc2NyaXB0IElEIGlzIG5vdCBzdWZmaWNpZW50IHRvIGRldGVybWluZSB3aGF0IGVuY29kaW5nXG4vLyB0byB1c2UgaW4gVHJ1ZVR5cGUgZmlsZXMuIEZvciBzb21lIGxhbmd1YWdlcywgTWFjT1MgdXNlZCBhIG1vZGlmaWNhdGlvblxuLy8gb2YgYSBtYWluc3RyZWFtIHNjcmlwdC4gRm9yIGV4YW1wbGUsIGFuIEljZWxhbmRpYyBuYW1lIHdvdWxkIGJlIHN0b3JlZFxuLy8gd2l0aCBzbVJvbWFuIGluIHRoZSBUcnVlVHlwZSBuYW1pbmcgdGFibGUsIGJ1dCB0aGUgYWN0dWFsIGVuY29kaW5nXG4vLyBpcyBhIHNwZWNpYWwgSWNlbGFuZGljIHZlcnNpb24gb2YgdGhlIG5vcm1hbCBNYWNpbnRvc2ggUm9tYW4gZW5jb2RpbmcuXG4vLyBBcyBhbm90aGVyIGV4YW1wbGUsIEludWt0aXR1dCB1c2VzIGFuIDgtYml0IGVuY29kaW5nIGZvciBDYW5hZGlhbiBBYm9yaWdpbmFsXG4vLyBTeWxsYWJsZXMgYnV0IE1hY09TIGhhZCBydW4gb3V0IG9mIGF2YWlsYWJsZSBzY3JpcHQgY29kZXMsIHNvIHRoaXMgd2FzXG4vLyBkb25lIGFzIGEgKHByZXR0eSByYWRpY2FsKSBcIm1vZGlmaWNhdGlvblwiIG9mIEV0aGlvcGljLlxuLy9cbi8vIGh0dHA6Ly91bmljb2RlLm9yZy9QdWJsaWMvTUFQUElOR1MvVkVORE9SUy9BUFBMRS9SZWFkbWUudHh0XG52YXIgbWFjTGFuZ3VhZ2VUb1NjcmlwdCA9IHtcbiAgICAwOiAwLCAgLy8gbGFuZ0VuZ2xpc2gg4oaSIHNtUm9tYW5cbiAgICAxOiAwLCAgLy8gbGFuZ0ZyZW5jaCDihpIgc21Sb21hblxuICAgIDI6IDAsICAvLyBsYW5nR2VybWFuIOKGkiBzbVJvbWFuXG4gICAgMzogMCwgIC8vIGxhbmdJdGFsaWFuIOKGkiBzbVJvbWFuXG4gICAgNDogMCwgIC8vIGxhbmdEdXRjaCDihpIgc21Sb21hblxuICAgIDU6IDAsICAvLyBsYW5nU3dlZGlzaCDihpIgc21Sb21hblxuICAgIDY6IDAsICAvLyBsYW5nU3BhbmlzaCDihpIgc21Sb21hblxuICAgIDc6IDAsICAvLyBsYW5nRGFuaXNoIOKGkiBzbVJvbWFuXG4gICAgODogMCwgIC8vIGxhbmdQb3J0dWd1ZXNlIOKGkiBzbVJvbWFuXG4gICAgOTogMCwgIC8vIGxhbmdOb3J3ZWdpYW4g4oaSIHNtUm9tYW5cbiAgICAxMDogNSwgIC8vIGxhbmdIZWJyZXcg4oaSIHNtSGVicmV3XG4gICAgMTE6IDEsICAvLyBsYW5nSmFwYW5lc2Ug4oaSIHNtSmFwYW5lc2VcbiAgICAxMjogNCwgIC8vIGxhbmdBcmFiaWMg4oaSIHNtQXJhYmljXG4gICAgMTM6IDAsICAvLyBsYW5nRmlubmlzaCDihpIgc21Sb21hblxuICAgIDE0OiA2LCAgLy8gbGFuZ0dyZWVrIOKGkiBzbUdyZWVrXG4gICAgMTU6IDAsICAvLyBsYW5nSWNlbGFuZGljIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAxNjogMCwgIC8vIGxhbmdNYWx0ZXNlIOKGkiBzbVJvbWFuXG4gICAgMTc6IDAsICAvLyBsYW5nVHVya2lzaCDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMTg6IDAsICAvLyBsYW5nQ3JvYXRpYW4g4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDE5OiAyLCAgLy8gbGFuZ1RyYWRDaGluZXNlIOKGkiBzbVRyYWRDaGluZXNlXG4gICAgMjA6IDQsICAvLyBsYW5nVXJkdSDihpIgc21BcmFiaWNcbiAgICAyMTogOSwgIC8vIGxhbmdIaW5kaSDihpIgc21EZXZhbmFnYXJpXG4gICAgMjI6IDIxLCAgLy8gbGFuZ1RoYWkg4oaSIHNtVGhhaVxuICAgIDIzOiAzLCAgLy8gbGFuZ0tvcmVhbiDihpIgc21Lb3JlYW5cbiAgICAyNDogMjksICAvLyBsYW5nTGl0aHVhbmlhbiDihpIgc21DZW50cmFsRXVyb1JvbWFuXG4gICAgMjU6IDI5LCAgLy8gbGFuZ1BvbGlzaCDihpIgc21DZW50cmFsRXVyb1JvbWFuXG4gICAgMjY6IDI5LCAgLy8gbGFuZ0h1bmdhcmlhbiDihpIgc21DZW50cmFsRXVyb1JvbWFuXG4gICAgMjc6IDI5LCAgLy8gbGFuZ0VzdG9uaWFuIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cbiAgICAyODogMjksICAvLyBsYW5nTGF0dmlhbiDihpIgc21DZW50cmFsRXVyb1JvbWFuXG4gICAgMjk6IDAsICAvLyBsYW5nU2FtaSDihpIgc21Sb21hblxuICAgIDMwOiAwLCAgLy8gbGFuZ0Zhcm9lc2Ug4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDMxOiA0LCAgLy8gbGFuZ0ZhcnNpIOKGkiBzbUFyYWJpYyAobW9kaWZpZWQpXG4gICAgMzI6IDcsICAvLyBsYW5nUnVzc2lhbiDihpIgc21DeXJpbGxpY1xuICAgIDMzOiAyNSwgIC8vIGxhbmdTaW1wQ2hpbmVzZSDihpIgc21TaW1wQ2hpbmVzZVxuICAgIDM0OiAwLCAgLy8gbGFuZ0ZsZW1pc2gg4oaSIHNtUm9tYW5cbiAgICAzNTogMCwgIC8vIGxhbmdJcmlzaEdhZWxpYyDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMzY6IDAsICAvLyBsYW5nQWxiYW5pYW4g4oaSIHNtUm9tYW5cbiAgICAzNzogMCwgIC8vIGxhbmdSb21hbmlhbiDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMzg6IDI5LCAgLy8gbGFuZ0N6ZWNoIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cbiAgICAzOTogMjksICAvLyBsYW5nU2xvdmFrIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cbiAgICA0MDogMCwgIC8vIGxhbmdTbG92ZW5pYW4g4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDQxOiA1LCAgLy8gbGFuZ1lpZGRpc2gg4oaSIHNtSGVicmV3XG4gICAgNDI6IDcsICAvLyBsYW5nU2VyYmlhbiDihpIgc21DeXJpbGxpY1xuICAgIDQzOiA3LCAgLy8gbGFuZ01hY2Vkb25pYW4g4oaSIHNtQ3lyaWxsaWNcbiAgICA0NDogNywgIC8vIGxhbmdCdWxnYXJpYW4g4oaSIHNtQ3lyaWxsaWNcbiAgICA0NTogNywgIC8vIGxhbmdVa3JhaW5pYW4g4oaSIHNtQ3lyaWxsaWMgKG1vZGlmaWVkKVxuICAgIDQ2OiA3LCAgLy8gbGFuZ0J5ZWxvcnVzc2lhbiDihpIgc21DeXJpbGxpY1xuICAgIDQ3OiA3LCAgLy8gbGFuZ1V6YmVrIOKGkiBzbUN5cmlsbGljXG4gICAgNDg6IDcsICAvLyBsYW5nS2F6YWtoIOKGkiBzbUN5cmlsbGljXG4gICAgNDk6IDcsICAvLyBsYW5nQXplcmJhaWphbmkg4oaSIHNtQ3lyaWxsaWNcbiAgICA1MDogNCwgIC8vIGxhbmdBemVyYmFpamFuQXIg4oaSIHNtQXJhYmljXG4gICAgNTE6IDI0LCAgLy8gbGFuZ0FybWVuaWFuIOKGkiBzbUFybWVuaWFuXG4gICAgNTI6IDIzLCAgLy8gbGFuZ0dlb3JnaWFuIOKGkiBzbUdlb3JnaWFuXG4gICAgNTM6IDcsICAvLyBsYW5nTW9sZGF2aWFuIOKGkiBzbUN5cmlsbGljXG4gICAgNTQ6IDcsICAvLyBsYW5nS2lyZ2hpeiDihpIgc21DeXJpbGxpY1xuICAgIDU1OiA3LCAgLy8gbGFuZ1RhamlraSDihpIgc21DeXJpbGxpY1xuICAgIDU2OiA3LCAgLy8gbGFuZ1R1cmttZW4g4oaSIHNtQ3lyaWxsaWNcbiAgICA1NzogMjcsICAvLyBsYW5nTW9uZ29saWFuIOKGkiBzbU1vbmdvbGlhblxuICAgIDU4OiA3LCAgLy8gbGFuZ01vbmdvbGlhbkN5ciDihpIgc21DeXJpbGxpY1xuICAgIDU5OiA0LCAgLy8gbGFuZ1Bhc2h0byDihpIgc21BcmFiaWNcbiAgICA2MDogNCwgIC8vIGxhbmdLdXJkaXNoIOKGkiBzbUFyYWJpY1xuICAgIDYxOiA0LCAgLy8gbGFuZ0thc2htaXJpIOKGkiBzbUFyYWJpY1xuICAgIDYyOiA0LCAgLy8gbGFuZ1NpbmRoaSDihpIgc21BcmFiaWNcbiAgICA2MzogMjYsICAvLyBsYW5nVGliZXRhbiDihpIgc21UaWJldGFuXG4gICAgNjQ6IDksICAvLyBsYW5nTmVwYWxpIOKGkiBzbURldmFuYWdhcmlcbiAgICA2NTogOSwgIC8vIGxhbmdTYW5za3JpdCDihpIgc21EZXZhbmFnYXJpXG4gICAgNjY6IDksICAvLyBsYW5nTWFyYXRoaSDihpIgc21EZXZhbmFnYXJpXG4gICAgNjc6IDEzLCAgLy8gbGFuZ0JlbmdhbGkg4oaSIHNtQmVuZ2FsaVxuICAgIDY4OiAxMywgIC8vIGxhbmdBc3NhbWVzZSDihpIgc21CZW5nYWxpXG4gICAgNjk6IDExLCAgLy8gbGFuZ0d1amFyYXRpIOKGkiBzbUd1amFyYXRpXG4gICAgNzA6IDEwLCAgLy8gbGFuZ1B1bmphYmkg4oaSIHNtR3VybXVraGlcbiAgICA3MTogMTIsICAvLyBsYW5nT3JpeWEg4oaSIHNtT3JpeWFcbiAgICA3MjogMTcsICAvLyBsYW5nTWFsYXlhbGFtIOKGkiBzbU1hbGF5YWxhbVxuICAgIDczOiAxNiwgIC8vIGxhbmdLYW5uYWRhIOKGkiBzbUthbm5hZGFcbiAgICA3NDogMTQsICAvLyBsYW5nVGFtaWwg4oaSIHNtVGFtaWxcbiAgICA3NTogMTUsICAvLyBsYW5nVGVsdWd1IOKGkiBzbVRlbHVndVxuICAgIDc2OiAxOCwgIC8vIGxhbmdTaW5oYWxlc2Ug4oaSIHNtU2luaGFsZXNlXG4gICAgNzc6IDE5LCAgLy8gbGFuZ0J1cm1lc2Ug4oaSIHNtQnVybWVzZVxuICAgIDc4OiAyMCwgIC8vIGxhbmdLaG1lciDihpIgc21LaG1lclxuICAgIDc5OiAyMiwgIC8vIGxhbmdMYW8g4oaSIHNtTGFvXG4gICAgODA6IDMwLCAgLy8gbGFuZ1ZpZXRuYW1lc2Ug4oaSIHNtVmlldG5hbWVzZVxuICAgIDgxOiAwLCAgLy8gbGFuZ0luZG9uZXNpYW4g4oaSIHNtUm9tYW5cbiAgICA4MjogMCwgIC8vIGxhbmdUYWdhbG9nIOKGkiBzbVJvbWFuXG4gICAgODM6IDAsICAvLyBsYW5nTWFsYXlSb21hbiDihpIgc21Sb21hblxuICAgIDg0OiA0LCAgLy8gbGFuZ01hbGF5QXJhYmljIOKGkiBzbUFyYWJpY1xuICAgIDg1OiAyOCwgIC8vIGxhbmdBbWhhcmljIOKGkiBzbUV0aGlvcGljXG4gICAgODY6IDI4LCAgLy8gbGFuZ1RpZ3JpbnlhIOKGkiBzbUV0aGlvcGljXG4gICAgODc6IDI4LCAgLy8gbGFuZ09yb21vIOKGkiBzbUV0aGlvcGljXG4gICAgODg6IDAsICAvLyBsYW5nU29tYWxpIOKGkiBzbVJvbWFuXG4gICAgODk6IDAsICAvLyBsYW5nU3dhaGlsaSDihpIgc21Sb21hblxuICAgIDkwOiAwLCAgLy8gbGFuZ0tpbnlhcndhbmRhIOKGkiBzbVJvbWFuXG4gICAgOTE6IDAsICAvLyBsYW5nUnVuZGkg4oaSIHNtUm9tYW5cbiAgICA5MjogMCwgIC8vIGxhbmdOeWFuamEg4oaSIHNtUm9tYW5cbiAgICA5MzogMCwgIC8vIGxhbmdNYWxhZ2FzeSDihpIgc21Sb21hblxuICAgIDk0OiAwLCAgLy8gbGFuZ0VzcGVyYW50byDihpIgc21Sb21hblxuICAgIDEyODogMCwgIC8vIGxhbmdXZWxzaCDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMTI5OiAwLCAgLy8gbGFuZ0Jhc3F1ZSDihpIgc21Sb21hblxuICAgIDEzMDogMCwgIC8vIGxhbmdDYXRhbGFuIOKGkiBzbVJvbWFuXG4gICAgMTMxOiAwLCAgLy8gbGFuZ0xhdGluIOKGkiBzbVJvbWFuXG4gICAgMTMyOiAwLCAgLy8gbGFuZ1F1ZWNodWEg4oaSIHNtUm9tYW5cbiAgICAxMzM6IDAsICAvLyBsYW5nR3VhcmFuaSDihpIgc21Sb21hblxuICAgIDEzNDogMCwgIC8vIGxhbmdBeW1hcmEg4oaSIHNtUm9tYW5cbiAgICAxMzU6IDcsICAvLyBsYW5nVGF0YXIg4oaSIHNtQ3lyaWxsaWNcbiAgICAxMzY6IDQsICAvLyBsYW5nVWlnaHVyIOKGkiBzbUFyYWJpY1xuICAgIDEzNzogMjYsICAvLyBsYW5nRHpvbmdraGEg4oaSIHNtVGliZXRhblxuICAgIDEzODogMCwgIC8vIGxhbmdKYXZhbmVzZVJvbSDihpIgc21Sb21hblxuICAgIDEzOTogMCwgIC8vIGxhbmdTdW5kYW5lc2VSb20g4oaSIHNtUm9tYW5cbiAgICAxNDA6IDAsICAvLyBsYW5nR2FsaWNpYW4g4oaSIHNtUm9tYW5cbiAgICAxNDE6IDAsICAvLyBsYW5nQWZyaWthYW5zIOKGkiBzbVJvbWFuXG4gICAgMTQyOiAwLCAgLy8gbGFuZ0JyZXRvbiDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMTQzOiAyOCwgIC8vIGxhbmdJbnVrdGl0dXQg4oaSIHNtRXRoaW9waWMgKG1vZGlmaWVkKVxuICAgIDE0NDogMCwgIC8vIGxhbmdTY290dGlzaEdhZWxpYyDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMTQ1OiAwLCAgLy8gbGFuZ01hbnhHYWVsaWMg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDE0NjogMCwgIC8vIGxhbmdJcmlzaEdhZWxpY1NjcmlwdCDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMTQ3OiAwLCAgLy8gbGFuZ1RvbmdhbiDihpIgc21Sb21hblxuICAgIDE0ODogNiwgIC8vIGxhbmdHcmVla0FuY2llbnQg4oaSIHNtUm9tYW5cbiAgICAxNDk6IDAsICAvLyBsYW5nR3JlZW5sYW5kaWMg4oaSIHNtUm9tYW5cbiAgICAxNTA6IDAsICAvLyBsYW5nQXplcmJhaWphblJvbWFuIOKGkiBzbVJvbWFuXG4gICAgMTUxOiAwICAgLy8gbGFuZ055bm9yc2sg4oaSIHNtUm9tYW5cbn07XG5cbi8vIFdoaWxlIE1pY3Jvc29mdCBpbmRpY2F0ZXMgYSByZWdpb24vY291bnRyeSBmb3IgYWxsIGl0cyBsYW5ndWFnZVxuLy8gSURzLCB3ZSBvbWl0IHRoZSByZWdpb24gY29kZSBpZiBpdCdzIGVxdWFsIHRvIHRoZSBcIm1vc3QgbGlrZWx5XG4vLyByZWdpb24gc3VidGFnXCIgYWNjb3JkaW5nIHRvIFVuaWNvZGUgQ0xEUi4gRm9yIHNjcmlwdHMsIHdlIG9taXRcbi8vIHRoZSBzdWJ0YWcgaWYgaXQgaXMgZXF1YWwgdG8gdGhlIFN1cHByZXNzLVNjcmlwdCBlbnRyeSBpbiB0aGVcbi8vIElBTkEgbGFuZ3VhZ2Ugc3VidGFnIHJlZ2lzdHJ5IGZvciBJRVRGIEJDUCA0Ny5cbi8vXG4vLyBGb3IgZXhhbXBsZSwgTWljcm9zb2Z0IHN0YXRlcyB0aGF0IGl0cyBsYW5ndWFnZSBjb2RlIDB4MDQxQSBpc1xuLy8gQ3JvYXRpYW4gaW4gQ3JvYXRpYS4gV2UgdHJhbnNmb3JtIHRoaXMgdG8gdGhlIEJDUCA0NyBsYW5ndWFnZSBjb2RlICdocidcbi8vIGFuZCBub3QgJ2hyLUhSJyBiZWNhdXNlIENyb2F0aWEgaXMgdGhlIGRlZmF1bHQgY291bnRyeSBmb3IgQ3JvYXRpYW4sXG4vLyBhY2NvcmRpbmcgdG8gVW5pY29kZSBDTERSLiBBcyBhbm90aGVyIGV4YW1wbGUsIE1pY3Jvc29mdCBzdGF0ZXNcbi8vIHRoYXQgMHgxMDFBIGlzIENyb2F0aWFuIChMYXRpbikgaW4gQm9zbmlhLUhlcnplZ292aW5hLiBXZSB0cmFuc2Zvcm1cbi8vIHRoaXMgdG8gJ2hyLUJBJyBhbmQgbm90ICdoci1MYXRuLUJBJyBiZWNhdXNlIExhdGluIGlzIHRoZSBkZWZhdWx0IHNjcmlwdFxuLy8gZm9yIHRoZSBDcm9hdGlhbiBsYW5ndWFnZSwgYWNjb3JkaW5nIHRvIElBTkEuXG4vL1xuLy8gaHR0cDovL3d3dy51bmljb2RlLm9yZy9jbGRyL2NoYXJ0cy9sYXRlc3Qvc3VwcGxlbWVudGFsL2xpa2VseV9zdWJ0YWdzLmh0bWxcbi8vIGh0dHA6Ly93d3cuaWFuYS5vcmcvYXNzaWdubWVudHMvbGFuZ3VhZ2Utc3VidGFnLXJlZ2lzdHJ5L2xhbmd1YWdlLXN1YnRhZy1yZWdpc3RyeVxudmFyIHdpbmRvd3NMYW5ndWFnZXMgPSB7XG4gICAgMHgwNDM2OiAnYWYnLFxuICAgIDB4MDQxQzogJ3NxJyxcbiAgICAweDA0ODQ6ICdnc3cnLFxuICAgIDB4MDQ1RTogJ2FtJyxcbiAgICAweDE0MDE6ICdhci1EWicsXG4gICAgMHgzQzAxOiAnYXItQkgnLFxuICAgIDB4MEMwMTogJ2FyJyxcbiAgICAweDA4MDE6ICdhci1JUScsXG4gICAgMHgyQzAxOiAnYXItSk8nLFxuICAgIDB4MzQwMTogJ2FyLUtXJyxcbiAgICAweDMwMDE6ICdhci1MQicsXG4gICAgMHgxMDAxOiAnYXItTFknLFxuICAgIDB4MTgwMTogJ2FyeScsXG4gICAgMHgyMDAxOiAnYXItT00nLFxuICAgIDB4NDAwMTogJ2FyLVFBJyxcbiAgICAweDA0MDE6ICdhci1TQScsXG4gICAgMHgyODAxOiAnYXItU1knLFxuICAgIDB4MUMwMTogJ2FlYicsXG4gICAgMHgzODAxOiAnYXItQUUnLFxuICAgIDB4MjQwMTogJ2FyLVlFJyxcbiAgICAweDA0MkI6ICdoeScsXG4gICAgMHgwNDREOiAnYXMnLFxuICAgIDB4MDgyQzogJ2F6LUN5cmwnLFxuICAgIDB4MDQyQzogJ2F6JyxcbiAgICAweDA0NkQ6ICdiYScsXG4gICAgMHgwNDJEOiAnZXUnLFxuICAgIDB4MDQyMzogJ2JlJyxcbiAgICAweDA4NDU6ICdibicsXG4gICAgMHgwNDQ1OiAnYm4tSU4nLFxuICAgIDB4MjAxQTogJ2JzLUN5cmwnLFxuICAgIDB4MTQxQTogJ2JzJyxcbiAgICAweDA0N0U6ICdicicsXG4gICAgMHgwNDAyOiAnYmcnLFxuICAgIDB4MDQwMzogJ2NhJyxcbiAgICAweDBDMDQ6ICd6aC1ISycsXG4gICAgMHgxNDA0OiAnemgtTU8nLFxuICAgIDB4MDgwNDogJ3poJyxcbiAgICAweDEwMDQ6ICd6aC1TRycsXG4gICAgMHgwNDA0OiAnemgtVFcnLFxuICAgIDB4MDQ4MzogJ2NvJyxcbiAgICAweDA0MUE6ICdocicsXG4gICAgMHgxMDFBOiAnaHItQkEnLFxuICAgIDB4MDQwNTogJ2NzJyxcbiAgICAweDA0MDY6ICdkYScsXG4gICAgMHgwNDhDOiAncHJzJyxcbiAgICAweDA0NjU6ICdkdicsXG4gICAgMHgwODEzOiAnbmwtQkUnLFxuICAgIDB4MDQxMzogJ25sJyxcbiAgICAweDBDMDk6ICdlbi1BVScsXG4gICAgMHgyODA5OiAnZW4tQlonLFxuICAgIDB4MTAwOTogJ2VuLUNBJyxcbiAgICAweDI0MDk6ICdlbi0wMjknLFxuICAgIDB4NDAwOTogJ2VuLUlOJyxcbiAgICAweDE4MDk6ICdlbi1JRScsXG4gICAgMHgyMDA5OiAnZW4tSk0nLFxuICAgIDB4NDQwOTogJ2VuLU1ZJyxcbiAgICAweDE0MDk6ICdlbi1OWicsXG4gICAgMHgzNDA5OiAnZW4tUEgnLFxuICAgIDB4NDgwOTogJ2VuLVNHJyxcbiAgICAweDFDMDk6ICdlbi1aQScsXG4gICAgMHgyQzA5OiAnZW4tVFQnLFxuICAgIDB4MDgwOTogJ2VuLUdCJyxcbiAgICAweDA0MDk6ICdlbicsXG4gICAgMHgzMDA5OiAnZW4tWlcnLFxuICAgIDB4MDQyNTogJ2V0JyxcbiAgICAweDA0Mzg6ICdmbycsXG4gICAgMHgwNDY0OiAnZmlsJyxcbiAgICAweDA0MEI6ICdmaScsXG4gICAgMHgwODBDOiAnZnItQkUnLFxuICAgIDB4MEMwQzogJ2ZyLUNBJyxcbiAgICAweDA0MEM6ICdmcicsXG4gICAgMHgxNDBDOiAnZnItTFUnLFxuICAgIDB4MTgwQzogJ2ZyLU1DJyxcbiAgICAweDEwMEM6ICdmci1DSCcsXG4gICAgMHgwNDYyOiAnZnknLFxuICAgIDB4MDQ1NjogJ2dsJyxcbiAgICAweDA0Mzc6ICdrYScsXG4gICAgMHgwQzA3OiAnZGUtQVQnLFxuICAgIDB4MDQwNzogJ2RlJyxcbiAgICAweDE0MDc6ICdkZS1MSScsXG4gICAgMHgxMDA3OiAnZGUtTFUnLFxuICAgIDB4MDgwNzogJ2RlLUNIJyxcbiAgICAweDA0MDg6ICdlbCcsXG4gICAgMHgwNDZGOiAna2wnLFxuICAgIDB4MDQ0NzogJ2d1JyxcbiAgICAweDA0Njg6ICdoYScsXG4gICAgMHgwNDBEOiAnaGUnLFxuICAgIDB4MDQzOTogJ2hpJyxcbiAgICAweDA0MEU6ICdodScsXG4gICAgMHgwNDBGOiAnaXMnLFxuICAgIDB4MDQ3MDogJ2lnJyxcbiAgICAweDA0MjE6ICdpZCcsXG4gICAgMHgwNDVEOiAnaXUnLFxuICAgIDB4MDg1RDogJ2l1LUxhdG4nLFxuICAgIDB4MDgzQzogJ2dhJyxcbiAgICAweDA0MzQ6ICd4aCcsXG4gICAgMHgwNDM1OiAnenUnLFxuICAgIDB4MDQxMDogJ2l0JyxcbiAgICAweDA4MTA6ICdpdC1DSCcsXG4gICAgMHgwNDExOiAnamEnLFxuICAgIDB4MDQ0QjogJ2tuJyxcbiAgICAweDA0M0Y6ICdraycsXG4gICAgMHgwNDUzOiAna20nLFxuICAgIDB4MDQ4NjogJ3F1YycsXG4gICAgMHgwNDg3OiAncncnLFxuICAgIDB4MDQ0MTogJ3N3JyxcbiAgICAweDA0NTc6ICdrb2snLFxuICAgIDB4MDQxMjogJ2tvJyxcbiAgICAweDA0NDA6ICdreScsXG4gICAgMHgwNDU0OiAnbG8nLFxuICAgIDB4MDQyNjogJ2x2JyxcbiAgICAweDA0Mjc6ICdsdCcsXG4gICAgMHgwODJFOiAnZHNiJyxcbiAgICAweDA0NkU6ICdsYicsXG4gICAgMHgwNDJGOiAnbWsnLFxuICAgIDB4MDgzRTogJ21zLUJOJyxcbiAgICAweDA0M0U6ICdtcycsXG4gICAgMHgwNDRDOiAnbWwnLFxuICAgIDB4MDQzQTogJ210JyxcbiAgICAweDA0ODE6ICdtaScsXG4gICAgMHgwNDdBOiAnYXJuJyxcbiAgICAweDA0NEU6ICdtcicsXG4gICAgMHgwNDdDOiAnbW9oJyxcbiAgICAweDA0NTA6ICdtbicsXG4gICAgMHgwODUwOiAnbW4tQ04nLFxuICAgIDB4MDQ2MTogJ25lJyxcbiAgICAweDA0MTQ6ICduYicsXG4gICAgMHgwODE0OiAnbm4nLFxuICAgIDB4MDQ4MjogJ29jJyxcbiAgICAweDA0NDg6ICdvcicsXG4gICAgMHgwNDYzOiAncHMnLFxuICAgIDB4MDQxNTogJ3BsJyxcbiAgICAweDA0MTY6ICdwdCcsXG4gICAgMHgwODE2OiAncHQtUFQnLFxuICAgIDB4MDQ0NjogJ3BhJyxcbiAgICAweDA0NkI6ICdxdS1CTycsXG4gICAgMHgwODZCOiAncXUtRUMnLFxuICAgIDB4MEM2QjogJ3F1JyxcbiAgICAweDA0MTg6ICdybycsXG4gICAgMHgwNDE3OiAncm0nLFxuICAgIDB4MDQxOTogJ3J1JyxcbiAgICAweDI0M0I6ICdzbW4nLFxuICAgIDB4MTAzQjogJ3Ntai1OTycsXG4gICAgMHgxNDNCOiAnc21qJyxcbiAgICAweDBDM0I6ICdzZS1GSScsXG4gICAgMHgwNDNCOiAnc2UnLFxuICAgIDB4MDgzQjogJ3NlLVNFJyxcbiAgICAweDIwM0I6ICdzbXMnLFxuICAgIDB4MTgzQjogJ3NtYS1OTycsXG4gICAgMHgxQzNCOiAnc21zJyxcbiAgICAweDA0NEY6ICdzYScsXG4gICAgMHgxQzFBOiAnc3ItQ3lybC1CQScsXG4gICAgMHgwQzFBOiAnc3InLFxuICAgIDB4MTgxQTogJ3NyLUxhdG4tQkEnLFxuICAgIDB4MDgxQTogJ3NyLUxhdG4nLFxuICAgIDB4MDQ2QzogJ25zbycsXG4gICAgMHgwNDMyOiAndG4nLFxuICAgIDB4MDQ1QjogJ3NpJyxcbiAgICAweDA0MUI6ICdzaycsXG4gICAgMHgwNDI0OiAnc2wnLFxuICAgIDB4MkMwQTogJ2VzLUFSJyxcbiAgICAweDQwMEE6ICdlcy1CTycsXG4gICAgMHgzNDBBOiAnZXMtQ0wnLFxuICAgIDB4MjQwQTogJ2VzLUNPJyxcbiAgICAweDE0MEE6ICdlcy1DUicsXG4gICAgMHgxQzBBOiAnZXMtRE8nLFxuICAgIDB4MzAwQTogJ2VzLUVDJyxcbiAgICAweDQ0MEE6ICdlcy1TVicsXG4gICAgMHgxMDBBOiAnZXMtR1QnLFxuICAgIDB4NDgwQTogJ2VzLUhOJyxcbiAgICAweDA4MEE6ICdlcy1NWCcsXG4gICAgMHg0QzBBOiAnZXMtTkknLFxuICAgIDB4MTgwQTogJ2VzLVBBJyxcbiAgICAweDNDMEE6ICdlcy1QWScsXG4gICAgMHgyODBBOiAnZXMtUEUnLFxuICAgIDB4NTAwQTogJ2VzLVBSJyxcblxuICAgIC8vIE1pY3Jvc29mdCBoYXMgZGVmaW5lZCB0d28gZGlmZmVyZW50IGxhbmd1YWdlIGNvZGVzIGZvclxuICAgIC8vIOKAnFNwYW5pc2ggd2l0aCBtb2Rlcm4gc29ydGluZ+KAnSBhbmQg4oCcU3BhbmlzaCB3aXRoIHRyYWRpdGlvbmFsXG4gICAgLy8gc29ydGluZ+KAnS4gVGhpcyBtYWtlcyBzZW5zZSBmb3IgY29sbGF0aW9uIEFQSXMsIGFuZCBpdCB3b3VsZCBiZVxuICAgIC8vIHBvc3NpYmxlIHRvIGV4cHJlc3MgdGhpcyBpbiBCQ1AgNDcgbGFuZ3VhZ2UgdGFncyB2aWEgVW5pY29kZVxuICAgIC8vIGV4dGVuc2lvbnMgKGVnLiwgZXMtdS1jby10cmFkIGlzIFNwYW5pc2ggd2l0aCB0cmFkaXRpb25hbFxuICAgIC8vIHNvcnRpbmcpLiBIb3dldmVyLCBmb3Igc3RvcmluZyBuYW1lcyBpbiBmb250cywgdGhlIGRpc3RpbmN0aW9uXG4gICAgLy8gZG9lcyBub3QgbWFrZSBzZW5zZSwgc28gd2UgZ2l2ZSDigJxlc+KAnSBpbiBib3RoIGNhc2VzLlxuICAgIDB4MEMwQTogJ2VzJyxcbiAgICAweDA0MEE6ICdlcycsXG5cbiAgICAweDU0MEE6ICdlcy1VUycsXG4gICAgMHgzODBBOiAnZXMtVVknLFxuICAgIDB4MjAwQTogJ2VzLVZFJyxcbiAgICAweDA4MUQ6ICdzdi1GSScsXG4gICAgMHgwNDFEOiAnc3YnLFxuICAgIDB4MDQ1QTogJ3N5cicsXG4gICAgMHgwNDI4OiAndGcnLFxuICAgIDB4MDg1RjogJ3R6bScsXG4gICAgMHgwNDQ5OiAndGEnLFxuICAgIDB4MDQ0NDogJ3R0JyxcbiAgICAweDA0NEE6ICd0ZScsXG4gICAgMHgwNDFFOiAndGgnLFxuICAgIDB4MDQ1MTogJ2JvJyxcbiAgICAweDA0MUY6ICd0cicsXG4gICAgMHgwNDQyOiAndGsnLFxuICAgIDB4MDQ4MDogJ3VnJyxcbiAgICAweDA0MjI6ICd1aycsXG4gICAgMHgwNDJFOiAnaHNiJyxcbiAgICAweDA0MjA6ICd1cicsXG4gICAgMHgwODQzOiAndXotQ3lybCcsXG4gICAgMHgwNDQzOiAndXonLFxuICAgIDB4MDQyQTogJ3ZpJyxcbiAgICAweDA0NTI6ICdjeScsXG4gICAgMHgwNDg4OiAnd28nLFxuICAgIDB4MDQ4NTogJ3NhaCcsXG4gICAgMHgwNDc4OiAnaWknLFxuICAgIDB4MDQ2QTogJ3lvJ1xufTtcblxuLy8gUmV0dXJucyBhIElFVEYgQkNQIDQ3IGxhbmd1YWdlIGNvZGUsIGZvciBleGFtcGxlICd6aC1IYW50J1xuLy8gZm9yICdDaGluZXNlIGluIHRoZSB0cmFkaXRpb25hbCBzY3JpcHQnLlxuZnVuY3Rpb24gZ2V0TGFuZ3VhZ2VDb2RlKHBsYXRmb3JtSUQsIGxhbmd1YWdlSUQsIGx0YWcpIHtcbiAgICBzd2l0Y2ggKHBsYXRmb3JtSUQpIHtcbiAgICAgICAgY2FzZSAwOiAgLy8gVW5pY29kZVxuICAgICAgICAgICAgaWYgKGxhbmd1YWdlSUQgPT09IDB4RkZGRikge1xuICAgICAgICAgICAgICAgIHJldHVybiAndW5kJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobHRhZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsdGFnW2xhbmd1YWdlSURdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIDE6ICAvLyBNYWNpbnRvc2hcbiAgICAgICAgICAgIHJldHVybiBtYWNMYW5ndWFnZXNbbGFuZ3VhZ2VJRF07XG5cbiAgICAgICAgY2FzZSAzOiAgLy8gV2luZG93c1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvd3NMYW5ndWFnZXNbbGFuZ3VhZ2VJRF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxudmFyIHV0ZjE2ID0gJ3V0Zi0xNic7XG5cbi8vIE1hY09TIHNjcmlwdCBJRCDihpIgZW5jb2RpbmcuIFRoaXMgdGFibGUgc3RvcmVzIHRoZSBkZWZhdWx0IGNhc2UsXG4vLyB3aGljaCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBtYWNMYW5ndWFnZUVuY29kaW5ncy5cbnZhciBtYWNTY3JpcHRFbmNvZGluZ3MgPSB7XG4gICAgMDogJ21hY2ludG9zaCcsICAgICAgICAgICAvLyBzbVJvbWFuXG4gICAgMTogJ3gtbWFjLWphcGFuZXNlJywgICAgICAvLyBzbUphcGFuZXNlXG4gICAgMjogJ3gtbWFjLWNoaW5lc2V0cmFkJywgICAvLyBzbVRyYWRDaGluZXNlXG4gICAgMzogJ3gtbWFjLWtvcmVhbicsICAgICAgICAvLyBzbUtvcmVhblxuICAgIDY6ICd4LW1hYy1ncmVlaycsICAgICAgICAgLy8gc21HcmVla1xuICAgIDc6ICd4LW1hYy1jeXJpbGxpYycsICAgICAgLy8gc21DeXJpbGxpY1xuICAgIDk6ICd4LW1hYy1kZXZhbmFnYWknLCAgICAgLy8gc21EZXZhbmFnYXJpXG4gICAgMTA6ICd4LW1hYy1ndXJtdWtoaScsICAgICAvLyBzbUd1cm11a2hpXG4gICAgMTE6ICd4LW1hYy1ndWphcmF0aScsICAgICAvLyBzbUd1amFyYXRpXG4gICAgMTI6ICd4LW1hYy1vcml5YScsICAgICAgICAvLyBzbU9yaXlhXG4gICAgMTM6ICd4LW1hYy1iZW5nYWxpJywgICAgICAvLyBzbUJlbmdhbGlcbiAgICAxNDogJ3gtbWFjLXRhbWlsJywgICAgICAgIC8vIHNtVGFtaWxcbiAgICAxNTogJ3gtbWFjLXRlbHVndScsICAgICAgIC8vIHNtVGVsdWd1XG4gICAgMTY6ICd4LW1hYy1rYW5uYWRhJywgICAgICAvLyBzbUthbm5hZGFcbiAgICAxNzogJ3gtbWFjLW1hbGF5YWxhbScsICAgIC8vIHNtTWFsYXlhbGFtXG4gICAgMTg6ICd4LW1hYy1zaW5oYWxlc2UnLCAgICAvLyBzbVNpbmhhbGVzZVxuICAgIDE5OiAneC1tYWMtYnVybWVzZScsICAgICAgLy8gc21CdXJtZXNlXG4gICAgMjA6ICd4LW1hYy1raG1lcicsICAgICAgICAvLyBzbUtobWVyXG4gICAgMjE6ICd4LW1hYy10aGFpJywgICAgICAgICAvLyBzbVRoYWlcbiAgICAyMjogJ3gtbWFjLWxhbycsICAgICAgICAgIC8vIHNtTGFvXG4gICAgMjM6ICd4LW1hYy1nZW9yZ2lhbicsICAgICAvLyBzbUdlb3JnaWFuXG4gICAgMjQ6ICd4LW1hYy1hcm1lbmlhbicsICAgICAvLyBzbUFybWVuaWFuXG4gICAgMjU6ICd4LW1hYy1jaGluZXNlc2ltcCcsICAvLyBzbVNpbXBDaGluZXNlXG4gICAgMjY6ICd4LW1hYy10aWJldGFuJywgICAgICAvLyBzbVRpYmV0YW5cbiAgICAyNzogJ3gtbWFjLW1vbmdvbGlhbicsICAgIC8vIHNtTW9uZ29saWFuXG4gICAgMjg6ICd4LW1hYy1ldGhpb3BpYycsICAgICAvLyBzbUV0aGlvcGljXG4gICAgMjk6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBzbUNlbnRyYWxFdXJvUm9tYW5cbiAgICAzMDogJ3gtbWFjLXZpZXRuYW1lc2UnLCAgIC8vIHNtVmlldG5hbWVzZVxuICAgIDMxOiAneC1tYWMtZXh0YXJhYmljJyAgICAgLy8gc21FeHRBcmFiaWNcbn07XG5cbi8vIE1hY09TIGxhbmd1YWdlIElEIOKGkiBlbmNvZGluZy4gVGhpcyB0YWJsZSBzdG9yZXMgdGhlIGV4Y2VwdGlvbmFsXG4vLyBjYXNlcywgd2hpY2ggb3ZlcnJpZGUgbWFjU2NyaXB0RW5jb2RpbmdzLiBGb3Igd3JpdGluZyBNYWNPUyBuYW1pbmdcbi8vIHRhYmxlcywgd2UgbmVlZCB0byBlbWl0IGEgTWFjT1Mgc2NyaXB0IElELiBUaGVyZWZvcmUsIHdlIGNhbm5vdFxuLy8gbWVyZ2UgbWFjU2NyaXB0RW5jb2RpbmdzIGludG8gbWFjTGFuZ3VhZ2VFbmNvZGluZ3MuXG4vL1xuLy8gaHR0cDovL3VuaWNvZGUub3JnL1B1YmxpYy9NQVBQSU5HUy9WRU5ET1JTL0FQUExFL1JlYWRtZS50eHRcbnZhciBtYWNMYW5ndWFnZUVuY29kaW5ncyA9IHtcbiAgICAxNTogJ3gtbWFjLWljZWxhbmRpYycsICAgIC8vIGxhbmdJY2VsYW5kaWNcbiAgICAxNzogJ3gtbWFjLXR1cmtpc2gnLCAgICAgIC8vIGxhbmdUdXJraXNoXG4gICAgMTg6ICd4LW1hYy1jcm9hdGlhbicsICAgICAvLyBsYW5nQ3JvYXRpYW5cbiAgICAyNDogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdMaXRodWFuaWFuXG4gICAgMjU6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nUG9saXNoXG4gICAgMjY6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nSHVuZ2FyaWFuXG4gICAgMjc6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nRXN0b25pYW5cbiAgICAyODogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdMYXR2aWFuXG4gICAgMzA6ICd4LW1hYy1pY2VsYW5kaWMnLCAgICAvLyBsYW5nRmFyb2VzZVxuICAgIDM3OiAneC1tYWMtcm9tYW5pYW4nLCAgICAgLy8gbGFuZ1JvbWFuaWFuXG4gICAgMzg6ICd4LW1hYy1jZScsICAgICAgICAgICAvLyBsYW5nQ3plY2hcbiAgICAzOTogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdTbG92YWtcbiAgICA0MDogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdTbG92ZW5pYW5cbiAgICAxNDM6ICd4LW1hYy1pbnVpdCcsICAgICAgIC8vIGxhbmdJbnVrdGl0dXRcbiAgICAxNDY6ICd4LW1hYy1nYWVsaWMnICAgICAgIC8vIGxhbmdJcmlzaEdhZWxpY1NjcmlwdFxufTtcblxuZnVuY3Rpb24gZ2V0RW5jb2RpbmcocGxhdGZvcm1JRCwgZW5jb2RpbmdJRCwgbGFuZ3VhZ2VJRCkge1xuICAgIHN3aXRjaCAocGxhdGZvcm1JRCkge1xuICAgICAgICBjYXNlIDA6ICAvLyBVbmljb2RlXG4gICAgICAgICAgICByZXR1cm4gdXRmMTY7XG5cbiAgICAgICAgY2FzZSAxOiAgLy8gQXBwbGUgTWFjaW50b3NoXG4gICAgICAgICAgICByZXR1cm4gbWFjTGFuZ3VhZ2VFbmNvZGluZ3NbbGFuZ3VhZ2VJRF0gfHwgbWFjU2NyaXB0RW5jb2RpbmdzW2VuY29kaW5nSURdO1xuXG4gICAgICAgIGNhc2UgMzogIC8vIE1pY3Jvc29mdCBXaW5kb3dzXG4gICAgICAgICAgICBpZiAoZW5jb2RpbmdJRCA9PT0gMSB8fCBlbmNvZGluZ0lEID09PSAxMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGYxNjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLy8gUGFyc2UgdGhlIG5hbWluZyBgbmFtZWAgdGFibGUuXG4vLyBGSVhNRTogRm9ybWF0IDEgYWRkaXRpb25hbCBmaWVsZHMgYXJlIG5vdCBzdXBwb3J0ZWQgeWV0LlxuLy8gbHRhZyBpcyB0aGUgY29udGVudCBvZiB0aGUgYGx0YWcnIHRhYmxlLCBzdWNoIGFzIFsnZW4nLCAnemgtSGFucycsICdkZS1DSC0xOTA0J10uXG5mdW5jdGlvbiBwYXJzZU5hbWVUYWJsZShkYXRhLCBzdGFydCwgbHRhZykge1xuICAgIHZhciBuYW1lID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgZm9ybWF0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBjb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgc3RyaW5nT2Zmc2V0ID0gcC5vZmZzZXQgKyBwLnBhcnNlVVNob3J0KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBwbGF0Zm9ybUlEID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgZW5jb2RpbmdJRCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIGxhbmd1YWdlSUQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBuYW1lSUQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IG5hbWVUYWJsZU5hbWVzW25hbWVJRF0gfHwgbmFtZUlEO1xuICAgICAgICB2YXIgYnl0ZUxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIGxhbmd1YWdlID0gZ2V0TGFuZ3VhZ2VDb2RlKHBsYXRmb3JtSUQsIGxhbmd1YWdlSUQsIGx0YWcpO1xuICAgICAgICB2YXIgZW5jb2RpbmcgPSBnZXRFbmNvZGluZyhwbGF0Zm9ybUlELCBlbmNvZGluZ0lELCBsYW5ndWFnZUlEKTtcbiAgICAgICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgbGFuZ3VhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHRleHQgPSAodm9pZCAwKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGluZyA9PT0gdXRmMTYpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZGVjb2RlLlVURjE2KGRhdGEsIHN0cmluZ09mZnNldCArIG9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSBkZWNvZGUuTUFDU1RSSU5HKGRhdGEsIHN0cmluZ09mZnNldCArIG9mZnNldCwgYnl0ZUxlbmd0aCwgZW5jb2RpbmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFuc2xhdGlvbnMgPSBuYW1lW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25zID0gbmFtZVtwcm9wZXJ0eV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbnNbbGFuZ3VhZ2VdID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYW5nVGFnQ291bnQgPSAwO1xuICAgIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgLy8gRklYTUU6IEFsc28gaGFuZGxlIE1pY3Jvc29mdCdzICduYW1lJyB0YWJsZSAxLlxuICAgICAgICBsYW5nVGFnQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWU7XG59XG5cbi8vIHsyMzogJ2Zvbyd9IOKGkiB7J2Zvbyc6IDIzfVxuLy8gWydiYXInLCAnYmF6J10g4oaSIHsnYmFyJzogMCwgJ2Jheic6IDF9XG5mdW5jdGlvbiByZXZlcnNlRGljdChkaWN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBkaWN0KSB7XG4gICAgICAgIHJlc3VsdFtkaWN0W2tleV1dID0gcGFyc2VJbnQoa2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBtYWtlTmFtZVJlY29yZChwbGF0Zm9ybUlELCBlbmNvZGluZ0lELCBsYW5ndWFnZUlELCBuYW1lSUQsIGxlbmd0aCwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5SZWNvcmQoJ05hbWVSZWNvcmQnLCBbXG4gICAgICAgIHtuYW1lOiAncGxhdGZvcm1JRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogcGxhdGZvcm1JRH0sXG4gICAgICAgIHtuYW1lOiAnZW5jb2RpbmdJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZW5jb2RpbmdJRH0sXG4gICAgICAgIHtuYW1lOiAnbGFuZ3VhZ2VJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbGFuZ3VhZ2VJRH0sXG4gICAgICAgIHtuYW1lOiAnbmFtZUlEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBuYW1lSUR9LFxuICAgICAgICB7bmFtZTogJ2xlbmd0aCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbGVuZ3RofSxcbiAgICAgICAge25hbWU6ICdvZmZzZXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IG9mZnNldH1cbiAgICBdKTtcbn1cblxuLy8gRmluZHMgdGhlIHBvc2l0aW9uIG9mIG5lZWRsZSBpbiBoYXlzdGFjaywgb3IgLTEgaWYgbm90IHRoZXJlLlxuLy8gTGlrZSBTdHJpbmcuaW5kZXhPZigpLCBidXQgZm9yIGFycmF5cy5cbmZ1bmN0aW9uIGZpbmRTdWJBcnJheShuZWVkbGUsIGhheXN0YWNrKSB7XG4gICAgdmFyIG5lZWRsZUxlbmd0aCA9IG5lZWRsZS5sZW5ndGg7XG4gICAgdmFyIGxpbWl0ID0gaGF5c3RhY2subGVuZ3RoIC0gbmVlZGxlTGVuZ3RoICsgMTtcblxuICAgIGxvb3A6XG4gICAgZm9yICh2YXIgcG9zID0gMDsgcG9zIDwgbGltaXQ7IHBvcysrKSB7XG4gICAgICAgIGZvciAoOyBwb3MgPCBsaW1pdDsgcG9zKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbmVlZGxlTGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF5c3RhY2tbcG9zICsga10gIT09IG5lZWRsZVtrXSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gYWRkU3RyaW5nVG9Qb29sKHMsIHBvb2wpIHtcbiAgICB2YXIgb2Zmc2V0ID0gZmluZFN1YkFycmF5KHMsIHBvb2wpO1xuICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgIG9mZnNldCA9IHBvb2wubGVuZ3RoO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBzLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgcG9vbC5wdXNoKHNbaV0pO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBtYWtlTmFtZVRhYmxlKG5hbWVzLCBsdGFnKSB7XG4gICAgdmFyIG5hbWVJRDtcbiAgICB2YXIgbmFtZUlEcyA9IFtdO1xuXG4gICAgdmFyIG5hbWVzV2l0aE51bWVyaWNLZXlzID0ge307XG4gICAgdmFyIG5hbWVUYWJsZUlkcyA9IHJldmVyc2VEaWN0KG5hbWVUYWJsZU5hbWVzKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gbmFtZXMpIHtcbiAgICAgICAgdmFyIGlkID0gbmFtZVRhYmxlSWRzW2tleV07XG4gICAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZCA9IGtleTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWVJRCA9IHBhcnNlSW50KGlkKTtcblxuICAgICAgICBpZiAoaXNOYU4obmFtZUlEKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYW1lIHRhYmxlIGVudHJ5IFwiJyArIGtleSArICdcIiBkb2VzIG5vdCBleGlzdCwgc2VlIG5hbWVUYWJsZU5hbWVzIGZvciBjb21wbGV0ZSBsaXN0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZXNXaXRoTnVtZXJpY0tleXNbbmFtZUlEXSA9IG5hbWVzW2tleV07XG4gICAgICAgIG5hbWVJRHMucHVzaChuYW1lSUQpO1xuICAgIH1cblxuICAgIHZhciBtYWNMYW5ndWFnZUlkcyA9IHJldmVyc2VEaWN0KG1hY0xhbmd1YWdlcyk7XG4gICAgdmFyIHdpbmRvd3NMYW5ndWFnZUlkcyA9IHJldmVyc2VEaWN0KHdpbmRvd3NMYW5ndWFnZXMpO1xuXG4gICAgdmFyIG5hbWVSZWNvcmRzID0gW107XG4gICAgdmFyIHN0cmluZ1Bvb2wgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZUlEcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuYW1lSUQgPSBuYW1lSURzW2ldO1xuICAgICAgICB2YXIgdHJhbnNsYXRpb25zID0gbmFtZXNXaXRoTnVtZXJpY0tleXNbbmFtZUlEXTtcbiAgICAgICAgZm9yICh2YXIgbGFuZyBpbiB0cmFuc2xhdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdHJhbnNsYXRpb25zW2xhbmddO1xuXG4gICAgICAgICAgICAvLyBGb3IgTWFjT1MsIHdlIHRyeSB0byBlbWl0IHRoZSBuYW1lIGluIHRoZSBmb3JtIHRoYXQgd2FzIGludHJvZHVjZWRcbiAgICAgICAgICAgIC8vIGluIHRoZSBpbml0aWFsIHZlcnNpb24gb2YgdGhlIFRydWVUeXBlIHNwZWMgKGluIHRoZSBsYXRlIDE5ODBzKS5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoaXMgY2FuIGZhaWwgZm9yIHZhcmlvdXMgcmVhc29uczogdGhlIHJlcXVlc3RlZCBCQ1AgNDdcbiAgICAgICAgICAgIC8vIGxhbmd1YWdlIGNvZGUgbWlnaHQgbm90IGhhdmUgYW4gb2xkLXN0eWxlIE1hYyBlcXVpdmFsZW50O1xuICAgICAgICAgICAgLy8gd2UgbWlnaHQgbm90IGhhdmUgYSBjb2RlYyBmb3IgdGhlIG5lZWRlZCBjaGFyYWN0ZXIgZW5jb2Rpbmc7XG4gICAgICAgICAgICAvLyBvciB0aGUgbmFtZSBtaWdodCBjb250YWluIGNoYXJhY3RlcnMgdGhhdCBjYW5ub3QgYmUgZXhwcmVzc2VkXG4gICAgICAgICAgICAvLyBpbiB0aGUgb2xkLXN0eWxlIE1hY2ludG9zaCBlbmNvZGluZy4gSW4gY2FzZSBvZiBmYWlsdXJlLCB3ZSBlbWl0XG4gICAgICAgICAgICAvLyB0aGUgbmFtZSBpbiBhIG1vcmUgbW9kZXJuIGZhc2hpb24gKFVuaWNvZGUgZW5jb2Rpbmcgd2l0aCBCQ1AgNDdcbiAgICAgICAgICAgIC8vIGxhbmd1YWdlIHRhZ3MpIHRoYXQgaXMgcmVjb2duaXplZCBieSBNYWNPUyAxMC41LCByZWxlYXNlZCBpbiAyMDA5LlxuICAgICAgICAgICAgLy8gSWYgZm9udHMgd2VyZSBvbmx5IHJlYWQgYnkgb3BlcmF0aW5nIHN5c3RlbXMsIHdlIGNvdWxkIHNpbXBseVxuICAgICAgICAgICAgLy8gZW1pdCBhbGwgbmFtZXMgaW4gdGhlIG1vZGVybiBmb3JtOyB0aGlzIHdvdWxkIGJlIG11Y2ggZWFzaWVyLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgdGhlcmUgYXJlIG1hbnkgYXBwbGljYXRpb25zIGFuZCBsaWJyYXJpZXMgdGhhdCByZWFkXG4gICAgICAgICAgICAvLyAnbmFtZScgdGFibGVzIGRpcmVjdGx5LCBhbmQgdGhlc2Ugd2lsbCB1c3VhbGx5IG9ubHkgcmVjb2duaXplXG4gICAgICAgICAgICAvLyB0aGUgYW5jaWVudCBmb3JtIChzaWxlbnRseSBza2lwcGluZyB0aGUgdW5yZWNvZ25pemVkIG5hbWVzKS5cbiAgICAgICAgICAgIHZhciBtYWNQbGF0Zm9ybSA9IDE7ICAvLyBNYWNpbnRvc2hcbiAgICAgICAgICAgIHZhciBtYWNMYW5ndWFnZSA9IG1hY0xhbmd1YWdlSWRzW2xhbmddO1xuICAgICAgICAgICAgdmFyIG1hY1NjcmlwdCA9IG1hY0xhbmd1YWdlVG9TY3JpcHRbbWFjTGFuZ3VhZ2VdO1xuICAgICAgICAgICAgdmFyIG1hY0VuY29kaW5nID0gZ2V0RW5jb2RpbmcobWFjUGxhdGZvcm0sIG1hY1NjcmlwdCwgbWFjTGFuZ3VhZ2UpO1xuICAgICAgICAgICAgdmFyIG1hY05hbWUgPSBlbmNvZGUuTUFDU1RSSU5HKHRleHQsIG1hY0VuY29kaW5nKTtcbiAgICAgICAgICAgIGlmIChtYWNOYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYWNQbGF0Zm9ybSA9IDA7ICAvLyBVbmljb2RlXG4gICAgICAgICAgICAgICAgbWFjTGFuZ3VhZ2UgPSBsdGFnLmluZGV4T2YobGFuZyk7XG4gICAgICAgICAgICAgICAgaWYgKG1hY0xhbmd1YWdlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBtYWNMYW5ndWFnZSA9IGx0YWcubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsdGFnLnB1c2gobGFuZyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbWFjU2NyaXB0ID0gNDsgIC8vIFVuaWNvZGUgMi4wIGFuZCBsYXRlclxuICAgICAgICAgICAgICAgIG1hY05hbWUgPSBlbmNvZGUuVVRGMTYodGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtYWNOYW1lT2Zmc2V0ID0gYWRkU3RyaW5nVG9Qb29sKG1hY05hbWUsIHN0cmluZ1Bvb2wpO1xuICAgICAgICAgICAgbmFtZVJlY29yZHMucHVzaChtYWtlTmFtZVJlY29yZChtYWNQbGF0Zm9ybSwgbWFjU2NyaXB0LCBtYWNMYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZUlELCBtYWNOYW1lLmxlbmd0aCwgbWFjTmFtZU9mZnNldCkpO1xuXG4gICAgICAgICAgICB2YXIgd2luTGFuZ3VhZ2UgPSB3aW5kb3dzTGFuZ3VhZ2VJZHNbbGFuZ107XG4gICAgICAgICAgICBpZiAod2luTGFuZ3VhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhciB3aW5OYW1lID0gZW5jb2RlLlVURjE2KHRleHQpO1xuICAgICAgICAgICAgICAgIHZhciB3aW5OYW1lT2Zmc2V0ID0gYWRkU3RyaW5nVG9Qb29sKHdpbk5hbWUsIHN0cmluZ1Bvb2wpO1xuICAgICAgICAgICAgICAgIG5hbWVSZWNvcmRzLnB1c2gobWFrZU5hbWVSZWNvcmQoMywgMSwgd2luTGFuZ3VhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lSUQsIHdpbk5hbWUubGVuZ3RoLCB3aW5OYW1lT2Zmc2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuYW1lUmVjb3Jkcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuICgoYS5wbGF0Zm9ybUlEIC0gYi5wbGF0Zm9ybUlEKSB8fFxuICAgICAgICAgICAgICAgIChhLmVuY29kaW5nSUQgLSBiLmVuY29kaW5nSUQpIHx8XG4gICAgICAgICAgICAgICAgKGEubGFuZ3VhZ2VJRCAtIGIubGFuZ3VhZ2VJRCkgfHxcbiAgICAgICAgICAgICAgICAoYS5uYW1lSUQgLSBiLm5hbWVJRCkpO1xuICAgIH0pO1xuXG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ25hbWUnLCBbXG4gICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdjb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbmFtZVJlY29yZHMubGVuZ3RofSxcbiAgICAgICAge25hbWU6ICdzdHJpbmdPZmZzZXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDYgKyBuYW1lUmVjb3Jkcy5sZW5ndGggKiAxMn1cbiAgICBdKTtcblxuICAgIGZvciAodmFyIHIgPSAwOyByIDwgbmFtZVJlY29yZHMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ3JlY29yZF8nICsgciwgdHlwZTogJ1JFQ09SRCcsIHZhbHVlOiBuYW1lUmVjb3Jkc1tyXX0pO1xuICAgIH1cblxuICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdzdHJpbmdzJywgdHlwZTogJ0xJVEVSQUwnLCB2YWx1ZTogc3RyaW5nUG9vbH0pO1xuICAgIHJldHVybiB0O1xufVxuXG52YXIgX25hbWUgPSB7IHBhcnNlOiBwYXJzZU5hbWVUYWJsZSwgbWFrZTogbWFrZU5hbWVUYWJsZSB9O1xuXG4vLyBUaGUgYE9TLzJgIHRhYmxlIGNvbnRhaW5zIG1ldHJpY3MgcmVxdWlyZWQgaW4gT3BlblR5cGUgZm9udHMuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL29zMi5odG1cblxudmFyIHVuaWNvZGVSYW5nZXMgPSBbXG4gICAge2JlZ2luOiAweDAwMDAsIGVuZDogMHgwMDdGfSwgLy8gQmFzaWMgTGF0aW5cbiAgICB7YmVnaW46IDB4MDA4MCwgZW5kOiAweDAwRkZ9LCAvLyBMYXRpbi0xIFN1cHBsZW1lbnRcbiAgICB7YmVnaW46IDB4MDEwMCwgZW5kOiAweDAxN0Z9LCAvLyBMYXRpbiBFeHRlbmRlZC1BXG4gICAge2JlZ2luOiAweDAxODAsIGVuZDogMHgwMjRGfSwgLy8gTGF0aW4gRXh0ZW5kZWQtQlxuICAgIHtiZWdpbjogMHgwMjUwLCBlbmQ6IDB4MDJBRn0sIC8vIElQQSBFeHRlbnNpb25zXG4gICAge2JlZ2luOiAweDAyQjAsIGVuZDogMHgwMkZGfSwgLy8gU3BhY2luZyBNb2RpZmllciBMZXR0ZXJzXG4gICAge2JlZ2luOiAweDAzMDAsIGVuZDogMHgwMzZGfSwgLy8gQ29tYmluaW5nIERpYWNyaXRpY2FsIE1hcmtzXG4gICAge2JlZ2luOiAweDAzNzAsIGVuZDogMHgwM0ZGfSwgLy8gR3JlZWsgYW5kIENvcHRpY1xuICAgIHtiZWdpbjogMHgyQzgwLCBlbmQ6IDB4MkNGRn0sIC8vIENvcHRpY1xuICAgIHtiZWdpbjogMHgwNDAwLCBlbmQ6IDB4MDRGRn0sIC8vIEN5cmlsbGljXG4gICAge2JlZ2luOiAweDA1MzAsIGVuZDogMHgwNThGfSwgLy8gQXJtZW5pYW5cbiAgICB7YmVnaW46IDB4MDU5MCwgZW5kOiAweDA1RkZ9LCAvLyBIZWJyZXdcbiAgICB7YmVnaW46IDB4QTUwMCwgZW5kOiAweEE2M0Z9LCAvLyBWYWlcbiAgICB7YmVnaW46IDB4MDYwMCwgZW5kOiAweDA2RkZ9LCAvLyBBcmFiaWNcbiAgICB7YmVnaW46IDB4MDdDMCwgZW5kOiAweDA3RkZ9LCAvLyBOS29cbiAgICB7YmVnaW46IDB4MDkwMCwgZW5kOiAweDA5N0Z9LCAvLyBEZXZhbmFnYXJpXG4gICAge2JlZ2luOiAweDA5ODAsIGVuZDogMHgwOUZGfSwgLy8gQmVuZ2FsaVxuICAgIHtiZWdpbjogMHgwQTAwLCBlbmQ6IDB4MEE3Rn0sIC8vIEd1cm11a2hpXG4gICAge2JlZ2luOiAweDBBODAsIGVuZDogMHgwQUZGfSwgLy8gR3VqYXJhdGlcbiAgICB7YmVnaW46IDB4MEIwMCwgZW5kOiAweDBCN0Z9LCAvLyBPcml5YVxuICAgIHtiZWdpbjogMHgwQjgwLCBlbmQ6IDB4MEJGRn0sIC8vIFRhbWlsXG4gICAge2JlZ2luOiAweDBDMDAsIGVuZDogMHgwQzdGfSwgLy8gVGVsdWd1XG4gICAge2JlZ2luOiAweDBDODAsIGVuZDogMHgwQ0ZGfSwgLy8gS2FubmFkYVxuICAgIHtiZWdpbjogMHgwRDAwLCBlbmQ6IDB4MEQ3Rn0sIC8vIE1hbGF5YWxhbVxuICAgIHtiZWdpbjogMHgwRTAwLCBlbmQ6IDB4MEU3Rn0sIC8vIFRoYWlcbiAgICB7YmVnaW46IDB4MEU4MCwgZW5kOiAweDBFRkZ9LCAvLyBMYW9cbiAgICB7YmVnaW46IDB4MTBBMCwgZW5kOiAweDEwRkZ9LCAvLyBHZW9yZ2lhblxuICAgIHtiZWdpbjogMHgxQjAwLCBlbmQ6IDB4MUI3Rn0sIC8vIEJhbGluZXNlXG4gICAge2JlZ2luOiAweDExMDAsIGVuZDogMHgxMUZGfSwgLy8gSGFuZ3VsIEphbW9cbiAgICB7YmVnaW46IDB4MUUwMCwgZW5kOiAweDFFRkZ9LCAvLyBMYXRpbiBFeHRlbmRlZCBBZGRpdGlvbmFsXG4gICAge2JlZ2luOiAweDFGMDAsIGVuZDogMHgxRkZGfSwgLy8gR3JlZWsgRXh0ZW5kZWRcbiAgICB7YmVnaW46IDB4MjAwMCwgZW5kOiAweDIwNkZ9LCAvLyBHZW5lcmFsIFB1bmN0dWF0aW9uXG4gICAge2JlZ2luOiAweDIwNzAsIGVuZDogMHgyMDlGfSwgLy8gU3VwZXJzY3JpcHRzIEFuZCBTdWJzY3JpcHRzXG4gICAge2JlZ2luOiAweDIwQTAsIGVuZDogMHgyMENGfSwgLy8gQ3VycmVuY3kgU3ltYm9sXG4gICAge2JlZ2luOiAweDIwRDAsIGVuZDogMHgyMEZGfSwgLy8gQ29tYmluaW5nIERpYWNyaXRpY2FsIE1hcmtzIEZvciBTeW1ib2xzXG4gICAge2JlZ2luOiAweDIxMDAsIGVuZDogMHgyMTRGfSwgLy8gTGV0dGVybGlrZSBTeW1ib2xzXG4gICAge2JlZ2luOiAweDIxNTAsIGVuZDogMHgyMThGfSwgLy8gTnVtYmVyIEZvcm1zXG4gICAge2JlZ2luOiAweDIxOTAsIGVuZDogMHgyMUZGfSwgLy8gQXJyb3dzXG4gICAge2JlZ2luOiAweDIyMDAsIGVuZDogMHgyMkZGfSwgLy8gTWF0aGVtYXRpY2FsIE9wZXJhdG9yc1xuICAgIHtiZWdpbjogMHgyMzAwLCBlbmQ6IDB4MjNGRn0sIC8vIE1pc2NlbGxhbmVvdXMgVGVjaG5pY2FsXG4gICAge2JlZ2luOiAweDI0MDAsIGVuZDogMHgyNDNGfSwgLy8gQ29udHJvbCBQaWN0dXJlc1xuICAgIHtiZWdpbjogMHgyNDQwLCBlbmQ6IDB4MjQ1Rn0sIC8vIE9wdGljYWwgQ2hhcmFjdGVyIFJlY29nbml0aW9uXG4gICAge2JlZ2luOiAweDI0NjAsIGVuZDogMHgyNEZGfSwgLy8gRW5jbG9zZWQgQWxwaGFudW1lcmljc1xuICAgIHtiZWdpbjogMHgyNTAwLCBlbmQ6IDB4MjU3Rn0sIC8vIEJveCBEcmF3aW5nXG4gICAge2JlZ2luOiAweDI1ODAsIGVuZDogMHgyNTlGfSwgLy8gQmxvY2sgRWxlbWVudHNcbiAgICB7YmVnaW46IDB4MjVBMCwgZW5kOiAweDI1RkZ9LCAvLyBHZW9tZXRyaWMgU2hhcGVzXG4gICAge2JlZ2luOiAweDI2MDAsIGVuZDogMHgyNkZGfSwgLy8gTWlzY2VsbGFuZW91cyBTeW1ib2xzXG4gICAge2JlZ2luOiAweDI3MDAsIGVuZDogMHgyN0JGfSwgLy8gRGluZ2JhdHNcbiAgICB7YmVnaW46IDB4MzAwMCwgZW5kOiAweDMwM0Z9LCAvLyBDSksgU3ltYm9scyBBbmQgUHVuY3R1YXRpb25cbiAgICB7YmVnaW46IDB4MzA0MCwgZW5kOiAweDMwOUZ9LCAvLyBIaXJhZ2FuYVxuICAgIHtiZWdpbjogMHgzMEEwLCBlbmQ6IDB4MzBGRn0sIC8vIEthdGFrYW5hXG4gICAge2JlZ2luOiAweDMxMDAsIGVuZDogMHgzMTJGfSwgLy8gQm9wb21vZm9cbiAgICB7YmVnaW46IDB4MzEzMCwgZW5kOiAweDMxOEZ9LCAvLyBIYW5ndWwgQ29tcGF0aWJpbGl0eSBKYW1vXG4gICAge2JlZ2luOiAweEE4NDAsIGVuZDogMHhBODdGfSwgLy8gUGhhZ3MtcGFcbiAgICB7YmVnaW46IDB4MzIwMCwgZW5kOiAweDMyRkZ9LCAvLyBFbmNsb3NlZCBDSksgTGV0dGVycyBBbmQgTW9udGhzXG4gICAge2JlZ2luOiAweDMzMDAsIGVuZDogMHgzM0ZGfSwgLy8gQ0pLIENvbXBhdGliaWxpdHlcbiAgICB7YmVnaW46IDB4QUMwMCwgZW5kOiAweEQ3QUZ9LCAvLyBIYW5ndWwgU3lsbGFibGVzXG4gICAge2JlZ2luOiAweEQ4MDAsIGVuZDogMHhERkZGfSwgLy8gTm9uLVBsYW5lIDAgKlxuICAgIHtiZWdpbjogMHgxMDkwMCwgZW5kOiAweDEwOTFGfSwgLy8gUGhvZW5pY2lhXG4gICAge2JlZ2luOiAweDRFMDAsIGVuZDogMHg5RkZGfSwgLy8gQ0pLIFVuaWZpZWQgSWRlb2dyYXBoc1xuICAgIHtiZWdpbjogMHhFMDAwLCBlbmQ6IDB4RjhGRn0sIC8vIFByaXZhdGUgVXNlIEFyZWEgKHBsYW5lIDApXG4gICAge2JlZ2luOiAweDMxQzAsIGVuZDogMHgzMUVGfSwgLy8gQ0pLIFN0cm9rZXNcbiAgICB7YmVnaW46IDB4RkIwMCwgZW5kOiAweEZCNEZ9LCAvLyBBbHBoYWJldGljIFByZXNlbnRhdGlvbiBGb3Jtc1xuICAgIHtiZWdpbjogMHhGQjUwLCBlbmQ6IDB4RkRGRn0sIC8vIEFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQVxuICAgIHtiZWdpbjogMHhGRTIwLCBlbmQ6IDB4RkUyRn0sIC8vIENvbWJpbmluZyBIYWxmIE1hcmtzXG4gICAge2JlZ2luOiAweEZFMTAsIGVuZDogMHhGRTFGfSwgLy8gVmVydGljYWwgRm9ybXNcbiAgICB7YmVnaW46IDB4RkU1MCwgZW5kOiAweEZFNkZ9LCAvLyBTbWFsbCBGb3JtIFZhcmlhbnRzXG4gICAge2JlZ2luOiAweEZFNzAsIGVuZDogMHhGRUZGfSwgLy8gQXJhYmljIFByZXNlbnRhdGlvbiBGb3Jtcy1CXG4gICAge2JlZ2luOiAweEZGMDAsIGVuZDogMHhGRkVGfSwgLy8gSGFsZndpZHRoIEFuZCBGdWxsd2lkdGggRm9ybXNcbiAgICB7YmVnaW46IDB4RkZGMCwgZW5kOiAweEZGRkZ9LCAvLyBTcGVjaWFsc1xuICAgIHtiZWdpbjogMHgwRjAwLCBlbmQ6IDB4MEZGRn0sIC8vIFRpYmV0YW5cbiAgICB7YmVnaW46IDB4MDcwMCwgZW5kOiAweDA3NEZ9LCAvLyBTeXJpYWNcbiAgICB7YmVnaW46IDB4MDc4MCwgZW5kOiAweDA3QkZ9LCAvLyBUaGFhbmFcbiAgICB7YmVnaW46IDB4MEQ4MCwgZW5kOiAweDBERkZ9LCAvLyBTaW5oYWxhXG4gICAge2JlZ2luOiAweDEwMDAsIGVuZDogMHgxMDlGfSwgLy8gTXlhbm1hclxuICAgIHtiZWdpbjogMHgxMjAwLCBlbmQ6IDB4MTM3Rn0sIC8vIEV0aGlvcGljXG4gICAge2JlZ2luOiAweDEzQTAsIGVuZDogMHgxM0ZGfSwgLy8gQ2hlcm9rZWVcbiAgICB7YmVnaW46IDB4MTQwMCwgZW5kOiAweDE2N0Z9LCAvLyBVbmlmaWVkIENhbmFkaWFuIEFib3JpZ2luYWwgU3lsbGFiaWNzXG4gICAge2JlZ2luOiAweDE2ODAsIGVuZDogMHgxNjlGfSwgLy8gT2doYW1cbiAgICB7YmVnaW46IDB4MTZBMCwgZW5kOiAweDE2RkZ9LCAvLyBSdW5pY1xuICAgIHtiZWdpbjogMHgxNzgwLCBlbmQ6IDB4MTdGRn0sIC8vIEtobWVyXG4gICAge2JlZ2luOiAweDE4MDAsIGVuZDogMHgxOEFGfSwgLy8gTW9uZ29saWFuXG4gICAge2JlZ2luOiAweDI4MDAsIGVuZDogMHgyOEZGfSwgLy8gQnJhaWxsZSBQYXR0ZXJuc1xuICAgIHtiZWdpbjogMHhBMDAwLCBlbmQ6IDB4QTQ4Rn0sIC8vIFlpIFN5bGxhYmxlc1xuICAgIHtiZWdpbjogMHgxNzAwLCBlbmQ6IDB4MTcxRn0sIC8vIFRhZ2Fsb2dcbiAgICB7YmVnaW46IDB4MTAzMDAsIGVuZDogMHgxMDMyRn0sIC8vIE9sZCBJdGFsaWNcbiAgICB7YmVnaW46IDB4MTAzMzAsIGVuZDogMHgxMDM0Rn0sIC8vIEdvdGhpY1xuICAgIHtiZWdpbjogMHgxMDQwMCwgZW5kOiAweDEwNDRGfSwgLy8gRGVzZXJldFxuICAgIHtiZWdpbjogMHgxRDAwMCwgZW5kOiAweDFEMEZGfSwgLy8gQnl6YW50aW5lIE11c2ljYWwgU3ltYm9sc1xuICAgIHtiZWdpbjogMHgxRDQwMCwgZW5kOiAweDFEN0ZGfSwgLy8gTWF0aGVtYXRpY2FsIEFscGhhbnVtZXJpYyBTeW1ib2xzXG4gICAge2JlZ2luOiAweEZGMDAwLCBlbmQ6IDB4RkZGRkR9LCAvLyBQcml2YXRlIFVzZSAocGxhbmUgMTUpXG4gICAge2JlZ2luOiAweEZFMDAsIGVuZDogMHhGRTBGfSwgLy8gVmFyaWF0aW9uIFNlbGVjdG9yc1xuICAgIHtiZWdpbjogMHhFMDAwMCwgZW5kOiAweEUwMDdGfSwgLy8gVGFnc1xuICAgIHtiZWdpbjogMHgxOTAwLCBlbmQ6IDB4MTk0Rn0sIC8vIExpbWJ1XG4gICAge2JlZ2luOiAweDE5NTAsIGVuZDogMHgxOTdGfSwgLy8gVGFpIExlXG4gICAge2JlZ2luOiAweDE5ODAsIGVuZDogMHgxOURGfSwgLy8gTmV3IFRhaSBMdWVcbiAgICB7YmVnaW46IDB4MUEwMCwgZW5kOiAweDFBMUZ9LCAvLyBCdWdpbmVzZVxuICAgIHtiZWdpbjogMHgyQzAwLCBlbmQ6IDB4MkM1Rn0sIC8vIEdsYWdvbGl0aWNcbiAgICB7YmVnaW46IDB4MkQzMCwgZW5kOiAweDJEN0Z9LCAvLyBUaWZpbmFnaFxuICAgIHtiZWdpbjogMHg0REMwLCBlbmQ6IDB4NERGRn0sIC8vIFlpamluZyBIZXhhZ3JhbSBTeW1ib2xzXG4gICAge2JlZ2luOiAweEE4MDAsIGVuZDogMHhBODJGfSwgLy8gU3lsb3RpIE5hZ3JpXG4gICAge2JlZ2luOiAweDEwMDAwLCBlbmQ6IDB4MTAwN0Z9LCAvLyBMaW5lYXIgQiBTeWxsYWJhcnlcbiAgICB7YmVnaW46IDB4MTAxNDAsIGVuZDogMHgxMDE4Rn0sIC8vIEFuY2llbnQgR3JlZWsgTnVtYmVyc1xuICAgIHtiZWdpbjogMHgxMDM4MCwgZW5kOiAweDEwMzlGfSwgLy8gVWdhcml0aWNcbiAgICB7YmVnaW46IDB4MTAzQTAsIGVuZDogMHgxMDNERn0sIC8vIE9sZCBQZXJzaWFuXG4gICAge2JlZ2luOiAweDEwNDUwLCBlbmQ6IDB4MTA0N0Z9LCAvLyBTaGF2aWFuXG4gICAge2JlZ2luOiAweDEwNDgwLCBlbmQ6IDB4MTA0QUZ9LCAvLyBPc21hbnlhXG4gICAge2JlZ2luOiAweDEwODAwLCBlbmQ6IDB4MTA4M0Z9LCAvLyBDeXByaW90IFN5bGxhYmFyeVxuICAgIHtiZWdpbjogMHgxMEEwMCwgZW5kOiAweDEwQTVGfSwgLy8gS2hhcm9zaHRoaVxuICAgIHtiZWdpbjogMHgxRDMwMCwgZW5kOiAweDFEMzVGfSwgLy8gVGFpIFh1YW4gSmluZyBTeW1ib2xzXG4gICAge2JlZ2luOiAweDEyMDAwLCBlbmQ6IDB4MTIzRkZ9LCAvLyBDdW5laWZvcm1cbiAgICB7YmVnaW46IDB4MUQzNjAsIGVuZDogMHgxRDM3Rn0sIC8vIENvdW50aW5nIFJvZCBOdW1lcmFsc1xuICAgIHtiZWdpbjogMHgxQjgwLCBlbmQ6IDB4MUJCRn0sIC8vIFN1bmRhbmVzZVxuICAgIHtiZWdpbjogMHgxQzAwLCBlbmQ6IDB4MUM0Rn0sIC8vIExlcGNoYVxuICAgIHtiZWdpbjogMHgxQzUwLCBlbmQ6IDB4MUM3Rn0sIC8vIE9sIENoaWtpXG4gICAge2JlZ2luOiAweEE4ODAsIGVuZDogMHhBOERGfSwgLy8gU2F1cmFzaHRyYVxuICAgIHtiZWdpbjogMHhBOTAwLCBlbmQ6IDB4QTkyRn0sIC8vIEtheWFoIExpXG4gICAge2JlZ2luOiAweEE5MzAsIGVuZDogMHhBOTVGfSwgLy8gUmVqYW5nXG4gICAge2JlZ2luOiAweEFBMDAsIGVuZDogMHhBQTVGfSwgLy8gQ2hhbVxuICAgIHtiZWdpbjogMHgxMDE5MCwgZW5kOiAweDEwMUNGfSwgLy8gQW5jaWVudCBTeW1ib2xzXG4gICAge2JlZ2luOiAweDEwMUQwLCBlbmQ6IDB4MTAxRkZ9LCAvLyBQaGFpc3RvcyBEaXNjXG4gICAge2JlZ2luOiAweDEwMkEwLCBlbmQ6IDB4MTAyREZ9LCAvLyBDYXJpYW5cbiAgICB7YmVnaW46IDB4MUYwMzAsIGVuZDogMHgxRjA5Rn0gIC8vIERvbWlubyBUaWxlc1xuXTtcblxuZnVuY3Rpb24gZ2V0VW5pY29kZVJhbmdlKHVuaWNvZGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuaWNvZGVSYW5nZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gdW5pY29kZVJhbmdlc1tpXTtcbiAgICAgICAgaWYgKHVuaWNvZGUgPj0gcmFuZ2UuYmVnaW4gJiYgdW5pY29kZSA8IHJhbmdlLmVuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG59XG5cbi8vIFBhcnNlIHRoZSBPUy8yIGFuZCBXaW5kb3dzIG1ldHJpY3MgYE9TLzJgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZU9TMlRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIG9zMiA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgb3MyLnZlcnNpb24gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnhBdmdDaGFyV2lkdGggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIudXNXZWlnaHRDbGFzcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNXaWR0aENsYXNzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi5mc1R5cGUgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRYU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WVNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1YnNjcmlwdFhPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1YnNjcmlwdFlPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1cGVyc2NyaXB0WFNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1cGVyc2NyaXB0WVNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN1cGVyc2NyaXB0WE9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRZT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdHJpa2VvdXRTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdHJpa2VvdXRQb3NpdGlvbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi5zRmFtaWx5Q2xhc3MgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIucGFub3NlID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgIG9zMi5wYW5vc2VbaV0gPSBwLnBhcnNlQnl0ZSgpO1xuICAgIH1cblxuICAgIG9zMi51bFVuaWNvZGVSYW5nZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBvczIudWxVbmljb2RlUmFuZ2UyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgb3MyLnVsVW5pY29kZVJhbmdlMyA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi51bFVuaWNvZGVSYW5nZTQgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBvczIuYWNoVmVuZElEID0gU3RyaW5nLmZyb21DaGFyQ29kZShwLnBhcnNlQnl0ZSgpLCBwLnBhcnNlQnl0ZSgpLCBwLnBhcnNlQnl0ZSgpLCBwLnBhcnNlQnl0ZSgpKTtcbiAgICBvczIuZnNTZWxlY3Rpb24gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnVzRmlyc3RDaGFySW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnVzTGFzdENoYXJJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIuc1R5cG9Bc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi5zVHlwb0Rlc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi5zVHlwb0xpbmVHYXAgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIudXNXaW5Bc2NlbnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLnVzV2luRGVzY2VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAob3MyLnZlcnNpb24gPj0gMSkge1xuICAgICAgICBvczIudWxDb2RlUGFnZVJhbmdlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgICBvczIudWxDb2RlUGFnZVJhbmdlMiA9IHAucGFyc2VVTG9uZygpO1xuICAgIH1cblxuICAgIGlmIChvczIudmVyc2lvbiA+PSAyKSB7XG4gICAgICAgIG9zMi5zeEhlaWdodCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICBvczIuc0NhcEhlaWdodCA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICBvczIudXNEZWZhdWx0Q2hhciA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgb3MyLnVzQnJlYWtDaGFyID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBvczIudXNNYXhDb250ZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIH1cblxuICAgIHJldHVybiBvczI7XG59XG5cbmZ1bmN0aW9uIG1ha2VPUzJUYWJsZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnT1MvMicsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAweDAwMDN9LFxuICAgICAgICB7bmFtZTogJ3hBdmdDaGFyV2lkdGgnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNXZWlnaHRDbGFzcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNXaWR0aENsYXNzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdmc1R5cGUnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdWJzY3JpcHRYU2l6ZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiA2NTB9LFxuICAgICAgICB7bmFtZTogJ3lTdWJzY3JpcHRZU2l6ZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiA2OTl9LFxuICAgICAgICB7bmFtZTogJ3lTdWJzY3JpcHRYT2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lTdWJzY3JpcHRZT2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDE0MH0sXG4gICAgICAgIHtuYW1lOiAneVN1cGVyc2NyaXB0WFNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogNjUwfSxcbiAgICAgICAge25hbWU6ICd5U3VwZXJzY3JpcHRZU2l6ZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiA2OTl9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFhPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneVN1cGVyc2NyaXB0WU9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiA0Nzl9LFxuICAgICAgICB7bmFtZTogJ3lTdHJpa2VvdXRTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDQ5fSxcbiAgICAgICAge25hbWU6ICd5U3RyaWtlb3V0UG9zaXRpb24nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMjU4fSxcbiAgICAgICAge25hbWU6ICdzRmFtaWx5Q2xhc3MnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYkZhbWlseVR5cGUnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiU2VyaWZTdHlsZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JXZWlnaHQnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiUHJvcG9ydGlvbicsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JDb250cmFzdCcsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JTdHJva2VWYXJpYXRpb24nLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiQXJtU3R5bGUnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiTGV0dGVyZm9ybScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JNaWRsaW5lJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYlhIZWlnaHQnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bFVuaWNvZGVSYW5nZTEnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2UyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlMycsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bFVuaWNvZGVSYW5nZTQnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYWNoVmVuZElEJywgdHlwZTogJ0NIQVJBUlJBWScsIHZhbHVlOiAnWFhYWCd9LFxuICAgICAgICB7bmFtZTogJ2ZzU2VsZWN0aW9uJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c0ZpcnN0Q2hhckluZGV4JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c0xhc3RDaGFySW5kZXgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NUeXBvQXNjZW5kZXInLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc1R5cG9EZXNjZW5kZXInLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc1R5cG9MaW5lR2FwJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzV2luQXNjZW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c1dpbkRlc2NlbnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsQ29kZVBhZ2VSYW5nZTEnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxDb2RlUGFnZVJhbmdlMicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzeEhlaWdodCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzQ2FwSGVpZ2h0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzRGVmYXVsdENoYXInLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzQnJlYWtDaGFyJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c01heENvbnRleHQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG4gICAgXSwgb3B0aW9ucyk7XG59XG5cbnZhciBvczIgPSB7IHBhcnNlOiBwYXJzZU9TMlRhYmxlLCBtYWtlOiBtYWtlT1MyVGFibGUsIHVuaWNvZGVSYW5nZXM6IHVuaWNvZGVSYW5nZXMsIGdldFVuaWNvZGVSYW5nZTogZ2V0VW5pY29kZVJhbmdlIH07XG5cbi8vIFRoZSBgcG9zdGAgdGFibGUgc3RvcmVzIGFkZGl0aW9uYWwgUG9zdFNjcmlwdCBpbmZvcm1hdGlvbiwgc3VjaCBhcyBnbHlwaCBuYW1lcy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvcG9zdC5odG1cblxuLy8gUGFyc2UgdGhlIFBvc3RTY3JpcHQgYHBvc3RgIHRhYmxlXG5mdW5jdGlvbiBwYXJzZVBvc3RUYWJsZShkYXRhLCBzdGFydCkge1xuICAgIHZhciBwb3N0ID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBwb3N0LnZlcnNpb24gPSBwLnBhcnNlVmVyc2lvbigpO1xuICAgIHBvc3QuaXRhbGljQW5nbGUgPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBwb3N0LnVuZGVybGluZVBvc2l0aW9uID0gcC5wYXJzZVNob3J0KCk7XG4gICAgcG9zdC51bmRlcmxpbmVUaGlja25lc3MgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBwb3N0LmlzRml4ZWRQaXRjaCA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWluTWVtVHlwZTQyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5tYXhNZW1UeXBlNDIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm1pbk1lbVR5cGUxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5tYXhNZW1UeXBlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgIHN3aXRjaCAocG9zdC52ZXJzaW9uKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHBvc3QubmFtZXMgPSBzdGFuZGFyZE5hbWVzLnNsaWNlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcG9zdC5udW1iZXJPZkdseXBocyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHBvc3QuZ2x5cGhOYW1lSW5kZXggPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkrKykge1xuICAgICAgICAgICAgICAgIHBvc3QuZ2x5cGhOYW1lSW5kZXhbaV0gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvc3QubmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkkMSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3QuZ2x5cGhOYW1lSW5kZXhbaSQxXSA+PSBzdGFuZGFyZE5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZUxlbmd0aCA9IHAucGFyc2VDaGFyKCk7XG4gICAgICAgICAgICAgICAgICAgIHBvc3QubmFtZXMucHVzaChwLnBhcnNlU3RyaW5nKG5hbWVMZW5ndGgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIuNTpcbiAgICAgICAgICAgIHBvc3QubnVtYmVyT2ZHbHlwaHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICBwb3N0Lm9mZnNldCA9IG5ldyBBcnJheShwb3N0Lm51bWJlck9mR2x5cGhzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHBvc3QubnVtYmVyT2ZHbHlwaHM7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgcG9zdC5vZmZzZXRbaSQyXSA9IHAucGFyc2VDaGFyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcG9zdDtcbn1cblxuZnVuY3Rpb24gbWFrZVBvc3RUYWJsZSgpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdwb3N0JywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMHgwMDAzMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnaXRhbGljQW5nbGUnLCB0eXBlOiAnRklYRUQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndW5kZXJsaW5lUG9zaXRpb24nLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndW5kZXJsaW5lVGhpY2tuZXNzJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2lzRml4ZWRQaXRjaCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtaW5NZW1UeXBlNDInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWF4TWVtVHlwZTQyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21pbk1lbVR5cGUxJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21heE1lbVR5cGUxJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9XG4gICAgXSk7XG59XG5cbnZhciBwb3N0ID0geyBwYXJzZTogcGFyc2VQb3N0VGFibGUsIG1ha2U6IG1ha2VQb3N0VGFibGUgfTtcblxuLy8gVGhlIGBHU1VCYCB0YWJsZSBjb250YWlucyBsaWdhdHVyZXMsIGFtb25nIG90aGVyIHRoaW5ncy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZ3N1Yi5odG1cblxudmFyIHN1YnRhYmxlUGFyc2VycyA9IG5ldyBBcnJheSg5KTsgICAgICAgICAvLyBzdWJ0YWJsZVBhcnNlcnNbMF0gaXMgdW51c2VkXG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jU1NcbnN1YnRhYmxlUGFyc2Vyc1sxXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMSgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChzdWJzdEZvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIGRlbHRhR2x5cGhJZDogdGhpcy5wYXJzZVVTaG9ydCgpXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDIsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIHN1YnN0aXR1dGU6IHRoaXMucGFyc2VPZmZzZXQxNkxpc3QoKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjaGVjay5hc3NlcnQoZmFsc2UsICcweCcgKyBzdGFydC50b1N0cmluZygxNikgKyAnOiBsb29rdXAgdHlwZSAxIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nKTtcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jTVNcbnN1YnRhYmxlUGFyc2Vyc1syXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMigpIHtcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXJndW1lbnQoc3Vic3RGb3JtYXQgPT09IDEsICdHU1VCIE11bHRpcGxlIFN1YnN0aXR1dGlvbiBTdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBzZXF1ZW5jZXM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cygpXG4gICAgfTtcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jQVNcbnN1YnRhYmxlUGFyc2Vyc1szXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMygpIHtcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXJndW1lbnQoc3Vic3RGb3JtYXQgPT09IDEsICdHU1VCIEFsdGVybmF0ZSBTdWJzdGl0dXRpb24gU3VidGFibGUgaWRlbnRpZmllci1mb3JtYXQgbXVzdCBiZSAxJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgYWx0ZXJuYXRlU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKClcbiAgICB9O1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNMU1xuc3VidGFibGVQYXJzZXJzWzRdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA0KCkge1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChzdWJzdEZvcm1hdCA9PT0gMSwgJ0dTVUIgbGlnYXR1cmUgdGFibGUgaWRlbnRpZmllci1mb3JtYXQgbXVzdCBiZSAxJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgbGlnYXR1cmVTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxpZ0dseXBoOiB0aGlzLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgY29tcG9uZW50czogdGhpcy5wYXJzZVVTaG9ydExpc3QodGhpcy5wYXJzZVVTaG9ydCgpIC0gMSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgfTtcbn07XG5cbnZhciBsb29rdXBSZWNvcmREZXNjID0ge1xuICAgIHNlcXVlbmNlSW5kZXg6IFBhcnNlci51U2hvcnQsXG4gICAgbG9va3VwTGlzdEluZGV4OiBQYXJzZXIudVNob3J0XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0NTRlxuc3VidGFibGVQYXJzZXJzWzVdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA1KCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG5cbiAgICBpZiAoc3Vic3RGb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgcnVsZVNldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2x5cGhDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic3RDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogdGhpcy5wYXJzZVVTaG9ydExpc3QoZ2x5cGhDb3VudCAtIDEpLFxuICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChzdWJzdENvdW50LCBsb29rdXBSZWNvcmREZXNjKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoc3Vic3RGb3JtYXQgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgY2xhc3NEZWY6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZiksXG4gICAgICAgICAgICBjbGFzc1NldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2x5cGhDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic3RDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzOiB0aGlzLnBhcnNlVVNob3J0TGlzdChnbHlwaENvdW50IC0gMSksXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KHN1YnN0Q291bnQsIGxvb2t1cFJlY29yZERlc2MpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMykge1xuICAgICAgICB2YXIgZ2x5cGhDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIHN1YnN0Q291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgICAgICBjb3ZlcmFnZXM6IHRoaXMucGFyc2VMaXN0KGdseXBoQ291bnQsIFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3Qoc3Vic3RDb3VudCwgbG9va3VwUmVjb3JkRGVzYylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2hlY2suYXNzZXJ0KGZhbHNlLCAnMHgnICsgc3RhcnQudG9TdHJpbmcoMTYpICsgJzogbG9va3VwIHR5cGUgNSBmb3JtYXQgbXVzdCBiZSAxLCAyIG9yIDMuJyk7XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0NDXG5zdWJ0YWJsZVBhcnNlcnNbNl0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDYoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAoc3Vic3RGb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBjaGFpblJ1bGVTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYmFja3RyYWNrOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogdGhpcy5wYXJzZVVTaG9ydExpc3QodGhpcy5wYXJzZVNob3J0KCkgLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgbG9va2FoZWFkOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpLFxuICAgICAgICAgICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChsb29rdXBSZWNvcmREZXNjKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoc3Vic3RGb3JtYXQgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAyLFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBiYWNrdHJhY2tDbGFzc0RlZjogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcbiAgICAgICAgICAgIGlucHV0Q2xhc3NEZWY6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZiksXG4gICAgICAgICAgICBsb29rYWhlYWRDbGFzc0RlZjogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcbiAgICAgICAgICAgIGNoYWluQ2xhc3NTZXQ6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBiYWNrdHJhY2s6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0aGlzLnBhcnNlVVNob3J0TGlzdCh0aGlzLnBhcnNlU2hvcnQoKSAtIDEpLFxuICAgICAgICAgICAgICAgICAgICBsb29rYWhlYWQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KGxvb2t1cFJlY29yZERlc2MpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDMsXG4gICAgICAgICAgICBiYWNrdHJhY2tDb3ZlcmFnZTogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG4gICAgICAgICAgICBpbnB1dENvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgICAgIGxvb2thaGVhZENvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KGxvb2t1cFJlY29yZERlc2MpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrLmFzc2VydChmYWxzZSwgJzB4JyArIHN0YXJ0LnRvU3RyaW5nKDE2KSArICc6IGxvb2t1cCB0eXBlIDYgZm9ybWF0IG11c3QgYmUgMSwgMiBvciAzLicpO1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNFU1xuc3VidGFibGVQYXJzZXJzWzddID0gZnVuY3Rpb24gcGFyc2VMb29rdXA3KCkge1xuICAgIC8vIEV4dGVuc2lvbiBTdWJzdGl0dXRpb24gc3VidGFibGVcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXJndW1lbnQoc3Vic3RGb3JtYXQgPT09IDEsICdHU1VCIEV4dGVuc2lvbiBTdWJzdGl0dXRpb24gc3VidGFibGUgaWRlbnRpZmllci1mb3JtYXQgbXVzdCBiZSAxJyk7XG4gICAgdmFyIGV4dGVuc2lvbkxvb2t1cFR5cGUgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGV4dGVuc2lvblBhcnNlciA9IG5ldyBQYXJzZXIodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucGFyc2VVTG9uZygpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzdEZvcm1hdDogMSxcbiAgICAgICAgbG9va3VwVHlwZTogZXh0ZW5zaW9uTG9va3VwVHlwZSxcbiAgICAgICAgZXh0ZW5zaW9uOiBzdWJ0YWJsZVBhcnNlcnNbZXh0ZW5zaW9uTG9va3VwVHlwZV0uY2FsbChleHRlbnNpb25QYXJzZXIpXG4gICAgfTtcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jUkNDU1xuc3VidGFibGVQYXJzZXJzWzhdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA4KCkge1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChzdWJzdEZvcm1hdCA9PT0gMSwgJ0dTVUIgUmV2ZXJzZSBDaGFpbmluZyBDb250ZXh0dWFsIFNpbmdsZSBTdWJzdGl0dXRpb24gU3VidGFibGUgaWRlbnRpZmllci1mb3JtYXQgbXVzdCBiZSAxJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgYmFja3RyYWNrQ292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICBsb29rYWhlYWRDb3ZlcmFnZTogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG4gICAgICAgIHN1YnN0aXR1dGVzOiB0aGlzLnBhcnNlVVNob3J0TGlzdCgpXG4gICAgfTtcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZ3N1Yi5odG1cbmZ1bmN0aW9uIHBhcnNlR3N1YlRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIHZhciBwID0gbmV3IFBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKDEpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMSB8fCB0YWJsZVZlcnNpb24gPT09IDEuMSwgJ1Vuc3VwcG9ydGVkIEdTVUIgdGFibGUgdmVyc2lvbi4nKTtcbiAgICBpZiAodGFibGVWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiB0YWJsZVZlcnNpb24sXG4gICAgICAgICAgICBzY3JpcHRzOiBwLnBhcnNlU2NyaXB0TGlzdCgpLFxuICAgICAgICAgICAgZmVhdHVyZXM6IHAucGFyc2VGZWF0dXJlTGlzdCgpLFxuICAgICAgICAgICAgbG9va3VwczogcC5wYXJzZUxvb2t1cExpc3Qoc3VidGFibGVQYXJzZXJzKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiB0YWJsZVZlcnNpb24sXG4gICAgICAgICAgICBzY3JpcHRzOiBwLnBhcnNlU2NyaXB0TGlzdCgpLFxuICAgICAgICAgICAgZmVhdHVyZXM6IHAucGFyc2VGZWF0dXJlTGlzdCgpLFxuICAgICAgICAgICAgbG9va3VwczogcC5wYXJzZUxvb2t1cExpc3Qoc3VidGFibGVQYXJzZXJzKSxcbiAgICAgICAgICAgIHZhcmlhdGlvbnM6IHAucGFyc2VGZWF0dXJlVmFyaWF0aW9uc0xpc3QoKVxuICAgICAgICB9O1xuICAgIH1cblxufVxuXG4vLyBHU1VCIFdyaXRpbmcgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xudmFyIHN1YnRhYmxlTWFrZXJzID0gbmV3IEFycmF5KDkpO1xuXG5zdWJ0YWJsZU1ha2Vyc1sxXSA9IGZ1bmN0aW9uIG1ha2VMb29rdXAxKHN1YnRhYmxlKSB7XG4gICAgaWYgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ3N1YnN0aXR1dGlvblRhYmxlJywgW1xuICAgICAgICAgICAge25hbWU6ICdzdWJzdEZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX0sXG4gICAgICAgICAgICB7bmFtZTogJ2NvdmVyYWdlJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Db3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSl9LFxuICAgICAgICAgICAge25hbWU6ICdkZWx0YUdseXBoSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHN1YnRhYmxlLmRlbHRhR2x5cGhJZH1cbiAgICAgICAgXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnc3Vic3RpdHV0aW9uVGFibGUnLCBbXG4gICAgICAgICAgICB7bmFtZTogJ3N1YnN0Rm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAyfSxcbiAgICAgICAgICAgIHtuYW1lOiAnY292ZXJhZ2UnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkNvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKX1cbiAgICAgICAgXS5jb25jYXQodGFibGUudXNob3J0TGlzdCgnc3Vic3RpdHV0ZScsIHN1YnRhYmxlLnN1YnN0aXR1dGUpKSk7XG4gICAgfVxuICAgIGNoZWNrLmZhaWwoJ0xvb2t1cCB0eXBlIDEgc3Vic3RGb3JtYXQgbXVzdCBiZSAxIG9yIDIuJyk7XG59O1xuXG5zdWJ0YWJsZU1ha2Vyc1szXSA9IGZ1bmN0aW9uIG1ha2VMb29rdXAzKHN1YnRhYmxlKSB7XG4gICAgY2hlY2suYXNzZXJ0KHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAxLCAnTG9va3VwIHR5cGUgMyBzdWJzdEZvcm1hdCBtdXN0IGJlIDEuJyk7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnc3Vic3RpdHV0aW9uVGFibGUnLCBbXG4gICAgICAgIHtuYW1lOiAnc3Vic3RGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ2NvdmVyYWdlJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Db3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSl9XG4gICAgXS5jb25jYXQodGFibGUudGFibGVMaXN0KCdhbHRTZXQnLCBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzLCBmdW5jdGlvbihhbHRlcm5hdGVTZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnYWx0ZXJuYXRlU2V0VGFibGUnLCB0YWJsZS51c2hvcnRMaXN0KCdhbHRlcm5hdGUnLCBhbHRlcm5hdGVTZXQpKTtcbiAgICB9KSkpO1xufTtcblxuc3VidGFibGVNYWtlcnNbNF0gPSBmdW5jdGlvbiBtYWtlTG9va3VwNChzdWJ0YWJsZSkge1xuICAgIGNoZWNrLmFzc2VydChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gMSwgJ0xvb2t1cCB0eXBlIDQgc3Vic3RGb3JtYXQgbXVzdCBiZSAxLicpO1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ3N1YnN0aXR1dGlvblRhYmxlJywgW1xuICAgICAgICB7bmFtZTogJ3N1YnN0Rm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxfSxcbiAgICAgICAge25hbWU6ICdjb3ZlcmFnZScsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpfVxuICAgIF0uY29uY2F0KHRhYmxlLnRhYmxlTGlzdCgnbGlnU2V0Jywgc3VidGFibGUubGlnYXR1cmVTZXRzLCBmdW5jdGlvbihsaWdhdHVyZVNldCkge1xuICAgICAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdsaWdhdHVyZVNldFRhYmxlJywgdGFibGUudGFibGVMaXN0KCdsaWdhdHVyZScsIGxpZ2F0dXJlU2V0LCBmdW5jdGlvbihsaWdhdHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnbGlnYXR1cmVUYWJsZScsXG4gICAgICAgICAgICAgICAgW3tuYW1lOiAnbGlnR2x5cGgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxpZ2F0dXJlLmxpZ0dseXBofV1cbiAgICAgICAgICAgICAgICAuY29uY2F0KHRhYmxlLnVzaG9ydExpc3QoJ2NvbXBvbmVudCcsIGxpZ2F0dXJlLmNvbXBvbmVudHMsIGxpZ2F0dXJlLmNvbXBvbmVudHMubGVuZ3RoICsgMSkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9KSk7XG4gICAgfSkpKTtcbn07XG5cbmZ1bmN0aW9uIG1ha2VHc3ViVGFibGUoZ3N1Yikge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ0dTVUInLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAweDEwMDAwfSxcbiAgICAgICAge25hbWU6ICdzY3JpcHRzJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5TY3JpcHRMaXN0KGdzdWIuc2NyaXB0cyl9LFxuICAgICAgICB7bmFtZTogJ2ZlYXR1cmVzJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5GZWF0dXJlTGlzdChnc3ViLmZlYXR1cmVzKX0sXG4gICAgICAgIHtuYW1lOiAnbG9va3VwcycsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuTG9va3VwTGlzdChnc3ViLmxvb2t1cHMsIHN1YnRhYmxlTWFrZXJzKX1cbiAgICBdKTtcbn1cblxudmFyIGdzdWIgPSB7IHBhcnNlOiBwYXJzZUdzdWJUYWJsZSwgbWFrZTogbWFrZUdzdWJUYWJsZSB9O1xuXG4vLyBUaGUgYEdQT1NgIHRhYmxlIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMsIGFtb25nIG90aGVyIHRoaW5ncy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvZ3Bvcy5odG1cblxuLy8gUGFyc2UgdGhlIG1ldGFkYXRhIGBtZXRhYCB0YWJsZS5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9mb250cy9UcnVlVHlwZS1SZWZlcmVuY2UtTWFudWFsL1JNMDYvQ2hhcDZtZXRhLmh0bWxcbmZ1bmN0aW9uIHBhcnNlTWV0YVRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVVMb25nKCk7XG4gICAgY2hlY2suYXJndW1lbnQodGFibGVWZXJzaW9uID09PSAxLCAnVW5zdXBwb3J0ZWQgTUVUQSB0YWJsZSB2ZXJzaW9uLicpO1xuICAgIHAucGFyc2VVTG9uZygpOyAvLyBmbGFncyAtIGN1cnJlbnRseSB1bnVzZWQgYW5kIHNldCB0byAwXG4gICAgcC5wYXJzZVVMb25nKCk7IC8vIHRhYmxlT2Zmc2V0XG4gICAgdmFyIG51bURhdGFNYXBzID0gcC5wYXJzZVVMb25nKCk7XG5cbiAgICB2YXIgdGFncyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRGF0YU1hcHM7IGkrKykge1xuICAgICAgICB2YXIgdGFnID0gcC5wYXJzZVRhZygpO1xuICAgICAgICB2YXIgZGF0YU9mZnNldCA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgICB2YXIgZGF0YUxlbmd0aCA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgICB2YXIgdGV4dCA9IGRlY29kZS5VVEY4KGRhdGEsIHN0YXJ0ICsgZGF0YU9mZnNldCwgZGF0YUxlbmd0aCk7XG5cbiAgICAgICAgdGFnc1t0YWddID0gdGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHRhZ3M7XG59XG5cbmZ1bmN0aW9uIG1ha2VNZXRhVGFibGUodGFncykge1xuICAgIHZhciBudW1UYWdzID0gT2JqZWN0LmtleXModGFncykubGVuZ3RoO1xuICAgIHZhciBzdHJpbmdQb29sID0gJyc7XG4gICAgdmFyIHN0cmluZ1Bvb2xPZmZzZXQgPSAxNiArIG51bVRhZ3MgKiAxMjtcblxuICAgIHZhciByZXN1bHQgPSBuZXcgdGFibGUuVGFibGUoJ21ldGEnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAxfSxcbiAgICAgICAge25hbWU6ICdmbGFncycsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdvZmZzZXQnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogc3RyaW5nUG9vbE9mZnNldH0sXG4gICAgICAgIHtuYW1lOiAnbnVtVGFncycsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBudW1UYWdzfVxuICAgIF0pO1xuXG4gICAgZm9yICh2YXIgdGFnIGluIHRhZ3MpIHtcbiAgICAgICAgdmFyIHBvcyA9IHN0cmluZ1Bvb2wubGVuZ3RoO1xuICAgICAgICBzdHJpbmdQb29sICs9IHRhZ3NbdGFnXTtcblxuICAgICAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICd0YWcgJyArIHRhZywgdHlwZTogJ1RBRycsIHZhbHVlOiB0YWd9KTtcbiAgICAgICAgcmVzdWx0LmZpZWxkcy5wdXNoKHtuYW1lOiAnb2Zmc2V0ICcgKyB0YWcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBzdHJpbmdQb29sT2Zmc2V0ICsgcG9zfSk7XG4gICAgICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ2xlbmd0aCAnICsgdGFnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogdGFnc1t0YWddLmxlbmd0aH0pO1xuICAgIH1cblxuICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ3N0cmluZ1Bvb2wnLCB0eXBlOiAnQ0hBUkFSUkFZJywgdmFsdWU6IHN0cmluZ1Bvb2x9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBtZXRhID0geyBwYXJzZTogcGFyc2VNZXRhVGFibGUsIG1ha2U6IG1ha2VNZXRhVGFibGUgfTtcblxuLy8gVGhlIGBzZm50YCB3cmFwcGVyIHByb3ZpZGVzIG9yZ2FuaXphdGlvbiBmb3IgdGhlIHRhYmxlcyBpbiB0aGUgZm9udC5cbi8vIEl0IGlzIHRoZSB0b3AtbGV2ZWwgZGF0YSBzdHJ1Y3R1cmUgaW4gYSBmb250LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9vdGZmLmh0bVxuLy8gUmVjb21tZW5kYXRpb25zIGZvciBjcmVhdGluZyBPcGVuVHlwZSBGb250czpcbi8vIGh0dHA6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L290c3BlYzE0MC9yZWNvbS5odG1cblxuZnVuY3Rpb24gbG9nMih2KSB7XG4gICAgcmV0dXJuIE1hdGgubG9nKHYpIC8gTWF0aC5sb2coMikgfCAwO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQ2hlY2tTdW0oYnl0ZXMpIHtcbiAgICB3aGlsZSAoYnl0ZXMubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgICAgICBieXRlcy5wdXNoKDApO1xuICAgIH1cblxuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgc3VtICs9IChieXRlc1tpXSA8PCAyNCkgK1xuICAgICAgICAgICAgKGJ5dGVzW2kgKyAxXSA8PCAxNikgK1xuICAgICAgICAgICAgKGJ5dGVzW2kgKyAyXSA8PCA4KSArXG4gICAgICAgICAgICAoYnl0ZXNbaSArIDNdKTtcbiAgICB9XG5cbiAgICBzdW0gJT0gTWF0aC5wb3coMiwgMzIpO1xuICAgIHJldHVybiBzdW07XG59XG5cbmZ1bmN0aW9uIG1ha2VUYWJsZVJlY29yZCh0YWcsIGNoZWNrU3VtLCBvZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgdGFibGUuUmVjb3JkKCdUYWJsZSBSZWNvcmQnLCBbXG4gICAgICAgIHtuYW1lOiAndGFnJywgdHlwZTogJ1RBRycsIHZhbHVlOiB0YWcgIT09IHVuZGVmaW5lZCA/IHRhZyA6ICcnfSxcbiAgICAgICAge25hbWU6ICdjaGVja1N1bScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBjaGVja1N1bSAhPT0gdW5kZWZpbmVkID8gY2hlY2tTdW0gOiAwfSxcbiAgICAgICAge25hbWU6ICdvZmZzZXQnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogb2Zmc2V0ICE9PSB1bmRlZmluZWQgPyBvZmZzZXQgOiAwfSxcbiAgICAgICAge25hbWU6ICdsZW5ndGgnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogbGVuZ3RoICE9PSB1bmRlZmluZWQgPyBsZW5ndGggOiAwfVxuICAgIF0pO1xufVxuXG5mdW5jdGlvbiBtYWtlU2ZudFRhYmxlKHRhYmxlcykge1xuICAgIHZhciBzZm50ID0gbmV3IHRhYmxlLlRhYmxlKCdzZm50JywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVEFHJywgdmFsdWU6ICdPVFRPJ30sXG4gICAgICAgIHtuYW1lOiAnbnVtVGFibGVzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzZWFyY2hSYW5nZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZW50cnlTZWxlY3RvcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmFuZ2VTaGlmdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdKTtcbiAgICBzZm50LnRhYmxlcyA9IHRhYmxlcztcbiAgICBzZm50Lm51bVRhYmxlcyA9IHRhYmxlcy5sZW5ndGg7XG4gICAgdmFyIGhpZ2hlc3RQb3dlck9mMiA9IE1hdGgucG93KDIsIGxvZzIoc2ZudC5udW1UYWJsZXMpKTtcbiAgICBzZm50LnNlYXJjaFJhbmdlID0gMTYgKiBoaWdoZXN0UG93ZXJPZjI7XG4gICAgc2ZudC5lbnRyeVNlbGVjdG9yID0gbG9nMihoaWdoZXN0UG93ZXJPZjIpO1xuICAgIHNmbnQucmFuZ2VTaGlmdCA9IHNmbnQubnVtVGFibGVzICogMTYgLSBzZm50LnNlYXJjaFJhbmdlO1xuXG4gICAgdmFyIHJlY29yZEZpZWxkcyA9IFtdO1xuICAgIHZhciB0YWJsZUZpZWxkcyA9IFtdO1xuXG4gICAgdmFyIG9mZnNldCA9IHNmbnQuc2l6ZU9mKCkgKyAobWFrZVRhYmxlUmVjb3JkKCkuc2l6ZU9mKCkgKiBzZm50Lm51bVRhYmxlcyk7XG4gICAgd2hpbGUgKG9mZnNldCAlIDQgIT09IDApIHtcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgIHRhYmxlRmllbGRzLnB1c2goe25hbWU6ICdwYWRkaW5nJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFibGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciB0ID0gdGFibGVzW2ldO1xuICAgICAgICBjaGVjay5hcmd1bWVudCh0LnRhYmxlTmFtZS5sZW5ndGggPT09IDQsICdUYWJsZSBuYW1lJyArIHQudGFibGVOYW1lICsgJyBpcyBpbnZhbGlkLicpO1xuICAgICAgICB2YXIgdGFibGVMZW5ndGggPSB0LnNpemVPZigpO1xuICAgICAgICB2YXIgdGFibGVSZWNvcmQgPSBtYWtlVGFibGVSZWNvcmQodC50YWJsZU5hbWUsIGNvbXB1dGVDaGVja1N1bSh0LmVuY29kZSgpKSwgb2Zmc2V0LCB0YWJsZUxlbmd0aCk7XG4gICAgICAgIHJlY29yZEZpZWxkcy5wdXNoKHtuYW1lOiB0YWJsZVJlY29yZC50YWcgKyAnIFRhYmxlIFJlY29yZCcsIHR5cGU6ICdSRUNPUkQnLCB2YWx1ZTogdGFibGVSZWNvcmR9KTtcbiAgICAgICAgdGFibGVGaWVsZHMucHVzaCh7bmFtZTogdC50YWJsZU5hbWUgKyAnIHRhYmxlJywgdHlwZTogJ1JFQ09SRCcsIHZhbHVlOiB0fSk7XG4gICAgICAgIG9mZnNldCArPSB0YWJsZUxlbmd0aDtcbiAgICAgICAgY2hlY2suYXJndW1lbnQoIWlzTmFOKG9mZnNldCksICdTb21ldGhpbmcgd2VudCB3cm9uZyBjYWxjdWxhdGluZyB0aGUgb2Zmc2V0LicpO1xuICAgICAgICB3aGlsZSAob2Zmc2V0ICUgNCAhPT0gMCkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgICAgICAgICB0YWJsZUZpZWxkcy5wdXNoKHtuYW1lOiAncGFkZGluZycsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRhYmxlIHJlY29yZHMgbmVlZCB0byBiZSBzb3J0ZWQgYWxwaGFiZXRpY2FsbHkuXG4gICAgcmVjb3JkRmllbGRzLnNvcnQoZnVuY3Rpb24ocjEsIHIyKSB7XG4gICAgICAgIGlmIChyMS52YWx1ZS50YWcgPiByMi52YWx1ZS50YWcpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBzZm50LmZpZWxkcyA9IHNmbnQuZmllbGRzLmNvbmNhdChyZWNvcmRGaWVsZHMpO1xuICAgIHNmbnQuZmllbGRzID0gc2ZudC5maWVsZHMuY29uY2F0KHRhYmxlRmllbGRzKTtcbiAgICByZXR1cm4gc2ZudDtcbn1cblxuLy8gR2V0IHRoZSBtZXRyaWNzIGZvciBhIGNoYXJhY3Rlci4gSWYgdGhlIHN0cmluZyBoYXMgbW9yZSB0aGFuIG9uZSBjaGFyYWN0ZXJcbi8vIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBtZXRyaWNzIGZvciB0aGUgZmlyc3QgYXZhaWxhYmxlIGNoYXJhY3Rlci5cbi8vIFlvdSBjYW4gcHJvdmlkZSBvcHRpb25hbCBmYWxsYmFjayBtZXRyaWNzIGlmIG5vIGNoYXJhY3RlcnMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIG1ldHJpY3NGb3JDaGFyKGZvbnQsIGNoYXJzLCBub3RGb3VuZE1ldHJpY3MpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaEluZGV4ID0gZm9udC5jaGFyVG9HbHlwaEluZGV4KGNoYXJzW2ldKTtcbiAgICAgICAgaWYgKGdseXBoSW5kZXggPiAwKSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBmb250LmdseXBocy5nZXQoZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gZ2x5cGguZ2V0TWV0cmljcygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vdEZvdW5kTWV0cmljcztcbn1cblxuZnVuY3Rpb24gYXZlcmFnZSh2cykge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgc3VtICs9IHZzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBzdW0gLyB2cy5sZW5ndGg7XG59XG5cbi8vIENvbnZlcnQgdGhlIGZvbnQgb2JqZWN0IHRvIGEgU0ZOVCBkYXRhIHN0cnVjdHVyZS5cbi8vIFRoaXMgc3RydWN0dXJlIGNvbnRhaW5zIGFsbCB0aGUgbmVjZXNzYXJ5IHRhYmxlcyBhbmQgbWV0YWRhdGEgdG8gY3JlYXRlIGEgYmluYXJ5IE9URiBmaWxlLlxuZnVuY3Rpb24gZm9udFRvU2ZudFRhYmxlKGZvbnQpIHtcbiAgICB2YXIgeE1pbnMgPSBbXTtcbiAgICB2YXIgeU1pbnMgPSBbXTtcbiAgICB2YXIgeE1heHMgPSBbXTtcbiAgICB2YXIgeU1heHMgPSBbXTtcbiAgICB2YXIgYWR2YW5jZVdpZHRocyA9IFtdO1xuICAgIHZhciBsZWZ0U2lkZUJlYXJpbmdzID0gW107XG4gICAgdmFyIHJpZ2h0U2lkZUJlYXJpbmdzID0gW107XG4gICAgdmFyIGZpcnN0Q2hhckluZGV4O1xuICAgIHZhciBsYXN0Q2hhckluZGV4ID0gMDtcbiAgICB2YXIgdWxVbmljb2RlUmFuZ2UxID0gMDtcbiAgICB2YXIgdWxVbmljb2RlUmFuZ2UyID0gMDtcbiAgICB2YXIgdWxVbmljb2RlUmFuZ2UzID0gMDtcbiAgICB2YXIgdWxVbmljb2RlUmFuZ2U0ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9udC5nbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoID0gZm9udC5nbHlwaHMuZ2V0KGkpO1xuICAgICAgICB2YXIgdW5pY29kZSA9IGdseXBoLnVuaWNvZGUgfCAwO1xuXG4gICAgICAgIGlmIChpc05hTihnbHlwaC5hZHZhbmNlV2lkdGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dseXBoICcgKyBnbHlwaC5uYW1lICsgJyAoJyArIGkgKyAnKTogYWR2YW5jZVdpZHRoIGlzIG5vdCBhIG51bWJlci4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaXJzdENoYXJJbmRleCA+IHVuaWNvZGUgfHwgZmlyc3RDaGFySW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gaWdub3JlIC5ub3RkZWYgY2hhclxuICAgICAgICAgICAgaWYgKHVuaWNvZGUgPiAwKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RDaGFySW5kZXggPSB1bmljb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhc3RDaGFySW5kZXggPCB1bmljb2RlKSB7XG4gICAgICAgICAgICBsYXN0Q2hhckluZGV4ID0gdW5pY29kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IG9zMi5nZXRVbmljb2RlUmFuZ2UodW5pY29kZSk7XG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDMyKSB7XG4gICAgICAgICAgICB1bFVuaWNvZGVSYW5nZTEgfD0gMSA8PCBwb3NpdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA8IDY0KSB7XG4gICAgICAgICAgICB1bFVuaWNvZGVSYW5nZTIgfD0gMSA8PCBwb3NpdGlvbiAtIDMyO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uIDwgOTYpIHtcbiAgICAgICAgICAgIHVsVW5pY29kZVJhbmdlMyB8PSAxIDw8IHBvc2l0aW9uIC0gNjQ7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPCAxMjMpIHtcbiAgICAgICAgICAgIHVsVW5pY29kZVJhbmdlNCB8PSAxIDw8IHBvc2l0aW9uIC0gOTY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaWNvZGUgcmFuZ2VzIGJpdHMgPiAxMjMgYXJlIHJlc2VydmVkIGZvciBpbnRlcm5hbCB1c2FnZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNraXAgbm9uLWltcG9ydGFudCBjaGFyYWN0ZXJzLlxuICAgICAgICBpZiAoZ2x5cGgubmFtZSA9PT0gJy5ub3RkZWYnKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgIHZhciBtZXRyaWNzID0gZ2x5cGguZ2V0TWV0cmljcygpO1xuICAgICAgICB4TWlucy5wdXNoKG1ldHJpY3MueE1pbik7XG4gICAgICAgIHlNaW5zLnB1c2gobWV0cmljcy55TWluKTtcbiAgICAgICAgeE1heHMucHVzaChtZXRyaWNzLnhNYXgpO1xuICAgICAgICB5TWF4cy5wdXNoKG1ldHJpY3MueU1heCk7XG4gICAgICAgIGxlZnRTaWRlQmVhcmluZ3MucHVzaChtZXRyaWNzLmxlZnRTaWRlQmVhcmluZyk7XG4gICAgICAgIHJpZ2h0U2lkZUJlYXJpbmdzLnB1c2gobWV0cmljcy5yaWdodFNpZGVCZWFyaW5nKTtcbiAgICAgICAgYWR2YW5jZVdpZHRocy5wdXNoKGdseXBoLmFkdmFuY2VXaWR0aCk7XG4gICAgfVxuXG4gICAgdmFyIGdsb2JhbHMgPSB7XG4gICAgICAgIHhNaW46IE1hdGgubWluLmFwcGx5KG51bGwsIHhNaW5zKSxcbiAgICAgICAgeU1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgeU1pbnMpLFxuICAgICAgICB4TWF4OiBNYXRoLm1heC5hcHBseShudWxsLCB4TWF4cyksXG4gICAgICAgIHlNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHlNYXhzKSxcbiAgICAgICAgYWR2YW5jZVdpZHRoTWF4OiBNYXRoLm1heC5hcHBseShudWxsLCBhZHZhbmNlV2lkdGhzKSxcbiAgICAgICAgYWR2YW5jZVdpZHRoQXZnOiBhdmVyYWdlKGFkdmFuY2VXaWR0aHMpLFxuICAgICAgICBtaW5MZWZ0U2lkZUJlYXJpbmc6IE1hdGgubWluLmFwcGx5KG51bGwsIGxlZnRTaWRlQmVhcmluZ3MpLFxuICAgICAgICBtYXhMZWZ0U2lkZUJlYXJpbmc6IE1hdGgubWF4LmFwcGx5KG51bGwsIGxlZnRTaWRlQmVhcmluZ3MpLFxuICAgICAgICBtaW5SaWdodFNpZGVCZWFyaW5nOiBNYXRoLm1pbi5hcHBseShudWxsLCByaWdodFNpZGVCZWFyaW5ncylcbiAgICB9O1xuICAgIGdsb2JhbHMuYXNjZW5kZXIgPSBmb250LmFzY2VuZGVyO1xuICAgIGdsb2JhbHMuZGVzY2VuZGVyID0gZm9udC5kZXNjZW5kZXI7XG5cbiAgICB2YXIgaGVhZFRhYmxlID0gaGVhZC5tYWtlKHtcbiAgICAgICAgZmxhZ3M6IDMsIC8vIDAwMDAwMDExIChiYXNlbGluZSBmb3IgZm9udCBhdCB5PTA7IGxlZnQgc2lkZWJlYXJpbmcgcG9pbnQgYXQgeD0wKVxuICAgICAgICB1bml0c1BlckVtOiBmb250LnVuaXRzUGVyRW0sXG4gICAgICAgIHhNaW46IGdsb2JhbHMueE1pbixcbiAgICAgICAgeU1pbjogZ2xvYmFscy55TWluLFxuICAgICAgICB4TWF4OiBnbG9iYWxzLnhNYXgsXG4gICAgICAgIHlNYXg6IGdsb2JhbHMueU1heCxcbiAgICAgICAgbG93ZXN0UmVjUFBFTTogMyxcbiAgICAgICAgY3JlYXRlZFRpbWVzdGFtcDogZm9udC5jcmVhdGVkVGltZXN0YW1wXG4gICAgfSk7XG5cbiAgICB2YXIgaGhlYVRhYmxlID0gaGhlYS5tYWtlKHtcbiAgICAgICAgYXNjZW5kZXI6IGdsb2JhbHMuYXNjZW5kZXIsXG4gICAgICAgIGRlc2NlbmRlcjogZ2xvYmFscy5kZXNjZW5kZXIsXG4gICAgICAgIGFkdmFuY2VXaWR0aE1heDogZ2xvYmFscy5hZHZhbmNlV2lkdGhNYXgsXG4gICAgICAgIG1pbkxlZnRTaWRlQmVhcmluZzogZ2xvYmFscy5taW5MZWZ0U2lkZUJlYXJpbmcsXG4gICAgICAgIG1pblJpZ2h0U2lkZUJlYXJpbmc6IGdsb2JhbHMubWluUmlnaHRTaWRlQmVhcmluZyxcbiAgICAgICAgeE1heEV4dGVudDogZ2xvYmFscy5tYXhMZWZ0U2lkZUJlYXJpbmcgKyAoZ2xvYmFscy54TWF4IC0gZ2xvYmFscy54TWluKSxcbiAgICAgICAgbnVtYmVyT2ZITWV0cmljczogZm9udC5nbHlwaHMubGVuZ3RoXG4gICAgfSk7XG5cbiAgICB2YXIgbWF4cFRhYmxlID0gbWF4cC5tYWtlKGZvbnQuZ2x5cGhzLmxlbmd0aCk7XG5cbiAgICB2YXIgb3MyVGFibGUgPSBvczIubWFrZSh7XG4gICAgICAgIHhBdmdDaGFyV2lkdGg6IE1hdGgucm91bmQoZ2xvYmFscy5hZHZhbmNlV2lkdGhBdmcpLFxuICAgICAgICB1c1dlaWdodENsYXNzOiBmb250LnRhYmxlcy5vczIudXNXZWlnaHRDbGFzcyxcbiAgICAgICAgdXNXaWR0aENsYXNzOiBmb250LnRhYmxlcy5vczIudXNXaWR0aENsYXNzLFxuICAgICAgICB1c0ZpcnN0Q2hhckluZGV4OiBmaXJzdENoYXJJbmRleCxcbiAgICAgICAgdXNMYXN0Q2hhckluZGV4OiBsYXN0Q2hhckluZGV4LFxuICAgICAgICB1bFVuaWNvZGVSYW5nZTE6IHVsVW5pY29kZVJhbmdlMSxcbiAgICAgICAgdWxVbmljb2RlUmFuZ2UyOiB1bFVuaWNvZGVSYW5nZTIsXG4gICAgICAgIHVsVW5pY29kZVJhbmdlMzogdWxVbmljb2RlUmFuZ2UzLFxuICAgICAgICB1bFVuaWNvZGVSYW5nZTQ6IHVsVW5pY29kZVJhbmdlNCxcbiAgICAgICAgZnNTZWxlY3Rpb246IGZvbnQudGFibGVzLm9zMi5mc1NlbGVjdGlvbiwgLy8gUkVHVUxBUlxuICAgICAgICAvLyBTZWUgaHR0cDovL3R5cG9waGlsZS5jb20vbm9kZS8xMzA4MSBmb3IgbW9yZSBpbmZvIG9uIHZlcnRpY2FsIG1ldHJpY3MuXG4gICAgICAgIC8vIFdlIGdldCBtZXRyaWNzIGZvciB0eXBpY2FsIGNoYXJhY3RlcnMgKHN1Y2ggYXMgXCJ4XCIgZm9yIHhIZWlnaHQpLlxuICAgICAgICAvLyBXZSBwcm92aWRlIHNvbWUgZmFsbGJhY2sgY2hhcmFjdGVycyBpZiBjaGFyYWN0ZXJzIGFyZSB1bmF2YWlsYWJsZTogdGhlaXJcbiAgICAgICAgLy8gb3JkZXJpbmcgd2FzIGNob3NlbiBleHBlcmltZW50YWxseS5cbiAgICAgICAgc1R5cG9Bc2NlbmRlcjogZ2xvYmFscy5hc2NlbmRlcixcbiAgICAgICAgc1R5cG9EZXNjZW5kZXI6IGdsb2JhbHMuZGVzY2VuZGVyLFxuICAgICAgICBzVHlwb0xpbmVHYXA6IDAsXG4gICAgICAgIHVzV2luQXNjZW50OiBnbG9iYWxzLnlNYXgsXG4gICAgICAgIHVzV2luRGVzY2VudDogTWF0aC5hYnMoZ2xvYmFscy55TWluKSxcbiAgICAgICAgdWxDb2RlUGFnZVJhbmdlMTogMSwgLy8gRklYTUU6IGhhcmQtY29kZSBMYXRpbiAxIHN1cHBvcnQgZm9yIG5vd1xuICAgICAgICBzeEhlaWdodDogbWV0cmljc0ZvckNoYXIoZm9udCwgJ3h5dncnLCB7eU1heDogTWF0aC5yb3VuZChnbG9iYWxzLmFzY2VuZGVyIC8gMil9KS55TWF4LFxuICAgICAgICBzQ2FwSGVpZ2h0OiBtZXRyaWNzRm9yQ2hhcihmb250LCAnSElLTEVGSk1OVFpCRFBSQUdPUVNVVldYWScsIGdsb2JhbHMpLnlNYXgsXG4gICAgICAgIHVzRGVmYXVsdENoYXI6IGZvbnQuaGFzQ2hhcignICcpID8gMzIgOiAwLCAvLyBVc2Ugc3BhY2UgYXMgdGhlIGRlZmF1bHQgY2hhcmFjdGVyLCBpZiBhdmFpbGFibGUuXG4gICAgICAgIHVzQnJlYWtDaGFyOiBmb250Lmhhc0NoYXIoJyAnKSA/IDMyIDogMCAvLyBVc2Ugc3BhY2UgYXMgdGhlIGJyZWFrIGNoYXJhY3RlciwgaWYgYXZhaWxhYmxlLlxuICAgIH0pO1xuXG4gICAgdmFyIGhtdHhUYWJsZSA9IGhtdHgubWFrZShmb250LmdseXBocyk7XG4gICAgdmFyIGNtYXBUYWJsZSA9IGNtYXAubWFrZShmb250LmdseXBocyk7XG5cbiAgICB2YXIgZW5nbGlzaEZhbWlseU5hbWUgPSBmb250LmdldEVuZ2xpc2hOYW1lKCdmb250RmFtaWx5Jyk7XG4gICAgdmFyIGVuZ2xpc2hTdHlsZU5hbWUgPSBmb250LmdldEVuZ2xpc2hOYW1lKCdmb250U3ViZmFtaWx5Jyk7XG4gICAgdmFyIGVuZ2xpc2hGdWxsTmFtZSA9IGVuZ2xpc2hGYW1pbHlOYW1lICsgJyAnICsgZW5nbGlzaFN0eWxlTmFtZTtcbiAgICB2YXIgcG9zdFNjcmlwdE5hbWUgPSBmb250LmdldEVuZ2xpc2hOYW1lKCdwb3N0U2NyaXB0TmFtZScpO1xuICAgIGlmICghcG9zdFNjcmlwdE5hbWUpIHtcbiAgICAgICAgcG9zdFNjcmlwdE5hbWUgPSBlbmdsaXNoRmFtaWx5TmFtZS5yZXBsYWNlKC9cXHMvZywgJycpICsgJy0nICsgZW5nbGlzaFN0eWxlTmFtZTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZXMgPSB7fTtcbiAgICBmb3IgKHZhciBuIGluIGZvbnQubmFtZXMpIHtcbiAgICAgICAgbmFtZXNbbl0gPSBmb250Lm5hbWVzW25dO1xuICAgIH1cblxuICAgIGlmICghbmFtZXMudW5pcXVlSUQpIHtcbiAgICAgICAgbmFtZXMudW5pcXVlSUQgPSB7ZW46IGZvbnQuZ2V0RW5nbGlzaE5hbWUoJ21hbnVmYWN0dXJlcicpICsgJzonICsgZW5nbGlzaEZ1bGxOYW1lfTtcbiAgICB9XG5cbiAgICBpZiAoIW5hbWVzLnBvc3RTY3JpcHROYW1lKSB7XG4gICAgICAgIG5hbWVzLnBvc3RTY3JpcHROYW1lID0ge2VuOiBwb3N0U2NyaXB0TmFtZX07XG4gICAgfVxuXG4gICAgaWYgKCFuYW1lcy5wcmVmZXJyZWRGYW1pbHkpIHtcbiAgICAgICAgbmFtZXMucHJlZmVycmVkRmFtaWx5ID0gZm9udC5uYW1lcy5mb250RmFtaWx5O1xuICAgIH1cblxuICAgIGlmICghbmFtZXMucHJlZmVycmVkU3ViZmFtaWx5KSB7XG4gICAgICAgIG5hbWVzLnByZWZlcnJlZFN1YmZhbWlseSA9IGZvbnQubmFtZXMuZm9udFN1YmZhbWlseTtcbiAgICB9XG5cbiAgICB2YXIgbGFuZ3VhZ2VUYWdzID0gW107XG4gICAgdmFyIG5hbWVUYWJsZSA9IF9uYW1lLm1ha2UobmFtZXMsIGxhbmd1YWdlVGFncyk7XG4gICAgdmFyIGx0YWdUYWJsZSA9IChsYW5ndWFnZVRhZ3MubGVuZ3RoID4gMCA/IGx0YWcubWFrZShsYW5ndWFnZVRhZ3MpIDogdW5kZWZpbmVkKTtcblxuICAgIHZhciBwb3N0VGFibGUgPSBwb3N0Lm1ha2UoKTtcbiAgICB2YXIgY2ZmVGFibGUgPSBjZmYubWFrZShmb250LmdseXBocywge1xuICAgICAgICB2ZXJzaW9uOiBmb250LmdldEVuZ2xpc2hOYW1lKCd2ZXJzaW9uJyksXG4gICAgICAgIGZ1bGxOYW1lOiBlbmdsaXNoRnVsbE5hbWUsXG4gICAgICAgIGZhbWlseU5hbWU6IGVuZ2xpc2hGYW1pbHlOYW1lLFxuICAgICAgICB3ZWlnaHROYW1lOiBlbmdsaXNoU3R5bGVOYW1lLFxuICAgICAgICBwb3N0U2NyaXB0TmFtZTogcG9zdFNjcmlwdE5hbWUsXG4gICAgICAgIHVuaXRzUGVyRW06IGZvbnQudW5pdHNQZXJFbSxcbiAgICAgICAgZm9udEJCb3g6IFswLCBnbG9iYWxzLnlNaW4sIGdsb2JhbHMuYXNjZW5kZXIsIGdsb2JhbHMuYWR2YW5jZVdpZHRoTWF4XVxuICAgIH0pO1xuXG4gICAgdmFyIG1ldGFUYWJsZSA9IChmb250Lm1ldGFzICYmIE9iamVjdC5rZXlzKGZvbnQubWV0YXMpLmxlbmd0aCA+IDApID8gbWV0YS5tYWtlKGZvbnQubWV0YXMpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gVGhlIG9yZGVyIGRvZXMgbm90IG1hdHRlciBiZWNhdXNlIG1ha2VTZm50VGFibGUoKSB3aWxsIHNvcnQgdGhlbS5cbiAgICB2YXIgdGFibGVzID0gW2hlYWRUYWJsZSwgaGhlYVRhYmxlLCBtYXhwVGFibGUsIG9zMlRhYmxlLCBuYW1lVGFibGUsIGNtYXBUYWJsZSwgcG9zdFRhYmxlLCBjZmZUYWJsZSwgaG10eFRhYmxlXTtcbiAgICBpZiAobHRhZ1RhYmxlKSB7XG4gICAgICAgIHRhYmxlcy5wdXNoKGx0YWdUYWJsZSk7XG4gICAgfVxuICAgIC8vIE9wdGlvbmFsIHRhYmxlc1xuICAgIGlmIChmb250LnRhYmxlcy5nc3ViKSB7XG4gICAgICAgIHRhYmxlcy5wdXNoKGdzdWIubWFrZShmb250LnRhYmxlcy5nc3ViKSk7XG4gICAgfVxuICAgIGlmIChtZXRhVGFibGUpIHtcbiAgICAgICAgdGFibGVzLnB1c2gobWV0YVRhYmxlKTtcbiAgICB9XG5cbiAgICB2YXIgc2ZudFRhYmxlID0gbWFrZVNmbnRUYWJsZSh0YWJsZXMpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgZm9udCdzIGNoZWNrU3VtIGFuZCBzdG9yZSBpdCBpbiBoZWFkLmNoZWNrU3VtQWRqdXN0bWVudC5cbiAgICB2YXIgYnl0ZXMgPSBzZm50VGFibGUuZW5jb2RlKCk7XG4gICAgdmFyIGNoZWNrU3VtID0gY29tcHV0ZUNoZWNrU3VtKGJ5dGVzKTtcbiAgICB2YXIgdGFibGVGaWVsZHMgPSBzZm50VGFibGUuZmllbGRzO1xuICAgIHZhciBjaGVja1N1bUFkanVzdGVkID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGFibGVGaWVsZHMubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICBpZiAodGFibGVGaWVsZHNbaSQxXS5uYW1lID09PSAnaGVhZCB0YWJsZScpIHtcbiAgICAgICAgICAgIHRhYmxlRmllbGRzW2kkMV0udmFsdWUuY2hlY2tTdW1BZGp1c3RtZW50ID0gMHhCMUIwQUZCQSAtIGNoZWNrU3VtO1xuICAgICAgICAgICAgY2hlY2tTdW1BZGp1c3RlZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2hlY2tTdW1BZGp1c3RlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIGhlYWQgdGFibGUgd2l0aCBjaGVja1N1bSB0byBhZGp1c3QuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNmbnRUYWJsZTtcbn1cblxudmFyIHNmbnQgPSB7IG1ha2U6IG1ha2VTZm50VGFibGUsIGZvbnRUb1RhYmxlOiBmb250VG9TZm50VGFibGUsIGNvbXB1dGVDaGVja1N1bTogY29tcHV0ZUNoZWNrU3VtIH07XG5cbi8vIFRoZSBMYXlvdXQgb2JqZWN0IGlzIHRoZSBwcm90b3R5cGUgb2YgU3Vic3RpdHV0aW9uIG9iamVjdHMsIGFuZCBwcm92aWRlc1xuLy8gdXRpbGl0eSBtZXRob2RzIHRvIG1hbmlwdWxhdGUgY29tbW9uIGxheW91dCB0YWJsZXMgKEdQT1MsIEdTVUIsIEdERUYuLi4pXG5cbmZ1bmN0aW9uIHNlYXJjaFRhZyhhcnIsIHRhZykge1xuICAgIC8qIGpzaGludCBiaXR3aXNlOiBmYWxzZSAqL1xuICAgIHZhciBpbWluID0gMDtcbiAgICB2YXIgaW1heCA9IGFyci5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChpbWluIDw9IGltYXgpIHtcbiAgICAgICAgdmFyIGltaWQgPSAoaW1pbiArIGltYXgpID4+PiAxO1xuICAgICAgICB2YXIgdmFsID0gYXJyW2ltaWRdLnRhZztcbiAgICAgICAgaWYgKHZhbCA9PT0gdGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1pZDtcbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPCB0YWcpIHtcbiAgICAgICAgICAgIGltaW4gPSBpbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHsgaW1heCA9IGltaWQgLSAxOyB9XG4gICAgfVxuICAgIC8vIE5vdCBmb3VuZDogcmV0dXJuIC0xLWluc2VydGlvbiBwb2ludFxuICAgIHJldHVybiAtaW1pbiAtIDE7XG59XG5cbmZ1bmN0aW9uIGJpblNlYXJjaChhcnIsIHZhbHVlKSB7XG4gICAgLyoganNoaW50IGJpdHdpc2U6IGZhbHNlICovXG4gICAgdmFyIGltaW4gPSAwO1xuICAgIHZhciBpbWF4ID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGltaW4gPD0gaW1heCkge1xuICAgICAgICB2YXIgaW1pZCA9IChpbWluICsgaW1heCkgPj4+IDE7XG4gICAgICAgIHZhciB2YWwgPSBhcnJbaW1pZF07XG4gICAgICAgIGlmICh2YWwgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW1pZDtcbiAgICAgICAgfSBlbHNlIGlmICh2YWwgPCB2YWx1ZSkge1xuICAgICAgICAgICAgaW1pbiA9IGltaWQgKyAxO1xuICAgICAgICB9IGVsc2UgeyBpbWF4ID0gaW1pZCAtIDE7IH1cbiAgICB9XG4gICAgLy8gTm90IGZvdW5kOiByZXR1cm4gLTEtaW5zZXJ0aW9uIHBvaW50XG4gICAgcmV0dXJuIC1pbWluIC0gMTtcbn1cblxuLy8gYmluYXJ5IHNlYXJjaCBpbiBhIGxpc3Qgb2YgcmFuZ2VzIChjb3ZlcmFnZSwgY2xhc3MgZGVmaW5pdGlvbilcbmZ1bmN0aW9uIHNlYXJjaFJhbmdlKHJhbmdlcywgdmFsdWUpIHtcbiAgICAvLyBqc2hpbnQgYml0d2lzZTogZmFsc2VcbiAgICB2YXIgcmFuZ2U7XG4gICAgdmFyIGltaW4gPSAwO1xuICAgIHZhciBpbWF4ID0gcmFuZ2VzLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGltaW4gPD0gaW1heCkge1xuICAgICAgICB2YXIgaW1pZCA9IChpbWluICsgaW1heCkgPj4+IDE7XG4gICAgICAgIHJhbmdlID0gcmFuZ2VzW2ltaWRdO1xuICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0IDwgdmFsdWUpIHtcbiAgICAgICAgICAgIGltaW4gPSBpbWlkICsgMTtcbiAgICAgICAgfSBlbHNlIHsgaW1heCA9IGltaWQgLSAxOyB9XG4gICAgfVxuICAgIGlmIChpbWluID4gMCkge1xuICAgICAgICByYW5nZSA9IHJhbmdlc1tpbWluIC0gMV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJhbmdlLmVuZCkgeyByZXR1cm4gMDsgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxufVxuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkxheW91dFxuICogQGNsYXNzXG4gKi9cbmZ1bmN0aW9uIExheW91dChmb250LCB0YWJsZU5hbWUpIHtcbiAgICB0aGlzLmZvbnQgPSBmb250O1xuICAgIHRoaXMudGFibGVOYW1lID0gdGFibGVOYW1lO1xufVxuXG5MYXlvdXQucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogQmluYXJ5IHNlYXJjaCBhbiBvYmplY3QgYnkgXCJ0YWdcIiBwcm9wZXJ0eVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBmdW5jdGlvbiBzZWFyY2hUYWdcbiAgICAgKiBAbWVtYmVyb2Ygb3BlbnR5cGUuTGF5b3V0XG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdGFnXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNlYXJjaFRhZzogc2VhcmNoVGFnLFxuXG4gICAgLyoqXG4gICAgICogQmluYXJ5IHNlYXJjaCBpbiBhIGxpc3Qgb2YgbnVtYmVyc1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBmdW5jdGlvbiBiaW5TZWFyY2hcbiAgICAgKiBAbWVtYmVyb2Ygb3BlbnR5cGUuTGF5b3V0XG4gICAgICogQHBhcmFtICB7QXJyYXl9IGFyclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgYmluU2VhcmNoOiBiaW5TZWFyY2gsXG5cbiAgICAvKipcbiAgICAgKiBHZXQgb3IgY3JlYXRlIHRoZSBMYXlvdXQgdGFibGUgKEdTVUIsIEdQT1MgZXRjKS5cbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjcmVhdGUgLSBXaGV0aGVyIHRvIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgR1NVQiBvciBHUE9TIHRhYmxlLlxuICAgICAqL1xuICAgIGdldFRhYmxlOiBmdW5jdGlvbihjcmVhdGUpIHtcbiAgICAgICAgdmFyIGxheW91dCA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdO1xuICAgICAgICBpZiAoIWxheW91dCAmJiBjcmVhdGUpIHtcbiAgICAgICAgICAgIGxheW91dCA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdID0gdGhpcy5jcmVhdGVEZWZhdWx0VGFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGF5b3V0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBzY3JpcHRzIGluIHRoZSBzdWJzdGl0dXRpb24gdGFibGUuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0U2NyaXB0TmFtZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXRUYWJsZSgpO1xuICAgICAgICBpZiAoIWxheW91dCkgeyByZXR1cm4gW107IH1cbiAgICAgICAgcmV0dXJuIGxheW91dC5zY3JpcHRzLm1hcChmdW5jdGlvbihzY3JpcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHQudGFnO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYmVzdCBiZXQgZm9yIGEgc2NyaXB0IG5hbWUuXG4gICAgICogUmV0dXJucyAnREZMVCcgaWYgaXQgZXhpc3RzLlxuICAgICAqIElmIG5vdCwgcmV0dXJucyAnbGF0bicgaWYgaXQgZXhpc3RzLlxuICAgICAqIElmIG5laXRoZXIgZXhpc3QsIHJldHVybnMgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIGdldERlZmF1bHRTY3JpcHROYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxheW91dCA9IHRoaXMuZ2V0VGFibGUoKTtcbiAgICAgICAgaWYgKCFsYXlvdXQpIHsgcmV0dXJuOyB9XG4gICAgICAgIHZhciBoYXNMYXRuID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0LnNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbGF5b3V0LnNjcmlwdHNbaV0udGFnO1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdERkxUJykgeyByZXR1cm4gbmFtZTsgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdsYXRuJykgeyBoYXNMYXRuID0gdHJ1ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNMYXRuKSB7IHJldHVybiAnbGF0bic7IH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgTGFuZ1N5c1JlY29yZHMgaW4gdGhlIGdpdmVuIHNjcmlwdC5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjcmVhdGUgLSBmb3JjZXMgdGhlIGNyZWF0aW9uIG9mIHRoaXMgc2NyaXB0IHRhYmxlIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0YWcgYW5kIHNjcmlwdCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGdldFNjcmlwdFRhYmxlOiBmdW5jdGlvbihzY3JpcHQsIGNyZWF0ZSkge1xuICAgICAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXRUYWJsZShjcmVhdGUpO1xuICAgICAgICBpZiAobGF5b3V0KSB7XG4gICAgICAgICAgICBzY3JpcHQgPSBzY3JpcHQgfHwgJ0RGTFQnO1xuICAgICAgICAgICAgdmFyIHNjcmlwdHMgPSBsYXlvdXQuc2NyaXB0cztcbiAgICAgICAgICAgIHZhciBwb3MgPSBzZWFyY2hUYWcobGF5b3V0LnNjcmlwdHMsIHNjcmlwdCk7XG4gICAgICAgICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0c1twb3NdLnNjcmlwdDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjciA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiBzY3JpcHQsXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdExhbmdTeXM6IHtyZXNlcnZlZDogMCwgcmVxRmVhdHVyZUluZGV4OiAweGZmZmYsIGZlYXR1cmVJbmRleGVzOiBbXX0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5nU3lzUmVjb3JkczogW11cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2NyaXB0cy5zcGxpY2UoLTEgLSBwb3MsIDAsIHNjcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNjci5zY3JpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxhbmd1YWdlIHN5c3RlbSB0YWJsZVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkbGZ0J11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhpcyBsYW5nU3lzVGFibGUgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0TGFuZ1N5c1RhYmxlOiBmdW5jdGlvbihzY3JpcHQsIGxhbmd1YWdlLCBjcmVhdGUpIHtcbiAgICAgICAgdmFyIHNjcmlwdFRhYmxlID0gdGhpcy5nZXRTY3JpcHRUYWJsZShzY3JpcHQsIGNyZWF0ZSk7XG4gICAgICAgIGlmIChzY3JpcHRUYWJsZSkge1xuICAgICAgICAgICAgaWYgKCFsYW5ndWFnZSB8fCBsYW5ndWFnZSA9PT0gJ2RmbHQnIHx8IGxhbmd1YWdlID09PSAnREZMVCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0VGFibGUuZGVmYXVsdExhbmdTeXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcG9zID0gc2VhcmNoVGFnKHNjcmlwdFRhYmxlLmxhbmdTeXNSZWNvcmRzLCBsYW5ndWFnZSk7XG4gICAgICAgICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NyaXB0VGFibGUubGFuZ1N5c1JlY29yZHNbcG9zXS5sYW5nU3lzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZ1N5c1JlY29yZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiBsYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgICAgbGFuZ1N5czoge3Jlc2VydmVkOiAwLCByZXFGZWF0dXJlSW5kZXg6IDB4ZmZmZiwgZmVhdHVyZUluZGV4ZXM6IFtdfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc2NyaXB0VGFibGUubGFuZ1N5c1JlY29yZHMuc3BsaWNlKC0xIC0gcG9zLCAwLCBsYW5nU3lzUmVjb3JkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZ1N5c1JlY29yZC5sYW5nU3lzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHNwZWNpZmljIGZlYXR1cmUgdGFibGUuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RsZnQnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gT25lIG9mIHRoZSBjb2RlcyBsaXN0ZWQgYXQgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9mZWF0dXJlbGlzdC5odG1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhlIGZlYXR1cmUgdGFibGUgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgZ2V0RmVhdHVyZVRhYmxlOiBmdW5jdGlvbihzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCBjcmVhdGUpIHtcbiAgICAgICAgdmFyIGxhbmdTeXNUYWJsZSA9IHRoaXMuZ2V0TGFuZ1N5c1RhYmxlKHNjcmlwdCwgbGFuZ3VhZ2UsIGNyZWF0ZSk7XG4gICAgICAgIGlmIChsYW5nU3lzVGFibGUpIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlUmVjb3JkO1xuICAgICAgICAgICAgdmFyIGZlYXRJbmRleGVzID0gbGFuZ1N5c1RhYmxlLmZlYXR1cmVJbmRleGVzO1xuICAgICAgICAgICAgdmFyIGFsbEZlYXR1cmVzID0gdGhpcy5mb250LnRhYmxlc1t0aGlzLnRhYmxlTmFtZV0uZmVhdHVyZXM7XG4gICAgICAgICAgICAvLyBUaGUgRmVhdHVyZUluZGV4IGFycmF5IG9mIGluZGljZXMgaXMgaW4gYXJiaXRyYXJ5IG9yZGVyLFxuICAgICAgICAgICAgLy8gZXZlbiBpZiBhbGxGZWF0dXJlcyBpcyBzb3J0ZWQgYWxwaGFiZXRpY2FsbHkgYnkgZmVhdHVyZSB0YWcuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXRJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZVJlY29yZCA9IGFsbEZlYXR1cmVzW2ZlYXRJbmRleGVzW2ldXTtcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZVJlY29yZC50YWcgPT09IGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZlYXR1cmVSZWNvcmQuZmVhdHVyZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYWxsRmVhdHVyZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8vIEF1dG9tYXRpYyBvcmRlcmluZyBvZiBmZWF0dXJlcyB3b3VsZCByZXF1aXJlIHRvIHNoaWZ0IGZlYXR1cmUgaW5kZXhlcyBpbiB0aGUgc2NyaXB0IGxpc3QuXG4gICAgICAgICAgICAgICAgY2hlY2suYXNzZXJ0KGluZGV4ID09PSAwIHx8IGZlYXR1cmUgPj0gYWxsRmVhdHVyZXNbaW5kZXggLSAxXS50YWcsICdGZWF0dXJlcyBtdXN0IGJlIGFkZGVkIGluIGFscGhhYmV0aWNhbCBvcmRlci4nKTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlUmVjb3JkID0ge1xuICAgICAgICAgICAgICAgICAgICB0YWc6IGZlYXR1cmUsXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmU6IHsgcGFyYW1zOiAwLCBsb29rdXBMaXN0SW5kZXhlczogW10gfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYWxsRmVhdHVyZXMucHVzaChmZWF0dXJlUmVjb3JkKTtcbiAgICAgICAgICAgICAgICBmZWF0SW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZVJlY29yZC5mZWF0dXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbG9va3VwIHRhYmxlcyBvZiBhIGdpdmVuIHR5cGUgZm9yIGEgc2NyaXB0L2xhbmd1YWdlL2ZlYXR1cmUuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RsZnQnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBjb2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvb2t1cFR5cGUgLSAxIHRvIDlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhlIGxvb2t1cCB0YWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LCB3aXRoIG5vIHN1YnRhYmxlcy5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAgICAgKi9cbiAgICBnZXRMb29rdXBUYWJsZXM6IGZ1bmN0aW9uKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIGxvb2t1cFR5cGUsIGNyZWF0ZSkge1xuICAgICAgICB2YXIgZmVhdHVyZVRhYmxlID0gdGhpcy5nZXRGZWF0dXJlVGFibGUoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgY3JlYXRlKTtcbiAgICAgICAgdmFyIHRhYmxlcyA9IFtdO1xuICAgICAgICBpZiAoZmVhdHVyZVRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgbG9va3VwVGFibGU7XG4gICAgICAgICAgICB2YXIgbG9va3VwTGlzdEluZGV4ZXMgPSBmZWF0dXJlVGFibGUubG9va3VwTGlzdEluZGV4ZXM7XG4gICAgICAgICAgICB2YXIgYWxsTG9va3VwcyA9IHRoaXMuZm9udC50YWJsZXNbdGhpcy50YWJsZU5hbWVdLmxvb2t1cHM7XG4gICAgICAgICAgICAvLyBsb29rdXBMaXN0SW5kZXhlcyBhcmUgaW4gbm8gcGFydGljdWxhciBvcmRlciwgc28gdXNlIG5haXZlIHNlYXJjaC5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9va3VwTGlzdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsb29rdXBUYWJsZSA9IGFsbExvb2t1cHNbbG9va3VwTGlzdEluZGV4ZXNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChsb29rdXBUYWJsZS5sb29rdXBUeXBlID09PSBsb29rdXBUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlcy5wdXNoKGxvb2t1cFRhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFibGVzLmxlbmd0aCA9PT0gMCAmJiBjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICBsb29rdXBUYWJsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwVHlwZTogbG9va3VwVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwRmxhZzogMCxcbiAgICAgICAgICAgICAgICAgICAgc3VidGFibGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgbWFya0ZpbHRlcmluZ1NldDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhbGxMb29rdXBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBhbGxMb29rdXBzLnB1c2gobG9va3VwVGFibGUpO1xuICAgICAgICAgICAgICAgIGxvb2t1cExpc3RJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbbG9va3VwVGFibGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWJsZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZpbmQgYSBnbHlwaCBpbiBhIGNsYXNzIGRlZmluaXRpb24gdGFibGVcbiAgICAgKiBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvY2hhcHRlcjIjY2xhc3MtZGVmaW5pdGlvbi10YWJsZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjbGFzc0RlZlRhYmxlIC0gYW4gT3BlblR5cGUgTGF5b3V0IGNsYXNzIGRlZmluaXRpb24gdGFibGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZ2x5cGhJbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgZ2x5cGggdG8gZmluZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0xIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICAgIGdldEdseXBoQ2xhc3M6IGZ1bmN0aW9uKGNsYXNzRGVmVGFibGUsIGdseXBoSW5kZXgpIHtcbiAgICAgICAgc3dpdGNoIChjbGFzc0RlZlRhYmxlLmZvcm1hdCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGlmIChjbGFzc0RlZlRhYmxlLnN0YXJ0R2x5cGggPD0gZ2x5cGhJbmRleCAmJiBnbHlwaEluZGV4IDwgY2xhc3NEZWZUYWJsZS5zdGFydEdseXBoICsgY2xhc3NEZWZUYWJsZS5jbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NEZWZUYWJsZS5jbGFzc2VzW2dseXBoSW5kZXggLSBjbGFzc0RlZlRhYmxlLnN0YXJ0R2x5cGhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWFyY2hSYW5nZShjbGFzc0RlZlRhYmxlLnJhbmdlcywgZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlID8gcmFuZ2UuY2xhc3NJZCA6IDA7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBhIGdseXBoIGluIGEgY292ZXJhZ2UgdGFibGVcbiAgICAgKiBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvY2hhcHRlcjIjY292ZXJhZ2UtdGFibGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY292ZXJhZ2VUYWJsZSAtIGFuIE9wZW5UeXBlIExheW91dCBjb3ZlcmFnZSB0YWJsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnbHlwaEluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBnbHlwaCB0byBmaW5kXG4gICAgICogQHJldHVybnMge251bWJlcn0gLTEgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgZ2V0Q292ZXJhZ2VJbmRleDogZnVuY3Rpb24oY292ZXJhZ2VUYWJsZSwgZ2x5cGhJbmRleCkge1xuICAgICAgICBzd2l0Y2ggKGNvdmVyYWdlVGFibGUuZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYmluU2VhcmNoKGNvdmVyYWdlVGFibGUuZ2x5cGhzLCBnbHlwaEluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPj0gMCA/IGluZGV4IDogLTE7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VhcmNoUmFuZ2UoY292ZXJhZ2VUYWJsZS5yYW5nZXMsIGdseXBoSW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZSA/IHJhbmdlLmluZGV4ICsgZ2x5cGhJbmRleCAtIHJhbmdlLnN0YXJ0IDogLTE7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBnbHlwaCBpbmRleGVzIG9mIGEgY292ZXJhZ2UgdGFibGUuXG4gICAgICogRm9ybWF0IDE6IHRoZSBsaXN0IGlzIHN0b3JlZCByYXdcbiAgICAgKiBGb3JtYXQgMjogY29tcGFjdCBsaXN0IGFzIHJhbmdlIHJlY29yZHMuXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBjb3ZlcmFnZVRhYmxlXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICovXG4gICAgZXhwYW5kQ292ZXJhZ2U6IGZ1bmN0aW9uKGNvdmVyYWdlVGFibGUpIHtcbiAgICAgICAgaWYgKGNvdmVyYWdlVGFibGUuZm9ybWF0ID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gY292ZXJhZ2VUYWJsZS5nbHlwaHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZ2x5cGhzID0gW107XG4gICAgICAgICAgICB2YXIgcmFuZ2VzID0gY292ZXJhZ2VUYWJsZS5yYW5nZXM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSByYW5nZS5zdGFydDtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gcmFuZ2UuZW5kO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBzdGFydDsgaiA8PSBlbmQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBnbHlwaHMucHVzaChqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2x5cGhzO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG4vLyBUaGUgUG9zaXRpb24gb2JqZWN0IHByb3ZpZGVzIHV0aWxpdHkgbWV0aG9kcyB0byBtYW5pcHVsYXRlXG4vLyB0aGUgR1BPUyBwb3NpdGlvbiB0YWJsZS5cblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5Qb3NpdGlvblxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBvcGVudHlwZS5MYXlvdXRcbiAqIEBwYXJhbSB7b3BlbnR5cGUuRm9udH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQb3NpdGlvbihmb250KSB7XG4gICAgTGF5b3V0LmNhbGwodGhpcywgZm9udCwgJ2dwb3MnKTtcbn1cblxuUG9zaXRpb24ucHJvdG90eXBlID0gTGF5b3V0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBGaW5kIGEgZ2x5cGggcGFpciBpbiBhIGxpc3Qgb2YgbG9va3VwIHRhYmxlcyBvZiB0eXBlIDIgYW5kIHJldHJpZXZlIHRoZSB4QWR2YW5jZSBrZXJuaW5nIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7aW50ZWdlcn0gbGVmdEluZGV4IC0gbGVmdCBnbHlwaCBpbmRleFxuICogQHBhcmFtIHtpbnRlZ2VyfSByaWdodEluZGV4IC0gcmlnaHQgZ2x5cGggaW5kZXhcbiAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICovXG5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0S2VybmluZ1ZhbHVlID0gZnVuY3Rpb24oa2VybmluZ0xvb2t1cHMsIGxlZnRJbmRleCwgcmlnaHRJbmRleCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXJuaW5nTG9va3Vwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3VidGFibGVzID0ga2VybmluZ0xvb2t1cHNbaV0uc3VidGFibGVzO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1YnRhYmxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2pdO1xuICAgICAgICAgICAgdmFyIGNvdkluZGV4ID0gdGhpcyQxLmdldENvdmVyYWdlSW5kZXgoc3VidGFibGUuY292ZXJhZ2UsIGxlZnRJbmRleCk7XG4gICAgICAgICAgICBpZiAoY292SW5kZXggPCAwKSB7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICBzd2l0Y2ggKHN1YnRhYmxlLnBvc0Zvcm1hdCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIFBhaXIgQWRqdXN0bWVudCBQb3NpdGlvbmluZyBGb3JtYXQgMVxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFpclNldCA9IHN1YnRhYmxlLnBhaXJTZXRzW2NvdkluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBwYWlyU2V0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJTZXRba107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFpci5zZWNvbmRHbHlwaCA9PT0gcmlnaHRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWlyLnZhbHVlMSAmJiBwYWlyLnZhbHVlMS54QWR2YW5jZSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAgICAgIC8vIGxlZnQgZ2x5cGggZm91bmQsIG5vdCByaWdodCBnbHlwaCAtIHRyeSBuZXh0IHN1YnRhYmxlXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAvLyBTZWFyY2ggUGFpciBBZGp1c3RtZW50IFBvc2l0aW9uaW5nIEZvcm1hdCAyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzczEgPSB0aGlzJDEuZ2V0R2x5cGhDbGFzcyhzdWJ0YWJsZS5jbGFzc0RlZjEsIGxlZnRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzczIgPSB0aGlzJDEuZ2V0R2x5cGhDbGFzcyhzdWJ0YWJsZS5jbGFzc0RlZjIsIHJpZ2h0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFpciQxID0gc3VidGFibGUuY2xhc3NSZWNvcmRzW2NsYXNzMV1bY2xhc3MyXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIkMS52YWx1ZTEgJiYgcGFpciQxLnZhbHVlMS54QWR2YW5jZSB8fCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBrZXJuaW5nIGxvb2t1cCB0YWJsZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXSAtIHVzZSBmb250LnBvc2l0aW9uLmdldERlZmF1bHRTY3JpcHROYW1lKCkgZm9yIGEgYmV0dGVyIGRlZmF1bHQgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICogQHJldHVybiB7b2JqZWN0W119IFRoZSBsaXN0IG9mIGtlcm5pbmcgbG9va3VwIHRhYmxlcyAobWF5IGJlIGVtcHR5KSwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIEdQT1MgdGFibGUgKGFuZCB3ZSBzaG91bGQgdXNlIHRoZSBrZXJuIHRhYmxlKVxuICovXG5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0S2VybmluZ1RhYmxlcyA9IGZ1bmN0aW9uKHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICBpZiAodGhpcy5mb250LnRhYmxlcy5ncG9zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCAna2VybicsIDIpO1xuICAgIH1cbn07XG5cbi8vIFRoZSBTdWJzdGl0dXRpb24gb2JqZWN0IHByb3ZpZGVzIHV0aWxpdHkgbWV0aG9kcyB0byBtYW5pcHVsYXRlXG4vLyB0aGUgR1NVQiBzdWJzdGl0dXRpb24gdGFibGUuXG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuU3Vic3RpdHV0aW9uXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIG9wZW50eXBlLkxheW91dFxuICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFN1YnN0aXR1dGlvbihmb250KSB7XG4gICAgTGF5b3V0LmNhbGwodGhpcywgZm9udCwgJ2dzdWInKTtcbn1cblxuLy8gQ2hlY2sgaWYgMiBhcnJheXMgb2YgcHJpbWl0aXZlcyBhcmUgZXF1YWwuXG5mdW5jdGlvbiBhcnJheXNFcXVhbChhcjEsIGFyMikge1xuICAgIHZhciBuID0gYXIxLmxlbmd0aDtcbiAgICBpZiAobiAhPT0gYXIyLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBpZiAoYXIxW2ldICE9PSBhcjJbaV0pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vLyBGaW5kIHRoZSBmaXJzdCBzdWJ0YWJsZSBvZiBhIGxvb2t1cCB0YWJsZSBpbiBhIHBhcnRpY3VsYXIgZm9ybWF0LlxuZnVuY3Rpb24gZ2V0U3Vic3RGb3JtYXQobG9va3VwVGFibGUsIGZvcm1hdCwgZGVmYXVsdFN1YnRhYmxlKSB7XG4gICAgdmFyIHN1YnRhYmxlcyA9IGxvb2t1cFRhYmxlLnN1YnRhYmxlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG4gICAgICAgIGlmIChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gZm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gc3VidGFibGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRTdWJ0YWJsZSkge1xuICAgICAgICBzdWJ0YWJsZXMucHVzaChkZWZhdWx0U3VidGFibGUpO1xuICAgICAgICByZXR1cm4gZGVmYXVsdFN1YnRhYmxlO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlID0gTGF5b3V0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDcmVhdGUgYSBkZWZhdWx0IEdTVUIgdGFibGUuXG4gKiBAcmV0dXJuIHtPYmplY3R9IGdzdWIgLSBUaGUgR1NVQiB0YWJsZS5cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5jcmVhdGVEZWZhdWx0VGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBHZW5lcmF0ZSBhIGRlZmF1bHQgZW1wdHkgR1NVQiB0YWJsZSB3aXRoIGp1c3QgYSBERkxUIHNjcmlwdCBhbmQgZGZsdCBsYW5nIHN5cy5cbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICBzY3JpcHRzOiBbe1xuICAgICAgICAgICAgdGFnOiAnREZMVCcsXG4gICAgICAgICAgICBzY3JpcHQ6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0TGFuZ1N5czogeyByZXNlcnZlZDogMCwgcmVxRmVhdHVyZUluZGV4OiAweGZmZmYsIGZlYXR1cmVJbmRleGVzOiBbXSB9LFxuICAgICAgICAgICAgICAgIGxhbmdTeXNSZWNvcmRzOiBbXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgZmVhdHVyZXM6IFtdLFxuICAgICAgICBsb29rdXBzOiBbXVxuICAgIH07XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIHNpbmdsZSBzdWJzdGl0dXRpb25zIChsb29rdXAgdHlwZSAxKSBmb3IgYSBnaXZlbiBzY3JpcHQsIGxhbmd1YWdlLCBhbmQgZmVhdHVyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWNoYXJhY3RlciBmZWF0dXJlIG5hbWUgKCdhYWx0JywgJ3NhbHQnLCAnc3MwMScuLi4pXG4gKiBAcmV0dXJuIHtBcnJheX0gc3Vic3RpdHV0aW9ucyAtIFRoZSBsaXN0IG9mIHN1YnN0aXR1dGlvbnMuXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0U2luZ2xlID0gZnVuY3Rpb24oZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHN1YnN0aXR1dGlvbnMgPSBbXTtcbiAgICB2YXIgbG9va3VwVGFibGVzID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMSk7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbG9va3VwVGFibGVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgdmFyIHN1YnRhYmxlcyA9IGxvb2t1cFRhYmxlc1tpZHhdLnN1YnRhYmxlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJ0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tpXTtcbiAgICAgICAgICAgIHZhciBnbHlwaHMgPSB0aGlzJDEuZXhwYW5kQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpO1xuICAgICAgICAgICAgdmFyIGogPSAodm9pZCAwKTtcbiAgICAgICAgICAgIGlmIChzdWJ0YWJsZS5zdWJzdEZvcm1hdCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IHN1YnRhYmxlLmRlbHRhR2x5cGhJZDtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic3RpdHV0aW9ucy5wdXNoKHsgc3ViOiBnbHlwaCwgYnk6IGdseXBoICsgZGVsdGEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgc3Vic3RpdHV0ZSA9IHN1YnRhYmxlLnN1YnN0aXR1dGU7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdseXBocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goeyBzdWI6IGdseXBoc1tqXSwgYnk6IHN1YnN0aXR1dGVbal0gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdWJzdGl0dXRpb25zO1xufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBhbHRlcm5hdGVzIChsb29rdXAgdHlwZSAzKSBmb3IgYSBnaXZlbiBzY3JpcHQsIGxhbmd1YWdlLCBhbmQgZmVhdHVyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWNoYXJhY3RlciBmZWF0dXJlIG5hbWUgKCdhYWx0JywgJ3NhbHQnLi4uKVxuICogQHJldHVybiB7QXJyYXl9IGFsdGVybmF0ZXMgLSBUaGUgbGlzdCBvZiBhbHRlcm5hdGVzXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0QWx0ZXJuYXRlcyA9IGZ1bmN0aW9uKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhbHRlcm5hdGVzID0gW107XG4gICAgdmFyIGxvb2t1cFRhYmxlcyA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDMpO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxvb2t1cFRhYmxlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG4gICAgICAgICAgICB2YXIgZ2x5cGhzID0gdGhpcyQxLmV4cGFuZENvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKTtcbiAgICAgICAgICAgIHZhciBhbHRlcm5hdGVTZXRzID0gc3VidGFibGUuYWx0ZXJuYXRlU2V0cztcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRlcy5wdXNoKHsgc3ViOiBnbHlwaHNbal0sIGJ5OiBhbHRlcm5hdGVTZXRzW2pdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbHRlcm5hdGVzO1xufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBsaWdhdHVyZXMgKGxvb2t1cCB0eXBlIDQpIGZvciBhIGdpdmVuIHNjcmlwdCwgbGFuZ3VhZ2UsIGFuZCBmZWF0dXJlLlxuICogVGhlIHJlc3VsdCBpcyBhbiBhcnJheSBvZiBsaWdhdHVyZSBvYmplY3RzIGxpa2UgeyBzdWI6IFtpZHNdLCBieTogaWQgfVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqIEByZXR1cm4ge0FycmF5fSBsaWdhdHVyZXMgLSBUaGUgbGlzdCBvZiBsaWdhdHVyZXMuXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0TGlnYXR1cmVzID0gZnVuY3Rpb24oZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGxpZ2F0dXJlcyA9IFtdO1xuICAgIHZhciBsb29rdXBUYWJsZXMgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCA0KTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsb29rdXBUYWJsZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGVzW2lkeF0uc3VidGFibGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuICAgICAgICAgICAgdmFyIGdseXBocyA9IHRoaXMkMS5leHBhbmRDb3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSk7XG4gICAgICAgICAgICB2YXIgbGlnYXR1cmVTZXRzID0gc3VidGFibGUubGlnYXR1cmVTZXRzO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRHbHlwaCA9IGdseXBoc1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgbGlnU2V0ID0gbGlnYXR1cmVTZXRzW2pdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGlnU2V0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaWcgPSBsaWdTZXRba107XG4gICAgICAgICAgICAgICAgICAgIGxpZ2F0dXJlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YjogW3N0YXJ0R2x5cGhdLmNvbmNhdChsaWcuY29tcG9uZW50cyksXG4gICAgICAgICAgICAgICAgICAgICAgICBieTogbGlnLmxpZ0dseXBoXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlnYXR1cmVzO1xufTtcblxuLyoqXG4gKiBBZGQgb3IgbW9kaWZ5IGEgc2luZ2xlIHN1YnN0aXR1dGlvbiAobG9va3VwIHR5cGUgMSlcbiAqIEZvcm1hdCAyLCBtb3JlIGZsZXhpYmxlLCBpcyBhbHdheXMgdXNlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lICgnbGlnYScsICdybGlnJywgJ2RsaWcnLi4uKVxuICogQHBhcmFtIHtPYmplY3R9IHN1YnN0aXR1dGlvbiAtIHsgc3ViOiBpZCwgZGVsdGE6IG51bWJlciB9IGZvciBmb3JtYXQgMSBvciB7IHN1YjogaWQsIGJ5OiBpZCB9IGZvciBmb3JtYXQgMi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmFkZFNpbmdsZSA9IGZ1bmN0aW9uKGZlYXR1cmUsIHN1YnN0aXR1dGlvbiwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIHZhciBsb29rdXBUYWJsZSA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDEsIHRydWUpWzBdO1xuICAgIHZhciBzdWJ0YWJsZSA9IGdldFN1YnN0Rm9ybWF0KGxvb2t1cFRhYmxlLCAyLCB7ICAgICAgICAgICAgICAgIC8vIGxvb2t1cCB0eXBlIDEgc3VidGFibGUsIGZvcm1hdCAyLCBjb3ZlcmFnZSBmb3JtYXQgMVxuICAgICAgICBzdWJzdEZvcm1hdDogMixcbiAgICAgICAgY292ZXJhZ2U6IHtmb3JtYXQ6IDEsIGdseXBoczogW119LFxuICAgICAgICBzdWJzdGl0dXRlOiBbXVxuICAgIH0pO1xuICAgIGNoZWNrLmFzc2VydChzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQgPT09IDEsICdMaWdhdHVyZTogdW5hYmxlIHRvIG1vZGlmeSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgJyArIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCk7XG4gICAgdmFyIGNvdmVyYWdlR2x5cGggPSBzdWJzdGl0dXRpb24uc3ViO1xuICAgIHZhciBwb3MgPSB0aGlzLmJpblNlYXJjaChzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMsIGNvdmVyYWdlR2x5cGgpO1xuICAgIGlmIChwb3MgPCAwKSB7XG4gICAgICAgIHBvcyA9IC0xIC0gcG9zO1xuICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMuc3BsaWNlKHBvcywgMCwgY292ZXJhZ2VHbHlwaCk7XG4gICAgICAgIHN1YnRhYmxlLnN1YnN0aXR1dGUuc3BsaWNlKHBvcywgMCwgMCk7XG4gICAgfVxuICAgIHN1YnRhYmxlLnN1YnN0aXR1dGVbcG9zXSA9IHN1YnN0aXR1dGlvbi5ieTtcbn07XG5cbi8qKlxuICogQWRkIG9yIG1vZGlmeSBhbiBhbHRlcm5hdGUgc3Vic3RpdHV0aW9uIChsb29rdXAgdHlwZSAxKVxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG4gKiBAcGFyYW0ge09iamVjdH0gc3Vic3RpdHV0aW9uIC0geyBzdWI6IGlkLCBieTogW2lkc10gfVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkQWx0ZXJuYXRlID0gZnVuY3Rpb24oZmVhdHVyZSwgc3Vic3RpdHV0aW9uLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMywgdHJ1ZSlbMF07XG4gICAgdmFyIHN1YnRhYmxlID0gZ2V0U3Vic3RGb3JtYXQobG9va3VwVGFibGUsIDEsIHsgICAgICAgICAgICAgICAgLy8gbG9va3VwIHR5cGUgMyBzdWJ0YWJsZSwgZm9ybWF0IDEsIGNvdmVyYWdlIGZvcm1hdCAxXG4gICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICBjb3ZlcmFnZToge2Zvcm1hdDogMSwgZ2x5cGhzOiBbXX0sXG4gICAgICAgIGFsdGVybmF0ZVNldHM6IFtdXG4gICAgfSk7XG4gICAgY2hlY2suYXNzZXJ0KHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCA9PT0gMSwgJ0xpZ2F0dXJlOiB1bmFibGUgdG8gbW9kaWZ5IGNvdmVyYWdlIHRhYmxlIGZvcm1hdCAnICsgc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0KTtcbiAgICB2YXIgY292ZXJhZ2VHbHlwaCA9IHN1YnN0aXR1dGlvbi5zdWI7XG4gICAgdmFyIHBvcyA9IHRoaXMuYmluU2VhcmNoKHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocywgY292ZXJhZ2VHbHlwaCk7XG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgcG9zID0gLTEgLSBwb3M7XG4gICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocy5zcGxpY2UocG9zLCAwLCBjb3ZlcmFnZUdseXBoKTtcbiAgICAgICAgc3VidGFibGUuYWx0ZXJuYXRlU2V0cy5zcGxpY2UocG9zLCAwLCAwKTtcbiAgICB9XG4gICAgc3VidGFibGUuYWx0ZXJuYXRlU2V0c1twb3NdID0gc3Vic3RpdHV0aW9uLmJ5O1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaWdhdHVyZSAobG9va3VwIHR5cGUgNClcbiAqIExpZ2F0dXJlcyB3aXRoIG1vcmUgY29tcG9uZW50cyBtdXN0IGJlIHN0b3JlZCBhaGVhZCBvZiB0aG9zZSB3aXRoIGZld2VyIGNvbXBvbmVudHMgaW4gb3JkZXIgdG8gYmUgZm91bmRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lICgnbGlnYScsICdybGlnJywgJ2RsaWcnLi4uKVxuICogQHBhcmFtIHtPYmplY3R9IGxpZ2F0dXJlIC0geyBzdWI6IFtpZHNdLCBieTogaWQgfVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkTGlnYXR1cmUgPSBmdW5jdGlvbihmZWF0dXJlLCBsaWdhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIHZhciBsb29rdXBUYWJsZSA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDQsIHRydWUpWzBdO1xuICAgIHZhciBzdWJ0YWJsZSA9IGxvb2t1cFRhYmxlLnN1YnRhYmxlc1swXTtcbiAgICBpZiAoIXN1YnRhYmxlKSB7XG4gICAgICAgIHN1YnRhYmxlID0geyAgICAgICAgICAgICAgICAvLyBsb29rdXAgdHlwZSA0IHN1YnRhYmxlLCBmb3JtYXQgMSwgY292ZXJhZ2UgZm9ybWF0IDFcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICAgICAgY292ZXJhZ2U6IHsgZm9ybWF0OiAxLCBnbHlwaHM6IFtdIH0sXG4gICAgICAgICAgICBsaWdhdHVyZVNldHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGxvb2t1cFRhYmxlLnN1YnRhYmxlc1swXSA9IHN1YnRhYmxlO1xuICAgIH1cbiAgICBjaGVjay5hc3NlcnQoc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0ID09PSAxLCAnTGlnYXR1cmU6IHVuYWJsZSB0byBtb2RpZnkgY292ZXJhZ2UgdGFibGUgZm9ybWF0ICcgKyBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQpO1xuICAgIHZhciBjb3ZlcmFnZUdseXBoID0gbGlnYXR1cmUuc3ViWzBdO1xuICAgIHZhciBsaWdDb21wb25lbnRzID0gbGlnYXR1cmUuc3ViLnNsaWNlKDEpO1xuICAgIHZhciBsaWdhdHVyZVRhYmxlID0ge1xuICAgICAgICBsaWdHbHlwaDogbGlnYXR1cmUuYnksXG4gICAgICAgIGNvbXBvbmVudHM6IGxpZ0NvbXBvbmVudHNcbiAgICB9O1xuICAgIHZhciBwb3MgPSB0aGlzLmJpblNlYXJjaChzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMsIGNvdmVyYWdlR2x5cGgpO1xuICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICAvLyBsaWdhdHVyZVNldCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICB2YXIgbGlnYXR1cmVTZXQgPSBzdWJ0YWJsZS5saWdhdHVyZVNldHNbcG9zXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaWdhdHVyZVNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gSWYgbGlnYXR1cmUgYWxyZWFkeSBleGlzdHMsIHJldHVybi5cbiAgICAgICAgICAgIGlmIChhcnJheXNFcXVhbChsaWdhdHVyZVNldFtpXS5jb21wb25lbnRzLCBsaWdDb21wb25lbnRzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBsaWdhdHVyZSBkb2VzIG5vdCBleGlzdDogYWRkIGl0LlxuICAgICAgICBsaWdhdHVyZVNldC5wdXNoKGxpZ2F0dXJlVGFibGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBsaWdhdHVyZVNldCBhbmQgYWRkIGNvdmVyYWdlIGZvciB0aGUgZmlyc3QgZ2x5cGguXG4gICAgICAgIHBvcyA9IC0xIC0gcG9zO1xuICAgICAgICBzdWJ0YWJsZS5jb3ZlcmFnZS5nbHlwaHMuc3BsaWNlKHBvcywgMCwgY292ZXJhZ2VHbHlwaCk7XG4gICAgICAgIHN1YnRhYmxlLmxpZ2F0dXJlU2V0cy5zcGxpY2UocG9zLCAwLCBbbGlnYXR1cmVUYWJsZV0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogTGlzdCBhbGwgZmVhdHVyZSBkYXRhIGZvciBhIGdpdmVuIHNjcmlwdCBhbmQgbGFuZ3VhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKiBAcmV0dXJuIHtBcnJheX0gc3Vic3RpdHV0aW9ucyAtIFRoZSBsaXN0IG9mIHN1YnN0aXR1dGlvbnMuXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0RmVhdHVyZSA9IGZ1bmN0aW9uKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICBpZiAoL3NzXFxkXFxkLy50ZXN0KGZlYXR1cmUpKSB7XG4gICAgICAgIC8vIHNzMDEgLSBzczIwXG4gICAgICAgIHJldHVybiB0aGlzLmdldFNpbmdsZShmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICB9XG4gICAgc3dpdGNoIChmZWF0dXJlKSB7XG4gICAgICAgIGNhc2UgJ2FhbHQnOlxuICAgICAgICBjYXNlICdzYWx0JzpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNpbmdsZShmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHRoaXMuZ2V0QWx0ZXJuYXRlcyhmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSk7XG4gICAgICAgIGNhc2UgJ2RsaWcnOlxuICAgICAgICBjYXNlICdsaWdhJzpcbiAgICAgICAgY2FzZSAncmxpZyc6IHJldHVybiB0aGlzLmdldExpZ2F0dXJlcyhmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogQWRkIGEgc3Vic3RpdHV0aW9uIHRvIGEgZmVhdHVyZSBmb3IgYSBnaXZlbiBzY3JpcHQgYW5kIGxhbmd1YWdlLlxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWIgLSB0aGUgc3Vic3RpdHV0aW9uIHRvIGFkZCAoYW4gb2JqZWN0IGxpa2UgeyBzdWI6IGlkIG9yIFtpZHNdLCBieTogaWQgb3IgW2lkc10gfSlcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIGlmICgvc3NcXGRcXGQvLnRlc3QoZmVhdHVyZSkpIHtcbiAgICAgICAgLy8gc3MwMSAtIHNzMjBcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkU2luZ2xlKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgfVxuICAgIHN3aXRjaCAoZmVhdHVyZSkge1xuICAgICAgICBjYXNlICdhYWx0JzpcbiAgICAgICAgY2FzZSAnc2FsdCc6XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN1Yi5ieSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRTaW5nbGUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZEFsdGVybmF0ZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgICAgICBjYXNlICdkbGlnJzpcbiAgICAgICAgY2FzZSAnbGlnYSc6XG4gICAgICAgIGNhc2UgJ3JsaWcnOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkTGlnYXR1cmUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmZ1bmN0aW9uIGlzQnJvd3NlcigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbmZ1bmN0aW9uIG5vZGVCdWZmZXJUb0FycmF5QnVmZmVyKGJ1ZmZlcikge1xuICAgIHZhciBhYiA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXIubGVuZ3RoKTtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7ICsraSkge1xuICAgICAgICB2aWV3W2ldID0gYnVmZmVyW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBhYjtcbn1cblxuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb05vZGVCdWZmZXIoYWIpIHtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihhYi5ieXRlTGVuZ3RoKTtcbiAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7ICsraSkge1xuICAgICAgICBidWZmZXJbaV0gPSB2aWV3W2ldO1xuICAgIH1cblxuICAgIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQXJndW1lbnQoZXhwcmVzc2lvbiwgbWVzc2FnZSkge1xuICAgIGlmICghZXhwcmVzc2lvbikge1xuICAgICAgICB0aHJvdyBtZXNzYWdlO1xuICAgIH1cbn1cblxuLyogQSBUcnVlVHlwZSBmb250IGhpbnRpbmcgaW50ZXJwcmV0ZXIuXG4qXG4qIChjKSAyMDE3IEF4ZWwgS2l0dGVuYmVyZ2VyXG4qXG4qIFRoaXMgaW50ZXJwcmV0ZXIgaGFzIGJlZW4gaW1wbGVtZW50ZWQgYWNjb3JkaW5nIHRvIHRoaXMgZG9jdW1lbnRhdGlvbjpcbiogaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2ZvbnRzL1RydWVUeXBlLVJlZmVyZW5jZS1NYW51YWwvUk0wNS9DaGFwNS5odG1sXG4qXG4qIEFjY29yZGluZyB0byB0aGUgZG9jdW1lbnRhdGlvbiBGMjRET1Q2IHZhbHVlcyBhcmUgdXNlZCBmb3IgcGl4ZWxzLlxuKiBUaGF0IG1lYW5zIGNhbGN1bGF0aW9uIGlzIDEvNjQgcGl4ZWwgYWNjdXJhdGUgYW5kIHVzZXMgaW50ZWdlciBvcGVyYXRpb25zLlxuKiBIb3dldmVyLCBKYXZhc2NyaXB0IGhhcyBmbG9hdGluZyBwb2ludCBvcGVyYXRpb25zIGJ5IGRlZmF1bHQgYW5kIG9ubHlcbiogdGhvc2UgYXJlIGF2YWlsYWJsZS4gT25lIGNvdWxkIG1ha2UgYSBjYXNlIHRvIHNpbXVsYXRlIHRoZSAxLzY0IGFjY3VyYWN5XG4qIGV4YWN0bHkgYnkgdHJ1bmNhdGluZyBhZnRlciBldmVyeSBkaXZpc2lvbiBvcGVyYXRpb25cbiogKGZvciBleGFtcGxlIHdpdGggPDwgMCkgdG8gZ2V0IHBpeGVsIGV4YWN0bHkgcmVzdWx0cyBhcyBvdGhlciBUcnVlVHlwZVxuKiBpbXBsZW1lbnRhdGlvbnMuIEl0IG1heSBtYWtlIHNlbnNlIHNpbmNlIHNvbWUgZm9udHMgYXJlIHBpeGVsIG9wdGltaXplZFxuKiBieSBoYW5kIHVzaW5nIERFTFRBUCBpbnN0cnVjdGlvbnMuIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIGRvZXNuJ3RcbiogYW5kIHJhdGhlciB1c2VzIGZ1bGwgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uLlxuKlxuKiB4U2NhbGUsIHlTY2FsZSBhbmQgcm90YXRpb24gaXMgY3VycmVudGx5IGlnbm9yZWQuXG4qXG4qIEEgZmV3IG5vbi10cml2aWFsIGluc3RydWN0aW9ucyBhcmUgbWlzc2luZyBhcyBJIGRpZG4ndCBlbmNvdW50ZXIgeWV0XG4qIGEgZm9udCB0aGF0IHVzZWQgdGhlbSB0byB0ZXN0IGEgcG9zc2libGUgaW1wbGVtZW50YXRpb24uXG4qXG4qIFNvbWUgZm9udHMgc2VlbSB0byB1c2UgdW5kb2N1bWVudGVkIGZlYXR1cmVzIHJlZ2FyZGluZyB0aGUgdHdpbGlnaHQgem9uZS5cbiogT25seSBzb21lIG9mIHRoZW0gYXJlIGltcGxlbWVudGVkIGFzIHRoZXkgd2VyZSBlbmNvdW50ZXJlZC5cbipcbiogVGhlIGV4cG9ydHMuREVCVUcgc3RhdGVtZW50cyBhcmUgcmVtb3ZlZCBvbiB0aGUgbWluaWZpZWQgZGlzdHJpYnV0aW9uIGZpbGUuXG4qL1xudmFyIGluc3RydWN0aW9uVGFibGU7XG52YXIgZXhlYztcbnZhciBleGVjR2x5cGg7XG52YXIgZXhlY0NvbXBvbmVudDtcblxuLypcbiogQ3JlYXRlcyBhIGhpbnRpbmcgb2JqZWN0LlxuKlxuKiBUaGVyZSBvdWdodCB0byBiZSBleGFjdGx5IG9uZVxuKiBmb3IgZWFjaCB0cnVldHlwZSBmb250IHRoYXQgaXMgdXNlZCBmb3IgaGludGluZy5cbiovXG5mdW5jdGlvbiBIaW50aW5nKGZvbnQpIHtcbiAgICAvLyB0aGUgZm9udCB0aGlzIGhpbnRpbmcgb2JqZWN0IGlzIGZvclxuICAgIHRoaXMuZm9udCA9IGZvbnQ7XG5cbiAgICAvLyBjYWNoZWQgc3RhdGVzXG4gICAgdGhpcy5fZnBnbVN0YXRlICA9XG4gICAgdGhpcy5fcHJlcFN0YXRlICA9XG4gICAgICAgIHVuZGVmaW5lZDtcblxuICAgIC8vIGVycm9yU3RhdGVcbiAgICAvLyAwIC4uLiBhbGwgb2theVxuICAgIC8vIDEgLi4uIGhhZCBhbiBlcnJvciBpbiBhIGdseWYsXG4gICAgLy8gICAgICAgY29udGludWUgd29ya2luZyBidXQgc3RvcCBzcGFtbWluZ1xuICAgIC8vICAgICAgIHRoZSBjb25zb2xlXG4gICAgLy8gMiAuLi4gZXJyb3IgYXQgcHJlcCwgc3RvcCBoaW50aW5nIGF0IHRoaXMgcHBlbVxuICAgIC8vIDMgLi4uIGVycm9yIGF0IGZwZWcsIHN0b3AgaGludGluZyBmb3IgdGhpcyBmb250IGF0IGFsbFxuICAgIHRoaXMuX2Vycm9yU3RhdGUgPSAwO1xufVxuXG4vKlxuKiBOb3Qgcm91bmRpbmcuXG4qL1xuZnVuY3Rpb24gcm91bmRPZmYodikge1xuICAgIHJldHVybiB2O1xufVxuXG4vKlxuKiBSb3VuZGluZyB0byBncmlkLlxuKi9cbmZ1bmN0aW9uIHJvdW5kVG9HcmlkKHYpIHtcbiAgICAvL1JvdW5kaW5nIGluIFRUIGlzIHN1cHBvc2VkIHRvIFwic3ltbWV0cmljYWwgYXJvdW5kIHplcm9cIlxuICAgIHJldHVybiBNYXRoLnNpZ24odikgKiBNYXRoLnJvdW5kKE1hdGguYWJzKHYpKTtcbn1cblxuLypcbiogUm91bmRpbmcgdG8gZG91YmxlIGdyaWQuXG4qL1xuZnVuY3Rpb24gcm91bmRUb0RvdWJsZUdyaWQodikge1xuICAgIHJldHVybiBNYXRoLnNpZ24odikgKiBNYXRoLnJvdW5kKE1hdGguYWJzKHYgKiAyKSkgLyAyO1xufVxuXG4vKlxuKiBSb3VuZGluZyB0byBoYWxmIGdyaWQuXG4qL1xuZnVuY3Rpb24gcm91bmRUb0hhbGZHcmlkKHYpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHYpICogKE1hdGgucm91bmQoTWF0aC5hYnModikgKyAwLjUpIC0gMC41KTtcbn1cblxuLypcbiogUm91bmRpbmcgdG8gdXAgdG8gZ3JpZC5cbiovXG5mdW5jdGlvbiByb3VuZFVwVG9HcmlkKHYpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHYpICogTWF0aC5jZWlsKE1hdGguYWJzKHYpKTtcbn1cblxuLypcbiogUm91bmRpbmcgdG8gZG93biB0byBncmlkLlxuKi9cbmZ1bmN0aW9uIHJvdW5kRG93blRvR3JpZCh2KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIE1hdGguZmxvb3IoTWF0aC5hYnModikpO1xufVxuXG4vKlxuKiBTdXBlciByb3VuZGluZy5cbiovXG52YXIgcm91bmRTdXBlciA9IGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIHBlcmlvZCA9IHRoaXMuc3JQZXJpb2Q7XG4gICAgdmFyIHBoYXNlID0gdGhpcy5zclBoYXNlO1xuICAgIHZhciB0aHJlc2hvbGQgPSB0aGlzLnNyVGhyZXNob2xkO1xuICAgIHZhciBzaWduID0gMTtcblxuICAgIGlmICh2IDwgMCkge1xuICAgICAgICB2ID0gLXY7XG4gICAgICAgIHNpZ24gPSAtMTtcbiAgICB9XG5cbiAgICB2ICs9IHRocmVzaG9sZCAtIHBoYXNlO1xuXG4gICAgdiA9IE1hdGgudHJ1bmModiAvIHBlcmlvZCkgKiBwZXJpb2Q7XG5cbiAgICB2ICs9IHBoYXNlO1xuXG4gICAgLy8gYWNjb3JkaW5nIHRvIGh0dHA6Ly94Z3JpZGZpdC5zb3VyY2Vmb3JnZS5uZXQvcm91bmQuaHRtbFxuICAgIGlmICh2IDwgMCkgeyByZXR1cm4gcGhhc2UgKiBzaWduOyB9XG5cbiAgICByZXR1cm4gdiAqIHNpZ247XG59O1xuXG4vKlxuKiBVbml0IHZlY3RvciBvZiB4LWF4aXMuXG4qL1xudmFyIHhVbml0VmVjdG9yID0ge1xuICAgIHg6IDEsXG5cbiAgICB5OiAwLFxuXG4gICAgYXhpczogJ3gnLFxuXG4gICAgLy8gR2V0cyB0aGUgcHJvamVjdGVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAvLyBvMS9vMiAuLi4gaWYgdHJ1ZSwgcmVzcGVjdGl2ZSBvcmlnaW5hbCBwb3NpdGlvbiBpcyB1c2VkLlxuICAgIGRpc3RhbmNlOiBmdW5jdGlvbiAocDEsIHAyLCBvMSwgbzIpIHtcbiAgICAgICAgcmV0dXJuIChvMSA/IHAxLnhvIDogcDEueCkgLSAobzIgPyBwMi54byA6IHAyLngpO1xuICAgIH0sXG5cbiAgICAvLyBNb3ZlcyBwb2ludCBwIHNvIHRoZSBtb3ZlZCBwb3NpdGlvbiBoYXMgdGhlIHNhbWUgcmVsYXRpdmVcbiAgICAvLyBwb3NpdGlvbiB0byB0aGUgbW92ZWQgcG9zaXRpb25zIG9mIHJwMSBhbmQgcnAyIHRoYW4gdGhlXG4gICAgLy8gb3JpZ2luYWwgcG9zaXRpb25zIGhhZC5cbiAgICAvL1xuICAgIC8vIFNlZSBBUFBFTkRJWCBvbiBJTlRFUlBPTEFURSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cbiAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gKHAsIHJwMSwgcnAyLCBwdikge1xuICAgICAgICB2YXIgZG8xO1xuICAgICAgICB2YXIgZG8yO1xuICAgICAgICB2YXIgZG9hMTtcbiAgICAgICAgdmFyIGRvYTI7XG4gICAgICAgIHZhciBkbTE7XG4gICAgICAgIHZhciBkbTI7XG4gICAgICAgIHZhciBkdDtcblxuICAgICAgICBpZiAoIXB2IHx8IHB2ID09PSB0aGlzKSB7XG4gICAgICAgICAgICBkbzEgPSBwLnhvIC0gcnAxLnhvO1xuICAgICAgICAgICAgZG8yID0gcC54byAtIHJwMi54bztcbiAgICAgICAgICAgIGRtMSA9IHJwMS54IC0gcnAxLnhvO1xuICAgICAgICAgICAgZG0yID0gcnAyLnggLSBycDIueG87XG4gICAgICAgICAgICBkb2ExID0gTWF0aC5hYnMoZG8xKTtcbiAgICAgICAgICAgIGRvYTIgPSBNYXRoLmFicyhkbzIpO1xuICAgICAgICAgICAgZHQgPSBkb2ExICsgZG9hMjtcblxuICAgICAgICAgICAgaWYgKGR0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcC54ID0gcC54byArIChkbTEgKyBkbTIpIC8gMjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAueCA9IHAueG8gKyAoZG0xICogZG9hMiArIGRtMiAqIGRvYTEpIC8gZHQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkbzEgPSBwdi5kaXN0YW5jZShwLCBycDEsIHRydWUsIHRydWUpO1xuICAgICAgICBkbzIgPSBwdi5kaXN0YW5jZShwLCBycDIsIHRydWUsIHRydWUpO1xuICAgICAgICBkbTEgPSBwdi5kaXN0YW5jZShycDEsIHJwMSwgZmFsc2UsIHRydWUpO1xuICAgICAgICBkbTIgPSBwdi5kaXN0YW5jZShycDIsIHJwMiwgZmFsc2UsIHRydWUpO1xuICAgICAgICBkb2ExID0gTWF0aC5hYnMoZG8xKTtcbiAgICAgICAgZG9hMiA9IE1hdGguYWJzKGRvMik7XG4gICAgICAgIGR0ID0gZG9hMSArIGRvYTI7XG5cbiAgICAgICAgaWYgKGR0ID09PSAwKSB7XG4gICAgICAgICAgICB4VW5pdFZlY3Rvci5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICsgZG0yKSAvIDIsIHB2LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHhVbml0VmVjdG9yLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKiBkb2EyICsgZG0yICogZG9hMSkgLyBkdCwgcHYsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvLyBTbG9wZSBvZiBsaW5lIG5vcm1hbCB0byB0aGlzXG4gICAgbm9ybWFsU2xvcGU6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcblxuICAgIC8vIFNldHMgdGhlIHBvaW50ICdwJyByZWxhdGl2ZSB0byBwb2ludCAncnAnXG4gICAgLy8gYnkgdGhlIGRpc3RhbmNlICdkJy5cbiAgICAvL1xuICAgIC8vIFNlZSBBUFBFTkRJWCBvbiBTRVRSRUxBVElWRSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cbiAgICAvL1xuICAgIC8vIHAgICAuLi4gcG9pbnQgdG8gc2V0XG4gICAgLy8gcnAgIC4uLiByZWZlcmVuY2UgcG9pbnRcbiAgICAvLyBkICAgLi4uIGRpc3RhbmNlIG9uIHByb2plY3Rpb24gdmVjdG9yXG4gICAgLy8gcHYgIC4uLiBwcm9qZWN0aW9uIHZlY3RvciAodW5kZWZpbmVkID0gdGhpcylcbiAgICAvLyBvcmcgLi4uIGlmIHRydWUsIHVzZXMgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIG9mIHJwIGFzIHJlZmVyZW5jZS5cbiAgICBzZXRSZWxhdGl2ZTogZnVuY3Rpb24gKHAsIHJwLCBkLCBwdiwgb3JnKSB7XG4gICAgICAgIGlmICghcHYgfHwgcHYgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHAueCA9IChvcmcgPyBycC54byA6IHJwLngpICsgZDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBycHggPSBvcmcgPyBycC54byA6IHJwLng7XG4gICAgICAgIHZhciBycHkgPSBvcmcgPyBycC55byA6IHJwLnk7XG4gICAgICAgIHZhciBycGR4ID0gcnB4ICsgZCAqIHB2Lng7XG4gICAgICAgIHZhciBycGR5ID0gcnB5ICsgZCAqIHB2Lnk7XG5cbiAgICAgICAgcC54ID0gcnBkeCArIChwLnkgLSBycGR5KSAvIHB2Lm5vcm1hbFNsb3BlO1xuICAgIH0sXG5cbiAgICAvLyBTbG9wZSBvZiB2ZWN0b3IgbGluZS5cbiAgICBzbG9wZTogMCxcblxuICAgIC8vIFRvdWNoZXMgdGhlIHBvaW50IHAuXG4gICAgdG91Y2g6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHAueFRvdWNoZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyBUZXN0cyBpZiBhIHBvaW50IHAgaXMgdG91Y2hlZC5cbiAgICB0b3VjaGVkOiBmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcC54VG91Y2hlZDtcbiAgICB9LFxuXG4gICAgLy8gVW50b3VjaGVzIHRoZSBwb2ludCBwLlxuICAgIHVudG91Y2g6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHAueFRvdWNoZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG4vKlxuKiBVbml0IHZlY3RvciBvZiB5LWF4aXMuXG4qL1xudmFyIHlVbml0VmVjdG9yID0ge1xuICAgIHg6IDAsXG5cbiAgICB5OiAxLFxuXG4gICAgYXhpczogJ3knLFxuXG4gICAgLy8gR2V0cyB0aGUgcHJvamVjdGVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiAgICAvLyBvMS9vMiAuLi4gaWYgdHJ1ZSwgcmVzcGVjdGl2ZSBvcmlnaW5hbCBwb3NpdGlvbiBpcyB1c2VkLlxuICAgIGRpc3RhbmNlOiBmdW5jdGlvbiAocDEsIHAyLCBvMSwgbzIpIHtcbiAgICAgICAgcmV0dXJuIChvMSA/IHAxLnlvIDogcDEueSkgLSAobzIgPyBwMi55byA6IHAyLnkpO1xuICAgIH0sXG5cbiAgICAvLyBNb3ZlcyBwb2ludCBwIHNvIHRoZSBtb3ZlZCBwb3NpdGlvbiBoYXMgdGhlIHNhbWUgcmVsYXRpdmVcbiAgICAvLyBwb3NpdGlvbiB0byB0aGUgbW92ZWQgcG9zaXRpb25zIG9mIHJwMSBhbmQgcnAyIHRoYW4gdGhlXG4gICAgLy8gb3JpZ2luYWwgcG9zaXRpb25zIGhhZC5cbiAgICAvL1xuICAgIC8vIFNlZSBBUFBFTkRJWCBvbiBJTlRFUlBPTEFURSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cbiAgICBpbnRlcnBvbGF0ZTogZnVuY3Rpb24gKHAsIHJwMSwgcnAyLCBwdikge1xuICAgICAgICB2YXIgZG8xO1xuICAgICAgICB2YXIgZG8yO1xuICAgICAgICB2YXIgZG9hMTtcbiAgICAgICAgdmFyIGRvYTI7XG4gICAgICAgIHZhciBkbTE7XG4gICAgICAgIHZhciBkbTI7XG4gICAgICAgIHZhciBkdDtcblxuICAgICAgICBpZiAoIXB2IHx8IHB2ID09PSB0aGlzKSB7XG4gICAgICAgICAgICBkbzEgPSBwLnlvIC0gcnAxLnlvO1xuICAgICAgICAgICAgZG8yID0gcC55byAtIHJwMi55bztcbiAgICAgICAgICAgIGRtMSA9IHJwMS55IC0gcnAxLnlvO1xuICAgICAgICAgICAgZG0yID0gcnAyLnkgLSBycDIueW87XG4gICAgICAgICAgICBkb2ExID0gTWF0aC5hYnMoZG8xKTtcbiAgICAgICAgICAgIGRvYTIgPSBNYXRoLmFicyhkbzIpO1xuICAgICAgICAgICAgZHQgPSBkb2ExICsgZG9hMjtcblxuICAgICAgICAgICAgaWYgKGR0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcC55ID0gcC55byArIChkbTEgKyBkbTIpIC8gMjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAueSA9IHAueW8gKyAoZG0xICogZG9hMiArIGRtMiAqIGRvYTEpIC8gZHQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkbzEgPSBwdi5kaXN0YW5jZShwLCBycDEsIHRydWUsIHRydWUpO1xuICAgICAgICBkbzIgPSBwdi5kaXN0YW5jZShwLCBycDIsIHRydWUsIHRydWUpO1xuICAgICAgICBkbTEgPSBwdi5kaXN0YW5jZShycDEsIHJwMSwgZmFsc2UsIHRydWUpO1xuICAgICAgICBkbTIgPSBwdi5kaXN0YW5jZShycDIsIHJwMiwgZmFsc2UsIHRydWUpO1xuICAgICAgICBkb2ExID0gTWF0aC5hYnMoZG8xKTtcbiAgICAgICAgZG9hMiA9IE1hdGguYWJzKGRvMik7XG4gICAgICAgIGR0ID0gZG9hMSArIGRvYTI7XG5cbiAgICAgICAgaWYgKGR0ID09PSAwKSB7XG4gICAgICAgICAgICB5VW5pdFZlY3Rvci5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICsgZG0yKSAvIDIsIHB2LCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHlVbml0VmVjdG9yLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKiBkb2EyICsgZG0yICogZG9hMSkgLyBkdCwgcHYsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvLyBTbG9wZSBvZiBsaW5lIG5vcm1hbCB0byB0aGlzLlxuICAgIG5vcm1hbFNsb3BlOiAwLFxuXG4gICAgLy8gU2V0cyB0aGUgcG9pbnQgJ3AnIHJlbGF0aXZlIHRvIHBvaW50ICdycCdcbiAgICAvLyBieSB0aGUgZGlzdGFuY2UgJ2QnXG4gICAgLy9cbiAgICAvLyBTZWUgQVBQRU5ESVggb24gU0VUUkVMQVRJVkUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG4gICAgLy9cbiAgICAvLyBwICAgLi4uIHBvaW50IHRvIHNldFxuICAgIC8vIHJwICAuLi4gcmVmZXJlbmNlIHBvaW50XG4gICAgLy8gZCAgIC4uLiBkaXN0YW5jZSBvbiBwcm9qZWN0aW9uIHZlY3RvclxuICAgIC8vIHB2ICAuLi4gcHJvamVjdGlvbiB2ZWN0b3IgKHVuZGVmaW5lZCA9IHRoaXMpXG4gICAgLy8gb3JnIC4uLiBpZiB0cnVlLCB1c2VzIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBvZiBycCBhcyByZWZlcmVuY2UuXG4gICAgc2V0UmVsYXRpdmU6IGZ1bmN0aW9uIChwLCBycCwgZCwgcHYsIG9yZykge1xuICAgICAgICBpZiAoIXB2IHx8IHB2ID09PSB0aGlzKSB7XG4gICAgICAgICAgICBwLnkgPSAob3JnID8gcnAueW8gOiBycC55KSArIGQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcnB4ID0gb3JnID8gcnAueG8gOiBycC54O1xuICAgICAgICB2YXIgcnB5ID0gb3JnID8gcnAueW8gOiBycC55O1xuICAgICAgICB2YXIgcnBkeCA9IHJweCArIGQgKiBwdi54O1xuICAgICAgICB2YXIgcnBkeSA9IHJweSArIGQgKiBwdi55O1xuXG4gICAgICAgIHAueSA9IHJwZHkgKyBwdi5ub3JtYWxTbG9wZSAqIChwLnggLSBycGR4KTtcbiAgICB9LFxuXG4gICAgLy8gU2xvcGUgb2YgdmVjdG9yIGxpbmUuXG4gICAgc2xvcGU6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcblxuICAgIC8vIFRvdWNoZXMgdGhlIHBvaW50IHAuXG4gICAgdG91Y2g6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHAueVRvdWNoZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyBUZXN0cyBpZiBhIHBvaW50IHAgaXMgdG91Y2hlZC5cbiAgICB0b3VjaGVkOiBmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcC55VG91Y2hlZDtcbiAgICB9LFxuXG4gICAgLy8gVW50b3VjaGVzIHRoZSBwb2ludCBwLlxuICAgIHVudG91Y2g6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHAueVRvdWNoZWQgPSBmYWxzZTtcbiAgICB9XG59O1xuXG5PYmplY3QuZnJlZXplKHhVbml0VmVjdG9yKTtcbk9iamVjdC5mcmVlemUoeVVuaXRWZWN0b3IpO1xuXG4vKlxuKiBDcmVhdGVzIGEgdW5pdCB2ZWN0b3IgdGhhdCBpcyBub3QgeC0gb3IgeS1heGlzLlxuKi9cbmZ1bmN0aW9uIFVuaXRWZWN0b3IoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLmF4aXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zbG9wZSA9IHkgLyB4O1xuICAgIHRoaXMubm9ybWFsU2xvcGUgPSAteCAvIHk7XG4gICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbn1cblxuLypcbiogR2V0cyB0aGUgcHJvamVjdGVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cbiogbzEvbzIgLi4uIGlmIHRydWUsIHJlc3BlY3RpdmUgb3JpZ2luYWwgcG9zaXRpb24gaXMgdXNlZC5cbiovXG5Vbml0VmVjdG9yLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uKHAxLCBwMiwgbzEsIG8yKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy54ICogeFVuaXRWZWN0b3IuZGlzdGFuY2UocDEsIHAyLCBvMSwgbzIpICtcbiAgICAgICAgdGhpcy55ICogeVVuaXRWZWN0b3IuZGlzdGFuY2UocDEsIHAyLCBvMSwgbzIpXG4gICAgKTtcbn07XG5cbi8qXG4qIE1vdmVzIHBvaW50IHAgc28gdGhlIG1vdmVkIHBvc2l0aW9uIGhhcyB0aGUgc2FtZSByZWxhdGl2ZVxuKiBwb3NpdGlvbiB0byB0aGUgbW92ZWQgcG9zaXRpb25zIG9mIHJwMSBhbmQgcnAyIHRoYW4gdGhlXG4qIG9yaWdpbmFsIHBvc2l0aW9ucyBoYWQuXG4qXG4qIFNlZSBBUFBFTkRJWCBvbiBJTlRFUlBPTEFURSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cbiovXG5Vbml0VmVjdG9yLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKHAsIHJwMSwgcnAyLCBwdikge1xuICAgIHZhciBkbTE7XG4gICAgdmFyIGRtMjtcbiAgICB2YXIgZG8xO1xuICAgIHZhciBkbzI7XG4gICAgdmFyIGRvYTE7XG4gICAgdmFyIGRvYTI7XG4gICAgdmFyIGR0O1xuXG4gICAgZG8xID0gcHYuZGlzdGFuY2UocCwgcnAxLCB0cnVlLCB0cnVlKTtcbiAgICBkbzIgPSBwdi5kaXN0YW5jZShwLCBycDIsIHRydWUsIHRydWUpO1xuICAgIGRtMSA9IHB2LmRpc3RhbmNlKHJwMSwgcnAxLCBmYWxzZSwgdHJ1ZSk7XG4gICAgZG0yID0gcHYuZGlzdGFuY2UocnAyLCBycDIsIGZhbHNlLCB0cnVlKTtcbiAgICBkb2ExID0gTWF0aC5hYnMoZG8xKTtcbiAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcbiAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG4gICAgaWYgKGR0ID09PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSArIGRtMikgLyAyLCBwdiwgdHJ1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKiBkb2EyICsgZG0yICogZG9hMSkgLyBkdCwgcHYsIHRydWUpO1xufTtcblxuLypcbiogU2V0cyB0aGUgcG9pbnQgJ3AnIHJlbGF0aXZlIHRvIHBvaW50ICdycCdcbiogYnkgdGhlIGRpc3RhbmNlICdkJ1xuKlxuKiBTZWUgQVBQRU5ESVggb24gU0VUUkVMQVRJVkUgYXQgdGhlIGJvdHRvbSBvZiB0aGlzIGZpbGUuXG4qXG4qIHAgICAuLi4gIHBvaW50IHRvIHNldFxuKiBycCAgLi4uIHJlZmVyZW5jZSBwb2ludFxuKiBkICAgLi4uIGRpc3RhbmNlIG9uIHByb2plY3Rpb24gdmVjdG9yXG4qIHB2ICAuLi4gcHJvamVjdGlvbiB2ZWN0b3IgKHVuZGVmaW5lZCA9IHRoaXMpXG4qIG9yZyAuLi4gaWYgdHJ1ZSwgdXNlcyB0aGUgb3JpZ2luYWwgcG9zaXRpb24gb2YgcnAgYXMgcmVmZXJlbmNlLlxuKi9cblVuaXRWZWN0b3IucHJvdG90eXBlLnNldFJlbGF0aXZlID0gZnVuY3Rpb24ocCwgcnAsIGQsIHB2LCBvcmcpIHtcbiAgICBwdiA9IHB2IHx8IHRoaXM7XG5cbiAgICB2YXIgcnB4ID0gb3JnID8gcnAueG8gOiBycC54O1xuICAgIHZhciBycHkgPSBvcmcgPyBycC55byA6IHJwLnk7XG4gICAgdmFyIHJwZHggPSBycHggKyBkICogcHYueDtcbiAgICB2YXIgcnBkeSA9IHJweSArIGQgKiBwdi55O1xuXG4gICAgdmFyIHB2bnMgPSBwdi5ub3JtYWxTbG9wZTtcbiAgICB2YXIgZnZzID0gdGhpcy5zbG9wZTtcblxuICAgIHZhciBweCA9IHAueDtcbiAgICB2YXIgcHkgPSBwLnk7XG5cbiAgICBwLnggPSAoZnZzICogcHggLSBwdm5zICogcnBkeCArIHJwZHkgLSBweSkgLyAoZnZzIC0gcHZucyk7XG4gICAgcC55ID0gZnZzICogKHAueCAtIHB4KSArIHB5O1xufTtcblxuLypcbiogVG91Y2hlcyB0aGUgcG9pbnQgcC5cbiovXG5Vbml0VmVjdG9yLnByb3RvdHlwZS50b3VjaCA9IGZ1bmN0aW9uKHApIHtcbiAgICBwLnhUb3VjaGVkID0gdHJ1ZTtcbiAgICBwLnlUb3VjaGVkID0gdHJ1ZTtcbn07XG5cbi8qXG4qIFJldHVybnMgYSB1bml0IHZlY3RvciB3aXRoIHgveSBjb29yZGluYXRlcy5cbiovXG5mdW5jdGlvbiBnZXRVbml0VmVjdG9yKHgsIHkpIHtcbiAgICB2YXIgZCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblxuICAgIHggLz0gZDtcbiAgICB5IC89IGQ7XG5cbiAgICBpZiAoeCA9PT0gMSAmJiB5ID09PSAwKSB7IHJldHVybiB4VW5pdFZlY3RvcjsgfVxuICAgIGVsc2UgaWYgKHggPT09IDAgJiYgeSA9PT0gMSkgeyByZXR1cm4geVVuaXRWZWN0b3I7IH1cbiAgICBlbHNlIHsgcmV0dXJuIG5ldyBVbml0VmVjdG9yKHgsIHkpOyB9XG59XG5cbi8qXG4qIENyZWF0ZXMgYSBwb2ludCBpbiB0aGUgaGludGluZyBlbmdpbmUuXG4qL1xuZnVuY3Rpb24gSFBvaW50KFxuICAgIHgsXG4gICAgeSxcbiAgICBsYXN0UG9pbnRPZkNvbnRvdXIsXG4gICAgb25DdXJ2ZVxuKSB7XG4gICAgdGhpcy54ID0gdGhpcy54byA9IE1hdGgucm91bmQoeCAqIDY0KSAvIDY0OyAvLyBoaW50ZWQgeCB2YWx1ZSBhbmQgb3JpZ2luYWwgeC12YWx1ZVxuICAgIHRoaXMueSA9IHRoaXMueW8gPSBNYXRoLnJvdW5kKHkgKiA2NCkgLyA2NDsgLy8gaGludGVkIHkgdmFsdWUgYW5kIG9yaWdpbmFsIHktdmFsdWVcblxuICAgIHRoaXMubGFzdFBvaW50T2ZDb250b3VyID0gbGFzdFBvaW50T2ZDb250b3VyO1xuICAgIHRoaXMub25DdXJ2ZSA9IG9uQ3VydmU7XG4gICAgdGhpcy5wcmV2UG9pbnRPbkNvbnRvdXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5uZXh0UG9pbnRPbkNvbnRvdXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54VG91Y2hlZCA9IGZhbHNlO1xuICAgIHRoaXMueVRvdWNoZWQgPSBmYWxzZTtcblxuICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTtcbn1cblxuLypcbiogUmV0dXJucyB0aGUgbmV4dCB0b3VjaGVkIHBvaW50IG9uIHRoZSBjb250b3VyLlxuKlxuKiB2ICAuLi4gdW5pdCB2ZWN0b3IgdG8gdGVzdCB0b3VjaCBheGlzLlxuKi9cbkhQb2ludC5wcm90b3R5cGUubmV4dFRvdWNoZWQgPSBmdW5jdGlvbih2KSB7XG4gICAgdmFyIHAgPSB0aGlzLm5leHRQb2ludE9uQ29udG91cjtcblxuICAgIHdoaWxlICghdi50b3VjaGVkKHApICYmIHAgIT09IHRoaXMpIHsgcCA9IHAubmV4dFBvaW50T25Db250b3VyOyB9XG5cbiAgICByZXR1cm4gcDtcbn07XG5cbi8qXG4qIFJldHVybnMgdGhlIHByZXZpb3VzIHRvdWNoZWQgcG9pbnQgb24gdGhlIGNvbnRvdXJcbipcbiogdiAgLi4uIHVuaXQgdmVjdG9yIHRvIHRlc3QgdG91Y2ggYXhpcy5cbiovXG5IUG9pbnQucHJvdG90eXBlLnByZXZUb3VjaGVkID0gZnVuY3Rpb24odikge1xuICAgIHZhciBwID0gdGhpcy5wcmV2UG9pbnRPbkNvbnRvdXI7XG5cbiAgICB3aGlsZSAoIXYudG91Y2hlZChwKSAmJiBwICE9PSB0aGlzKSB7IHAgPSBwLnByZXZQb2ludE9uQ29udG91cjsgfVxuXG4gICAgcmV0dXJuIHA7XG59O1xuXG4vKlxuKiBUaGUgemVybyBwb2ludC5cbiovXG52YXIgSFBaZXJvID0gT2JqZWN0LmZyZWV6ZShuZXcgSFBvaW50KDAsIDApKTtcblxuLypcbiogVGhlIGRlZmF1bHQgc3RhdGUgb2YgdGhlIGludGVycHJldGVyLlxuKlxuKiBOb3RlOiBGcmVlemluZyB0aGUgZGVmYXVsdFN0YXRlIGFuZCB0aGVuIGRlcml2aW5nIGZyb20gaXRcbiogbWFrZXMgdGhlIFY4IEphdmFzY3JpcHQgZW5naW5lIGdvaW5nIGF3a3dhcmQsXG4qIHNvIHRoaXMgaXMgYXZvaWRlZCwgYWxiZWl0IHRoZSBkZWZhdWx0U3RhdGUgc2hvdWxkbid0XG4qIGV2ZXIgY2hhbmdlLlxuKi9cbnZhciBkZWZhdWx0U3RhdGUgPSB7XG4gICAgY3ZDdXRJbjogMTcgLyAxNiwgICAgLy8gY29udHJvbCB2YWx1ZSBjdXQgaW5cbiAgICBkZWx0YUJhc2U6IDksXG4gICAgZGVsdGFTaGlmdDogMC4xMjUsXG4gICAgbG9vcDogMSwgICAgICAgICAgICAgLy8gbG9vcHMgc29tZSBpbnN0cnVjdGlvbnNcbiAgICBtaW5EaXM6IDEsICAgICAgICAgICAvLyBtaW5pbXVtIGRpc3RhbmNlXG4gICAgYXV0b0ZsaXA6IHRydWVcbn07XG5cbi8qXG4qIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBpbnRlcnByZXRlci5cbipcbiogZW52ICAuLi4gJ2ZwZ20nIG9yICdwcmVwJyBvciAnZ2x5ZidcbiogcHJvZyAuLi4gdGhlIHByb2dyYW1cbiovXG5mdW5jdGlvbiBTdGF0ZShlbnYsIHByb2cpIHtcbiAgICB0aGlzLmVudiA9IGVudjtcbiAgICB0aGlzLnN0YWNrID0gW107XG4gICAgdGhpcy5wcm9nID0gcHJvZztcblxuICAgIHN3aXRjaCAoZW52KSB7XG4gICAgICAgIGNhc2UgJ2dseWYnIDpcbiAgICAgICAgICAgIHRoaXMuenAwID0gdGhpcy56cDEgPSB0aGlzLnpwMiA9IDE7XG4gICAgICAgICAgICB0aGlzLnJwMCA9IHRoaXMucnAxID0gdGhpcy5ycDIgPSAwO1xuICAgICAgICAgICAgLyogZmFsbCB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3ByZXAnIDpcbiAgICAgICAgICAgIHRoaXMuZnYgPSB0aGlzLnB2ID0gdGhpcy5kcHYgPSB4VW5pdFZlY3RvcjtcbiAgICAgICAgICAgIHRoaXMucm91bmQgPSByb3VuZFRvR3JpZDtcbiAgICB9XG59XG5cbi8qXG4qIEV4ZWN1dGVzIGEgZ2x5cGggcHJvZ3JhbS5cbipcbiogVGhpcyBkb2VzIHRoZSBoaW50aW5nIGZvciBlYWNoIGdseXBoLlxuKlxuKiBSZXR1cm5zIGFuIGFycmF5IG9mIG1vdmVkIHBvaW50cy5cbipcbiogZ2x5cGg6IHRoZSBnbHlwaCB0byBoaW50XG4qIHBwZW06IHRoZSBzaXplIHRoZSBnbHlwaCBpcyByZW5kZXJlZCBmb3JcbiovXG5IaW50aW5nLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oZ2x5cGgsIHBwZW0pIHtcbiAgICBpZiAodHlwZW9mIHBwZW0gIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgc2l6ZSBpcyBub3QgYSBudW1iZXIhJyk7XG4gICAgfVxuXG4gICAgLy8gUmVjZWl2ZWQgYSBmYXRhbCBlcnJvciwgZG9uJ3QgZG8gYW55IGhpbnRpbmcgYW55bW9yZS5cbiAgICBpZiAodGhpcy5fZXJyb3JTdGF0ZSA+IDIpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgZm9udCA9IHRoaXMuZm9udDtcbiAgICB2YXIgcHJlcFN0YXRlID0gdGhpcy5fcHJlcFN0YXRlO1xuXG4gICAgaWYgKCFwcmVwU3RhdGUgfHwgcHJlcFN0YXRlLnBwZW0gIT09IHBwZW0pIHtcbiAgICAgICAgdmFyIGZwZ21TdGF0ZSA9IHRoaXMuX2ZwZ21TdGF0ZTtcblxuICAgICAgICBpZiAoIWZwZ21TdGF0ZSkge1xuICAgICAgICAgICAgLy8gRXhlY3V0ZXMgdGhlIGZwZ20gc3RhdGUuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHVzZWQgYnkgZm9udHMgdG8gZGVmaW5lIGZ1bmN0aW9ucy5cbiAgICAgICAgICAgIFN0YXRlLnByb3RvdHlwZSA9IGRlZmF1bHRTdGF0ZTtcblxuICAgICAgICAgICAgZnBnbVN0YXRlID1cbiAgICAgICAgICAgIHRoaXMuX2ZwZ21TdGF0ZSA9XG4gICAgICAgICAgICAgICAgbmV3IFN0YXRlKCdmcGdtJywgZm9udC50YWJsZXMuZnBnbSk7XG5cbiAgICAgICAgICAgIGZwZ21TdGF0ZS5mdW5jcyA9IFsgXTtcbiAgICAgICAgICAgIGZwZ21TdGF0ZS5mb250ID0gZm9udDtcblxuICAgICAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBGUEdNLS0tJyk7XG4gICAgICAgICAgICAgICAgZnBnbVN0YXRlLnN0ZXAgPSAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBleGVjKGZwZ21TdGF0ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0hpbnRpbmcgZXJyb3IgaW4gRlBHTTonICsgZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3JTdGF0ZSA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhlY3V0ZXMgdGhlIHByZXAgcHJvZ3JhbSBmb3IgdGhpcyBwcGVtIHNldHRpbmcuXG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZCBieSBmb250cyB0byBzZXQgY3Z0IHZhbHVlc1xuICAgICAgICAvLyBkZXBlbmRpbmcgb24gdG8gYmUgcmVuZGVyZWQgZm9udCBzaXplLlxuXG4gICAgICAgIFN0YXRlLnByb3RvdHlwZSA9IGZwZ21TdGF0ZTtcbiAgICAgICAgcHJlcFN0YXRlID1cbiAgICAgICAgdGhpcy5fcHJlcFN0YXRlID1cbiAgICAgICAgICAgIG5ldyBTdGF0ZSgncHJlcCcsIGZvbnQudGFibGVzLnByZXApO1xuXG4gICAgICAgIHByZXBTdGF0ZS5wcGVtID0gcHBlbTtcblxuICAgICAgICAvLyBDcmVhdGVzIGEgY29weSBvZiB0aGUgY3Z0IHRhYmxlXG4gICAgICAgIC8vIGFuZCBzY2FsZXMgaXQgdG8gdGhlIGN1cnJlbnQgcHBlbSBzZXR0aW5nLlxuICAgICAgICB2YXIgb0N2dCA9IGZvbnQudGFibGVzLmN2dDtcbiAgICAgICAgaWYgKG9DdnQpIHtcbiAgICAgICAgICAgIHZhciBjdnQgPSBwcmVwU3RhdGUuY3Z0ID0gbmV3IEFycmF5KG9DdnQubGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IHBwZW0gLyBmb250LnVuaXRzUGVyRW07XG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG9DdnQubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgICAgICBjdnRbY10gPSBvQ3Z0W2NdICogc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmVwU3RhdGUuY3Z0ID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLUVYRUMgUFJFUC0tLScpO1xuICAgICAgICAgICAgcHJlcFN0YXRlLnN0ZXAgPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBleGVjKHByZXBTdGF0ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvclN0YXRlIDwgMikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIaW50aW5nIGVycm9yIGluIFBSRVA6JyArIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZXJyb3JTdGF0ZSA9IDI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXJyb3JTdGF0ZSA+IDEpIHsgcmV0dXJuOyB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gZXhlY0dseXBoKGdseXBoLCBwcmVwU3RhdGUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Vycm9yU3RhdGUgPCAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSGludGluZyBlcnJvcjonICsgZSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTm90ZTogZnVydGhlciBoaW50aW5nIGVycm9ycyBhcmUgc2lsZW5jZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lcnJvclN0YXRlID0gMTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59O1xuXG4vKlxuKiBFeGVjdXRlcyB0aGUgaGludGluZyBwcm9ncmFtIGZvciBhIGdseXBoLlxuKi9cbmV4ZWNHbHlwaCA9IGZ1bmN0aW9uKGdseXBoLCBwcmVwU3RhdGUpIHtcbiAgICAvLyBvcmlnaW5hbCBwb2ludCBwb3NpdGlvbnNcbiAgICB2YXIgeFNjYWxlID0gcHJlcFN0YXRlLnBwZW0gLyBwcmVwU3RhdGUuZm9udC51bml0c1BlckVtO1xuICAgIHZhciB5U2NhbGUgPSB4U2NhbGU7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBnbHlwaC5jb21wb25lbnRzO1xuICAgIHZhciBjb250b3VycztcbiAgICB2YXIgZ1pvbmU7XG4gICAgdmFyIHN0YXRlO1xuXG4gICAgU3RhdGUucHJvdG90eXBlID0gcHJlcFN0YXRlO1xuICAgIGlmICghY29tcG9uZW50cykge1xuICAgICAgICBzdGF0ZSA9IG5ldyBTdGF0ZSgnZ2x5ZicsIGdseXBoLmluc3RydWN0aW9ucyk7XG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBHTFlQSC0tLScpO1xuICAgICAgICAgICAgc3RhdGUuc3RlcCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGV4ZWNDb21wb25lbnQoZ2x5cGgsIHN0YXRlLCB4U2NhbGUsIHlTY2FsZSk7XG4gICAgICAgIGdab25lID0gc3RhdGUuZ1pvbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZvbnQgPSBwcmVwU3RhdGUuZm9udDtcbiAgICAgICAgZ1pvbmUgPSBbXTtcbiAgICAgICAgY29udG91cnMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgICAgICB2YXIgY2cgPSBmb250LmdseXBocy5nZXQoYy5nbHlwaEluZGV4KTtcblxuICAgICAgICAgICAgc3RhdGUgPSBuZXcgU3RhdGUoJ2dseWYnLCBjZy5pbnN0cnVjdGlvbnMpO1xuXG4gICAgICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS1FWEVDIENPTVAgJyArIGkgKyAnLS0tJyk7XG4gICAgICAgICAgICAgICAgc3RhdGUuc3RlcCA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleGVjQ29tcG9uZW50KGNnLCBzdGF0ZSwgeFNjYWxlLCB5U2NhbGUpO1xuICAgICAgICAgICAgLy8gYXBwZW5kcyB0aGUgY29tcHV0ZWQgcG9pbnRzIHRvIHRoZSByZXN1bHQgYXJyYXlcbiAgICAgICAgICAgIC8vIHBvc3QgcHJvY2Vzc2VzIHRoZSBjb21wb25lbnQgcG9pbnRzXG4gICAgICAgICAgICB2YXIgZHggPSBNYXRoLnJvdW5kKGMuZHggKiB4U2NhbGUpO1xuICAgICAgICAgICAgdmFyIGR5ID0gTWF0aC5yb3VuZChjLmR5ICogeVNjYWxlKTtcbiAgICAgICAgICAgIHZhciBneiA9IHN0YXRlLmdab25lO1xuICAgICAgICAgICAgdmFyIGNjID0gc3RhdGUuY29udG91cnM7XG4gICAgICAgICAgICBmb3IgKHZhciBwaSA9IDA7IHBpIDwgZ3oubGVuZ3RoOyBwaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBneltwaV07XG4gICAgICAgICAgICAgICAgcC54VG91Y2hlZCA9IHAueVRvdWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBwLnhvID0gcC54ID0gcC54ICsgZHg7XG4gICAgICAgICAgICAgICAgcC55byA9IHAueSA9IHAueSArIGR5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZ0xlbiA9IGdab25lLmxlbmd0aDtcbiAgICAgICAgICAgIGdab25lLnB1c2guYXBwbHkoZ1pvbmUsIGd6KTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb250b3Vycy5wdXNoKGNjW2pdICsgZ0xlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2x5cGguaW5zdHJ1Y3Rpb25zICYmICFzdGF0ZS5pbmhpYml0R3JpZEZpdCkge1xuICAgICAgICAgICAgLy8gdGhlIGNvbXBvc2l0ZSBoYXMgaW5zdHJ1Y3Rpb25zIG9uIGl0cyBvd25cbiAgICAgICAgICAgIHN0YXRlID0gbmV3IFN0YXRlKCdnbHlmJywgZ2x5cGguaW5zdHJ1Y3Rpb25zKTtcblxuICAgICAgICAgICAgc3RhdGUuZ1pvbmUgPSBzdGF0ZS56MCA9IHN0YXRlLnoxID0gc3RhdGUuejIgPSBnWm9uZTtcblxuICAgICAgICAgICAgc3RhdGUuY29udG91cnMgPSBjb250b3VycztcblxuICAgICAgICAgICAgLy8gbm90ZTogSFBaZXJvIGNhbm5vdCBiZSB1c2VkIGhlcmUsIHNpbmNlXG4gICAgICAgICAgICAvLyAgICAgICB0aGUgcG9pbnQgbWlnaHQgYmUgbW9kaWZpZWRcbiAgICAgICAgICAgIGdab25lLnB1c2goXG4gICAgICAgICAgICAgICAgbmV3IEhQb2ludCgwLCAwKSxcbiAgICAgICAgICAgICAgICBuZXcgSFBvaW50KE1hdGgucm91bmQoZ2x5cGguYWR2YW5jZVdpZHRoICogeFNjYWxlKSwgMClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLUVYRUMgQ09NUE9TSVRFLS0tJyk7XG4gICAgICAgICAgICAgICAgc3RhdGUuc3RlcCA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleGVjKHN0YXRlKTtcblxuICAgICAgICAgICAgZ1pvbmUubGVuZ3RoIC09IDI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ1pvbmU7XG59O1xuXG4vKlxuKiBFeGVjdXRlcyB0aGUgaGludGluZyBwcm9ncmFtIGZvciBhIGNvbXBvbmVudCBvZiBhIG11bHRpLWNvbXBvbmVudCBnbHlwaFxuKiBvciBvZiB0aGUgZ2x5cGggaXRzZWxmIGZvciBhIG5vbi1jb21wb25lbnQgZ2x5cGguXG4qL1xuZXhlY0NvbXBvbmVudCA9IGZ1bmN0aW9uKGdseXBoLCBzdGF0ZSwgeFNjYWxlLCB5U2NhbGUpXG57XG4gICAgdmFyIHBvaW50cyA9IGdseXBoLnBvaW50cyB8fCBbXTtcbiAgICB2YXIgcExlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgdmFyIGdab25lID0gc3RhdGUuZ1pvbmUgPSBzdGF0ZS56MCA9IHN0YXRlLnoxID0gc3RhdGUuejIgPSBbXTtcbiAgICB2YXIgY29udG91cnMgPSBzdGF0ZS5jb250b3VycyA9IFtdO1xuXG4gICAgLy8gU2NhbGVzIHRoZSBvcmlnaW5hbCBwb2ludHMgYW5kXG4gICAgLy8gbWFrZXMgY29waWVzIGZvciB0aGUgaGludGVkIHBvaW50cy5cbiAgICB2YXIgY3A7IC8vIGN1cnJlbnQgcG9pbnRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBMZW47IGkrKykge1xuICAgICAgICBjcCA9IHBvaW50c1tpXTtcblxuICAgICAgICBnWm9uZVtpXSA9IG5ldyBIUG9pbnQoXG4gICAgICAgICAgICBjcC54ICogeFNjYWxlLFxuICAgICAgICAgICAgY3AueSAqIHlTY2FsZSxcbiAgICAgICAgICAgIGNwLmxhc3RQb2ludE9mQ29udG91cixcbiAgICAgICAgICAgIGNwLm9uQ3VydmVcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBDaGFpbiBsaW5rcyB0aGUgY29udG91cnMuXG4gICAgdmFyIHNwOyAvLyBzdGFydCBwb2ludFxuICAgIHZhciBucDsgLy8gbmV4dCBwb2ludFxuXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcExlbjsgaSQxKyspIHtcbiAgICAgICAgY3AgPSBnWm9uZVtpJDFdO1xuXG4gICAgICAgIGlmICghc3ApIHtcbiAgICAgICAgICAgIHNwID0gY3A7XG4gICAgICAgICAgICBjb250b3Vycy5wdXNoKGkkMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3AubGFzdFBvaW50T2ZDb250b3VyKSB7XG4gICAgICAgICAgICBjcC5uZXh0UG9pbnRPbkNvbnRvdXIgPSBzcDtcbiAgICAgICAgICAgIHNwLnByZXZQb2ludE9uQ29udG91ciA9IGNwO1xuICAgICAgICAgICAgc3AgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBucCA9IGdab25lW2kkMSArIDFdO1xuICAgICAgICAgICAgY3AubmV4dFBvaW50T25Db250b3VyID0gbnA7XG4gICAgICAgICAgICBucC5wcmV2UG9pbnRPbkNvbnRvdXIgPSBjcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzdGF0ZS5pbmhpYml0R3JpZEZpdCkgeyByZXR1cm47IH1cblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdQUk9DRVNTSU5HIEdMWVBIJywgc3RhdGUuc3RhY2spO1xuICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBwTGVuOyBpJDIrKykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coaSQyLCBnWm9uZVtpJDJdLngsIGdab25lW2kkMl0ueSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnWm9uZS5wdXNoKFxuICAgICAgICBuZXcgSFBvaW50KDAsIDApLFxuICAgICAgICBuZXcgSFBvaW50KE1hdGgucm91bmQoZ2x5cGguYWR2YW5jZVdpZHRoICogeFNjYWxlKSwgMClcbiAgICApO1xuXG4gICAgZXhlYyhzdGF0ZSk7XG5cbiAgICAvLyBSZW1vdmVzIHRoZSBleHRyYSBwb2ludHMuXG4gICAgZ1pvbmUubGVuZ3RoIC09IDI7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICBjb25zb2xlLmxvZygnRklOSVNIRUQgR0xZUEgnLCBzdGF0ZS5zdGFjayk7XG4gICAgICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IHBMZW47IGkkMysrKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhpJDMsIGdab25lW2kkM10ueCwgZ1pvbmVbaSQzXS55KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qXG4qIEV4ZWN1dGVzIHRoZSBwcm9ncmFtIGxvYWRlZCBpbiBzdGF0ZS5cbiovXG5leGVjID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG5cbiAgICBpZiAoIXByb2cpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgcExlbiA9IHByb2cubGVuZ3RoO1xuICAgIHZhciBpbnM7XG5cbiAgICBmb3IgKHN0YXRlLmlwID0gMDsgc3RhdGUuaXAgPCBwTGVuOyBzdGF0ZS5pcCsrKSB7XG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IHN0YXRlLnN0ZXArKzsgfVxuICAgICAgICBpbnMgPSBpbnN0cnVjdGlvblRhYmxlW3Byb2dbc3RhdGUuaXBdXTtcblxuICAgICAgICBpZiAoIWlucykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICd1bmtub3duIGluc3RydWN0aW9uOiAweCcgK1xuICAgICAgICAgICAgICAgIE51bWJlcihwcm9nW3N0YXRlLmlwXSkudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5zKHN0YXRlKTtcblxuICAgICAgICAvLyB2ZXJ5IGV4dGVuc2l2ZSBkZWJ1Z2dpbmcgZm9yIGVhY2ggc3RlcFxuICAgICAgICAvKlxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgdmFyIGRhO1xuICAgICAgICAgICAgaWYgKHN0YXRlLmdab25lKSB7XG4gICAgICAgICAgICAgICAgZGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLmdab25lLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZGEucHVzaChpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmdab25lW2ldLnggKiA2NCArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5nWm9uZVtpXS55ICogNjQgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLmdab25lW2ldLnhUb3VjaGVkID8gJ3gnIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5nWm9uZVtpXS55VG91Y2hlZCA/ICd5JyA6ICcnKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnR1onLCBkYSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzdGF0ZS50Wm9uZSkge1xuICAgICAgICAgICAgICAgIGRhID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZS50Wm9uZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBkYS5wdXNoKGkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudFpvbmVbaV0ueCAqIDY0ICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLnRab25lW2ldLnkgKiA2NCArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUudFpvbmVbaV0ueFRvdWNoZWQgPyAneCcgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLnRab25lW2ldLnlUb3VjaGVkID8gJ3knIDogJycpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdUWicsIGRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0YXRlLnN0YWNrLmxlbmd0aCA+IDEwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnN0YWNrLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgJy4uLicsIHN0YXRlLnN0YWNrLnNsaWNlKHN0YXRlLnN0YWNrLmxlbmd0aCAtIDEwKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0YXRlLnN0YWNrLmxlbmd0aCwgc3RhdGUuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICovXG4gICAgfVxufTtcblxuLypcbiogSW5pdGlhbGl6ZXMgdGhlIHR3aWxpZ2h0IHpvbmUuXG4qXG4qIFRoaXMgaXMgb25seSBkb25lIGlmIGEgU1pQeCBpbnN0cnVjdGlvblxuKiByZWZlcnMgdG8gdGhlIHR3aWxpZ2h0IHpvbmUuXG4qL1xuZnVuY3Rpb24gaW5pdFRab25lKHN0YXRlKVxue1xuICAgIHZhciB0Wm9uZSA9IHN0YXRlLnRab25lID0gbmV3IEFycmF5KHN0YXRlLmdab25lLmxlbmd0aCk7XG5cbiAgICAvLyBubyBpZGVhIGlmIHRoaXMgaXMgYWN0dWFsbHkgY29ycmVjdC4uLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdFpvbmUubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgICB0Wm9uZVtpXSA9IG5ldyBIUG9pbnQoMCwgMCk7XG4gICAgfVxufVxuXG4vKlxuKiBTa2lwcyB0aGUgaW5zdHJ1Y3Rpb24gcG9pbnRlciBhaGVhZCBvdmVyIGFuIElGL0VMU0UgYmxvY2suXG4qIGhhbmRsZUVsc2UgLi4gaWYgdHJ1ZSBicmVha3Mgb24gbWF0Y2hpbmcgRUxTRVxuKi9cbmZ1bmN0aW9uIHNraXAoc3RhdGUsIGhhbmRsZUVsc2UpXG57XG4gICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuICAgIHZhciBuZXN0aW5nID0gMTtcbiAgICB2YXIgaW5zO1xuXG4gICAgZG8ge1xuICAgICAgICBpbnMgPSBwcm9nWysraXBdO1xuICAgICAgICBpZiAoaW5zID09PSAweDU4KSAvLyBJRlxuICAgICAgICAgICAgeyBuZXN0aW5nKys7IH1cbiAgICAgICAgZWxzZSBpZiAoaW5zID09PSAweDU5KSAvLyBFSUZcbiAgICAgICAgICAgIHsgbmVzdGluZy0tOyB9XG4gICAgICAgIGVsc2UgaWYgKGlucyA9PT0gMHg0MCkgLy8gTlBVU0hCXG4gICAgICAgICAgICB7IGlwICs9IHByb2dbaXAgKyAxXSArIDE7IH1cbiAgICAgICAgZWxzZSBpZiAoaW5zID09PSAweDQxKSAvLyBOUFVTSFdcbiAgICAgICAgICAgIHsgaXAgKz0gMiAqIHByb2dbaXAgKyAxXSArIDE7IH1cbiAgICAgICAgZWxzZSBpZiAoaW5zID49IDB4QjAgJiYgaW5zIDw9IDB4QjcpIC8vIFBVU0hCXG4gICAgICAgICAgICB7IGlwICs9IGlucyAtIDB4QjAgKyAxOyB9XG4gICAgICAgIGVsc2UgaWYgKGlucyA+PSAweEI4ICYmIGlucyA8PSAweEJGKSAvLyBQVVNIV1xuICAgICAgICAgICAgeyBpcCArPSAoaW5zIC0gMHhCOCArIDEpICogMjsgfVxuICAgICAgICBlbHNlIGlmIChoYW5kbGVFbHNlICYmIG5lc3RpbmcgPT09IDEgJiYgaW5zID09PSAweDFCKSAvLyBFTFNFXG4gICAgICAgICAgICB7IGJyZWFrOyB9XG4gICAgfSB3aGlsZSAobmVzdGluZyA+IDApO1xuXG4gICAgc3RhdGUuaXAgPSBpcDtcbn1cblxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKlxuKiAgICAgICAgICBBbmQgdGhlbiBhIGxvdCBvZiBpbnN0cnVjdGlvbnMuLi4gICAgICAgICAgICAgICAgKlxuKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vLyBTVlRDQVthXSBTZXQgZnJlZWRvbSBhbmQgcHJvamVjdGlvbiBWZWN0b3JzIFRvIENvb3JkaW5hdGUgQXhpc1xuLy8gMHgwMC0weDAxXG5mdW5jdGlvbiBTVlRDQSh2LCBzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTVlRDQVsnICsgdi5heGlzICsgJ10nKTsgfVxuXG4gICAgc3RhdGUuZnYgPSBzdGF0ZS5wdiA9IHN0YXRlLmRwdiA9IHY7XG59XG5cbi8vIFNQVlRDQVthXSBTZXQgUHJvamVjdGlvbiBWZWN0b3IgdG8gQ29vcmRpbmF0ZSBBeGlzXG4vLyAweDAyLTB4MDNcbmZ1bmN0aW9uIFNQVlRDQSh2LCBzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUFZUQ0FbJyArIHYuYXhpcyArICddJyk7IH1cblxuICAgIHN0YXRlLnB2ID0gc3RhdGUuZHB2ID0gdjtcbn1cblxuLy8gU0ZWVENBW2FdIFNldCBGcmVlZG9tIFZlY3RvciB0byBDb29yZGluYXRlIEF4aXNcbi8vIDB4MDQtMHgwNVxuZnVuY3Rpb24gU0ZWVENBKHYsIHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NGVlRDQVsnICsgdi5heGlzICsgJ10nKTsgfVxuXG4gICAgc3RhdGUuZnYgPSB2O1xufVxuXG4vLyBTUFZUTFthXSBTZXQgUHJvamVjdGlvbiBWZWN0b3IgVG8gTGluZVxuLy8gMHgwNi0weDA3XG5mdW5jdGlvbiBTUFZUTChhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwMmkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcDFpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAyID0gc3RhdGUuejJbcDJpXTtcbiAgICB2YXIgcDEgPSBzdGF0ZS56MVtwMWldO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coJ1NQVlRMWycgKyBhICsgJ10nLCBwMmksIHAxaSk7IH1cblxuICAgIHZhciBkeDtcbiAgICB2YXIgZHk7XG5cbiAgICBpZiAoIWEpIHtcbiAgICAgICAgZHggPSBwMS54IC0gcDIueDtcbiAgICAgICAgZHkgPSBwMS55IC0gcDIueTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkeCA9IHAyLnkgLSBwMS55O1xuICAgICAgICBkeSA9IHAxLnggLSBwMi54O1xuICAgIH1cblxuICAgIHN0YXRlLnB2ID0gc3RhdGUuZHB2ID0gZ2V0VW5pdFZlY3RvcihkeCwgZHkpO1xufVxuXG4vLyBTRlZUTFthXSBTZXQgRnJlZWRvbSBWZWN0b3IgVG8gTGluZVxuLy8gMHgwOC0weDA5XG5mdW5jdGlvbiBTRlZUTChhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwMmkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcDFpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAyID0gc3RhdGUuejJbcDJpXTtcbiAgICB2YXIgcDEgPSBzdGF0ZS56MVtwMWldO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coJ1NGVlRMWycgKyBhICsgJ10nLCBwMmksIHAxaSk7IH1cblxuICAgIHZhciBkeDtcbiAgICB2YXIgZHk7XG5cbiAgICBpZiAoIWEpIHtcbiAgICAgICAgZHggPSBwMS54IC0gcDIueDtcbiAgICAgICAgZHkgPSBwMS55IC0gcDIueTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkeCA9IHAyLnkgLSBwMS55O1xuICAgICAgICBkeSA9IHAxLnggLSBwMi54O1xuICAgIH1cblxuICAgIHN0YXRlLmZ2ID0gZ2V0VW5pdFZlY3RvcihkeCwgZHkpO1xufVxuXG4vLyBTUFZGU1tdIFNldCBQcm9qZWN0aW9uIFZlY3RvciBGcm9tIFN0YWNrXG4vLyAweDBBXG5mdW5jdGlvbiBTUFZGUyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciB5ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHggPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUFZGU1tdJywgeSwgeCk7IH1cblxuICAgIHN0YXRlLnB2ID0gc3RhdGUuZHB2ID0gZ2V0VW5pdFZlY3Rvcih4LCB5KTtcbn1cblxuLy8gU0ZWRlNbXSBTZXQgRnJlZWRvbSBWZWN0b3IgRnJvbSBTdGFja1xuLy8gMHgwQlxuZnVuY3Rpb24gU0ZWRlMoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgeSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciB4ID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1BWRlNbXScsIHksIHgpOyB9XG5cbiAgICBzdGF0ZS5mdiA9IGdldFVuaXRWZWN0b3IoeCwgeSk7XG59XG5cbi8vIEdQVltdIEdldCBQcm9qZWN0aW9uIFZlY3RvclxuLy8gMHgwQ1xuZnVuY3Rpb24gR1BWKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR1BWW10nKTsgfVxuXG4gICAgc3RhY2sucHVzaChwdi54ICogMHg0MDAwKTtcbiAgICBzdGFjay5wdXNoKHB2LnkgKiAweDQwMDApO1xufVxuXG4vLyBHRlZbXSBHZXQgRnJlZWRvbSBWZWN0b3Jcbi8vIDB4MENcbmZ1bmN0aW9uIEdGVihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dGVltdJyk7IH1cblxuICAgIHN0YWNrLnB1c2goZnYueCAqIDB4NDAwMCk7XG4gICAgc3RhY2sucHVzaChmdi55ICogMHg0MDAwKTtcbn1cblxuLy8gU0ZWVFBWW10gU2V0IEZyZWVkb20gVmVjdG9yIFRvIFByb2plY3Rpb24gVmVjdG9yXG4vLyAweDBFXG5mdW5jdGlvbiBTRlZUUFYoc3RhdGUpIHtcbiAgICBzdGF0ZS5mdiA9IHN0YXRlLnB2O1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NGVlRQVltdJyk7IH1cbn1cblxuLy8gSVNFQ1RbXSBtb3ZlcyBwb2ludCBwIHRvIHRoZSBJbnRlclNFQ1Rpb24gb2YgdHdvIGxpbmVzXG4vLyAweDBGXG5mdW5jdGlvbiBJU0VDVChzdGF0ZSlcbntcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcGEwaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwYTFpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHBiMGkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcGIxaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciB6MCA9IHN0YXRlLnowO1xuICAgIHZhciB6MSA9IHN0YXRlLnoxO1xuICAgIHZhciBwYTAgPSB6MFtwYTBpXTtcbiAgICB2YXIgcGExID0gejBbcGExaV07XG4gICAgdmFyIHBiMCA9IHoxW3BiMGldO1xuICAgIHZhciBwYjEgPSB6MVtwYjFpXTtcbiAgICB2YXIgcCA9IHN0YXRlLnoyW3BpXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKCdJU0VDVFtdLCAnLCBwYTBpLCBwYTFpLCBwYjBpLCBwYjFpLCBwaSk7IH1cblxuICAgIC8vIG1hdGggZnJvbVxuICAgIC8vIGVuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lJUUyJTgwJTkzbGluZV9pbnRlcnNlY3Rpb24jR2l2ZW5fdHdvX3BvaW50c19vbl9lYWNoX2xpbmVcblxuICAgIHZhciB4MSA9IHBhMC54O1xuICAgIHZhciB5MSA9IHBhMC55O1xuICAgIHZhciB4MiA9IHBhMS54O1xuICAgIHZhciB5MiA9IHBhMS55O1xuICAgIHZhciB4MyA9IHBiMC54O1xuICAgIHZhciB5MyA9IHBiMC55O1xuICAgIHZhciB4NCA9IHBiMS54O1xuICAgIHZhciB5NCA9IHBiMS55O1xuXG4gICAgdmFyIGRpdiA9ICh4MSAtIHgyKSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqICh4MyAtIHg0KTtcbiAgICB2YXIgZjEgPSB4MSAqIHkyIC0geTEgKiB4MjtcbiAgICB2YXIgZjIgPSB4MyAqIHk0IC0geTMgKiB4NDtcblxuICAgIHAueCA9IChmMSAqICh4MyAtIHg0KSAtIGYyICogKHgxIC0geDIpKSAvIGRpdjtcbiAgICBwLnkgPSAoZjEgKiAoeTMgLSB5NCkgLSBmMiAqICh5MSAtIHkyKSkgLyBkaXY7XG59XG5cbi8vIFNSUDBbXSBTZXQgUmVmZXJlbmNlIFBvaW50IDBcbi8vIDB4MTBcbmZ1bmN0aW9uIFNSUDAoc3RhdGUpIHtcbiAgICBzdGF0ZS5ycDAgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUlAwW10nLCBzdGF0ZS5ycDApOyB9XG59XG5cbi8vIFNSUDFbXSBTZXQgUmVmZXJlbmNlIFBvaW50IDFcbi8vIDB4MTFcbmZ1bmN0aW9uIFNSUDEoc3RhdGUpIHtcbiAgICBzdGF0ZS5ycDEgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUlAxW10nLCBzdGF0ZS5ycDEpOyB9XG59XG5cbi8vIFNSUDFbXSBTZXQgUmVmZXJlbmNlIFBvaW50IDJcbi8vIDB4MTJcbmZ1bmN0aW9uIFNSUDIoc3RhdGUpIHtcbiAgICBzdGF0ZS5ycDIgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUlAyW10nLCBzdGF0ZS5ycDIpOyB9XG59XG5cbi8vIFNaUDBbXSBTZXQgWm9uZSBQb2ludGVyIDBcbi8vIDB4MTNcbmZ1bmN0aW9uIFNaUDAoc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NaUDBbXScsIG4pOyB9XG5cbiAgICBzdGF0ZS56cDAgPSBuO1xuXG4gICAgc3dpdGNoIChuKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghc3RhdGUudFpvbmUpIHsgaW5pdFRab25lKHN0YXRlKTsgfVxuICAgICAgICAgICAgc3RhdGUuejAgPSBzdGF0ZS50Wm9uZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgOlxuICAgICAgICAgICAgc3RhdGUuejAgPSBzdGF0ZS5nWm9uZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB6b25lIHBvaW50ZXInKTtcbiAgICB9XG59XG5cbi8vIFNaUDFbXSBTZXQgWm9uZSBQb2ludGVyIDFcbi8vIDB4MTRcbmZ1bmN0aW9uIFNaUDEoc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NaUDFbXScsIG4pOyB9XG5cbiAgICBzdGF0ZS56cDEgPSBuO1xuXG4gICAgc3dpdGNoIChuKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghc3RhdGUudFpvbmUpIHsgaW5pdFRab25lKHN0YXRlKTsgfVxuICAgICAgICAgICAgc3RhdGUuejEgPSBzdGF0ZS50Wm9uZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgOlxuICAgICAgICAgICAgc3RhdGUuejEgPSBzdGF0ZS5nWm9uZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB6b25lIHBvaW50ZXInKTtcbiAgICB9XG59XG5cbi8vIFNaUDJbXSBTZXQgWm9uZSBQb2ludGVyIDJcbi8vIDB4MTVcbmZ1bmN0aW9uIFNaUDIoc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NaUDJbXScsIG4pOyB9XG5cbiAgICBzdGF0ZS56cDIgPSBuO1xuXG4gICAgc3dpdGNoIChuKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICghc3RhdGUudFpvbmUpIHsgaW5pdFRab25lKHN0YXRlKTsgfVxuICAgICAgICAgICAgc3RhdGUuejIgPSBzdGF0ZS50Wm9uZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgOlxuICAgICAgICAgICAgc3RhdGUuejIgPSBzdGF0ZS5nWm9uZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB6b25lIHBvaW50ZXInKTtcbiAgICB9XG59XG5cbi8vIFNaUFNbXSBTZXQgWm9uZSBQb2ludGVyU1xuLy8gMHgxNlxuZnVuY3Rpb24gU1pQUyhzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1pQU1tdJywgbik7IH1cblxuICAgIHN0YXRlLnpwMCA9IHN0YXRlLnpwMSA9IHN0YXRlLnpwMiA9IG47XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS50Wm9uZSkgeyBpbml0VFpvbmUoc3RhdGUpOyB9XG4gICAgICAgICAgICBzdGF0ZS56MCA9IHN0YXRlLnoxID0gc3RhdGUuejIgPSBzdGF0ZS50Wm9uZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgOlxuICAgICAgICAgICAgc3RhdGUuejAgPSBzdGF0ZS56MSA9IHN0YXRlLnoyID0gc3RhdGUuZ1pvbmU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZSBwb2ludGVyJyk7XG4gICAgfVxufVxuXG4vLyBTTE9PUFtdIFNldCBMT09QIHZhcmlhYmxlXG4vLyAweDE3XG5mdW5jdGlvbiBTTE9PUChzdGF0ZSkge1xuICAgIHN0YXRlLmxvb3AgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTTE9PUFtdJywgc3RhdGUubG9vcCk7IH1cbn1cblxuLy8gUlRHW10gUm91bmQgVG8gR3JpZFxuLy8gMHgxOFxuZnVuY3Rpb24gUlRHKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JUR1tdJyk7IH1cblxuICAgIHN0YXRlLnJvdW5kID0gcm91bmRUb0dyaWQ7XG59XG5cbi8vIFJUSEdbXSBSb3VuZCBUbyBIYWxmIEdyaWRcbi8vIDB4MTlcbmZ1bmN0aW9uIFJUSEcoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlRIR1tdJyk7IH1cblxuICAgIHN0YXRlLnJvdW5kID0gcm91bmRUb0hhbGZHcmlkO1xufVxuXG4vLyBTTURbXSBTZXQgTWluaW11bSBEaXN0YW5jZVxuLy8gMHgxQVxuZnVuY3Rpb24gU01EKHN0YXRlKSB7XG4gICAgdmFyIGQgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTTURbXScsIGQpOyB9XG5cbiAgICBzdGF0ZS5taW5EaXMgPSBkIC8gMHg0MDtcbn1cblxuLy8gRUxTRVtdIEVMU0UgY2xhdXNlXG4vLyAweDFCXG5mdW5jdGlvbiBFTFNFKHN0YXRlKSB7XG4gICAgLy8gVGhpcyBpbnN0cnVjdGlvbiBoYXMgYmVlbiByZWFjaGVkIGJ5IGV4ZWN1dGluZyBhIHRoZW4gYnJhbmNoXG4gICAgLy8gc28gaXQganVzdCBza2lwcyBhaGVhZCB1bnRpbCBtYXRjaGluZyBFSUYuXG4gICAgLy9cbiAgICAvLyBJbiBjYXNlIHRoZSBJRiB3YXMgbmVnYXRpdmUgdGhlIElGW10gaW5zdHJ1Y3Rpb24gYWxyZWFkeVxuICAgIC8vIHNraXBwZWQgZm9yd2FyZCBvdmVyIHRoZSBFTFNFW11cblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdFTFNFW10nKTsgfVxuXG4gICAgc2tpcChzdGF0ZSwgZmFsc2UpO1xufVxuXG4vLyBKTVBSW10gSnVNUCBSZWxhdGl2ZVxuLy8gMHgxQ1xuZnVuY3Rpb24gSk1QUihzdGF0ZSkge1xuICAgIHZhciBvID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnSk1QUltdJywgbyk7IH1cblxuICAgIC8vIEEganVtcCBieSAxIHdvdWxkIGRvIG5vdGhpbmcuXG4gICAgc3RhdGUuaXAgKz0gbyAtIDE7XG59XG5cbi8vIFNDVlRDSVtdIFNldCBDb250cm9sIFZhbHVlIFRhYmxlIEN1dC1JblxuLy8gMHgxRFxuZnVuY3Rpb24gU0NWVENJKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTQ1ZUQ0lbXScsIG4pOyB9XG5cbiAgICBzdGF0ZS5jdkN1dEluID0gbiAvIDB4NDA7XG59XG5cbi8vIERVUFtdIERVUGxpY2F0ZSB0b3Agc3RhY2sgZWxlbWVudFxuLy8gMHgyMFxuZnVuY3Rpb24gRFVQKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRFVQW10nKTsgfVxuXG4gICAgc3RhY2sucHVzaChzdGFja1tzdGFjay5sZW5ndGggLSAxXSk7XG59XG5cbi8vIFBPUFtdIFBPUCB0b3Agc3RhY2sgZWxlbWVudFxuLy8gMHgyMVxuZnVuY3Rpb24gUE9QKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1BPUFtdJyk7IH1cblxuICAgIHN0YXRlLnN0YWNrLnBvcCgpO1xufVxuXG4vLyBDTEVBUltdIENMRUFSIHRoZSBzdGFja1xuLy8gMHgyMlxuZnVuY3Rpb24gQ0xFQVIoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQ0xFQVJbXScpOyB9XG5cbiAgICBzdGF0ZS5zdGFjay5sZW5ndGggPSAwO1xufVxuXG4vLyBTV0FQW10gU1dBUCB0aGUgdG9wIHR3byBlbGVtZW50cyBvbiB0aGUgc3RhY2tcbi8vIDB4MjNcbmZ1bmN0aW9uIFNXQVAoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuICAgIHZhciBhID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGIgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTV0FQW10nKTsgfVxuXG4gICAgc3RhY2sucHVzaChhKTtcbiAgICBzdGFjay5wdXNoKGIpO1xufVxuXG4vLyBERVBUSFtdIERFUFRIIG9mIHRoZSBzdGFja1xuLy8gMHgyNFxuZnVuY3Rpb24gREVQVEgoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdERVBUSFtdJyk7IH1cblxuICAgIHN0YWNrLnB1c2goc3RhY2subGVuZ3RoKTtcbn1cblxuLy8gTE9PUENBTExbXSBMT09QQ0FMTCBmdW5jdGlvblxuLy8gMHgyQVxuZnVuY3Rpb24gTE9PUENBTEwoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZm4gPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgYyA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0xPT1BDQUxMW10nLCBmbiwgYyk7IH1cblxuICAgIC8vIHNhdmVzIGNhbGxlcnMgcHJvZ3JhbVxuICAgIHZhciBjaXAgPSBzdGF0ZS5pcDtcbiAgICB2YXIgY3Byb2cgPSBzdGF0ZS5wcm9nO1xuXG4gICAgc3RhdGUucHJvZyA9IHN0YXRlLmZ1bmNzW2ZuXTtcblxuICAgIC8vIGV4ZWN1dGVzIHRoZSBmdW5jdGlvblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYzsgaSsrKSB7XG4gICAgICAgIGV4ZWMoc3RhdGUpO1xuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgKytzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgaSArIDEgPCBjID8gJ25leHQgbG9vcGNhbGwnIDogJ2RvbmUgbG9vcGNhbGwnLFxuICAgICAgICAgICAgaVxuICAgICAgICApOyB9XG4gICAgfVxuXG4gICAgLy8gcmVzdG9yZXMgdGhlIGNhbGxlcnMgcHJvZ3JhbVxuICAgIHN0YXRlLmlwID0gY2lwO1xuICAgIHN0YXRlLnByb2cgPSBjcHJvZztcbn1cblxuLy8gQ0FMTFtdIENBTEwgZnVuY3Rpb25cbi8vIDB4MkJcbmZ1bmN0aW9uIENBTEwoc3RhdGUpIHtcbiAgICB2YXIgZm4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdDQUxMW10nLCBmbik7IH1cblxuICAgIC8vIHNhdmVzIGNhbGxlcnMgcHJvZ3JhbVxuICAgIHZhciBjaXAgPSBzdGF0ZS5pcDtcbiAgICB2YXIgY3Byb2cgPSBzdGF0ZS5wcm9nO1xuXG4gICAgc3RhdGUucHJvZyA9IHN0YXRlLmZ1bmNzW2ZuXTtcblxuICAgIC8vIGV4ZWN1dGVzIHRoZSBmdW5jdGlvblxuICAgIGV4ZWMoc3RhdGUpO1xuXG4gICAgLy8gcmVzdG9yZXMgdGhlIGNhbGxlcnMgcHJvZ3JhbVxuICAgIHN0YXRlLmlwID0gY2lwO1xuICAgIHN0YXRlLnByb2cgPSBjcHJvZztcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKCsrc3RhdGUuc3RlcCwgJ3JldHVybmluZyBmcm9tJywgZm4pOyB9XG59XG5cbi8vIENJTkRFWFtdIENvcHkgdGhlIElOREVYZWQgZWxlbWVudCB0byB0aGUgdG9wIG9mIHRoZSBzdGFja1xuLy8gMHgyNVxuZnVuY3Rpb24gQ0lOREVYKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGsgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdDSU5ERVhbXScsIGspOyB9XG5cbiAgICAvLyBJbiBjYXNlIG9mIGsgPT0gMSwgaXQgY29waWVzIHRoZSBsYXN0IGVsZW1lbnQgYWZ0ZXIgcG9wcGluZ1xuICAgIC8vIHRodXMgc3RhY2subGVuZ3RoIC0gay5cbiAgICBzdGFjay5wdXNoKHN0YWNrW3N0YWNrLmxlbmd0aCAtIGtdKTtcbn1cblxuLy8gTUlOREVYW10gTW92ZSB0aGUgSU5ERVhlZCBlbGVtZW50IHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4vLyAweDI2XG5mdW5jdGlvbiBNSU5ERVgoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgayA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01JTkRFWFtdJywgayk7IH1cblxuICAgIHN0YWNrLnB1c2goc3RhY2suc3BsaWNlKHN0YWNrLmxlbmd0aCAtIGssIDEpWzBdKTtcbn1cblxuLy8gRkRFRltdIEZ1bmN0aW9uIERFRmluaXRpb25cbi8vIDB4MkNcbmZ1bmN0aW9uIEZERUYoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUuZW52ICE9PSAnZnBnbScpIHsgdGhyb3cgbmV3IEVycm9yKCdGREVGIG5vdCBhbGxvd2VkIGhlcmUnKTsgfVxuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcbiAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcblxuICAgIHZhciBmbiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBpcEJlZ2luID0gaXA7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRkRFRltdJywgZm4pOyB9XG5cbiAgICB3aGlsZSAocHJvZ1srK2lwXSAhPT0gMHgyRCl7ICB9XG5cbiAgICBzdGF0ZS5pcCA9IGlwO1xuICAgIHN0YXRlLmZ1bmNzW2ZuXSA9IHByb2cuc2xpY2UoaXBCZWdpbiArIDEsIGlwKTtcbn1cblxuLy8gTURBUFthXSBNb3ZlIERpcmVjdCBBYnNvbHV0ZSBQb2ludFxuLy8gMHgyRS0weDJGXG5mdW5jdGlvbiBNREFQKHJvdW5kLCBzdGF0ZSkge1xuICAgIHZhciBwaSA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuICAgIHZhciBwID0gc3RhdGUuejBbcGldO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01EQVBbJyArIHJvdW5kICsgJ10nLCBwaSk7IH1cblxuICAgIHZhciBkID0gcHYuZGlzdGFuY2UocCwgSFBaZXJvKTtcblxuICAgIGlmIChyb3VuZCkgeyBkID0gc3RhdGUucm91bmQoZCk7IH1cblxuICAgIGZ2LnNldFJlbGF0aXZlKHAsIEhQWmVybywgZCwgcHYpO1xuICAgIGZ2LnRvdWNoKHApO1xuXG4gICAgc3RhdGUucnAwID0gc3RhdGUucnAxID0gcGk7XG59XG5cbi8vIElVUFthXSBJbnRlcnBvbGF0ZSBVbnRvdWNoZWQgUG9pbnRzIHRocm91Z2ggdGhlIG91dGxpbmVcbi8vIDB4MzBcbmZ1bmN0aW9uIElVUCh2LCBzdGF0ZSkge1xuICAgIHZhciB6MiA9IHN0YXRlLnoyO1xuICAgIHZhciBwTGVuID0gejIubGVuZ3RoIC0gMjtcbiAgICB2YXIgY3A7XG4gICAgdmFyIHBwO1xuICAgIHZhciBucDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdJVVBbJyArIHYuYXhpcyArICddJyk7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcExlbjsgaSsrKSB7XG4gICAgICAgIGNwID0gejJbaV07IC8vIGN1cnJlbnQgcG9pbnRcblxuICAgICAgICAvLyBpZiB0aGlzIHBvaW50IGhhcyBiZWVuIHRvdWNoZWQgZ28gb25cbiAgICAgICAgaWYgKHYudG91Y2hlZChjcCkpIHsgY29udGludWU7IH1cblxuICAgICAgICBwcCA9IGNwLnByZXZUb3VjaGVkKHYpO1xuXG4gICAgICAgIC8vIG5vIHBvaW50IG9uIHRoZSBjb250b3VyIGhhcyBiZWVuIHRvdWNoZWQ/XG4gICAgICAgIGlmIChwcCA9PT0gY3ApIHsgY29udGludWU7IH1cblxuICAgICAgICBucCA9IGNwLm5leHRUb3VjaGVkKHYpO1xuXG4gICAgICAgIGlmIChwcCA9PT0gbnApIHtcbiAgICAgICAgICAgIC8vIG9ubHkgb25lIHBvaW50IG9uIHRoZSBjb250b3VyIGhhcyBiZWVuIHRvdWNoZWRcbiAgICAgICAgICAgIC8vIHNvIHNpbXBseSBtb3ZlcyB0aGUgcG9pbnQgbGlrZSB0aGF0XG5cbiAgICAgICAgICAgIHYuc2V0UmVsYXRpdmUoY3AsIGNwLCB2LmRpc3RhbmNlKHBwLCBwcCwgZmFsc2UsIHRydWUpLCB2LCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHYuaW50ZXJwb2xhdGUoY3AsIHBwLCBucCwgdik7XG4gICAgfVxufVxuXG4vLyBTSFBbXSBTSGlmdCBQb2ludCB1c2luZyByZWZlcmVuY2UgcG9pbnRcbi8vIDB4MzItMHgzM1xuZnVuY3Rpb24gU0hQKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHJwaSA9IGEgPyBzdGF0ZS5ycDEgOiBzdGF0ZS5ycDI7XG4gICAgdmFyIHJwID0gKGEgPyBzdGF0ZS56MCA6IHN0YXRlLnoxKVtycGldO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuICAgIHZhciBsb29wID0gc3RhdGUubG9vcDtcbiAgICB2YXIgejIgPSBzdGF0ZS56MjtcblxuICAgIHdoaWxlIChsb29wLS0pXG4gICAge1xuICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHAgPSB6MltwaV07XG5cbiAgICAgICAgdmFyIGQgPSBwdi5kaXN0YW5jZShycCwgcnAsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpO1xuICAgICAgICBmdi50b3VjaChwKTtcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICAgICAoc3RhdGUubG9vcCA+IDEgP1xuICAgICAgICAgICAgICAgICAgICdsb29wICcgKyAoc3RhdGUubG9vcCAtIGxvb3ApICsgJzogJyA6XG4gICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgICAnU0hQWycgKyAoYSA/ICdycDEnIDogJ3JwMicpICsgJ10nLCBwaVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLmxvb3AgPSAxO1xufVxuXG4vLyBTSENbXSBTSGlmdCBDb250b3VyIHVzaW5nIHJlZmVyZW5jZSBwb2ludFxuLy8gMHgzNi0weDM3XG5mdW5jdGlvbiBTSEMoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcnBpID0gYSA/IHN0YXRlLnJwMSA6IHN0YXRlLnJwMjtcbiAgICB2YXIgcnAgPSAoYSA/IHN0YXRlLnowIDogc3RhdGUuejEpW3JwaV07XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG4gICAgdmFyIGNpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHNwID0gc3RhdGUuejJbc3RhdGUuY29udG91cnNbY2ldXTtcbiAgICB2YXIgcCA9IHNwO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NIQ1snICsgYSArICddJywgY2kpOyB9XG5cbiAgICB2YXIgZCA9IHB2LmRpc3RhbmNlKHJwLCBycCwgZmFsc2UsIHRydWUpO1xuXG4gICAgZG8ge1xuICAgICAgICBpZiAocCAhPT0gcnApIHsgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpOyB9XG4gICAgICAgIHAgPSBwLm5leHRQb2ludE9uQ29udG91cjtcbiAgICB9IHdoaWxlIChwICE9PSBzcCk7XG59XG5cbi8vIFNIWltdIFNIaWZ0IFpvbmUgdXNpbmcgcmVmZXJlbmNlIHBvaW50XG4vLyAweDM2LTB4MzdcbmZ1bmN0aW9uIFNIWihhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBycGkgPSBhID8gc3RhdGUucnAxIDogc3RhdGUucnAyO1xuICAgIHZhciBycCA9IChhID8gc3RhdGUuejAgOiBzdGF0ZS56MSlbcnBpXTtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcblxuICAgIHZhciBlID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0haWycgKyBhICsgJ10nLCBlKTsgfVxuXG4gICAgdmFyIHo7XG4gICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgMCA6IHogPSBzdGF0ZS50Wm9uZTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMSA6IHogPSBzdGF0ZS5nWm9uZTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQgOiB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgem9uZScpO1xuICAgIH1cblxuICAgIHZhciBwO1xuICAgIHZhciBkID0gcHYuZGlzdGFuY2UocnAsIHJwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgdmFyIHBMZW4gPSB6Lmxlbmd0aCAtIDI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwTGVuOyBpKyspXG4gICAge1xuICAgICAgICBwID0geltpXTtcbiAgICAgICAgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpO1xuICAgICAgICAvL2lmIChwICE9PSBycCkgZnYuc2V0UmVsYXRpdmUocCwgcCwgZCwgcHYpO1xuICAgIH1cbn1cblxuLy8gU0hQSVhbXSBTSGlmdCBwb2ludCBieSBhIFBJWGVsIGFtb3VudFxuLy8gMHgzOFxuZnVuY3Rpb24gU0hQSVgoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbG9vcCA9IHN0YXRlLmxvb3A7XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIGQgPSBzdGFjay5wb3AoKSAvIDB4NDA7XG4gICAgdmFyIHoyID0gc3RhdGUuejI7XG5cbiAgICB3aGlsZSAobG9vcC0tKSB7XG4gICAgICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcCA9IHoyW3BpXTtcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICAgICAoc3RhdGUubG9vcCA+IDEgPyAnbG9vcCAnICsgKHN0YXRlLmxvb3AgLSBsb29wKSArICc6ICcgOiAnJykgK1xuICAgICAgICAgICAgICAgICdTSFBJWFtdJywgcGksIGRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBwLCBkKTtcbiAgICAgICAgZnYudG91Y2gocCk7XG4gICAgfVxuXG4gICAgc3RhdGUubG9vcCA9IDE7XG59XG5cbi8vIElQW10gSW50ZXJwb2xhdGUgUG9pbnRcbi8vIDB4MzlcbmZ1bmN0aW9uIElQKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHJwMWkgPSBzdGF0ZS5ycDE7XG4gICAgdmFyIHJwMmkgPSBzdGF0ZS5ycDI7XG4gICAgdmFyIGxvb3AgPSBzdGF0ZS5sb29wO1xuICAgIHZhciBycDEgPSBzdGF0ZS56MFtycDFpXTtcbiAgICB2YXIgcnAyID0gc3RhdGUuejFbcnAyaV07XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUuZHB2O1xuICAgIHZhciB6MiA9IHN0YXRlLnoyO1xuXG4gICAgd2hpbGUgKGxvb3AtLSkge1xuICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHAgPSB6MltwaV07XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxvb3AgPiAxID8gJ2xvb3AgJyArIChzdGF0ZS5sb29wIC0gbG9vcCkgKyAnOiAnIDogJycpICtcbiAgICAgICAgICAgICAgICAnSVBbXScsIHBpLCBycDFpLCAnPC0+JywgcnAyaVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ2LmludGVycG9sYXRlKHAsIHJwMSwgcnAyLCBwdik7XG5cbiAgICAgICAgZnYudG91Y2gocCk7XG4gICAgfVxuXG4gICAgc3RhdGUubG9vcCA9IDE7XG59XG5cbi8vIE1TSVJQW2FdIE1vdmUgU3RhY2sgSW5kaXJlY3QgUmVsYXRpdmUgUG9pbnRcbi8vIDB4M0EtMHgzQlxuZnVuY3Rpb24gTVNJUlAoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZCA9IHN0YWNrLnBvcCgpIC8gNjQ7XG4gICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAgPSBzdGF0ZS56MVtwaV07XG4gICAgdmFyIHJwMCA9IHN0YXRlLnowW3N0YXRlLnJwMF07XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG5cbiAgICBmdi5zZXRSZWxhdGl2ZShwLCBycDAsIGQsIHB2KTtcbiAgICBmdi50b3VjaChwKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNU0lSUFsnICsgYSArICddJywgZCwgcGkpOyB9XG5cbiAgICBzdGF0ZS5ycDEgPSBzdGF0ZS5ycDA7XG4gICAgc3RhdGUucnAyID0gcGk7XG4gICAgaWYgKGEpIHsgc3RhdGUucnAwID0gcGk7IH1cbn1cblxuLy8gQUxJR05SUFtdIEFsaWduIHRvIHJlZmVyZW5jZSBwb2ludC5cbi8vIDB4M0NcbmZ1bmN0aW9uIEFMSUdOUlAoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcnAwaSA9IHN0YXRlLnJwMDtcbiAgICB2YXIgcnAwID0gc3RhdGUuejBbcnAwaV07XG4gICAgdmFyIGxvb3AgPSBzdGF0ZS5sb29wO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuICAgIHZhciB6MSA9IHN0YXRlLnoxO1xuXG4gICAgd2hpbGUgKGxvb3AtLSkge1xuICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIHAgPSB6MVtwaV07XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxvb3AgPiAxID8gJ2xvb3AgJyArIChzdGF0ZS5sb29wIC0gbG9vcCkgKyAnOiAnIDogJycpICtcbiAgICAgICAgICAgICAgICAnQUxJR05SUFtdJywgcGlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBycDAsIDAsIHB2KTtcbiAgICAgICAgZnYudG91Y2gocCk7XG4gICAgfVxuXG4gICAgc3RhdGUubG9vcCA9IDE7XG59XG5cbi8vIFJUR1tdIFJvdW5kIFRvIERvdWJsZSBHcmlkXG4vLyAweDNEXG5mdW5jdGlvbiBSVERHKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JUREdbXScpOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kVG9Eb3VibGVHcmlkO1xufVxuXG4vLyBNSUFQW2FdIE1vdmUgSW5kaXJlY3QgQWJzb2x1dGUgUG9pbnRcbi8vIDB4M0UtMHgzRlxuZnVuY3Rpb24gTUlBUChyb3VuZCwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwID0gc3RhdGUuejBbcGldO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuICAgIHZhciBjdiA9IHN0YXRlLmN2dFtuXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICdNSUFQWycgKyByb3VuZCArICddJyxcbiAgICAgICAgICAgIG4sICcoJywgY3YsICcpJywgcGlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgZCA9IHB2LmRpc3RhbmNlKHAsIEhQWmVybyk7XG5cbiAgICBpZiAocm91bmQpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGQgLSBjdikgPCBzdGF0ZS5jdkN1dEluKSB7IGQgPSBjdjsgfVxuXG4gICAgICAgIGQgPSBzdGF0ZS5yb3VuZChkKTtcbiAgICB9XG5cbiAgICBmdi5zZXRSZWxhdGl2ZShwLCBIUFplcm8sIGQsIHB2KTtcblxuICAgIGlmIChzdGF0ZS56cDAgPT09IDApIHtcbiAgICAgICAgcC54byA9IHAueDtcbiAgICAgICAgcC55byA9IHAueTtcbiAgICB9XG5cbiAgICBmdi50b3VjaChwKTtcblxuICAgIHN0YXRlLnJwMCA9IHN0YXRlLnJwMSA9IHBpO1xufVxuXG4vLyBOUFVTQltdIFBVU0ggTiBCeXRlc1xuLy8gMHg0MFxuZnVuY3Rpb24gTlBVU0hCKHN0YXRlKSB7XG4gICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG4gICAgdmFyIG4gPSBwcm9nWysraXBdO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05QVVNIQltdJywgbik7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7IHN0YWNrLnB1c2gocHJvZ1srK2lwXSk7IH1cblxuICAgIHN0YXRlLmlwID0gaXA7XG59XG5cbi8vIE5QVVNIV1tdIFBVU0ggTiBXb3Jkc1xuLy8gMHg0MVxuZnVuY3Rpb24gTlBVU0hXKHN0YXRlKSB7XG4gICAgdmFyIGlwID0gc3RhdGUuaXA7XG4gICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gcHJvZ1srK2lwXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdOUFVTSFdbXScsIG4pOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgdyA9IChwcm9nWysraXBdIDw8IDgpIHwgcHJvZ1srK2lwXTtcbiAgICAgICAgaWYgKHcgJiAweDgwMDApIHsgdyA9IC0oKHcgXiAweGZmZmYpICsgMSk7IH1cbiAgICAgICAgc3RhY2sucHVzaCh3KTtcbiAgICB9XG5cbiAgICBzdGF0ZS5pcCA9IGlwO1xufVxuXG4vLyBXU1tdIFdyaXRlIFN0b3JlXG4vLyAweDQyXG5mdW5jdGlvbiBXUyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBzdG9yZSA9IHN0YXRlLnN0b3JlO1xuXG4gICAgaWYgKCFzdG9yZSkgeyBzdG9yZSA9IHN0YXRlLnN0b3JlID0gW107IH1cblxuICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGwgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdXUycsIHYsIGwpOyB9XG5cbiAgICBzdG9yZVtsXSA9IHY7XG59XG5cbi8vIFJTW10gUmVhZCBTdG9yZVxuLy8gMHg0M1xuZnVuY3Rpb24gUlMoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgc3RvcmUgPSBzdGF0ZS5zdG9yZTtcblxuICAgIHZhciBsID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlMnLCBsKTsgfVxuXG4gICAgdmFyIHYgPSAoc3RvcmUgJiYgc3RvcmVbbF0pIHx8IDA7XG5cbiAgICBzdGFjay5wdXNoKHYpO1xufVxuXG4vLyBXQ1ZUUFtdIFdyaXRlIENvbnRyb2wgVmFsdWUgVGFibGUgaW4gUGl4ZWwgdW5pdHNcbi8vIDB4NDRcbmZ1bmN0aW9uIFdDVlRQKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cbiAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBsID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnV0NWVFAnLCB2LCBsKTsgfVxuXG4gICAgc3RhdGUuY3Z0W2xdID0gdiAvIDB4NDA7XG59XG5cbi8vIFJDVlRbXSBSZWFkIENvbnRyb2wgVmFsdWUgVGFibGUgZW50cnlcbi8vIDB4NDVcbmZ1bmN0aW9uIFJDVlQoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgY3Z0ZSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JDVlQnLCBjdnRlKTsgfVxuXG4gICAgc3RhY2sucHVzaChzdGF0ZS5jdnRbY3Z0ZV0gKiAweDQwKTtcbn1cblxuLy8gR0NbXSBHZXQgQ29vcmRpbmF0ZSBwcm9qZWN0ZWQgb250byB0aGUgcHJvamVjdGlvbiB2ZWN0b3Jcbi8vIDB4NDYtMHg0N1xuZnVuY3Rpb24gR0MoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcCA9IHN0YXRlLnoyW3BpXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHQ1snICsgYSArICddJywgcGkpOyB9XG5cbiAgICBzdGFjay5wdXNoKHN0YXRlLmRwdi5kaXN0YW5jZShwLCBIUFplcm8sIGEsIGZhbHNlKSAqIDB4NDApO1xufVxuXG4vLyBNRFthXSBNZWFzdXJlIERpc3RhbmNlXG4vLyAweDQ5LTB4NEFcbmZ1bmN0aW9uIE1EKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHBpMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwaTEgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcDIgPSBzdGF0ZS56MVtwaTJdO1xuICAgIHZhciBwMSA9IHN0YXRlLnowW3BpMV07XG4gICAgdmFyIGQgPSBzdGF0ZS5kcHYuZGlzdGFuY2UocDEsIHAyLCBhLCBhKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNRFsnICsgYSArICddJywgcGkyLCBwaTEsICctPicsIGQpOyB9XG5cbiAgICBzdGF0ZS5zdGFjay5wdXNoKE1hdGgucm91bmQoZCAqIDY0KSk7XG59XG5cbi8vIE1QUEVNW10gTWVhc3VyZSBQaXhlbHMgUGVyIEVNXG4vLyAweDRCXG5mdW5jdGlvbiBNUFBFTShzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNUFBFTVtdJyk7IH1cbiAgICBzdGF0ZS5zdGFjay5wdXNoKHN0YXRlLnBwZW0pO1xufVxuXG4vLyBGTElQT05bXSBzZXQgdGhlIGF1dG8gRkxJUCBCb29sZWFuIHRvIE9OXG4vLyAweDREXG5mdW5jdGlvbiBGTElQT04oc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRkxJUE9OW10nKTsgfVxuICAgIHN0YXRlLmF1dG9GbGlwID0gdHJ1ZTtcbn1cblxuLy8gTFRbXSBMZXNzIFRoYW5cbi8vIDB4NTBcbmZ1bmN0aW9uIExUKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTFRbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTEgPCBlMiA/IDEgOiAwKTtcbn1cblxuLy8gTFRFUVtdIExlc3MgVGhhbiBvciBFUXVhbFxuLy8gMHg1M1xuZnVuY3Rpb24gTFRFUShzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0xURVFbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTEgPD0gZTIgPyAxIDogMCk7XG59XG5cbi8vIEdURVFbXSBHcmVhdGVyIFRoYW5cbi8vIDB4NTJcbmZ1bmN0aW9uIEdUKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR1RbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTEgPiBlMiA/IDEgOiAwKTtcbn1cblxuLy8gR1RFUVtdIEdyZWF0ZXIgVGhhbiBvciBFUXVhbFxuLy8gMHg1M1xuZnVuY3Rpb24gR1RFUShzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dURVFbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTEgPj0gZTIgPyAxIDogMCk7XG59XG5cbi8vIEVRW10gRVF1YWxcbi8vIDB4NTRcbmZ1bmN0aW9uIEVRKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRVFbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTIgPT09IGUxID8gMSA6IDApO1xufVxuXG4vLyBORVFbXSBOb3QgRVF1YWxcbi8vIDB4NTVcbmZ1bmN0aW9uIE5FUShzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05FUVtdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChlMiAhPT0gZTEgPyAxIDogMCk7XG59XG5cbi8vIE9ERFtdIE9ERFxuLy8gMHg1NlxuZnVuY3Rpb24gT0REKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdPRERbXScsIG4pOyB9XG5cbiAgICBzdGFjay5wdXNoKE1hdGgudHJ1bmMobikgJSAyID8gMSA6IDApO1xufVxuXG4vLyBFVkVOW10gRVZFTlxuLy8gMHg1N1xuZnVuY3Rpb24gRVZFTihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRVZFTltdJywgbik7IH1cblxuICAgIHN0YWNrLnB1c2goTWF0aC50cnVuYyhuKSAlIDIgPyAwIDogMSk7XG59XG5cbi8vIElGW10gSUYgdGVzdFxuLy8gMHg1OFxuZnVuY3Rpb24gSUYoc3RhdGUpIHtcbiAgICB2YXIgdGVzdCA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuICAgIHZhciBpbnM7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnSUZbXScsIHRlc3QpOyB9XG5cbiAgICAvLyBpZiB0ZXN0IGlzIHRydWUgaXQganVzdCBjb250aW51ZXNcbiAgICAvLyBpZiBub3QgdGhlIGlwIGlzIHNraXBwZWQgdW50aWwgbWF0Y2hpbmcgRUxTRSBvciBFSUZcbiAgICBpZiAoIXRlc3QpIHtcbiAgICAgICAgc2tpcChzdGF0ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgaW5zID09PSAweDFCID8gJ0VMU0VbXScgOiAnRUlGW10nKTsgfVxuICAgIH1cbn1cblxuLy8gRUlGW10gRW5kIElGXG4vLyAweDU5XG5mdW5jdGlvbiBFSUYoc3RhdGUpIHtcbiAgICAvLyB0aGlzIGNhbiBiZSByZWFjaGVkIG5vcm1hbGx5IHdoZW5cbiAgICAvLyBleGVjdXRpbmcgYW4gZWxzZSBicmFuY2guXG4gICAgLy8gLT4ganVzdCBpZ25vcmUgaXRcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdFSUZbXScpOyB9XG59XG5cbi8vIEFORFtdIGxvZ2ljYWwgQU5EXG4vLyAweDVBXG5mdW5jdGlvbiBBTkQoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdBTkRbXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goZTIgJiYgZTEgPyAxIDogMCk7XG59XG5cbi8vIE9SW10gbG9naWNhbCBPUlxuLy8gMHg1QlxuZnVuY3Rpb24gT1Ioc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdPUltdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChlMiB8fCBlMSA/IDEgOiAwKTtcbn1cblxuLy8gTk9UW10gbG9naWNhbCBOT1Rcbi8vIDB4NUNcbmZ1bmN0aW9uIE5PVChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTk9UW10nLCBlKTsgfVxuXG4gICAgc3RhY2sucHVzaChlID8gMCA6IDEpO1xufVxuXG4vLyBERUxUQVAxW10gREVMVEEgZXhjZXB0aW9uIFAxXG4vLyBERUxUQVAyW10gREVMVEEgZXhjZXB0aW9uIFAyXG4vLyBERUxUQVAzW10gREVMVEEgZXhjZXB0aW9uIFAzXG4vLyAweDVELCAweDcxLCAweDcyXG5mdW5jdGlvbiBERUxUQVAxMjMoYiwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuICAgIHZhciBwcGVtID0gc3RhdGUucHBlbTtcbiAgICB2YXIgYmFzZSA9IHN0YXRlLmRlbHRhQmFzZSArIChiIC0gMSkgKiAxNjtcbiAgICB2YXIgZHMgPSBzdGF0ZS5kZWx0YVNoaWZ0O1xuICAgIHZhciB6MCA9IHN0YXRlLnowO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RFTFRBUFsnICsgYiArICddJywgbiwgc3RhY2spOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIGFyZyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgYXBwZW0gPSBiYXNlICsgKChhcmcgJiAweEYwKSA+PiA0KTtcbiAgICAgICAgaWYgKGFwcGVtICE9PSBwcGVtKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgdmFyIG1hZyA9IChhcmcgJiAweDBGKSAtIDg7XG4gICAgICAgIGlmIChtYWcgPj0gMCkgeyBtYWcrKzsgfVxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFQRklYJywgcGksICdieScsIG1hZyAqIGRzKTsgfVxuXG4gICAgICAgIHZhciBwID0gejBbcGldO1xuICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBwLCBtYWcgKiBkcywgcHYpO1xuICAgIH1cbn1cblxuLy8gU0RCW10gU2V0IERlbHRhIEJhc2UgaW4gdGhlIGdyYXBoaWNzIHN0YXRlXG4vLyAweDVFXG5mdW5jdGlvbiBTREIoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NEQltdJywgbik7IH1cblxuICAgIHN0YXRlLmRlbHRhQmFzZSA9IG47XG59XG5cbi8vIFNEU1tdIFNldCBEZWx0YSBTaGlmdCBpbiB0aGUgZ3JhcGhpY3Mgc3RhdGVcbi8vIDB4NUZcbmZ1bmN0aW9uIFNEUyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0RTW10nLCBuKTsgfVxuXG4gICAgc3RhdGUuZGVsdGFTaGlmdCA9IE1hdGgucG93KDAuNSwgbik7XG59XG5cbi8vIEFERFtdIEFERFxuLy8gMHg2MFxuZnVuY3Rpb24gQUREKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4yID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIG4xID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQUREW10nLCBuMiwgbjEpOyB9XG5cbiAgICBzdGFjay5wdXNoKG4xICsgbjIpO1xufVxuXG4vLyBTVUJbXSBTVUJcbi8vIDB4NjFcbmZ1bmN0aW9uIFNVQihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBuMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NVQltdJywgbjIsIG4xKTsgfVxuXG4gICAgc3RhY2sucHVzaChuMSAtIG4yKTtcbn1cblxuLy8gRElWW10gRElWXG4vLyAweDYyXG5mdW5jdGlvbiBESVYoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbjIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbjEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdESVZbXScsIG4yLCBuMSk7IH1cblxuICAgIHN0YWNrLnB1c2gobjEgKiA2NCAvIG4yKTtcbn1cblxuLy8gTVVMW10gTVVMXG4vLyAweDYzXG5mdW5jdGlvbiBNVUwoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbjIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbjEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNVUxbXScsIG4yLCBuMSk7IH1cblxuICAgIHN0YWNrLnB1c2gobjEgKiBuMiAvIDY0KTtcbn1cblxuLy8gQUJTW10gQUJTb2x1dGUgdmFsdWVcbi8vIDB4NjRcbmZ1bmN0aW9uIEFCUyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQUJTW10nLCBuKTsgfVxuXG4gICAgc3RhY2sucHVzaChNYXRoLmFicyhuKSk7XG59XG5cbi8vIE5FR1tdIE5FR2F0ZVxuLy8gMHg2NVxuZnVuY3Rpb24gTkVHKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdORUdbXScsIG4pOyB9XG5cbiAgICBzdGFjay5wdXNoKC1uKTtcbn1cblxuLy8gRkxPT1JbXSBGTE9PUlxuLy8gMHg2NlxuZnVuY3Rpb24gRkxPT1Ioc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0ZMT09SW10nLCBuKTsgfVxuXG4gICAgc3RhY2sucHVzaChNYXRoLmZsb29yKG4gLyAweDQwKSAqIDB4NDApO1xufVxuXG4vLyBDRUlMSU5HW10gQ0VJTElOR1xuLy8gMHg2N1xuZnVuY3Rpb24gQ0VJTElORyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnQ0VJTElOR1tdJywgbik7IH1cblxuICAgIHN0YWNrLnB1c2goTWF0aC5jZWlsKG4gLyAweDQwKSAqIDB4NDApO1xufVxuXG4vLyBST1VORFthYl0gUk9VTkQgdmFsdWVcbi8vIDB4NjgtMHg2QlxuZnVuY3Rpb24gUk9VTkQoZHQsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdST1VORFtdJyk7IH1cblxuICAgIHN0YWNrLnB1c2goc3RhdGUucm91bmQobiAvIDB4NDApICogMHg0MCk7XG59XG5cbi8vIFdDVlRGW10gV3JpdGUgQ29udHJvbCBWYWx1ZSBUYWJsZSBpbiBGdW5pdHNcbi8vIDB4NzBcbmZ1bmN0aW9uIFdDVlRGKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1dDVlRGW10nLCB2LCBsKTsgfVxuXG4gICAgc3RhdGUuY3Z0W2xdID0gdiAqIHN0YXRlLnBwZW0gLyBzdGF0ZS5mb250LnVuaXRzUGVyRW07XG59XG5cbi8vIERFTFRBQzFbXSBERUxUQSBleGNlcHRpb24gQzFcbi8vIERFTFRBQzJbXSBERUxUQSBleGNlcHRpb24gQzJcbi8vIERFTFRBQzNbXSBERUxUQSBleGNlcHRpb24gQzNcbi8vIDB4NzMsIDB4NzQsIDB4NzVcbmZ1bmN0aW9uIERFTFRBQzEyMyhiLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHBwZW0gPSBzdGF0ZS5wcGVtO1xuICAgIHZhciBiYXNlID0gc3RhdGUuZGVsdGFCYXNlICsgKGIgLSAxKSAqIDE2O1xuICAgIHZhciBkcyA9IHN0YXRlLmRlbHRhU2hpZnQ7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFDWycgKyBiICsgJ10nLCBuLCBzdGFjayk7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBjID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBhcmcgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIGFwcGVtID0gYmFzZSArICgoYXJnICYgMHhGMCkgPj4gNCk7XG4gICAgICAgIGlmIChhcHBlbSAhPT0gcHBlbSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHZhciBtYWcgPSAoYXJnICYgMHgwRikgLSA4O1xuICAgICAgICBpZiAobWFnID49IDApIHsgbWFnKys7IH1cblxuICAgICAgICB2YXIgZGVsdGEgPSBtYWcgKiBkcztcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFDRklYJywgYywgJ2J5JywgZGVsdGEpOyB9XG5cbiAgICAgICAgc3RhdGUuY3Z0W2NdICs9IGRlbHRhO1xuICAgIH1cbn1cblxuLy8gU1JPVU5EW10gU3VwZXIgUk9VTkRcbi8vIDB4NzZcbmZ1bmN0aW9uIFNST1VORChzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1JPVU5EW10nLCBuKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZFN1cGVyO1xuXG4gICAgdmFyIHBlcmlvZDtcblxuICAgIHN3aXRjaCAobiAmIDB4QzApIHtcbiAgICAgICAgY2FzZSAweDAwOlxuICAgICAgICAgICAgcGVyaW9kID0gMC41O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHg0MDpcbiAgICAgICAgICAgIHBlcmlvZCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDgwOlxuICAgICAgICAgICAgcGVyaW9kID0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFNST1VORCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHN0YXRlLnNyUGVyaW9kID0gcGVyaW9kO1xuXG4gICAgc3dpdGNoIChuICYgMHgzMCkge1xuICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC4yNSAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MjA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC41ICAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MzA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC43NSAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgU1JPVU5EIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgbiAmPSAweDBGO1xuXG4gICAgaWYgKG4gPT09IDApIHsgc3RhdGUuc3JUaHJlc2hvbGQgPSAwOyB9XG4gICAgZWxzZSB7IHN0YXRlLnNyVGhyZXNob2xkID0gKG4gLyA4IC0gMC41KSAqIHBlcmlvZDsgfVxufVxuXG4vLyBTNDVST1VORFtdIFN1cGVyIFJPVU5EIDQ1IGRlZ3JlZXNcbi8vIDB4NzdcbmZ1bmN0aW9uIFM0NVJPVU5EKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTNDVST1VORFtdJywgbik7IH1cblxuICAgIHN0YXRlLnJvdW5kID0gcm91bmRTdXBlcjtcblxuICAgIHZhciBwZXJpb2Q7XG5cbiAgICBzd2l0Y2ggKG4gJiAweEMwKSB7XG4gICAgICAgIGNhc2UgMHgwMDpcbiAgICAgICAgICAgIHBlcmlvZCA9IE1hdGguc3FydCgyKSAvIDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDQwOlxuICAgICAgICAgICAgcGVyaW9kID0gTWF0aC5zcXJ0KDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHg4MDpcbiAgICAgICAgICAgIHBlcmlvZCA9IDIgKiBNYXRoLnNxcnQoMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBTNDVST1VORCB2YWx1ZScpO1xuICAgIH1cblxuICAgIHN0YXRlLnNyUGVyaW9kID0gcGVyaW9kO1xuXG4gICAgc3dpdGNoIChuICYgMHgzMCkge1xuICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MTA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC4yNSAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MjA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC41ICAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4MzA6XG4gICAgICAgICAgICBzdGF0ZS5zclBoYXNlID0gMC43NSAqIHBlcmlvZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFM0NVJPVU5EIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgbiAmPSAweDBGO1xuXG4gICAgaWYgKG4gPT09IDApIHsgc3RhdGUuc3JUaHJlc2hvbGQgPSAwOyB9XG4gICAgZWxzZSB7IHN0YXRlLnNyVGhyZXNob2xkID0gKG4gLyA4IC0gMC41KSAqIHBlcmlvZDsgfVxufVxuXG4vLyBST0ZGW10gUm91bmQgT2ZmXG4vLyAweDdBXG5mdW5jdGlvbiBST0ZGKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JPRkZbXScpOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kT2ZmO1xufVxuXG4vLyBSVVRHW10gUm91bmQgVXAgVG8gR3JpZFxuLy8gMHg3Q1xuZnVuY3Rpb24gUlVURyhzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSVVRHW10nKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZFVwVG9HcmlkO1xufVxuXG4vLyBSRFRHW10gUm91bmQgRG93biBUbyBHcmlkXG4vLyAweDdEXG5mdW5jdGlvbiBSRFRHKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JEVEdbXScpOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kRG93blRvR3JpZDtcbn1cblxuLy8gU0NBTkNUUkxbXSBTQ0FOIGNvbnZlcnNpb24gQ29uVFJvTFxuLy8gMHg4NVxuZnVuY3Rpb24gU0NBTkNUUkwoc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgLy8gaWdub3JlZCBieSBvcGVudHlwZS5qc1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NDQU5DVFJMW10nLCBuKTsgfVxufVxuXG4vLyBTRFBWVExbYV0gU2V0IER1YWwgUHJvamVjdGlvbiBWZWN0b3IgVG8gTGluZVxuLy8gMHg4Ni0weDg3XG5mdW5jdGlvbiBTRFBWVEwoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcDJpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAxaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwMiA9IHN0YXRlLnoyW3AyaV07XG4gICAgdmFyIHAxID0gc3RhdGUuejFbcDFpXTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTRFBWVExbJyArIGEgKyAnXScsIHAyaSwgcDFpKTsgfVxuXG4gICAgdmFyIGR4O1xuICAgIHZhciBkeTtcblxuICAgIGlmICghYSkge1xuICAgICAgICBkeCA9IHAxLnggLSBwMi54O1xuICAgICAgICBkeSA9IHAxLnkgLSBwMi55O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGR4ID0gcDIueSAtIHAxLnk7XG4gICAgICAgIGR5ID0gcDEueCAtIHAyLng7XG4gICAgfVxuXG4gICAgc3RhdGUuZHB2ID0gZ2V0VW5pdFZlY3RvcihkeCwgZHkpO1xufVxuXG4vLyBHRVRJTkZPW10gR0VUIElORk9ybWF0aW9uXG4vLyAweDg4XG5mdW5jdGlvbiBHRVRJTkZPKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHNlbCA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciByID0gMDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHRVRJTkZPW10nLCBzZWwpOyB9XG5cbiAgICAvLyB2MzUgYXMgaW4gbm8gc3VicGl4ZWwgaGludGluZ1xuICAgIGlmIChzZWwgJiAweDAxKSB7IHIgPSAzNTsgfVxuXG4gICAgLy8gVE9ETyByb3RhdGlvbiBhbmQgc3RyZXRjaCBjdXJyZW50bHkgbm90IHN1cHBvcnRlZFxuICAgIC8vIGFuZCB0aHVzIHRob3NlIEdFVElORk8gYXJlIGFsd2F5cyAwLlxuXG4gICAgLy8gb3BlbnR5cGUuanMgaXMgYWx3YXlzIGdyYXkgc2NhbGluZ1xuICAgIGlmIChzZWwgJiAweDIwKSB7IHIgfD0gMHgxMDAwOyB9XG5cbiAgICBzdGFjay5wdXNoKHIpO1xufVxuXG4vLyBST0xMW10gUk9MTCB0aGUgdG9wIHRocmVlIHN0YWNrIGVsZW1lbnRzXG4vLyAweDhBXG5mdW5jdGlvbiBST0xMKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGEgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgYiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBjID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUk9MTFtdJyk7IH1cblxuICAgIHN0YWNrLnB1c2goYik7XG4gICAgc3RhY2sucHVzaChhKTtcbiAgICBzdGFjay5wdXNoKGMpO1xufVxuXG4vLyBNQVhbXSBNQVhpbXVtIG9mIHRvcCB0d28gc3RhY2sgZWxlbWVudHNcbi8vIDB4OEJcbmZ1bmN0aW9uIE1BWChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01BWFtdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChNYXRoLm1heChlMSwgZTIpKTtcbn1cblxuLy8gTUlOW10gTUlOaW11bSBvZiB0b3AgdHdvIHN0YWNrIGVsZW1lbnRzXG4vLyAweDhDXG5mdW5jdGlvbiBNSU4oc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdNSU5bXScsIGUyLCBlMSk7IH1cblxuICAgIHN0YWNrLnB1c2goTWF0aC5taW4oZTEsIGUyKSk7XG59XG5cbi8vIFNDQU5UWVBFW10gU0NBTlRZUEVcbi8vIDB4OERcbmZ1bmN0aW9uIFNDQU5UWVBFKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgICAvLyBpZ25vcmVkIGJ5IG9wZW50eXBlLmpzXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NDQU5UWVBFW10nLCBuKTsgfVxufVxuXG4vLyBJTlNUQ1RSTFtdIElOU1RDVFJMXG4vLyAweDhEXG5mdW5jdGlvbiBJTlNUQ1RSTChzdGF0ZSkge1xuICAgIHZhciBzID0gc3RhdGUuc3RhY2sucG9wKCk7XG4gICAgdmFyIHYgPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdJTlNUQ1RSTFtdJywgcywgdik7IH1cblxuICAgIHN3aXRjaCAocykge1xuICAgICAgICBjYXNlIDEgOiBzdGF0ZS5pbmhpYml0R3JpZEZpdCA9ICEhdjsgcmV0dXJuO1xuICAgICAgICBjYXNlIDIgOiBzdGF0ZS5pZ25vcmVDdnQgPSAhIXY7IHJldHVybjtcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIElOU1RDVFJMW10gc2VsZWN0b3InKTtcbiAgICB9XG59XG5cbi8vIFBVU0hCW2FiY10gUFVTSCBCeXRlc1xuLy8gMHhCMC0weEI3XG5mdW5jdGlvbiBQVVNIQihuLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcbiAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdQVVNIQlsnICsgbiArICddJyk7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7IHN0YWNrLnB1c2gocHJvZ1srK2lwXSk7IH1cblxuICAgIHN0YXRlLmlwID0gaXA7XG59XG5cbi8vIFBVU0hXW2FiY10gUFVTSCBXb3Jkc1xuLy8gMHhCOC0weEJGXG5mdW5jdGlvbiBQVVNIVyhuLCBzdGF0ZSkge1xuICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLmlwLCAnUFVTSFdbJyArIG4gKyAnXScpOyB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICB2YXIgdyA9IChwcm9nWysraXBdIDw8IDgpIHwgcHJvZ1srK2lwXTtcbiAgICAgICAgaWYgKHcgJiAweDgwMDApIHsgdyA9IC0oKHcgXiAweGZmZmYpICsgMSk7IH1cbiAgICAgICAgc3RhY2sucHVzaCh3KTtcbiAgICB9XG5cbiAgICBzdGF0ZS5pcCA9IGlwO1xufVxuXG4vLyBNRFJQW2FiY2RlXSBNb3ZlIERpcmVjdCBSZWxhdGl2ZSBQb2ludFxuLy8gMHhEMC0weEVGXG4vLyAoaWYgaW5kaXJlY3QgaXMgMClcbi8vXG4vLyBhbmRcbi8vXG4vLyBNSVJQW2FiY2RlXSBNb3ZlIEluZGlyZWN0IFJlbGF0aXZlIFBvaW50XG4vLyAweEUwLTB4RkZcbi8vIChpZiBpbmRpcmVjdCBpcyAxKVxuXG5mdW5jdGlvbiBNRFJQX01JUlAoaW5kaXJlY3QsIHNldFJwMCwga2VlcEQsIHJvLCBkdCwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgY3Z0ZSA9IGluZGlyZWN0ICYmIHN0YWNrLnBvcCgpO1xuICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBycDBpID0gc3RhdGUucnAwO1xuICAgIHZhciBycCA9IHN0YXRlLnowW3JwMGldO1xuICAgIHZhciBwID0gc3RhdGUuejFbcGldO1xuXG4gICAgdmFyIG1kID0gc3RhdGUubWluRGlzO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLmRwdjtcbiAgICB2YXIgb2Q7IC8vIG9yaWdpbmFsIGRpc3RhbmNlXG4gICAgdmFyIGQ7IC8vIG1vdmluZyBkaXN0YW5jZVxuICAgIHZhciBzaWduOyAvLyBzaWduIG9mIGRpc3RhbmNlXG4gICAgdmFyIGN2O1xuXG4gICAgZCA9IG9kID0gcHYuZGlzdGFuY2UocCwgcnAsIHRydWUsIHRydWUpO1xuICAgIHNpZ24gPSBkID49IDAgPyAxIDogLTE7IC8vIE1hdGguc2lnbiB3b3VsZCBiZSAwIGluIGNhc2Ugb2YgMFxuXG4gICAgLy8gVE9ETyBjb25zaWRlciBhdXRvRmxpcFxuICAgIGQgPSBNYXRoLmFicyhkKTtcblxuICAgIGlmIChpbmRpcmVjdCkge1xuICAgICAgICBjdiA9IHN0YXRlLmN2dFtjdnRlXTtcblxuICAgICAgICBpZiAocm8gJiYgTWF0aC5hYnMoZCAtIGN2KSA8IHN0YXRlLmN2Q3V0SW4pIHsgZCA9IGN2OyB9XG4gICAgfVxuXG4gICAgaWYgKGtlZXBEICYmIGQgPCBtZCkgeyBkID0gbWQ7IH1cblxuICAgIGlmIChybykgeyBkID0gc3RhdGUucm91bmQoZCk7IH1cblxuICAgIGZ2LnNldFJlbGF0aXZlKHAsIHJwLCBzaWduICogZCwgcHYpO1xuICAgIGZ2LnRvdWNoKHApO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgKGluZGlyZWN0ID8gJ01JUlBbJyA6ICdNRFJQWycpICtcbiAgICAgICAgICAgIChzZXRScDAgPyAnTScgOiAnbScpICtcbiAgICAgICAgICAgIChrZWVwRCA/ICc+JyA6ICdfJykgK1xuICAgICAgICAgICAgKHJvID8gJ1InIDogJ18nKSArXG4gICAgICAgICAgICAoZHQgPT09IDAgPyAnR3InIDogKGR0ID09PSAxID8gJ0JsJyA6IChkdCA9PT0gMiA/ICdXaCcgOiAnJykpKSArXG4gICAgICAgICAgICAnXScsXG4gICAgICAgICAgICBpbmRpcmVjdCA/XG4gICAgICAgICAgICAgICAgY3Z0ZSArICcoJyArIHN0YXRlLmN2dFtjdnRlXSArICcsJyArICBjdiArICcpJyA6XG4gICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICBwaSxcbiAgICAgICAgICAgICcoZCA9Jywgb2QsICctPicsIHNpZ24gKiBkLCAnKSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5ycDEgPSBzdGF0ZS5ycDA7XG4gICAgc3RhdGUucnAyID0gcGk7XG4gICAgaWYgKHNldFJwMCkgeyBzdGF0ZS5ycDAgPSBwaTsgfVxufVxuXG4vKlxuKiBUaGUgaW5zdHJ1Y3Rpb24gdGFibGUuXG4qL1xuaW5zdHJ1Y3Rpb25UYWJsZSA9IFtcbiAgICAvKiAweDAwICovIFNWVENBLmJpbmQodW5kZWZpbmVkLCB5VW5pdFZlY3RvciksXG4gICAgLyogMHgwMSAqLyBTVlRDQS5iaW5kKHVuZGVmaW5lZCwgeFVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MDIgKi8gU1BWVENBLmJpbmQodW5kZWZpbmVkLCB5VW5pdFZlY3RvciksXG4gICAgLyogMHgwMyAqLyBTUFZUQ0EuYmluZCh1bmRlZmluZWQsIHhVbml0VmVjdG9yKSxcbiAgICAvKiAweDA0ICovIFNGVlRDQS5iaW5kKHVuZGVmaW5lZCwgeVVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MDUgKi8gU0ZWVENBLmJpbmQodW5kZWZpbmVkLCB4VW5pdFZlY3RvciksXG4gICAgLyogMHgwNiAqLyBTUFZUTC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgwNyAqLyBTUFZUTC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgwOCAqLyBTRlZUTC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgwOSAqLyBTRlZUTC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgwQSAqLyBTUFZGUyxcbiAgICAvKiAweDBCICovIFNGVkZTLFxuICAgIC8qIDB4MEMgKi8gR1BWLFxuICAgIC8qIDB4MEQgKi8gR0ZWLFxuICAgIC8qIDB4MEUgKi8gU0ZWVFBWLFxuICAgIC8qIDB4MEYgKi8gSVNFQ1QsXG4gICAgLyogMHgxMCAqLyBTUlAwLFxuICAgIC8qIDB4MTEgKi8gU1JQMSxcbiAgICAvKiAweDEyICovIFNSUDIsXG4gICAgLyogMHgxMyAqLyBTWlAwLFxuICAgIC8qIDB4MTQgKi8gU1pQMSxcbiAgICAvKiAweDE1ICovIFNaUDIsXG4gICAgLyogMHgxNiAqLyBTWlBTLFxuICAgIC8qIDB4MTcgKi8gU0xPT1AsXG4gICAgLyogMHgxOCAqLyBSVEcsXG4gICAgLyogMHgxOSAqLyBSVEhHLFxuICAgIC8qIDB4MUEgKi8gU01ELFxuICAgIC8qIDB4MUIgKi8gRUxTRSxcbiAgICAvKiAweDFDICovIEpNUFIsXG4gICAgLyogMHgxRCAqLyBTQ1ZUQ0ksXG4gICAgLyogMHgxRSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBTU1dDSVxuICAgIC8qIDB4MUYgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gU1NXXG4gICAgLyogMHgyMCAqLyBEVVAsXG4gICAgLyogMHgyMSAqLyBQT1AsXG4gICAgLyogMHgyMiAqLyBDTEVBUixcbiAgICAvKiAweDIzICovIFNXQVAsXG4gICAgLyogMHgyNCAqLyBERVBUSCxcbiAgICAvKiAweDI1ICovIENJTkRFWCxcbiAgICAvKiAweDI2ICovIE1JTkRFWCxcbiAgICAvKiAweDI3ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEFMSUdOUFRTXG4gICAgLyogMHgyOCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHgyOSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBVVFBcbiAgICAvKiAweDJBICovIExPT1BDQUxMLFxuICAgIC8qIDB4MkIgKi8gQ0FMTCxcbiAgICAvKiAweDJDICovIEZERUYsXG4gICAgLyogMHgyRCAqLyB1bmRlZmluZWQsICAgLy8gRU5ERiAoZWF0ZW4gYnkgRkRFRilcbiAgICAvKiAweDJFICovIE1EQVAuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4MkYgKi8gTURBUC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgzMCAqLyBJVVAuYmluZCh1bmRlZmluZWQsIHlVbml0VmVjdG9yKSxcbiAgICAvKiAweDMxICovIElVUC5iaW5kKHVuZGVmaW5lZCwgeFVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MzIgKi8gU0hQLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDMzICovIFNIUC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgzNCAqLyBTSEMuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4MzUgKi8gU0hDLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDM2ICovIFNIWi5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgzNyAqLyBTSFouYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4MzggKi8gU0hQSVgsXG4gICAgLyogMHgzOSAqLyBJUCxcbiAgICAvKiAweDNBICovIE1TSVJQLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDNCICovIE1TSVJQLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDNDICovIEFMSUdOUlAsXG4gICAgLyogMHgzRCAqLyBSVERHLFxuICAgIC8qIDB4M0UgKi8gTUlBUC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgzRiAqLyBNSUFQLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDQwICovIE5QVVNIQixcbiAgICAvKiAweDQxICovIE5QVVNIVyxcbiAgICAvKiAweDQyICovIFdTLFxuICAgIC8qIDB4NDMgKi8gUlMsXG4gICAgLyogMHg0NCAqLyBXQ1ZUUCxcbiAgICAvKiAweDQ1ICovIFJDVlQsXG4gICAgLyogMHg0NiAqLyBHQy5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHg0NyAqLyBHQy5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHg0OCAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBTQ0ZTXG4gICAgLyogMHg0OSAqLyBNRC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHg0QSAqLyBNRC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHg0QiAqLyBNUFBFTSxcbiAgICAvKiAweDRDICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIE1QU1xuICAgIC8qIDB4NEQgKi8gRkxJUE9OLFxuICAgIC8qIDB4NEUgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gRkxJUE9GRlxuICAgIC8qIDB4NEYgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gREVCVUdcbiAgICAvKiAweDUwICovIExULFxuICAgIC8qIDB4NTEgKi8gTFRFUSxcbiAgICAvKiAweDUyICovIEdULFxuICAgIC8qIDB4NTMgKi8gR1RFUSxcbiAgICAvKiAweDU0ICovIEVRLFxuICAgIC8qIDB4NTUgKi8gTkVRLFxuICAgIC8qIDB4NTYgKi8gT0RELFxuICAgIC8qIDB4NTcgKi8gRVZFTixcbiAgICAvKiAweDU4ICovIElGLFxuICAgIC8qIDB4NTkgKi8gRUlGLFxuICAgIC8qIDB4NUEgKi8gQU5ELFxuICAgIC8qIDB4NUIgKi8gT1IsXG4gICAgLyogMHg1QyAqLyBOT1QsXG4gICAgLyogMHg1RCAqLyBERUxUQVAxMjMuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4NUUgKi8gU0RCLFxuICAgIC8qIDB4NUYgKi8gU0RTLFxuICAgIC8qIDB4NjAgKi8gQURELFxuICAgIC8qIDB4NjEgKi8gU1VCLFxuICAgIC8qIDB4NjIgKi8gRElWLFxuICAgIC8qIDB4NjMgKi8gTVVMLFxuICAgIC8qIDB4NjQgKi8gQUJTLFxuICAgIC8qIDB4NjUgKi8gTkVHLFxuICAgIC8qIDB4NjYgKi8gRkxPT1IsXG4gICAgLyogMHg2NyAqLyBDRUlMSU5HLFxuICAgIC8qIDB4NjggKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4NjkgKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4NkEgKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgIC8qIDB4NkIgKi8gUk9VTkQuYmluZCh1bmRlZmluZWQsIDMpLFxuICAgIC8qIDB4NkMgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuICAgIC8qIDB4NkQgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuICAgIC8qIDB4NkUgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuICAgIC8qIDB4NkYgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTlJPVU5EW2FiXVxuICAgIC8qIDB4NzAgKi8gV0NWVEYsXG4gICAgLyogMHg3MSAqLyBERUxUQVAxMjMuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgIC8qIDB4NzIgKi8gREVMVEFQMTIzLmJpbmQodW5kZWZpbmVkLCAzKSxcbiAgICAvKiAweDczICovIERFTFRBQzEyMy5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHg3NCAqLyBERUxUQUMxMjMuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgIC8qIDB4NzUgKi8gREVMVEFDMTIzLmJpbmQodW5kZWZpbmVkLCAzKSxcbiAgICAvKiAweDc2ICovIFNST1VORCxcbiAgICAvKiAweDc3ICovIFM0NVJPVU5ELFxuICAgIC8qIDB4NzggKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gSlJPVFtdXG4gICAgLyogMHg3OSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBKUk9GW11cbiAgICAvKiAweDdBICovIFJPRkYsXG4gICAgLyogMHg3QiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg3QyAqLyBSVVRHLFxuICAgIC8qIDB4N0QgKi8gUkRURyxcbiAgICAvKiAweDdFICovIFBPUCwgLy8gYWN0dWFsbHkgU0FOR1csIHN1cHBvc2VkIHRvIGRvIG9ubHkgYSBwb3AgdGhvdWdoXG4gICAgLyogMHg3RiAqLyBQT1AsIC8vIGFjdHVhbGx5IEFBLCBzdXBwb3NlZCB0byBkbyBvbmx5IGEgcG9wIHRob3VnaFxuICAgIC8qIDB4ODAgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gRkxJUFBUXG4gICAgLyogMHg4MSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBGTElQUkdPTlxuICAgIC8qIDB4ODIgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gRkxJUFJHT0ZGXG4gICAgLyogMHg4MyAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg4NCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg4NSAqLyBTQ0FOQ1RSTCxcbiAgICAvKiAweDg2ICovIFNEUFZUTC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHg4NyAqLyBTRFBWVEwuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4ODggKi8gR0VUSU5GTyxcbiAgICAvKiAweDg5ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIElERUZcbiAgICAvKiAweDhBICovIFJPTEwsXG4gICAgLyogMHg4QiAqLyBNQVgsXG4gICAgLyogMHg4QyAqLyBNSU4sXG4gICAgLyogMHg4RCAqLyBTQ0FOVFlQRSxcbiAgICAvKiAweDhFICovIElOU1RDVFJMLFxuICAgIC8qIDB4OEYgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTAgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTEgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTIgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTMgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTQgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTUgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTYgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTcgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTggKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OTkgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OUEgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OUIgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OUMgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OUQgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OUUgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4OUYgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTAgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTEgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTIgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTMgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTQgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTUgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTYgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTcgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTggKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QTkgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QUEgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QUIgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QUMgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QUQgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QUUgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QUYgKi8gdW5kZWZpbmVkLFxuICAgIC8qIDB4QjAgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4QjEgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgIC8qIDB4QjIgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDMpLFxuICAgIC8qIDB4QjMgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDQpLFxuICAgIC8qIDB4QjQgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDUpLFxuICAgIC8qIDB4QjUgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDYpLFxuICAgIC8qIDB4QjYgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDcpLFxuICAgIC8qIDB4QjcgKi8gUFVTSEIuYmluZCh1bmRlZmluZWQsIDgpLFxuICAgIC8qIDB4QjggKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4QjkgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDIpLFxuICAgIC8qIDB4QkEgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDMpLFxuICAgIC8qIDB4QkIgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDQpLFxuICAgIC8qIDB4QkMgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDUpLFxuICAgIC8qIDB4QkQgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDYpLFxuICAgIC8qIDB4QkUgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDcpLFxuICAgIC8qIDB4QkYgKi8gUFVTSFcuYmluZCh1bmRlZmluZWQsIDgpLFxuICAgIC8qIDB4QzAgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAwLCAwKSxcbiAgICAvKiAweEMxICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMCwgMSksXG4gICAgLyogMHhDMiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDAsIDIpLFxuICAgIC8qIDB4QzMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAwLCAzKSxcbiAgICAvKiAweEM0ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMSwgMCksXG4gICAgLyogMHhDNSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDEsIDEpLFxuICAgIC8qIDB4QzYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAxLCAyKSxcbiAgICAvKiAweEM3ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMSwgMyksXG4gICAgLyogMHhDOCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDAsIDApLFxuICAgIC8qIDB4QzkgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAwLCAxKSxcbiAgICAvKiAweENBICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMCwgMiksXG4gICAgLyogMHhDQiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDAsIDMpLFxuICAgIC8qIDB4Q0MgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAxLCAwKSxcbiAgICAvKiAweENEICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMSwgMSksXG4gICAgLyogMHhDRSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDEsIDIpLFxuICAgIC8qIDB4Q0YgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAxLCAzKSxcbiAgICAvKiAweEQwICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMCwgMCksXG4gICAgLyogMHhEMSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDAsIDEpLFxuICAgIC8qIDB4RDIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAwLCAyKSxcbiAgICAvKiAweEQzICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMCwgMyksXG4gICAgLyogMHhENCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDEsIDApLFxuICAgIC8qIDB4RDUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAxLCAxKSxcbiAgICAvKiAweEQ2ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMSwgMiksXG4gICAgLyogMHhENyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDEsIDMpLFxuICAgIC8qIDB4RDggKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAwLCAwKSxcbiAgICAvKiAweEQ5ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMCwgMSksXG4gICAgLyogMHhEQSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDAsIDIpLFxuICAgIC8qIDB4REIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAwLCAzKSxcbiAgICAvKiAweERDICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMSwgMCksXG4gICAgLyogMHhERCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDEsIDEpLFxuICAgIC8qIDB4REUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAxLCAyKSxcbiAgICAvKiAweERGICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMSwgMyksXG4gICAgLyogMHhFMCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDAsIDApLFxuICAgIC8qIDB4RTEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAwLCAxKSxcbiAgICAvKiAweEUyICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMCwgMiksXG4gICAgLyogMHhFMyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDAsIDMpLFxuICAgIC8qIDB4RTQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAxLCAwKSxcbiAgICAvKiAweEU1ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMSwgMSksXG4gICAgLyogMHhFNiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDEsIDIpLFxuICAgIC8qIDB4RTcgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAxLCAzKSxcbiAgICAvKiAweEU4ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMCwgMCksXG4gICAgLyogMHhFOSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDAsIDEpLFxuICAgIC8qIDB4RUEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAwLCAyKSxcbiAgICAvKiAweEVCICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMCwgMyksXG4gICAgLyogMHhFQyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDEsIDApLFxuICAgIC8qIDB4RUQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAxLCAxKSxcbiAgICAvKiAweEVFICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMSwgMiksXG4gICAgLyogMHhFRiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDEsIDMpLFxuICAgIC8qIDB4RjAgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAwLCAwKSxcbiAgICAvKiAweEYxICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMCwgMSksXG4gICAgLyogMHhGMiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDAsIDIpLFxuICAgIC8qIDB4RjMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAwLCAzKSxcbiAgICAvKiAweEY0ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMSwgMCksXG4gICAgLyogMHhGNSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDEsIDEpLFxuICAgIC8qIDB4RjYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAxLCAyKSxcbiAgICAvKiAweEY3ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMSwgMyksXG4gICAgLyogMHhGOCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDAsIDApLFxuICAgIC8qIDB4RjkgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAwLCAxKSxcbiAgICAvKiAweEZBICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMCwgMiksXG4gICAgLyogMHhGQiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDAsIDMpLFxuICAgIC8qIDB4RkMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAxLCAwKSxcbiAgICAvKiAweEZEICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMSwgMSksXG4gICAgLyogMHhGRSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDEsIDIpLFxuICAgIC8qIDB4RkYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAxLCAzKVxuXTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICBNYXRoZW1hdGljYWwgQ29uc2lkZXJhdGlvbnNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5mdiAuLi4gcmVmZXJzIHRvIGZyZWVkb20gdmVjdG9yXG5wdiAuLi4gcmVmZXJzIHRvIHByb2plY3Rpb24gdmVjdG9yXG5ycCAuLi4gcmVmZXJzIHRvIHJlZmVyZW5jZSBwb2ludFxucCAgLi4uIHJlZmVycyB0byB0byBwb2ludCBiZWluZyBvcGVyYXRlZCBvblxuZCAgLi4uIHJlZmVycyB0byBkaXN0YW5jZVxuXG5TRVRSRUxBVElWRTpcbj09PT09PT09PT09PVxuXG5jYXNlIGZyZWVkb20gdmVjdG9yID09IHgtYXhpczpcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAocHYpXG4gICAgICAgICAgICAgICAgICAgICAuLSdcbiAgICAgICAgICAgICAgcnBkIC4tJ1xuICAgICAgICAgICAgICAgLi0qXG4gICAgICAgICAgZCAuLSc5MMKwJ1xuICAgICAgICAgLi0nICAgICAgICdcbiAgICAgIC4tJyAgICAgICAgICAgJ1xuICAgKi0nICAgICAgICAgICAgICAgJyBiXG4gIHJwICAgICAgICAgICAgICAgICAgJ1xuICAgICAgICAgICAgICAgICAgICAgICAnXG4gICAgICAgICAgICAgICAgICAgICAgICAnXG4gICAgICAgICAgICBwICotLS0tLS0tLS0tKi0tLS0tLS0tLS0tLS0tIChmdilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG1cblxuICBycGR4ID0gcnB4ICsgZCAqIHB2LnhcbiAgcnBkeSA9IHJweSArIGQgKiBwdi55XG5cbiAgZXF1YXRpb24gb2YgbGluZSBiXG5cbiAgIHkgLSBycGR5ID0gcHZucyAqICh4LSBycGR4KVxuXG4gICB5ID0gcC55XG5cbiAgIHggPSBycGR4ICsgKCBwLnkgLSBycGR5ICkgLyBwdm5zXG5cblxuY2FzZSBmcmVlZG9tIHZlY3RvciA9PSB5LWF4aXM6XG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICogcG1cbiAgICB8XFxcbiAgICB8IFxcXG4gICAgfCAgXFxcbiAgICB8ICAgXFxcbiAgICB8ICAgIFxcXG4gICAgfCAgICAgXFxcbiAgICB8ICAgICAgXFxcbiAgICB8ICAgICAgIFxcXG4gICAgfCAgICAgICAgXFxcbiAgICB8ICAgICAgICAgXFwgYlxuICAgIHwgICAgICAgICAgXFxcbiAgICB8ICAgICAgICAgICBcXFxuICAgIHwgICAgICAgICAgICBcXCAgICAuLScgKHB2KVxuICAgIHwgICAgICAgICA5MMKwIFxcLi0nXG4gICAgfCAgICAgICAgICAgLi0nKiBycGRcbiAgICB8ICAgICAgICAuLSdcbiAgICAqICAgICAqLScgIGRcbiAgICBwICAgICBycFxuXG4gIHJwZHggPSBycHggKyBkICogcHYueFxuICBycGR5ID0gcnB5ICsgZCAqIHB2LnlcblxuICBlcXVhdGlvbiBvZiBsaW5lIGI6XG4gICAgICAgICAgIHB2bnMgLi4uIG5vcm1hbCBzbG9wZSB0byBwdlxuXG4gICB5IC0gcnBkeSA9IHB2bnMgKiAoeCAtIHJwZHgpXG5cbiAgIHggPSBwLnhcblxuICAgeSA9IHJwZHkgKyAgcHZucyAqIChwLnggLSBycGR4KVxuXG5cblxuZ2VuZXJpYyBjYXNlOlxuLS0tLS0tLS0tLS0tLVxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4nKGZ2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4nXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC4qIHBtXG4gICAgICAgICAgICAgICAgICAgICAgICAuJyAhXG4gICAgICAgICAgICAgICAgICAgICAgLicgICAgLlxuICAgICAgICAgICAgICAgICAgICAuJyAgICAgICFcbiAgICAgICAgICAgICAgICAgIC4nICAgICAgICAgLiBiXG4gICAgICAgICAgICAgICAgLicgICAgICAgICAgICFcbiAgICAgICAgICAgICAgICogICAgICAgICAgICAgIC5cbiAgICAgICAgICAgICAgcCAgICAgICAgICAgICAgICFcbiAgICAgICAgICAgICAgICAgICAgICAgICA5MMKwICAgLiAgICAuLi4gKHB2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uLSotJycnXG4gICAgICAgICAgICAgICAgICAuLi4tLS0nJycgICAgcnBkXG4gICAgICAgICAuLi4tLS0nJycgICBkXG4gICAqLS0nJydcbiAgcnBcblxuICAgIHJwZHggPSBycHggKyBkICogcHYueFxuICAgIHJwZHkgPSBycHkgKyBkICogcHYueVxuXG4gZXF1YXRpb24gb2YgbGluZSBiOlxuICAgIHB2bnMuLi4gbm9ybWFsIHNsb3BlIHRvIHB2XG5cbiAgICB5IC0gcnBkeSA9IHB2bnMgKiAoeCAtIHJwZHgpXG5cbiBlcXVhdGlvbiBvZiBmcmVlZG9tIHZlY3RvciBsaW5lOlxuICAgIGZ2cyAuLi4gc2xvcGUgb2YgZnJlZWRvbSB2ZWN0b3IgKD1meS9meClcblxuICAgIHkgLSBweSA9IGZ2cyAqICh4IC0gcHgpXG5cblxuICBvbiBwbSBib3RoIGVxdWF0aW9ucyBhcmUgdHJ1ZSBmb3Igc2FtZSB4L3lcblxuICAgIHkgLSBycGR5ID0gcHZucyAqICh4IC0gcnBkeClcblxuICAgIHkgLSBweSA9IGZ2cyAqICh4IC0gcHgpXG5cbiAgZm9ybSB0byB5IGFuZCBzZXQgZXF1YWw6XG5cbiAgICBwdm5zICogKHggLSBycGR4KSArIHJwZHkgPSBmdnMgKiAoeCAtIHB4KSArIHB5XG5cbiAgZXhwYW5kOlxuXG4gICAgcHZucyAqIHggLSBwdm5zICogcnBkeCArIHJwZHkgPSBmdnMgKiB4IC0gZnZzICogcHggKyBweVxuXG4gIHN3aXRjaDpcblxuICAgIGZ2cyAqIHggLSBmdnMgKiBweCArIHB5ID0gcHZucyAqIHggLSBwdm5zICogcnBkeCArIHJwZHlcblxuICBzb2x2ZSBmb3IgeDpcblxuICAgIGZ2cyAqIHggLSBwdm5zICogeCA9IGZ2cyAqIHB4IC0gcHZucyAqIHJwZHggLSBweSArIHJwZHlcblxuXG5cbiAgICAgICAgICBmdnMgKiBweCAtIHB2bnMgKiBycGR4ICsgcnBkeSAtIHB5XG4gICAgeCA9ICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgICAgICBmdnMgLSBwdm5zXG5cbiAgYW5kOlxuXG4gICAgeSA9IGZ2cyAqICh4IC0gcHgpICsgcHlcblxuXG5cbklOVEVSUE9MQVRFOlxuPT09PT09PT09PT09XG5cbkV4YW1wbGVzIG9mIHBvaW50IGludGVycG9sYXRpb24uXG5cblRoZSB3ZWlnaHQgb2YgdGhlIG1vdmVtZW50IG9mIHRoZSByZWZlcmVuY2UgcG9pbnQgZ2V0cyBiaWdnZXJcbnRoZSBmdXJ0aGVyIHRoZSBvdGhlciByZWZlcmVuY2UgcG9pbnQgaXMgYXdheSwgdGh1cyB0aGUgc2FmZXN0XG5vcHRpb24gKHRoYXQgaXMgYXZvaWRpbmcgMC8wIGRpdmlzaW9ucykgaXMgdG8gd2VpZ2h0IHRoZVxub3JpZ2luYWwgZGlzdGFuY2Ugb2YgdGhlIG90aGVyIHBvaW50IGJ5IHRoZSBzdW0gb2YgYm90aCBkaXN0YW5jZXMuXG5cbklmIHRoZSBzdW0gb2YgYm90aCBkaXN0YW5jZXMgaXMgMCwgdGhlbiBtb3ZlIHRoZSBwb2ludCBieSB0aGVcbmFyaXRobWV0aWMgYXZlcmFnZSBvZiB0aGUgbW92ZW1lbnQgb2YgYm90aCByZWZlcmVuY2UgcG9pbnRzLlxuXG5cblxuXG4gICAgICAgICAgICgrNilcbiAgICBycDFvICotLS0tPipycDFcbiAgICAgICAgIC4gICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgICgrMTIpXG4gICAgICAgICAuICAgICAuICAgICAgICAgICAgICAgICAgcnAybyAqLS0tLS0tLS0tLT4qIHJwMlxuICAgICAgICAgLiAgICAgLiAgICAgICAgICAgICAgICAgICAgICAgLiAgICAgICAgICAgLlxuICAgICAgICAgLiAgICAgLiAgICAgICAgICAgICAgICAgICAgICAgLiAgICAgICAgICAgLlxuICAgICAgICAgLiAgICAxMCAgICAgICAgICAyMCAgICAgICAgICAgLiAgICAgICAgICAgLlxuICAgICAgICAgfC4uLi4uLi4uLnwuLi4uLi4uLi4uLi4uLi4uLi4ufCAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgLiAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgLiAgIC4gKCs4KSAgICAgICAgICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgIHBvICotLS0tLS0+KnAgICAgICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgLiAgICAgICAgICAgLiAgICAgICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgLiAgICAxMiAgICAgLiAgICAgICAgICAyNCAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgfC4uLi4uLi4uLi4ufC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4ufFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDM2XG5cblxuLS0tLS0tLVxuXG5cblxuICAgICAgICAgICAoKzEwKVxuICAgIHJwMW8gKi0tLS0tLS0tPipycDFcbiAgICAgICAgIC4gICAgICAgICAuICAgICAgICAgICAgICAgICAgICAgICgtMTApXG4gICAgICAgICAuICAgICAgICAgLiAgICAgICAgICAgICAgcnAyICo8LS0tLS0tLS0tKiBycG8yXG4gICAgICAgICAuICAgICAgICAgLiAgICAgICAgICAgICAgICAgICAuICAgICAgICAgLlxuICAgICAgICAgLiAgICAgICAgIC4gICAgICAgICAgICAgICAgICAgLiAgICAgICAgIC5cbiAgICAgICAgIC4gICAgMTAgICAuICAgICAgICAgIDMwICAgICAgIC4gICAgICAgICAuXG4gICAgICAgICB8Li4uLi4uLi4ufC4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4ufFxuICAgICAgICAgICAgICAgICAgIC4gICAgICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgICAgIC4gKCs1KSAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgIHBvICotLS0+KiBwICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgICAgIC4gICAgLiAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICAgICAgIC4gICAgLiAgIDIwICAgICAgICAgLlxuICAgICAgICAgICAgICAgICAgIHwuLi4ufC4uLi4uLi4uLi4uLi4ufFxuICAgICAgICAgICAgICAgICAgICAgNSAgICAgICAgMTVcblxuXG4tLS0tLS0tXG5cblxuICAgICAgICAgICAoKzEwKVxuICAgIHJwMW8gKi0tLS0tLS0tPipycDFcbiAgICAgICAgIC4gICAgICAgICAuXG4gICAgICAgICAuICAgICAgICAgLlxuICAgIHJwMm8gKi0tLS0tLS0tPipycDJcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCsxMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG8gKi0tLS0tLS0tPiogcFxuXG4tLS0tLS0tXG5cblxuICAgICAgICAgICAoKzEwKVxuICAgIHJwMW8gKi0tLS0tLS0tPipycDFcbiAgICAgICAgIC4gICAgICAgICAuXG4gICAgICAgICAuICAgICAgICAgLigrMzApXG4gICAgcnAybyAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT4qcnAyXG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgrMjUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBvICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLT4qIHBcblxuXG5cbnZpbTogc2V0IHRzPTQgc3c9NCBleHBhbmR0YWI6XG4qKioqKi9cblxuLy8gVGhlIEZvbnQgb2JqZWN0XG5cbi8qKlxuICogQHR5cGVkZWYgRm9udE9wdGlvbnNcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBlbXB0eSAtIHdoZXRoZXIgdG8gY3JlYXRlIGEgbmV3IGVtcHR5IGZvbnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmYW1pbHlOYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3R5bGVOYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGZ1bGxOYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZz19IHBvc3RTY3JpcHROYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGRlc2lnbmVyXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGRlc2lnbmVyVVJMXG4gKiBAcHJvcGVydHkge3N0cmluZz19IG1hbnVmYWN0dXJlclxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBtYW51ZmFjdHVyZXJVUkxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gbGljZW5zZVxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBsaWNlbnNlVVJMXG4gKiBAcHJvcGVydHkge3N0cmluZz19IHZlcnNpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZGVzY3JpcHRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gY29weXJpZ2h0XG4gKiBAcHJvcGVydHkge3N0cmluZz19IHRyYWRlbWFya1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IHVuaXRzUGVyRW1cbiAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBhc2NlbmRlclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGRlc2NlbmRlclxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGNyZWF0ZWRUaW1lc3RhbXBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gd2VpZ2h0Q2xhc3NcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gd2lkdGhDbGFzc1xuICogQHByb3BlcnR5IHtzdHJpbmc9fSBmc1NlbGVjdGlvblxuICovXG5cbi8qKlxuICogQSBGb250IHJlcHJlc2VudHMgYSBsb2FkZWQgT3BlblR5cGUgZm9udCBmaWxlLlxuICogSXQgY29udGFpbnMgYSBzZXQgb2YgZ2x5cGhzIGFuZCBtZXRob2RzIHRvIGRyYXcgdGV4dCBvbiBhIGRyYXdpbmcgY29udGV4dCxcbiAqIG9yIHRvIGdldCBhIHBhdGggcmVwcmVzZW50aW5nIHRoZSB0ZXh0LlxuICogQGV4cG9ydHMgb3BlbnR5cGUuRm9udFxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0ZvbnRPcHRpb25zfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEZvbnQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKCFvcHRpb25zLmVtcHR5KSB7XG4gICAgICAgIC8vIENoZWNrIHRoYXQgd2UndmUgcHJvdmlkZWQgdGhlIG1pbmltdW0gc2V0IG9mIG5hbWVzLlxuICAgICAgICBjaGVja0FyZ3VtZW50KG9wdGlvbnMuZmFtaWx5TmFtZSwgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIGZhbWlseU5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIGNoZWNrQXJndW1lbnQob3B0aW9ucy5zdHlsZU5hbWUsICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCBzdHlsZU5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIGNoZWNrQXJndW1lbnQob3B0aW9ucy51bml0c1BlckVtLCAnV2hlbiBjcmVhdGluZyBhIG5ldyBGb250IG9iamVjdCwgdW5pdHNQZXJFbSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgY2hlY2tBcmd1bWVudChvcHRpb25zLmFzY2VuZGVyLCAnV2hlbiBjcmVhdGluZyBhIG5ldyBGb250IG9iamVjdCwgYXNjZW5kZXIgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIGNoZWNrQXJndW1lbnQob3B0aW9ucy5kZXNjZW5kZXIsICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCBkZXNjZW5kZXIgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIGNoZWNrQXJndW1lbnQob3B0aW9ucy5kZXNjZW5kZXIgPCAwLCAnRGVzY2VuZGVyIHNob3VsZCBiZSBuZWdhdGl2ZSAoZS5nLiAtNTEyKS4nKTtcblxuICAgICAgICAvLyBPUyBYIHdpbGwgY29tcGxhaW4gaWYgdGhlIG5hbWVzIGFyZSBlbXB0eSwgc28gd2UgcHV0IGEgc2luZ2xlIHNwYWNlIGV2ZXJ5d2hlcmUgYnkgZGVmYXVsdC5cbiAgICAgICAgdGhpcy5uYW1lcyA9IHtcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6IHtlbjogb3B0aW9ucy5mYW1pbHlOYW1lIHx8ICcgJ30sXG4gICAgICAgICAgICBmb250U3ViZmFtaWx5OiB7ZW46IG9wdGlvbnMuc3R5bGVOYW1lIHx8ICcgJ30sXG4gICAgICAgICAgICBmdWxsTmFtZToge2VuOiBvcHRpb25zLmZ1bGxOYW1lIHx8IG9wdGlvbnMuZmFtaWx5TmFtZSArICcgJyArIG9wdGlvbnMuc3R5bGVOYW1lfSxcbiAgICAgICAgICAgIHBvc3RTY3JpcHROYW1lOiB7ZW46IG9wdGlvbnMucG9zdFNjcmlwdE5hbWUgfHwgb3B0aW9ucy5mYW1pbHlOYW1lICsgb3B0aW9ucy5zdHlsZU5hbWV9LFxuICAgICAgICAgICAgZGVzaWduZXI6IHtlbjogb3B0aW9ucy5kZXNpZ25lciB8fCAnICd9LFxuICAgICAgICAgICAgZGVzaWduZXJVUkw6IHtlbjogb3B0aW9ucy5kZXNpZ25lclVSTCB8fCAnICd9LFxuICAgICAgICAgICAgbWFudWZhY3R1cmVyOiB7ZW46IG9wdGlvbnMubWFudWZhY3R1cmVyIHx8ICcgJ30sXG4gICAgICAgICAgICBtYW51ZmFjdHVyZXJVUkw6IHtlbjogb3B0aW9ucy5tYW51ZmFjdHVyZXJVUkwgfHwgJyAnfSxcbiAgICAgICAgICAgIGxpY2Vuc2U6IHtlbjogb3B0aW9ucy5saWNlbnNlIHx8ICcgJ30sXG4gICAgICAgICAgICBsaWNlbnNlVVJMOiB7ZW46IG9wdGlvbnMubGljZW5zZVVSTCB8fCAnICd9LFxuICAgICAgICAgICAgdmVyc2lvbjoge2VuOiBvcHRpb25zLnZlcnNpb24gfHwgJ1ZlcnNpb24gMC4xJ30sXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjoge2VuOiBvcHRpb25zLmRlc2NyaXB0aW9uIHx8ICcgJ30sXG4gICAgICAgICAgICBjb3B5cmlnaHQ6IHtlbjogb3B0aW9ucy5jb3B5cmlnaHQgfHwgJyAnfSxcbiAgICAgICAgICAgIHRyYWRlbWFyazoge2VuOiBvcHRpb25zLnRyYWRlbWFyayB8fCAnICd9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudW5pdHNQZXJFbSA9IG9wdGlvbnMudW5pdHNQZXJFbSB8fCAxMDAwO1xuICAgICAgICB0aGlzLmFzY2VuZGVyID0gb3B0aW9ucy5hc2NlbmRlcjtcbiAgICAgICAgdGhpcy5kZXNjZW5kZXIgPSBvcHRpb25zLmRlc2NlbmRlcjtcbiAgICAgICAgdGhpcy5jcmVhdGVkVGltZXN0YW1wID0gb3B0aW9ucy5jcmVhdGVkVGltZXN0YW1wO1xuICAgICAgICB0aGlzLnRhYmxlcyA9IHsgb3MyOiB7XG4gICAgICAgICAgICB1c1dlaWdodENsYXNzOiBvcHRpb25zLndlaWdodENsYXNzIHx8IHRoaXMudXNXZWlnaHRDbGFzc2VzLk1FRElVTSxcbiAgICAgICAgICAgIHVzV2lkdGhDbGFzczogb3B0aW9ucy53aWR0aENsYXNzIHx8IHRoaXMudXNXaWR0aENsYXNzZXMuTUVESVVNLFxuICAgICAgICAgICAgZnNTZWxlY3Rpb246IG9wdGlvbnMuZnNTZWxlY3Rpb24gfHwgdGhpcy5mc1NlbGVjdGlvblZhbHVlcy5SRUdVTEFSXG4gICAgICAgIH0gfTtcbiAgICB9XG5cbiAgICB0aGlzLnN1cHBvcnRlZCA9IHRydWU7IC8vIERlcHJlY2F0ZWQ6IHBhcnNlQnVmZmVyIHdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgZm9udCBpcyBub3Qgc3VwcG9ydGVkLlxuICAgIHRoaXMuZ2x5cGhzID0gbmV3IGdseXBoc2V0LkdseXBoU2V0KHRoaXMsIG9wdGlvbnMuZ2x5cGhzIHx8IFtdKTtcbiAgICB0aGlzLmVuY29kaW5nID0gbmV3IERlZmF1bHRFbmNvZGluZyh0aGlzKTtcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFBvc2l0aW9uKHRoaXMpO1xuICAgIHRoaXMuc3Vic3RpdHV0aW9uID0gbmV3IFN1YnN0aXR1dGlvbih0aGlzKTtcbiAgICB0aGlzLnRhYmxlcyA9IHRoaXMudGFibGVzIHx8IHt9O1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdoaW50aW5nJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hpbnRpbmcpIHsgcmV0dXJuIHRoaXMuX2hpbnRpbmc7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLm91dGxpbmVzRm9ybWF0ID09PSAndHJ1ZXR5cGUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9oaW50aW5nID0gbmV3IEhpbnRpbmcodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGZvbnQgaGFzIGEgZ2x5cGggZm9yIHRoZSBnaXZlbiBjaGFyYWN0ZXIuXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5Gb250LnByb3RvdHlwZS5oYXNDaGFyID0gZnVuY3Rpb24oYykge1xuICAgIHJldHVybiB0aGlzLmVuY29kaW5nLmNoYXJUb0dseXBoSW5kZXgoYykgIT09IG51bGw7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGNoYXJhY3RlciB0byBhIHNpbmdsZSBnbHlwaCBpbmRleC5cbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGVyZSBpcyBhIG9uZS10by1vbmUgbWFwcGluZyBiZXR3ZWVuXG4gKiB0aGUgZ2l2ZW4gY2hhcmFjdGVyIGFuZCBhIGdseXBoOyBmb3IgY29tcGxleCBzY3JpcHRzIHRoaXMgbWlnaHQgbm90IGJlIHRoZSBjYXNlLlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Gb250LnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24ocykge1xuICAgIHJldHVybiB0aGlzLmVuY29kaW5nLmNoYXJUb0dseXBoSW5kZXgocyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGNoYXJhY3RlciB0byBhIHNpbmdsZSBHbHlwaCBvYmplY3QuXG4gKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlcmUgaXMgYSBvbmUtdG8tb25lIG1hcHBpbmcgYmV0d2VlblxuICogdGhlIGdpdmVuIGNoYXJhY3RlciBhbmQgYSBnbHlwaDsgZm9yIGNvbXBsZXggc2NyaXB0cyB0aGlzIG1pZ2h0IG5vdCBiZSB0aGUgY2FzZS5cbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5Gb250LnByb3RvdHlwZS5jaGFyVG9HbHlwaCA9IGZ1bmN0aW9uKGMpIHtcbiAgICB2YXIgZ2x5cGhJbmRleCA9IHRoaXMuY2hhclRvR2x5cGhJbmRleChjKTtcbiAgICB2YXIgZ2x5cGggPSB0aGlzLmdseXBocy5nZXQoZ2x5cGhJbmRleCk7XG4gICAgaWYgKCFnbHlwaCkge1xuICAgICAgICAvLyAubm90ZGVmXG4gICAgICAgIGdseXBoID0gdGhpcy5nbHlwaHMuZ2V0KDApO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaDtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gdGV4dCB0byBhIGxpc3Qgb2YgR2x5cGggb2JqZWN0cy5cbiAqIE5vdGUgdGhhdCB0aGVyZSBpcyBubyBzdHJpY3Qgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW4gY2hhcmFjdGVycyBhbmRcbiAqIGdseXBocywgc28gdGhlIGxpc3Qgb2YgcmV0dXJuZWQgZ2x5cGhzIGNhbiBiZSBsYXJnZXIgb3Igc21hbGxlciB0aGFuIHRoZVxuICogbGVuZ3RoIG9mIHRoZSBnaXZlbiBzdHJpbmcuXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGhbXX1cbiAqL1xuRm9udC5wcm90b3R5cGUuc3RyaW5nVG9HbHlwaHMgPSBmdW5jdGlvbihzLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB0aGlzLmRlZmF1bHRSZW5kZXJPcHRpb25zO1xuICAgIC8vIEdldCBnbHlwaCBpbmRleGVzXG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSBzW2ldO1xuICAgICAgICBpbmRleGVzLnB1c2godGhpcyQxLmNoYXJUb0dseXBoSW5kZXgoYykpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gaW5kZXhlcy5sZW5ndGg7XG5cbiAgICAvLyBBcHBseSBzdWJzdGl0dXRpb25zIG9uIGdseXBoIGluZGV4ZXNcbiAgICBpZiAob3B0aW9ucy5mZWF0dXJlcykge1xuICAgICAgICB2YXIgc2NyaXB0ID0gb3B0aW9ucy5zY3JpcHQgfHwgdGhpcy5zdWJzdGl0dXRpb24uZ2V0RGVmYXVsdFNjcmlwdE5hbWUoKTtcbiAgICAgICAgdmFyIG1hbnlUb09uZSA9IFtdO1xuICAgICAgICBpZiAob3B0aW9ucy5mZWF0dXJlcy5saWdhKSB7IG1hbnlUb09uZSA9IG1hbnlUb09uZS5jb25jYXQodGhpcy5zdWJzdGl0dXRpb24uZ2V0RmVhdHVyZSgnbGlnYScsIHNjcmlwdCwgb3B0aW9ucy5sYW5ndWFnZSkpOyB9XG4gICAgICAgIGlmIChvcHRpb25zLmZlYXR1cmVzLnJsaWcpIHsgbWFueVRvT25lID0gbWFueVRvT25lLmNvbmNhdCh0aGlzLnN1YnN0aXR1dGlvbi5nZXRGZWF0dXJlKCdybGlnJywgc2NyaXB0LCBvcHRpb25zLmxhbmd1YWdlKSk7IH1cbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYW55VG9PbmUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlnYXR1cmUgPSBtYW55VG9PbmVbal07XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBsaWdhdHVyZS5zdWI7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBDb3VudCA9IGNvbXBvbmVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoayA8IGNvbXBDb3VudCAmJiBjb21wb25lbnRzW2tdID09PSBpbmRleGVzW2kkMSArIGtdKSB7IGsrKzsgfVxuICAgICAgICAgICAgICAgIGlmIChrID09PSBjb21wQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlcy5zcGxpY2UoaSQxLCBjb21wQ291bnQsIGxpZ2F0dXJlLmJ5KTtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gbGVuZ3RoIC0gY29tcENvdW50ICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IGdseXBoIGluZGV4ZXMgdG8gZ2x5cGggb2JqZWN0c1xuICAgIHZhciBnbHlwaHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICB2YXIgbm90ZGVmID0gdGhpcy5nbHlwaHMuZ2V0KDApO1xuICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGxlbmd0aDsgaSQyICs9IDEpIHtcbiAgICAgICAgZ2x5cGhzW2kkMl0gPSB0aGlzJDEuZ2x5cGhzLmdldChpbmRleGVzW2kkMl0pIHx8IG5vdGRlZjtcbiAgICB9XG4gICAgcmV0dXJuIGdseXBocztcbn07XG5cbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Gb250LnByb3RvdHlwZS5uYW1lVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLmdseXBoTmFtZXMubmFtZVRvR2x5cGhJbmRleChuYW1lKTtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gKi9cbkZvbnQucHJvdG90eXBlLm5hbWVUb0dseXBoID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBnbHlwaEluZGV4ID0gdGhpcy5uYW1lVG9HbHlwaEluZGV4KG5hbWUpO1xuICAgIHZhciBnbHlwaCA9IHRoaXMuZ2x5cGhzLmdldChnbHlwaEluZGV4KTtcbiAgICBpZiAoIWdseXBoKSB7XG4gICAgICAgIC8vIC5ub3RkZWZcbiAgICAgICAgZ2x5cGggPSB0aGlzLmdseXBocy5nZXQoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBoO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9XG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbkZvbnQucHJvdG90eXBlLmdseXBoSW5kZXhUb05hbWUgPSBmdW5jdGlvbihnaWQpIHtcbiAgICBpZiAoIXRoaXMuZ2x5cGhOYW1lcy5nbHlwaEluZGV4VG9OYW1lKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nbHlwaE5hbWVzLmdseXBoSW5kZXhUb05hbWUoZ2lkKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgdGhlIHZhbHVlIG9mIHRoZSBrZXJuaW5nIHBhaXIgYmV0d2VlbiB0aGUgbGVmdCBnbHlwaCAob3IgaXRzIGluZGV4KVxuICogYW5kIHRoZSByaWdodCBnbHlwaCAob3IgaXRzIGluZGV4KS4gSWYgbm8ga2VybmluZyBwYWlyIGlzIGZvdW5kLCByZXR1cm4gMC5cbiAqIFRoZSBrZXJuaW5nIHZhbHVlIGdldHMgYWRkZWQgdG8gdGhlIGFkdmFuY2Ugd2lkdGggd2hlbiBjYWxjdWxhdGluZyB0aGUgc3BhY2luZ1xuICogYmV0d2VlbiBnbHlwaHMuXG4gKiBAcGFyYW0gIHtvcGVudHlwZS5HbHlwaH0gbGVmdEdseXBoXG4gKiBAcGFyYW0gIHtvcGVudHlwZS5HbHlwaH0gcmlnaHRHbHlwaFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Gb250LnByb3RvdHlwZS5nZXRLZXJuaW5nVmFsdWUgPSBmdW5jdGlvbihsZWZ0R2x5cGgsIHJpZ2h0R2x5cGgpIHtcbiAgICBsZWZ0R2x5cGggPSBsZWZ0R2x5cGguaW5kZXggfHwgbGVmdEdseXBoO1xuICAgIHJpZ2h0R2x5cGggPSByaWdodEdseXBoLmluZGV4IHx8IHJpZ2h0R2x5cGg7XG4gICAgcmV0dXJuIHRoaXMua2VybmluZ1BhaXJzW2xlZnRHbHlwaCArICcsJyArIHJpZ2h0R2x5cGhdIHx8IDA7XG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIEdseXBoUmVuZGVyT3B0aW9uc1xuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3NjcmlwdF0gLSBzY3JpcHQgdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggZmVhdHVyZXMgdG8gYXBwbHkuIEJ5IGRlZmF1bHQsICdERkxUJyBvciAnbGF0bicgaXMgdXNlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL3NjcmlwdHRhZ3MuaHRtXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J10gLSBsYW5ndWFnZSBzeXN0ZW0gdXNlZCB0byBkZXRlcm1pbmUgd2hpY2ggZmVhdHVyZXMgdG8gYXBwbHkuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTZWUgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L2RldmVsb3BlcnMvb3BlbnR5cGUvbGFuZ3VhZ2V0YWdzLmFzcHhcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2tlcm5pbmc9dHJ1ZV0gLSB3aGV0aGVyIHRvIGluY2x1ZGUga2VybmluZyB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbZmVhdHVyZXNdIC0gT3BlblR5cGUgTGF5b3V0IGZlYXR1cmUgdGFncy4gVXNlZCB0byBlbmFibGUgb3IgZGlzYWJsZSB0aGUgZmVhdHVyZXMgb2YgdGhlIGdpdmVuIHNjcmlwdC9sYW5ndWFnZSBzeXN0ZW0uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjL2ZlYXR1cmV0YWdzLmh0bVxuICovXG5Gb250LnByb3RvdHlwZS5kZWZhdWx0UmVuZGVyT3B0aW9ucyA9IHtcbiAgICBrZXJuaW5nOiB0cnVlLFxuICAgIGZlYXR1cmVzOiB7XG4gICAgICAgIGxpZ2E6IHRydWUsXG4gICAgICAgIHJsaWc6IHRydWVcbiAgICB9XG59O1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBlYWNoIGdseXBoIGluIHRoZSBnaXZlbiB0ZXh0LlxuICogVGhlIGNhbGxiYWNrIGdldHMgYChnbHlwaCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpYC4qIEBwYXJhbSAge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBhcHBseS5cbiAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbkZvbnQucHJvdG90eXBlLmZvckVhY2hHbHlwaCA9IGZ1bmN0aW9uKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgeCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuICAgIHkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcbiAgICBmb250U2l6ZSA9IGZvbnRTaXplICE9PSB1bmRlZmluZWQgPyBmb250U2l6ZSA6IDcyO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHRoaXMuZGVmYXVsdFJlbmRlck9wdGlvbnM7XG4gICAgdmFyIGZvbnRTY2FsZSA9IDEgLyB0aGlzLnVuaXRzUGVyRW0gKiBmb250U2l6ZTtcbiAgICB2YXIgZ2x5cGhzID0gdGhpcy5zdHJpbmdUb0dseXBocyh0ZXh0LCBvcHRpb25zKTtcbiAgICB2YXIga2VybmluZ0xvb2t1cHM7XG4gICAgaWYgKG9wdGlvbnMua2VybmluZykge1xuICAgICAgICB2YXIgc2NyaXB0ID0gb3B0aW9ucy5zY3JpcHQgfHwgdGhpcy5wb3NpdGlvbi5nZXREZWZhdWx0U2NyaXB0TmFtZSgpO1xuICAgICAgICBrZXJuaW5nTG9va3VwcyA9IHRoaXMucG9zaXRpb24uZ2V0S2VybmluZ1RhYmxlcyhzY3JpcHQsIG9wdGlvbnMubGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcyQxLCBnbHlwaCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZ2x5cGguYWR2YW5jZVdpZHRoKSB7XG4gICAgICAgICAgICB4ICs9IGdseXBoLmFkdmFuY2VXaWR0aCAqIGZvbnRTY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmtlcm5pbmcgJiYgaSA8IGdseXBocy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAvLyBXZSBzaG91bGQgYXBwbHkgcG9zaXRpb24gYWRqdXN0bWVudCBsb29rdXBzIGluIGEgbW9yZSBnZW5lcmljIHdheS5cbiAgICAgICAgICAgIC8vIEhlcmUgd2Ugb25seSB1c2UgdGhlIHhBZHZhbmNlIHZhbHVlLlxuICAgICAgICAgICAgdmFyIGtlcm5pbmdWYWx1ZSA9IGtlcm5pbmdMb29rdXBzID9cbiAgICAgICAgICAgICAgICAgIHRoaXMkMS5wb3NpdGlvbi5nZXRLZXJuaW5nVmFsdWUoa2VybmluZ0xvb2t1cHMsIGdseXBoLmluZGV4LCBnbHlwaHNbaSArIDFdLmluZGV4KSA6XG4gICAgICAgICAgICAgICAgICB0aGlzJDEuZ2V0S2VybmluZ1ZhbHVlKGdseXBoLCBnbHlwaHNbaSArIDFdKTtcbiAgICAgICAgICAgIHggKz0ga2VybmluZ1ZhbHVlICogZm9udFNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubGV0dGVyU3BhY2luZykge1xuICAgICAgICAgICAgeCArPSBvcHRpb25zLmxldHRlclNwYWNpbmcgKiBmb250U2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnRyYWNraW5nKSB7XG4gICAgICAgICAgICB4ICs9IChvcHRpb25zLnRyYWNraW5nIC8gMTAwMCkgKiBmb250U2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgUGF0aCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBnaXZlbiB0ZXh0LlxuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5QYXRofVxuICovXG5Gb250LnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24odGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB2YXIgZnVsbFBhdGggPSBuZXcgUGF0aCgpO1xuICAgIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbihnbHlwaCwgZ1gsIGdZLCBnRm9udFNpemUpIHtcbiAgICAgICAgdmFyIGdseXBoUGF0aCA9IGdseXBoLmdldFBhdGgoZ1gsIGdZLCBnRm9udFNpemUsIG9wdGlvbnMsIHRoaXMpO1xuICAgICAgICBmdWxsUGF0aC5leHRlbmQoZ2x5cGhQYXRoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVsbFBhdGg7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbiBhcnJheSBvZiBQYXRoIG9iamVjdHMgdGhhdCByZXByZXNlbnQgdGhlIGdseXBocyBvZiBhIGdpdmVuIHRleHQuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAqIEByZXR1cm4ge29wZW50eXBlLlBhdGhbXX1cbiAqL1xuRm9udC5wcm90b3R5cGUuZ2V0UGF0aHMgPSBmdW5jdGlvbih0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHZhciBnbHlwaFBhdGhzID0gW107XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uKGdseXBoLCBnWCwgZ1ksIGdGb250U2l6ZSkge1xuICAgICAgICB2YXIgZ2x5cGhQYXRoID0gZ2x5cGguZ2V0UGF0aChnWCwgZ1ksIGdGb250U2l6ZSwgb3B0aW9ucywgdGhpcyk7XG4gICAgICAgIGdseXBoUGF0aHMucHVzaChnbHlwaFBhdGgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGdseXBoUGF0aHM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGFkdmFuY2Ugd2lkdGggb2YgYSB0ZXh0LlxuICpcbiAqIFRoaXMgaXMgc29tZXRoaW5nIGRpZmZlcmVudCB0aGFuIFBhdGguZ2V0Qm91bmRpbmdCb3goKSBhcyBmb3IgZXhhbXBsZSBhXG4gKiBzdWZmaXhlZCB3aGl0ZXNwYWNlIGluY3JlYXNlcyB0aGUgYWR2YW5jZVdpZHRoIGJ1dCBub3QgdGhlIGJvdW5kaW5nIGJveFxuICogb3IgYW4gb3ZlcmhhbmdpbmcgbGV0dGVyIGxpa2UgYSBjYWxsaWdyYXBoaWMgJ2YnIG1pZ2h0IGhhdmUgYSBxdWl0ZSBsYXJnZXJcbiAqIGJvdW5kaW5nIGJveCB0aGFuIGl0cyBhZHZhbmNlIHdpZHRoLlxuICpcbiAqIFRoaXMgY29ycmVzcG9uZHMgdG8gY2FudmFzMmRDb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAqIEByZXR1cm4gYWR2YW5jZSB3aWR0aFxuICovXG5Gb250LnByb3RvdHlwZS5nZXRBZHZhbmNlV2lkdGggPSBmdW5jdGlvbih0ZXh0LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmZvckVhY2hHbHlwaCh0ZXh0LCAwLCAwLCBmb250U2l6ZSwgb3B0aW9ucywgZnVuY3Rpb24oKSB7fSk7XG59O1xuXG4vKipcbiAqIERyYXcgdGhlIHRleHQgb24gdGhlIGdpdmVuIGRyYXdpbmcgY29udGV4dC5cbiAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuICogQHBhcmFtICB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKi9cbkZvbnQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjdHgsIHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdGhpcy5nZXRQYXRoKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKS5kcmF3KGN0eCk7XG59O1xuXG4vKipcbiAqIERyYXcgdGhlIHBvaW50cyBvZiBhbGwgZ2x5cGhzIGluIHRoZSB0ZXh0LlxuICogT24tY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gYmx1ZSwgb2ZmLWN1cnZlIHBvaW50cyB3aWxsIGJlIGRyYXduIGluIHJlZC5cbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICogQHBhcmFtIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKi9cbkZvbnQucHJvdG90eXBlLmRyYXdQb2ludHMgPSBmdW5jdGlvbihjdHgsIHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uKGdseXBoLCBnWCwgZ1ksIGdGb250U2l6ZSkge1xuICAgICAgICBnbHlwaC5kcmF3UG9pbnRzKGN0eCwgZ1gsIGdZLCBnRm9udFNpemUpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBEcmF3IGxpbmVzIGluZGljYXRpbmcgaW1wb3J0YW50IGZvbnQgbWVhc3VyZW1lbnRzIGZvciBhbGwgZ2x5cGhzIGluIHRoZSB0ZXh0LlxuICogQmxhY2sgbGluZXMgaW5kaWNhdGUgdGhlIG9yaWdpbiBvZiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gKHBvaW50IDAsMCkuXG4gKiBCbHVlIGxpbmVzIGluZGljYXRlIHRoZSBnbHlwaCBib3VuZGluZyBib3guXG4gKiBHcmVlbiBsaW5lIGluZGljYXRlcyB0aGUgYWR2YW5jZSB3aWR0aCBvZiB0aGUgZ2x5cGguXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4IC0gQSAyRCBkcmF3aW5nIGNvbnRleHQsIGxpa2UgQ2FudmFzLlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuICovXG5Gb250LnByb3RvdHlwZS5kcmF3TWV0cmljcyA9IGZ1bmN0aW9uKGN0eCwgdGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmZvckVhY2hHbHlwaCh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucywgZnVuY3Rpb24oZ2x5cGgsIGdYLCBnWSwgZ0ZvbnRTaXplKSB7XG4gICAgICAgIGdseXBoLmRyYXdNZXRyaWNzKGN0eCwgZ1gsIGdZLCBnRm9udFNpemUpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbkZvbnQucHJvdG90eXBlLmdldEVuZ2xpc2hOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciB0cmFuc2xhdGlvbnMgPSB0aGlzLm5hbWVzW25hbWVdO1xuICAgIGlmICh0cmFuc2xhdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9ucy5lbjtcbiAgICB9XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlXG4gKi9cbkZvbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHdhcm5pbmdzID0gW107XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGFzc2VydChwcmVkaWNhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUpIHtcbiAgICAgICAgICAgIHdhcm5pbmdzLnB1c2gobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhc3NlcnROYW1lUHJlc2VudChuYW1lKSB7XG4gICAgICAgIHZhciBlbmdsaXNoTmFtZSA9IF90aGlzLmdldEVuZ2xpc2hOYW1lKG5hbWUpO1xuICAgICAgICBhc3NlcnQoZW5nbGlzaE5hbWUgJiYgZW5nbGlzaE5hbWUudHJpbSgpLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICAgICAnTm8gRW5nbGlzaCAnICsgbmFtZSArICcgc3BlY2lmaWVkLicpO1xuICAgIH1cblxuICAgIC8vIElkZW50aWZpY2F0aW9uIGluZm9ybWF0aW9uXG4gICAgYXNzZXJ0TmFtZVByZXNlbnQoJ2ZvbnRGYW1pbHknKTtcbiAgICBhc3NlcnROYW1lUHJlc2VudCgnd2VpZ2h0TmFtZScpO1xuICAgIGFzc2VydE5hbWVQcmVzZW50KCdtYW51ZmFjdHVyZXInKTtcbiAgICBhc3NlcnROYW1lUHJlc2VudCgnY29weXJpZ2h0Jyk7XG4gICAgYXNzZXJ0TmFtZVByZXNlbnQoJ3ZlcnNpb24nKTtcblxuICAgIC8vIERpbWVuc2lvbiBpbmZvcm1hdGlvblxuICAgIGFzc2VydCh0aGlzLnVuaXRzUGVyRW0gPiAwLCAnTm8gdW5pdHNQZXJFbSBzcGVjaWZpZWQuJyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIGZvbnQgb2JqZWN0IHRvIGEgU0ZOVCBkYXRhIHN0cnVjdHVyZS5cbiAqIFRoaXMgc3RydWN0dXJlIGNvbnRhaW5zIGFsbCB0aGUgbmVjZXNzYXJ5IHRhYmxlcyBhbmQgbWV0YWRhdGEgdG8gY3JlYXRlIGEgYmluYXJ5IE9URiBmaWxlLlxuICogQHJldHVybiB7b3BlbnR5cGUuVGFibGV9XG4gKi9cbkZvbnQucHJvdG90eXBlLnRvVGFibGVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHNmbnQuZm9udFRvVGFibGUodGhpcyk7XG59O1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBGb250LnRvQnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBGb250LnRvQXJyYXlCdWZmZXIgaW5zdGVhZC5cbiAqL1xuRm9udC5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLndhcm4oJ0ZvbnQudG9CdWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIEZvbnQudG9BcnJheUJ1ZmZlciBpbnN0ZWFkLicpO1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlCdWZmZXIoKTtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgYG9wZW50eXBlLkZvbnRgIGludG8gYW4gYEFycmF5QnVmZmVyYFxuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9XG4gKi9cbkZvbnQucHJvdG90eXBlLnRvQXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2ZudFRhYmxlID0gdGhpcy50b1RhYmxlcygpO1xuICAgIHZhciBieXRlcyA9IHNmbnRUYWJsZS5lbmNvZGUoKTtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzLmxlbmd0aCk7XG4gICAgdmFyIGludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludEFycmF5W2ldID0gYnl0ZXNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbi8qKlxuICogSW5pdGlhdGUgYSBkb3dubG9hZCBvZiB0aGUgT3BlblR5cGUgZm9udC5cbiAqL1xuRm9udC5wcm90b3R5cGUuZG93bmxvYWQgPSBmdW5jdGlvbihmaWxlTmFtZSkge1xuICAgIHZhciBmYW1pbHlOYW1lID0gdGhpcy5nZXRFbmdsaXNoTmFtZSgnZm9udEZhbWlseScpO1xuICAgIHZhciBzdHlsZU5hbWUgPSB0aGlzLmdldEVuZ2xpc2hOYW1lKCdmb250U3ViZmFtaWx5Jyk7XG4gICAgZmlsZU5hbWUgPSBmaWxlTmFtZSB8fCBmYW1pbHlOYW1lLnJlcGxhY2UoL1xccy9nLCAnJykgKyAnLScgKyBzdHlsZU5hbWUgKyAnLm90Zic7XG4gICAgdmFyIGFycmF5QnVmZmVyID0gdGhpcy50b0FycmF5QnVmZmVyKCk7XG5cbiAgICBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtID0gd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0RmlsZVN5c3RlbTtcbiAgICAgICAgd2luZG93LnJlcXVlc3RGaWxlU3lzdGVtKHdpbmRvdy5URU1QT1JBUlksIGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgsIGZ1bmN0aW9uKGZzKSB7XG4gICAgICAgICAgICBmcy5yb290LmdldEZpbGUoZmlsZU5hbWUsIHtjcmVhdGU6IHRydWV9LCBmdW5jdGlvbihmaWxlRW50cnkpIHtcbiAgICAgICAgICAgICAgICBmaWxlRW50cnkuY3JlYXRlV3JpdGVyKGZ1bmN0aW9uKHdyaXRlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcoYXJyYXlCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtkYXRhVmlld10sIHt0eXBlOiAnZm9udC9vcGVudHlwZSd9KTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlKGJsb2IpO1xuXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5hZGRFdmVudExpc3RlbmVyKCd3cml0ZWVuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmF2aWdhdGluZyB0byB0aGUgZmlsZSB3aWxsIGRvd25sb2FkIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb24uaHJlZiA9IGZpbGVFbnRyeS50b1VSTCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyLm5hbWUgKyAnOiAnICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuICAgICAgICB2YXIgYnVmZmVyID0gYXJyYXlCdWZmZXJUb05vZGVCdWZmZXIoYXJyYXlCdWZmZXIpO1xuICAgICAgICBmcy53cml0ZUZpbGVTeW5jKGZpbGVOYW1lLCBidWZmZXIpO1xuICAgIH1cbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbkZvbnQucHJvdG90eXBlLmZzU2VsZWN0aW9uVmFsdWVzID0ge1xuICAgIElUQUxJQzogICAgICAgICAgICAgIDB4MDAxLCAvLzFcbiAgICBVTkRFUlNDT1JFOiAgICAgICAgICAweDAwMiwgLy8yXG4gICAgTkVHQVRJVkU6ICAgICAgICAgICAgMHgwMDQsIC8vNFxuICAgIE9VVExJTkVEOiAgICAgICAgICAgIDB4MDA4LCAvLzhcbiAgICBTVFJJS0VPVVQ6ICAgICAgICAgICAweDAxMCwgLy8xNlxuICAgIEJPTEQ6ICAgICAgICAgICAgICAgIDB4MDIwLCAvLzMyXG4gICAgUkVHVUxBUjogICAgICAgICAgICAgMHgwNDAsIC8vNjRcbiAgICBVU0VSX1RZUE9fTUVUUklDUzogICAweDA4MCwgLy8xMjhcbiAgICBXV1M6ICAgICAgICAgICAgICAgICAweDEwMCwgLy8yNTZcbiAgICBPQkxJUVVFOiAgICAgICAgICAgICAweDIwMCAgLy81MTJcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRm9udC5wcm90b3R5cGUudXNXaWR0aENsYXNzZXMgPSB7XG4gICAgVUxUUkFfQ09OREVOU0VEOiAxLFxuICAgIEVYVFJBX0NPTkRFTlNFRDogMixcbiAgICBDT05ERU5TRUQ6IDMsXG4gICAgU0VNSV9DT05ERU5TRUQ6IDQsXG4gICAgTUVESVVNOiA1LFxuICAgIFNFTUlfRVhQQU5ERUQ6IDYsXG4gICAgRVhQQU5ERUQ6IDcsXG4gICAgRVhUUkFfRVhQQU5ERUQ6IDgsXG4gICAgVUxUUkFfRVhQQU5ERUQ6IDlcbn07XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRm9udC5wcm90b3R5cGUudXNXZWlnaHRDbGFzc2VzID0ge1xuICAgIFRISU46IDEwMCxcbiAgICBFWFRSQV9MSUdIVDogMjAwLFxuICAgIExJR0hUOiAzMDAsXG4gICAgTk9STUFMOiA0MDAsXG4gICAgTUVESVVNOiA1MDAsXG4gICAgU0VNSV9CT0xEOiA2MDAsXG4gICAgQk9MRDogNzAwLFxuICAgIEVYVFJBX0JPTEQ6IDgwMCxcbiAgICBCTEFDSzogICAgOTAwXG59O1xuXG4vLyBUaGUgYGZ2YXJgIHRhYmxlIHN0b3JlcyBmb250IHZhcmlhdGlvbiBheGVzIGFuZCBpbnN0YW5jZXMuXG4vLyBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9udHMvVHJ1ZVR5cGUtUmVmZXJlbmNlLU1hbnVhbC9STTA2L0NoYXA2ZnZhci5odG1sXG5cbmZ1bmN0aW9uIGFkZE5hbWUobmFtZSwgbmFtZXMpIHtcbiAgICB2YXIgbmFtZVN0cmluZyA9IEpTT04uc3RyaW5naWZ5KG5hbWUpO1xuICAgIHZhciBuYW1lSUQgPSAyNTY7XG4gICAgZm9yICh2YXIgbmFtZUtleSBpbiBuYW1lcykge1xuICAgICAgICB2YXIgbiA9IHBhcnNlSW50KG5hbWVLZXkpO1xuICAgICAgICBpZiAoIW4gfHwgbiA8IDI1Nikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSlNPTi5zdHJpbmdpZnkobmFtZXNbbmFtZUtleV0pID09PSBuYW1lU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuYW1lSUQgPD0gbikge1xuICAgICAgICAgICAgbmFtZUlEID0gbiArIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuYW1lc1tuYW1lSURdID0gbmFtZTtcbiAgICByZXR1cm4gbmFtZUlEO1xufVxuXG5mdW5jdGlvbiBtYWtlRnZhckF4aXMobiwgYXhpcywgbmFtZXMpIHtcbiAgICB2YXIgbmFtZUlEID0gYWRkTmFtZShheGlzLm5hbWUsIG5hbWVzKTtcbiAgICByZXR1cm4gW1xuICAgICAgICB7bmFtZTogJ3RhZ18nICsgbiwgdHlwZTogJ1RBRycsIHZhbHVlOiBheGlzLnRhZ30sXG4gICAgICAgIHtuYW1lOiAnbWluVmFsdWVfJyArIG4sIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiBheGlzLm1pblZhbHVlIDw8IDE2fSxcbiAgICAgICAge25hbWU6ICdkZWZhdWx0VmFsdWVfJyArIG4sIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiBheGlzLmRlZmF1bHRWYWx1ZSA8PCAxNn0sXG4gICAgICAgIHtuYW1lOiAnbWF4VmFsdWVfJyArIG4sIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiBheGlzLm1heFZhbHVlIDw8IDE2fSxcbiAgICAgICAge25hbWU6ICdmbGFnc18nICsgbiwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICduYW1lSURfJyArIG4sIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbmFtZUlEfVxuICAgIF07XG59XG5cbmZ1bmN0aW9uIHBhcnNlRnZhckF4aXMoZGF0YSwgc3RhcnQsIG5hbWVzKSB7XG4gICAgdmFyIGF4aXMgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGF4aXMudGFnID0gcC5wYXJzZVRhZygpO1xuICAgIGF4aXMubWluVmFsdWUgPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBheGlzLmRlZmF1bHRWYWx1ZSA9IHAucGFyc2VGaXhlZCgpO1xuICAgIGF4aXMubWF4VmFsdWUgPSBwLnBhcnNlRml4ZWQoKTtcbiAgICBwLnNraXAoJ3VTaG9ydCcsIDEpOyAgLy8gcmVzZXJ2ZWQgZm9yIGZsYWdzOyBubyB2YWx1ZXMgZGVmaW5lZFxuICAgIGF4aXMubmFtZSA9IG5hbWVzW3AucGFyc2VVU2hvcnQoKV0gfHwge307XG4gICAgcmV0dXJuIGF4aXM7XG59XG5cbmZ1bmN0aW9uIG1ha2VGdmFySW5zdGFuY2UobiwgaW5zdCwgYXhlcywgbmFtZXMpIHtcbiAgICB2YXIgbmFtZUlEID0gYWRkTmFtZShpbnN0Lm5hbWUsIG5hbWVzKTtcbiAgICB2YXIgZmllbGRzID0gW1xuICAgICAgICB7bmFtZTogJ25hbWVJRF8nICsgbiwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBuYW1lSUR9LFxuICAgICAgICB7bmFtZTogJ2ZsYWdzXycgKyBuLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9XG4gICAgXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgYXhpc1RhZyA9IGF4ZXNbaV0udGFnO1xuICAgICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiAnYXhpc18nICsgbiArICcgJyArIGF4aXNUYWcsXG4gICAgICAgICAgICB0eXBlOiAnRklYRUQnLFxuICAgICAgICAgICAgdmFsdWU6IGluc3QuY29vcmRpbmF0ZXNbYXhpc1RhZ10gPDwgMTZcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gcGFyc2VGdmFySW5zdGFuY2UoZGF0YSwgc3RhcnQsIGF4ZXMsIG5hbWVzKSB7XG4gICAgdmFyIGluc3QgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGluc3QubmFtZSA9IG5hbWVzW3AucGFyc2VVU2hvcnQoKV0gfHwge307XG4gICAgcC5za2lwKCd1U2hvcnQnLCAxKTsgIC8vIHJlc2VydmVkIGZvciBmbGFnczsgbm8gdmFsdWVzIGRlZmluZWRcblxuICAgIGluc3QuY29vcmRpbmF0ZXMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaW5zdC5jb29yZGluYXRlc1theGVzW2ldLnRhZ10gPSBwLnBhcnNlRml4ZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdDtcbn1cblxuZnVuY3Rpb24gbWFrZUZ2YXJUYWJsZShmdmFyLCBuYW1lcykge1xuICAgIHZhciByZXN1bHQgPSBuZXcgdGFibGUuVGFibGUoJ2Z2YXInLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAweDEwMDAwfSxcbiAgICAgICAge25hbWU6ICdvZmZzZXRUb0RhdGEnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2NvdW50U2l6ZVBhaXJzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAyfSxcbiAgICAgICAge25hbWU6ICdheGlzQ291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGZ2YXIuYXhlcy5sZW5ndGh9LFxuICAgICAgICB7bmFtZTogJ2F4aXNTaXplJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAyMH0sXG4gICAgICAgIHtuYW1lOiAnaW5zdGFuY2VDb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZnZhci5pbnN0YW5jZXMubGVuZ3RofSxcbiAgICAgICAge25hbWU6ICdpbnN0YW5jZVNpemUnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDQgKyBmdmFyLmF4ZXMubGVuZ3RoICogNH1cbiAgICBdKTtcbiAgICByZXN1bHQub2Zmc2V0VG9EYXRhID0gcmVzdWx0LnNpemVPZigpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmdmFyLmF4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0LmZpZWxkcyA9IHJlc3VsdC5maWVsZHMuY29uY2F0KG1ha2VGdmFyQXhpcyhpLCBmdmFyLmF4ZXNbaV0sIG5hbWVzKSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBmdmFyLmluc3RhbmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICByZXN1bHQuZmllbGRzID0gcmVzdWx0LmZpZWxkcy5jb25jYXQobWFrZUZ2YXJJbnN0YW5jZShqLCBmdmFyLmluc3RhbmNlc1tqXSwgZnZhci5heGVzLCBuYW1lcykpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRnZhclRhYmxlKGRhdGEsIHN0YXJ0LCBuYW1lcykge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMHgwMDAxMDAwMCwgJ1Vuc3VwcG9ydGVkIGZ2YXIgdGFibGUgdmVyc2lvbi4nKTtcbiAgICB2YXIgb2Zmc2V0VG9EYXRhID0gcC5wYXJzZU9mZnNldDE2KCk7XG4gICAgLy8gU2tpcCBjb3VudFNpemVQYWlycy5cbiAgICBwLnNraXAoJ3VTaG9ydCcsIDEpO1xuICAgIHZhciBheGlzQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGF4aXNTaXplID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBpbnN0YW5jZUNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBpbnN0YW5jZVNpemUgPSBwLnBhcnNlVVNob3J0KCk7XG5cbiAgICB2YXIgYXhlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhpc0NvdW50OyBpKyspIHtcbiAgICAgICAgYXhlcy5wdXNoKHBhcnNlRnZhckF4aXMoZGF0YSwgc3RhcnQgKyBvZmZzZXRUb0RhdGEgKyBpICogYXhpc1NpemUsIG5hbWVzKSk7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlcyA9IFtdO1xuICAgIHZhciBpbnN0YW5jZVN0YXJ0ID0gc3RhcnQgKyBvZmZzZXRUb0RhdGEgKyBheGlzQ291bnQgKiBheGlzU2l6ZTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGluc3RhbmNlQ291bnQ7IGorKykge1xuICAgICAgICBpbnN0YW5jZXMucHVzaChwYXJzZUZ2YXJJbnN0YW5jZShkYXRhLCBpbnN0YW5jZVN0YXJ0ICsgaiAqIGluc3RhbmNlU2l6ZSwgYXhlcywgbmFtZXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge2F4ZXM6IGF4ZXMsIGluc3RhbmNlczogaW5zdGFuY2VzfTtcbn1cblxudmFyIGZ2YXIgPSB7IG1ha2U6IG1ha2VGdmFyVGFibGUsIHBhcnNlOiBwYXJzZUZ2YXJUYWJsZSB9O1xuXG4vLyBUaGUgYEdQT1NgIHRhYmxlIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMsIGFtb25nIG90aGVyIHRoaW5ncy5cbi8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9ncG9zXG5cbnZhciBzdWJ0YWJsZVBhcnNlcnMkMSA9IG5ldyBBcnJheSgxMCk7ICAgICAgICAgLy8gc3VidGFibGVQYXJzZXJzWzBdIGlzIHVudXNlZFxuXG4vLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvZ3BvcyNsb29rdXAtdHlwZS0xLXNpbmdsZS1hZGp1c3RtZW50LXBvc2l0aW9uaW5nLXN1YnRhYmxlXG4vLyB0aGlzID0gUGFyc2VyIGluc3RhbmNlXG5zdWJ0YWJsZVBhcnNlcnMkMVsxXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMSgpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIHBvc2Zvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAocG9zZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3NGb3JtYXQ6IDEsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQoKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAocG9zZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3NGb3JtYXQ6IDIsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIHZhbHVlczogdGhpcy5wYXJzZVZhbHVlUmVjb3JkTGlzdCgpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrLmFzc2VydChmYWxzZSwgJzB4JyArIHN0YXJ0LnRvU3RyaW5nKDE2KSArICc6IEdQT1MgbG9va3VwIHR5cGUgMSBmb3JtYXQgbXVzdCBiZSAxIG9yIDIuJyk7XG59O1xuXG4vLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvZ3BvcyNsb29rdXAtdHlwZS0yLXBhaXItYWRqdXN0bWVudC1wb3NpdGlvbmluZy1zdWJ0YWJsZVxuc3VidGFibGVQYXJzZXJzJDFbMl0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDIoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBwb3NGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGNvdmVyYWdlID0gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKTtcbiAgICB2YXIgdmFsdWVGb3JtYXQxID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciB2YWx1ZUZvcm1hdDIgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKHBvc0Zvcm1hdCA9PT0gMSkge1xuICAgICAgICAvLyBBZGp1c3RtZW50cyBmb3IgR2x5cGggUGFpcnNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc0Zvcm1hdDogcG9zRm9ybWF0LFxuICAgICAgICAgICAgY292ZXJhZ2U6IGNvdmVyYWdlLFxuICAgICAgICAgICAgdmFsdWVGb3JtYXQxOiB2YWx1ZUZvcm1hdDEsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdDI6IHZhbHVlRm9ybWF0MixcbiAgICAgICAgICAgIHBhaXJTZXRzOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIubGlzdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAgICAgICAgLy8gcGFpclZhbHVlUmVjb3JkXG4gICAgICAgICAgICAgICAgICAgIHNlY29uZEdseXBoOiB0aGlzLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlMTogdGhpcy5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0MSksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlMjogdGhpcy5wYXJzZVZhbHVlUmVjb3JkKHZhbHVlRm9ybWF0MilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAocG9zRm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHZhciBjbGFzc0RlZjEgPSB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpO1xuICAgICAgICB2YXIgY2xhc3NEZWYyID0gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKTtcbiAgICAgICAgdmFyIGNsYXNzMUNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgY2xhc3MyQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvLyBDbGFzcyBQYWlyIEFkanVzdG1lbnRcbiAgICAgICAgICAgIHBvc0Zvcm1hdDogcG9zRm9ybWF0LFxuICAgICAgICAgICAgY292ZXJhZ2U6IGNvdmVyYWdlLFxuICAgICAgICAgICAgdmFsdWVGb3JtYXQxOiB2YWx1ZUZvcm1hdDEsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdDI6IHZhbHVlRm9ybWF0MixcbiAgICAgICAgICAgIGNsYXNzRGVmMTogY2xhc3NEZWYxLFxuICAgICAgICAgICAgY2xhc3NEZWYyOiBjbGFzc0RlZjIsXG4gICAgICAgICAgICBjbGFzczFDb3VudDogY2xhc3MxQ291bnQsXG4gICAgICAgICAgICBjbGFzczJDb3VudDogY2xhc3MyQ291bnQsXG4gICAgICAgICAgICBjbGFzc1JlY29yZHM6IHRoaXMucGFyc2VMaXN0KGNsYXNzMUNvdW50LCBQYXJzZXIubGlzdChjbGFzczJDb3VudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUxOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQodmFsdWVGb3JtYXQxKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUyOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQodmFsdWVGb3JtYXQyKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2hlY2suYXNzZXJ0KGZhbHNlLCAnMHgnICsgc3RhcnQudG9TdHJpbmcoMTYpICsgJzogR1BPUyBsb29rdXAgdHlwZSAyIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nKTtcbn07XG5cbnN1YnRhYmxlUGFyc2VycyQxWzNdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAzKCkgeyByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDMgbm90IHN1cHBvcnRlZCcgfTsgfTtcbnN1YnRhYmxlUGFyc2VycyQxWzRdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA0KCkgeyByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDQgbm90IHN1cHBvcnRlZCcgfTsgfTtcbnN1YnRhYmxlUGFyc2VycyQxWzVdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA1KCkgeyByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDUgbm90IHN1cHBvcnRlZCcgfTsgfTtcbnN1YnRhYmxlUGFyc2VycyQxWzZdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA2KCkgeyByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDYgbm90IHN1cHBvcnRlZCcgfTsgfTtcbnN1YnRhYmxlUGFyc2VycyQxWzddID0gZnVuY3Rpb24gcGFyc2VMb29rdXA3KCkgeyByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDcgbm90IHN1cHBvcnRlZCcgfTsgfTtcbnN1YnRhYmxlUGFyc2VycyQxWzhdID0gZnVuY3Rpb24gcGFyc2VMb29rdXA4KCkgeyByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDggbm90IHN1cHBvcnRlZCcgfTsgfTtcbnN1YnRhYmxlUGFyc2VycyQxWzldID0gZnVuY3Rpb24gcGFyc2VMb29rdXA5KCkgeyByZXR1cm4geyBlcnJvcjogJ0dQT1MgTG9va3VwIDkgbm90IHN1cHBvcnRlZCcgfTsgfTtcblxuLy8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2dwb3NcbmZ1bmN0aW9uIHBhcnNlR3Bvc1RhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICAgIHZhciBwID0gbmV3IFBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHRhYmxlVmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKDEpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHRhYmxlVmVyc2lvbiA9PT0gMSB8fCB0YWJsZVZlcnNpb24gPT09IDEuMSwgJ1Vuc3VwcG9ydGVkIEdQT1MgdGFibGUgdmVyc2lvbiAnICsgdGFibGVWZXJzaW9uKTtcblxuICAgIGlmICh0YWJsZVZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IHRhYmxlVmVyc2lvbixcbiAgICAgICAgICAgIHNjcmlwdHM6IHAucGFyc2VTY3JpcHRMaXN0KCksXG4gICAgICAgICAgICBmZWF0dXJlczogcC5wYXJzZUZlYXR1cmVMaXN0KCksXG4gICAgICAgICAgICBsb29rdXBzOiBwLnBhcnNlTG9va3VwTGlzdChzdWJ0YWJsZVBhcnNlcnMkMSlcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbjogdGFibGVWZXJzaW9uLFxuICAgICAgICAgICAgc2NyaXB0czogcC5wYXJzZVNjcmlwdExpc3QoKSxcbiAgICAgICAgICAgIGZlYXR1cmVzOiBwLnBhcnNlRmVhdHVyZUxpc3QoKSxcbiAgICAgICAgICAgIGxvb2t1cHM6IHAucGFyc2VMb29rdXBMaXN0KHN1YnRhYmxlUGFyc2VycyQxKSxcbiAgICAgICAgICAgIHZhcmlhdGlvbnM6IHAucGFyc2VGZWF0dXJlVmFyaWF0aW9uc0xpc3QoKVxuICAgICAgICB9O1xuICAgIH1cblxufVxuXG4vLyBHUE9TIFdyaXRpbmcgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gTk9UIFNVUFBPUlRFRFxudmFyIHN1YnRhYmxlTWFrZXJzJDEgPSBuZXcgQXJyYXkoMTApO1xuXG5mdW5jdGlvbiBtYWtlR3Bvc1RhYmxlKGdwb3MpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdHUE9TJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMHgxMDAwMH0sXG4gICAgICAgIHtuYW1lOiAnc2NyaXB0cycsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuU2NyaXB0TGlzdChncG9zLnNjcmlwdHMpfSxcbiAgICAgICAge25hbWU6ICdmZWF0dXJlcycsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuRmVhdHVyZUxpc3QoZ3Bvcy5mZWF0dXJlcyl9LFxuICAgICAgICB7bmFtZTogJ2xvb2t1cHMnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkxvb2t1cExpc3QoZ3Bvcy5sb29rdXBzLCBzdWJ0YWJsZU1ha2VycyQxKX1cbiAgICBdKTtcbn1cblxudmFyIGdwb3MgPSB7IHBhcnNlOiBwYXJzZUdwb3NUYWJsZSwgbWFrZTogbWFrZUdwb3NUYWJsZSB9O1xuXG4vLyBUaGUgYGtlcm5gIHRhYmxlIGNvbnRhaW5zIGtlcm5pbmcgcGFpcnMuXG4vLyBOb3RlIHRoYXQgc29tZSBmb250cyB1c2UgdGhlIEdQT1MgT3BlblR5cGUgbGF5b3V0IHRhYmxlIHRvIHNwZWNpZnkga2VybmluZy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMva2Vybi5odG1cblxuZnVuY3Rpb24gcGFyc2VXaW5kb3dzS2VyblRhYmxlKHApIHtcbiAgICB2YXIgcGFpcnMgPSB7fTtcbiAgICAvLyBTa2lwIG5UYWJsZXMuXG4gICAgcC5za2lwKCd1U2hvcnQnKTtcbiAgICB2YXIgc3VidGFibGVWZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHN1YnRhYmxlVmVyc2lvbiA9PT0gMCwgJ1Vuc3VwcG9ydGVkIGtlcm4gc3ViLXRhYmxlIHZlcnNpb24uJyk7XG4gICAgLy8gU2tpcCBzdWJ0YWJsZUxlbmd0aCwgc3VidGFibGVDb3ZlcmFnZVxuICAgIHAuc2tpcCgndVNob3J0JywgMik7XG4gICAgdmFyIG5QYWlycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAvLyBTa2lwIHNlYXJjaFJhbmdlLCBlbnRyeVNlbGVjdG9yLCByYW5nZVNoaWZ0LlxuICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFpcnM7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbGVmdEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgcmlnaHRJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIHBhaXJzW2xlZnRJbmRleCArICcsJyArIHJpZ2h0SW5kZXhdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbn1cblxuZnVuY3Rpb24gcGFyc2VNYWNLZXJuVGFibGUocCkge1xuICAgIHZhciBwYWlycyA9IHt9O1xuICAgIC8vIFRoZSBNYWMga2VybiB0YWJsZSBzdG9yZXMgdGhlIHZlcnNpb24gYXMgYSBmaXhlZCAoMzIgYml0cykgYnV0IHdlIG9ubHkgbG9hZGVkIHRoZSBmaXJzdCAxNiBiaXRzLlxuICAgIC8vIFNraXAgdGhlIHJlc3QuXG4gICAgcC5za2lwKCd1U2hvcnQnKTtcbiAgICB2YXIgblRhYmxlcyA9IHAucGFyc2VVTG9uZygpO1xuICAgIC8vY2hlY2suYXJndW1lbnQoblRhYmxlcyA9PT0gMSwgJ09ubHkgMSBzdWJ0YWJsZSBpcyBzdXBwb3J0ZWQgKGdvdCAnICsgblRhYmxlcyArICcpLicpO1xuICAgIGlmIChuVGFibGVzID4gMSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ09ubHkgdGhlIGZpcnN0IGtlcm4gc3VidGFibGUgaXMgc3VwcG9ydGVkLicpO1xuICAgIH1cbiAgICBwLnNraXAoJ3VMb25nJyk7XG4gICAgdmFyIGNvdmVyYWdlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBzdWJ0YWJsZVZlcnNpb24gPSBjb3ZlcmFnZSAmIDB4RkY7XG4gICAgcC5za2lwKCd1U2hvcnQnKTtcbiAgICBpZiAoc3VidGFibGVWZXJzaW9uID09PSAwKSB7XG4gICAgICAgIHZhciBuUGFpcnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIC8vIFNraXAgc2VhcmNoUmFuZ2UsIGVudHJ5U2VsZWN0b3IsIHJhbmdlU2hpZnQuXG4gICAgICAgIHAuc2tpcCgndVNob3J0JywgMyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgblBhaXJzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgICAgICB2YXIgcmlnaHRJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICAgICAgcGFpcnNbbGVmdEluZGV4ICsgJywnICsgcmlnaHRJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG59XG5cbi8vIFBhcnNlIHRoZSBga2VybmAgdGFibGUgd2hpY2ggY29udGFpbnMga2VybmluZyBwYWlycy5cbmZ1bmN0aW9uIHBhcnNlS2VyblRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmICh0YWJsZVZlcnNpb24gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlV2luZG93c0tlcm5UYWJsZShwKTtcbiAgICB9IGVsc2UgaWYgKHRhYmxlVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gcGFyc2VNYWNLZXJuVGFibGUocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBrZXJuIHRhYmxlIHZlcnNpb24gKCcgKyB0YWJsZVZlcnNpb24gKyAnKS4nKTtcbiAgICB9XG59XG5cbnZhciBrZXJuID0geyBwYXJzZTogcGFyc2VLZXJuVGFibGUgfTtcblxuLy8gVGhlIGBsb2NhYCB0YWJsZSBzdG9yZXMgdGhlIG9mZnNldHMgdG8gdGhlIGxvY2F0aW9ucyBvZiB0aGUgZ2x5cGhzIGluIHRoZSBmb250LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9sb2NhLmh0bVxuXG4vLyBQYXJzZSB0aGUgYGxvY2FgIHRhYmxlLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgb2Zmc2V0cyB0byB0aGUgbG9jYXRpb25zIG9mIHRoZSBnbHlwaHMgaW4gdGhlIGZvbnQsXG4vLyByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBnbHlwaERhdGEgdGFibGUuXG4vLyBUaGUgbnVtYmVyIG9mIGdseXBocyBzdG9yZWQgaW4gdGhlIGBsb2NhYCB0YWJsZSBpcyBzcGVjaWZpZWQgaW4gdGhlIGBtYXhwYCB0YWJsZSAodW5kZXIgbnVtR2x5cGhzKVxuLy8gVGhlIGxvY2EgdGFibGUgaGFzIHR3byB2ZXJzaW9uczogYSBzaG9ydCB2ZXJzaW9uIHdoZXJlIG9mZnNldHMgYXJlIHN0b3JlZCBhcyB1U2hvcnRzLCBhbmQgYSBsb25nXG4vLyB2ZXJzaW9uIHdoZXJlIG9mZnNldHMgYXJlIHN0b3JlZCBhcyB1TG9uZ3MuIFRoZSBgaGVhZGAgdGFibGUgc3BlY2lmaWVzIHdoaWNoIHZlcnNpb24gdG8gdXNlXG4vLyAodW5kZXIgaW5kZXhUb0xvY0Zvcm1hdCkuXG5mdW5jdGlvbiBwYXJzZUxvY2FUYWJsZShkYXRhLCBzdGFydCwgbnVtR2x5cGhzLCBzaG9ydFZlcnNpb24pIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBwYXJzZUZuID0gc2hvcnRWZXJzaW9uID8gcC5wYXJzZVVTaG9ydCA6IHAucGFyc2VVTG9uZztcbiAgICAvLyBUaGVyZSBpcyBhbiBleHRyYSBlbnRyeSBhZnRlciB0aGUgbGFzdCBpbmRleCBlbGVtZW50IHRvIGNvbXB1dGUgdGhlIGxlbmd0aCBvZiB0aGUgbGFzdCBnbHlwaC5cbiAgICAvLyBUaGF0J3Mgd2h5IHdlIHVzZSBudW1HbHlwaHMgKyAxLlxuICAgIHZhciBnbHlwaE9mZnNldHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUdseXBocyArIDE7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGhPZmZzZXQgPSBwYXJzZUZuLmNhbGwocCk7XG4gICAgICAgIGlmIChzaG9ydFZlcnNpb24pIHtcbiAgICAgICAgICAgIC8vIFRoZSBzaG9ydCB0YWJsZSB2ZXJzaW9uIHN0b3JlcyB0aGUgYWN0dWFsIG9mZnNldCBkaXZpZGVkIGJ5IDIuXG4gICAgICAgICAgICBnbHlwaE9mZnNldCAqPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2x5cGhPZmZzZXRzLnB1c2goZ2x5cGhPZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaE9mZnNldHM7XG59XG5cbnZhciBsb2NhID0geyBwYXJzZTogcGFyc2VMb2NhVGFibGUgfTtcblxuLy8gb3BlbnR5cGUuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlYm94L29wZW50eXBlLmpzXG4vLyAoYykgMjAxNSBGcmVkZXJpayBEZSBCbGVzZXJcbi8vIG9wZW50eXBlLmpzIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4vKiBnbG9iYWwgRGF0YVZpZXcsIFVpbnQ4QXJyYXksIFhNTEh0dHBSZXF1ZXN0ICAqL1xuXG4vKipcbiAqIFRoZSBvcGVudHlwZSBsaWJyYXJ5LlxuICogQG5hbWVzcGFjZSBvcGVudHlwZVxuICovXG5cbi8vIEZpbGUgbG9hZGVycyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogTG9hZHMgYSBmb250IGZyb20gYSBmaWxlLiBUaGUgY2FsbGJhY2sgdGhyb3dzIGFuIGVycm9yIG1lc3NhZ2UgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciBpZiBpdCBmYWlsc1xuICogYW5kIHRoZSBmb250IGFzIGFuIEFycmF5QnVmZmVyIGluIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlmIGl0IHN1Y2NlZWRzLlxuICogQHBhcmFtICB7c3RyaW5nfSBwYXRoIC0gVGhlIHBhdGggb2YgdGhlIGZpbGVcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGZvbnQgbG9hZCBjb21wbGV0ZXNcbiAqL1xuZnVuY3Rpb24gbG9hZEZyb21GaWxlKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICBmcy5yZWFkRmlsZShwYXRoLCBmdW5jdGlvbihlcnIsIGJ1ZmZlcikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLm1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgbm9kZUJ1ZmZlclRvQXJyYXlCdWZmZXIoYnVmZmVyKSk7XG4gICAgfSk7XG59XG4vKipcbiAqIExvYWRzIGEgZm9udCBmcm9tIGEgVVJMLiBUaGUgY2FsbGJhY2sgdGhyb3dzIGFuIGVycm9yIG1lc3NhZ2UgYXMgdGhlIGZpcnN0IHBhcmFtZXRlciBpZiBpdCBmYWlsc1xuICogYW5kIHRoZSBmb250IGFzIGFuIEFycmF5QnVmZmVyIGluIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlmIGl0IHN1Y2NlZWRzLlxuICogQHBhcmFtICB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBmb250IGZpbGUuXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBmb250IGxvYWQgY29tcGxldGVzXG4gKi9cbmZ1bmN0aW9uIGxvYWRGcm9tVXJsKHVybCwgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Qub3BlbignZ2V0JywgdXJsLCB0cnVlKTtcbiAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXF1ZXN0LnJlc3BvbnNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygnRm9udCBjb3VsZCBub3QgYmUgbG9hZGVkOiAnICsgcmVxdWVzdC5zdGF0dXNUZXh0KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKCdGb250IGNvdWxkIG5vdCBiZSBsb2FkZWQnKTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdC5zZW5kKCk7XG59XG5cbi8vIFRhYmxlIERpcmVjdG9yeSBFbnRyaWVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogUGFyc2VzIE9wZW5UeXBlIHRhYmxlIGVudHJpZXMuXG4gKiBAcGFyYW0gIHtEYXRhVmlld31cbiAqIEBwYXJhbSAge051bWJlcn1cbiAqIEByZXR1cm4ge09iamVjdFtdfVxuICovXG5mdW5jdGlvbiBwYXJzZU9wZW5UeXBlVGFibGVFbnRyaWVzKGRhdGEsIG51bVRhYmxlcykge1xuICAgIHZhciB0YWJsZUVudHJpZXMgPSBbXTtcbiAgICB2YXIgcCA9IDEyO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVGFibGVzOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHRhZyA9IHBhcnNlLmdldFRhZyhkYXRhLCBwKTtcbiAgICAgICAgdmFyIGNoZWNrc3VtID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDQpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDgpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDEyKTtcbiAgICAgICAgdGFibGVFbnRyaWVzLnB1c2goe3RhZzogdGFnLCBjaGVja3N1bTogY2hlY2tzdW0sIG9mZnNldDogb2Zmc2V0LCBsZW5ndGg6IGxlbmd0aCwgY29tcHJlc3Npb246IGZhbHNlfSk7XG4gICAgICAgIHAgKz0gMTY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhYmxlRW50cmllcztcbn1cblxuLyoqXG4gKiBQYXJzZXMgV09GRiB0YWJsZSBlbnRyaWVzLlxuICogQHBhcmFtICB7RGF0YVZpZXd9XG4gKiBAcGFyYW0gIHtOdW1iZXJ9XG4gKiBAcmV0dXJuIHtPYmplY3RbXX1cbiAqL1xuZnVuY3Rpb24gcGFyc2VXT0ZGVGFibGVFbnRyaWVzKGRhdGEsIG51bVRhYmxlcykge1xuICAgIHZhciB0YWJsZUVudHJpZXMgPSBbXTtcbiAgICB2YXIgcCA9IDQ0OyAvLyBvZmZzZXQgdG8gdGhlIGZpcnN0IHRhYmxlIGRpcmVjdG9yeSBlbnRyeS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRhYmxlczsgaSArPSAxKSB7XG4gICAgICAgIHZhciB0YWcgPSBwYXJzZS5nZXRUYWcoZGF0YSwgcCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgNCk7XG4gICAgICAgIHZhciBjb21wTGVuZ3RoID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDgpO1xuICAgICAgICB2YXIgb3JpZ0xlbmd0aCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyAxMik7XG4gICAgICAgIHZhciBjb21wcmVzc2lvbiA9ICh2b2lkIDApO1xuICAgICAgICBpZiAoY29tcExlbmd0aCA8IG9yaWdMZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbXByZXNzaW9uID0gJ1dPRkYnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcHJlc3Npb24gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRhYmxlRW50cmllcy5wdXNoKHt0YWc6IHRhZywgb2Zmc2V0OiBvZmZzZXQsIGNvbXByZXNzaW9uOiBjb21wcmVzc2lvbixcbiAgICAgICAgICAgIGNvbXByZXNzZWRMZW5ndGg6IGNvbXBMZW5ndGgsIGxlbmd0aDogb3JpZ0xlbmd0aH0pO1xuICAgICAgICBwICs9IDIwO1xuICAgIH1cblxuICAgIHJldHVybiB0YWJsZUVudHJpZXM7XG59XG5cbi8qKlxuICogQHR5cGVkZWYgVGFibGVEYXRhXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RGF0YVZpZXd9IGRhdGEgLSBUaGUgRGF0YVZpZXdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvZmZzZXQgLSBUaGUgZGF0YSBvZmZzZXQuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0gIHtEYXRhVmlld31cbiAqIEBwYXJhbSAge09iamVjdH1cbiAqIEByZXR1cm4ge1RhYmxlRGF0YX1cbiAqL1xuZnVuY3Rpb24gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpIHtcbiAgICBpZiAodGFibGVFbnRyeS5jb21wcmVzc2lvbiA9PT0gJ1dPRkYnKSB7XG4gICAgICAgIHZhciBpbkJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyLCB0YWJsZUVudHJ5Lm9mZnNldCArIDIsIHRhYmxlRW50cnkuY29tcHJlc3NlZExlbmd0aCAtIDIpO1xuICAgICAgICB2YXIgb3V0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodGFibGVFbnRyeS5sZW5ndGgpO1xuICAgICAgICB0aW55SW5mbGF0ZShpbkJ1ZmZlciwgb3V0QnVmZmVyKTtcbiAgICAgICAgaWYgKG91dEJ1ZmZlci5ieXRlTGVuZ3RoICE9PSB0YWJsZUVudHJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNvbXByZXNzaW9uIGVycm9yOiAnICsgdGFibGVFbnRyeS50YWcgKyAnIGRlY29tcHJlc3NlZCBsZW5ndGggZG9lc25cXCd0IG1hdGNoIHJlY29yZGVkIGxlbmd0aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcob3V0QnVmZmVyLmJ1ZmZlciwgMCk7XG4gICAgICAgIHJldHVybiB7ZGF0YTogdmlldywgb2Zmc2V0OiAwfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge2RhdGE6IGRhdGEsIG9mZnNldDogdGFibGVFbnRyeS5vZmZzZXR9O1xuICAgIH1cbn1cblxuLy8gUHVibGljIEFQSSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIFBhcnNlIHRoZSBPcGVuVHlwZSBmaWxlIGRhdGEgKGFzIGFuIEFycmF5QnVmZmVyKSBhbmQgcmV0dXJuIGEgRm9udCBvYmplY3QuXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGZvbnQgY291bGQgbm90IGJlIHBhcnNlZC5cbiAqIEBwYXJhbSAge0FycmF5QnVmZmVyfVxuICogQHJldHVybiB7b3BlbnR5cGUuRm9udH1cbiAqL1xuZnVuY3Rpb24gcGFyc2VCdWZmZXIoYnVmZmVyKSB7XG4gICAgdmFyIGluZGV4VG9Mb2NGb3JtYXQ7XG4gICAgdmFyIGx0YWdUYWJsZTtcblxuICAgIC8vIFNpbmNlIHRoZSBjb25zdHJ1Y3RvciBjYW4gYWxzbyBiZSBjYWxsZWQgdG8gY3JlYXRlIG5ldyBmb250cyBmcm9tIHNjcmF0Y2gsIHdlIGluZGljYXRlIHRoaXNcbiAgICAvLyBzaG91bGQgYmUgYW4gZW1wdHkgZm9udCB0aGF0IHdlJ2xsIGZpbGwgd2l0aCBvdXIgb3duIGRhdGEuXG4gICAgdmFyIGZvbnQgPSBuZXcgRm9udCh7ZW1wdHk6IHRydWV9KTtcblxuICAgIC8vIE9wZW5UeXBlIGZvbnRzIHVzZSBiaWcgZW5kaWFuIGJ5dGUgb3JkZXJpbmcuXG4gICAgLy8gV2UgY2FuJ3QgcmVseSBvbiB0eXBlZCBhcnJheSB2aWV3IHR5cGVzLCBiZWNhdXNlIHRoZXkgb3BlcmF0ZSB3aXRoIHRoZSBlbmRpYW5uZXNzIG9mIHRoZSBob3N0IGNvbXB1dGVyLlxuICAgIC8vIEluc3RlYWQgd2UgdXNlIERhdGFWaWV3cyB3aGVyZSB3ZSBjYW4gc3BlY2lmeSBlbmRpYW5uZXNzLlxuICAgIHZhciBkYXRhID0gbmV3IERhdGFWaWV3KGJ1ZmZlciwgMCk7XG4gICAgdmFyIG51bVRhYmxlcztcbiAgICB2YXIgdGFibGVFbnRyaWVzID0gW107XG4gICAgdmFyIHNpZ25hdHVyZSA9IHBhcnNlLmdldFRhZyhkYXRhLCAwKTtcbiAgICBpZiAoc2lnbmF0dXJlID09PSBTdHJpbmcuZnJvbUNoYXJDb2RlKDAsIDEsIDAsIDApIHx8IHNpZ25hdHVyZSA9PT0gJ3RydWUnIHx8IHNpZ25hdHVyZSA9PT0gJ3R5cDEnKSB7XG4gICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAndHJ1ZXR5cGUnO1xuICAgICAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgNCk7XG4gICAgICAgIHRhYmxlRW50cmllcyA9IHBhcnNlT3BlblR5cGVUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKTtcbiAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZSA9PT0gJ09UVE8nKSB7XG4gICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAnY2ZmJztcbiAgICAgICAgbnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIDQpO1xuICAgICAgICB0YWJsZUVudHJpZXMgPSBwYXJzZU9wZW5UeXBlVGFibGVFbnRyaWVzKGRhdGEsIG51bVRhYmxlcyk7XG4gICAgfSBlbHNlIGlmIChzaWduYXR1cmUgPT09ICd3T0ZGJykge1xuICAgICAgICB2YXIgZmxhdm9yID0gcGFyc2UuZ2V0VGFnKGRhdGEsIDQpO1xuICAgICAgICBpZiAoZmxhdm9yID09PSBTdHJpbmcuZnJvbUNoYXJDb2RlKDAsIDEsIDAsIDApKSB7XG4gICAgICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ3RydWV0eXBlJztcbiAgICAgICAgfSBlbHNlIGlmIChmbGF2b3IgPT09ICdPVFRPJykge1xuICAgICAgICAgICAgZm9udC5vdXRsaW5lc0Zvcm1hdCA9ICdjZmYnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBPcGVuVHlwZSBmbGF2b3IgJyArIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cblxuICAgICAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgMTIpO1xuICAgICAgICB0YWJsZUVudHJpZXMgPSBwYXJzZVdPRkZUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE9wZW5UeXBlIHNpZ25hdHVyZSAnICsgc2lnbmF0dXJlKTtcbiAgICB9XG5cbiAgICB2YXIgY2ZmVGFibGVFbnRyeTtcbiAgICB2YXIgZnZhclRhYmxlRW50cnk7XG4gICAgdmFyIGdseWZUYWJsZUVudHJ5O1xuICAgIHZhciBncG9zVGFibGVFbnRyeTtcbiAgICB2YXIgZ3N1YlRhYmxlRW50cnk7XG4gICAgdmFyIGhtdHhUYWJsZUVudHJ5O1xuICAgIHZhciBrZXJuVGFibGVFbnRyeTtcbiAgICB2YXIgbG9jYVRhYmxlRW50cnk7XG4gICAgdmFyIG5hbWVUYWJsZUVudHJ5O1xuICAgIHZhciBtZXRhVGFibGVFbnRyeTtcbiAgICB2YXIgcDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVGFibGVzOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHRhYmxlRW50cnkgPSB0YWJsZUVudHJpZXNbaV07XG4gICAgICAgIHZhciB0YWJsZSA9ICh2b2lkIDApO1xuICAgICAgICBzd2l0Y2ggKHRhYmxlRW50cnkudGFnKSB7XG4gICAgICAgICAgICBjYXNlICdjbWFwJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5jbWFwID0gY21hcC5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQuZW5jb2RpbmcgPSBuZXcgQ21hcEVuY29kaW5nKGZvbnQudGFibGVzLmNtYXApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY3Z0ICcgOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMuY3Z0ID0gcC5wYXJzZVNob3J0TGlzdCh0YWJsZUVudHJ5Lmxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZnZhcic6XG4gICAgICAgICAgICAgICAgZnZhclRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZnBnbScgOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMuZnBnbSA9IHAucGFyc2VCeXRlTGlzdCh0YWJsZUVudHJ5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5oZWFkID0gaGVhZC5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQudW5pdHNQZXJFbSA9IGZvbnQudGFibGVzLmhlYWQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgICAgICBpbmRleFRvTG9jRm9ybWF0ID0gZm9udC50YWJsZXMuaGVhZC5pbmRleFRvTG9jRm9ybWF0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaGhlYSc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMuaGhlYSA9IGhoZWEucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LmFzY2VuZGVyID0gZm9udC50YWJsZXMuaGhlYS5hc2NlbmRlcjtcbiAgICAgICAgICAgICAgICBmb250LmRlc2NlbmRlciA9IGZvbnQudGFibGVzLmhoZWEuZGVzY2VuZGVyO1xuICAgICAgICAgICAgICAgIGZvbnQubnVtYmVyT2ZITWV0cmljcyA9IGZvbnQudGFibGVzLmhoZWEubnVtYmVyT2ZITWV0cmljcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2htdHgnOlxuICAgICAgICAgICAgICAgIGhtdHhUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2x0YWcnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGx0YWdUYWJsZSA9IGx0YWcucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21heHAnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLm1heHAgPSBtYXhwLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC5udW1HbHlwaHMgPSBmb250LnRhYmxlcy5tYXhwLm51bUdseXBocztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25hbWUnOlxuICAgICAgICAgICAgICAgIG5hbWVUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ09TLzInOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLm9zMiA9IG9zMi5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncG9zdCc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMucG9zdCA9IHBvc3QucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LmdseXBoTmFtZXMgPSBuZXcgR2x5cGhOYW1lcyhmb250LnRhYmxlcy5wb3N0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3ByZXAnIDpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBwID0gbmV3IHBhcnNlLlBhcnNlcih0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLnByZXAgPSBwLnBhcnNlQnl0ZUxpc3QodGFibGVFbnRyeS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZ2x5Zic6XG4gICAgICAgICAgICAgICAgZ2x5ZlRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbG9jYSc6XG4gICAgICAgICAgICAgICAgbG9jYVRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQ0ZGICc6XG4gICAgICAgICAgICAgICAgY2ZmVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdrZXJuJzpcbiAgICAgICAgICAgICAgICBrZXJuVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdHUE9TJzpcbiAgICAgICAgICAgICAgICBncG9zVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdHU1VCJzpcbiAgICAgICAgICAgICAgICBnc3ViVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtZXRhJzpcbiAgICAgICAgICAgICAgICBtZXRhVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmFtZVRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIG5hbWVUYWJsZUVudHJ5KTtcbiAgICBmb250LnRhYmxlcy5uYW1lID0gX25hbWUucGFyc2UobmFtZVRhYmxlLmRhdGEsIG5hbWVUYWJsZS5vZmZzZXQsIGx0YWdUYWJsZSk7XG4gICAgZm9udC5uYW1lcyA9IGZvbnQudGFibGVzLm5hbWU7XG5cbiAgICBpZiAoZ2x5ZlRhYmxlRW50cnkgJiYgbG9jYVRhYmxlRW50cnkpIHtcbiAgICAgICAgdmFyIHNob3J0VmVyc2lvbiA9IGluZGV4VG9Mb2NGb3JtYXQgPT09IDA7XG4gICAgICAgIHZhciBsb2NhVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgbG9jYVRhYmxlRW50cnkpO1xuICAgICAgICB2YXIgbG9jYU9mZnNldHMgPSBsb2NhLnBhcnNlKGxvY2FUYWJsZS5kYXRhLCBsb2NhVGFibGUub2Zmc2V0LCBmb250Lm51bUdseXBocywgc2hvcnRWZXJzaW9uKTtcbiAgICAgICAgdmFyIGdseWZUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBnbHlmVGFibGVFbnRyeSk7XG4gICAgICAgIGZvbnQuZ2x5cGhzID0gZ2x5Zi5wYXJzZShnbHlmVGFibGUuZGF0YSwgZ2x5ZlRhYmxlLm9mZnNldCwgbG9jYU9mZnNldHMsIGZvbnQpO1xuICAgIH0gZWxzZSBpZiAoY2ZmVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgY2ZmVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgY2ZmVGFibGVFbnRyeSk7XG4gICAgICAgIGNmZi5wYXJzZShjZmZUYWJsZS5kYXRhLCBjZmZUYWJsZS5vZmZzZXQsIGZvbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRm9udCBkb2VzblxcJ3QgY29udGFpbiBUcnVlVHlwZSBvciBDRkYgb3V0bGluZXMuJyk7XG4gICAgfVxuXG4gICAgdmFyIGhtdHhUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBobXR4VGFibGVFbnRyeSk7XG4gICAgaG10eC5wYXJzZShobXR4VGFibGUuZGF0YSwgaG10eFRhYmxlLm9mZnNldCwgZm9udC5udW1iZXJPZkhNZXRyaWNzLCBmb250Lm51bUdseXBocywgZm9udC5nbHlwaHMpO1xuICAgIGFkZEdseXBoTmFtZXMoZm9udCk7XG5cbiAgICBpZiAoa2VyblRhYmxlRW50cnkpIHtcbiAgICAgICAgdmFyIGtlcm5UYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBrZXJuVGFibGVFbnRyeSk7XG4gICAgICAgIGZvbnQua2VybmluZ1BhaXJzID0ga2Vybi5wYXJzZShrZXJuVGFibGUuZGF0YSwga2VyblRhYmxlLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9udC5rZXJuaW5nUGFpcnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoZ3Bvc1RhYmxlRW50cnkpIHtcbiAgICAgICAgdmFyIGdwb3NUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBncG9zVGFibGVFbnRyeSk7XG4gICAgICAgIGZvbnQudGFibGVzLmdwb3MgPSBncG9zLnBhcnNlKGdwb3NUYWJsZS5kYXRhLCBncG9zVGFibGUub2Zmc2V0KTtcbiAgICB9XG5cbiAgICBpZiAoZ3N1YlRhYmxlRW50cnkpIHtcbiAgICAgICAgdmFyIGdzdWJUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBnc3ViVGFibGVFbnRyeSk7XG4gICAgICAgIGZvbnQudGFibGVzLmdzdWIgPSBnc3ViLnBhcnNlKGdzdWJUYWJsZS5kYXRhLCBnc3ViVGFibGUub2Zmc2V0KTtcbiAgICB9XG5cbiAgICBpZiAoZnZhclRhYmxlRW50cnkpIHtcbiAgICAgICAgdmFyIGZ2YXJUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBmdmFyVGFibGVFbnRyeSk7XG4gICAgICAgIGZvbnQudGFibGVzLmZ2YXIgPSBmdmFyLnBhcnNlKGZ2YXJUYWJsZS5kYXRhLCBmdmFyVGFibGUub2Zmc2V0LCBmb250Lm5hbWVzKTtcbiAgICB9XG5cbiAgICBpZiAobWV0YVRhYmxlRW50cnkpIHtcbiAgICAgICAgdmFyIG1ldGFUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBtZXRhVGFibGVFbnRyeSk7XG4gICAgICAgIGZvbnQudGFibGVzLm1ldGEgPSBtZXRhLnBhcnNlKG1ldGFUYWJsZS5kYXRhLCBtZXRhVGFibGUub2Zmc2V0KTtcbiAgICAgICAgZm9udC5tZXRhcyA9IGZvbnQudGFibGVzLm1ldGE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvbnQ7XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgbG9hZCB0aGUgZm9udCBmcm9tIGEgVVJMIG9yIGEgZmlsZXN5c3RlbS4gV2hlbiBkb25lLCBjYWxsIHRoZSBjYWxsYmFja1xuICogd2l0aCB0d28gYXJndW1lbnRzIGAoZXJyLCBmb250KWAuIFRoZSBgZXJyYCB3aWxsIGJlIG51bGwgb24gc3VjY2VzcyxcbiAqIHRoZSBgZm9udGAgaXMgYSBGb250IG9iamVjdC5cbiAqIFdlIHVzZSB0aGUgbm9kZS5qcyBjYWxsYmFjayBjb252ZW50aW9uIHNvIHRoYXRcbiAqIG9wZW50eXBlLmpzIGNhbiBpbnRlZ3JhdGUgd2l0aCBmcmFtZXdvcmtzIGxpa2UgYXN5bmMuanMuXG4gKiBAYWxpYXMgb3BlbnR5cGUubG9hZFxuICogQHBhcmFtICB7c3RyaW5nfSB1cmwgLSBUaGUgVVJMIG9mIHRoZSBmb250IHRvIGxvYWQuXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGxvYWQodXJsLCBjYWxsYmFjaykge1xuICAgIHZhciBpc05vZGUkJDEgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJztcbiAgICB2YXIgbG9hZEZuID0gaXNOb2RlJCQxID8gbG9hZEZyb21GaWxlIDogbG9hZEZyb21Vcmw7XG4gICAgbG9hZEZuKHVybCwgZnVuY3Rpb24oZXJyLCBhcnJheUJ1ZmZlcikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9udDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvbnQgPSBwYXJzZUJ1ZmZlcihhcnJheUJ1ZmZlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgZm9udCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogU3luY2hyb25vdXNseSBsb2FkIHRoZSBmb250IGZyb20gYSBVUkwgb3IgZmlsZS5cbiAqIFdoZW4gZG9uZSwgcmV0dXJucyB0aGUgZm9udCBvYmplY3Qgb3IgdGhyb3dzIGFuIGVycm9yLlxuICogQGFsaWFzIG9wZW50eXBlLmxvYWRTeW5jXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVybCAtIFRoZSBVUkwgb2YgdGhlIGZvbnQgdG8gbG9hZC5cbiAqIEByZXR1cm4ge29wZW50eXBlLkZvbnR9XG4gKi9cbmZ1bmN0aW9uIGxvYWRTeW5jKHVybCkge1xuICAgIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgdmFyIGJ1ZmZlciA9IGZzLnJlYWRGaWxlU3luYyh1cmwpO1xuICAgIHJldHVybiBwYXJzZUJ1ZmZlcihub2RlQnVmZmVyVG9BcnJheUJ1ZmZlcihidWZmZXIpKTtcbn1cblxuZXhwb3J0cy5Gb250ID0gRm9udDtcbmV4cG9ydHMuR2x5cGggPSBHbHlwaDtcbmV4cG9ydHMuUGF0aCA9IFBhdGg7XG5leHBvcnRzLkJvdW5kaW5nQm94ID0gQm91bmRpbmdCb3g7XG5leHBvcnRzLl9wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlQnVmZmVyO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMubG9hZFN5bmMgPSBsb2FkU3luYztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9wZW50eXBlLmpzLm1hcFxuIiwiaW1wb3J0IFBhdGggZnJvbSAnLi9nbGNhdC1wYXRoJztcblxuY29uc3QgZ2xzbGlmeSA9IHJlcXVpcmUoICdnbHNsaWZ5JyApO1xuXG5sZXQgcmVxdWlyZWRGaWVsZHMgPSAoIG9iamVjdCwgbmFuaXRoZWZ1Y2ssIGZpZWxkcyApID0+IHtcbiAgZmllbGRzLm1hcCggZmllbGQgPT4ge1xuICAgIGlmICggdHlwZW9mIG9iamVjdFsgZmllbGQgXSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcbiAgICAgIHRocm93IFwiR0xDYXQtUGF0aDogXCIgKyBmaWVsZCArIFwiIGlzIHJlcXVpcmVkIGZvciBcIiArIG5hbml0aGVmdWNrO1xuICAgIH1cbiAgfSApO1xufTtcblxubGV0IFBhdGhHVUkgPSBjbGFzcyBleHRlbmRzIFBhdGgge1xuICBjb25zdHJ1Y3RvciggZ2xDYXQsIHBhcmFtcyApIHtcbiAgICBzdXBlciggZ2xDYXQsIHBhcmFtcyApO1xuICAgIGxldCBpdCA9IHRoaXM7XG5cbiAgICByZXF1aXJlZEZpZWxkcyggcGFyYW1zLCBcInBhcmFtc1wiLCBbXG4gICAgICBcImNhbnZhc1wiLFxuICAgICAgXCJlbFwiXG4gICAgXSApO1xuXG4gICAgaXQuZ3VpID0geyBwYXJlbnQ6IGl0LnBhcmFtcy5lbCB9O1xuXG4gICAgaXQuZ3VpLmluZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNwYW5cIiApO1xuICAgIGl0Lmd1aS5wYXJlbnQuYXBwZW5kQ2hpbGQoIGl0Lmd1aS5pbmZvICk7XG4gICAgXG4gICAgaXQuZ3VpLnJhbmdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG4gICAgaXQuZ3VpLnJhbmdlLnR5cGUgPSBcInJhbmdlXCI7XG4gICAgaXQuZ3VpLnJhbmdlLm1pbiA9IDA7XG4gICAgaXQuZ3VpLnJhbmdlLm1heCA9IDA7XG4gICAgaXQuZ3VpLnJhbmdlLnN0ZXAgPSAxO1xuICAgIGl0Lmd1aS5wYXJlbnQuYXBwZW5kQ2hpbGQoIGl0Lmd1aS5yYW5nZSApO1xuXG4gICAgaXQuZGF0ZUxpc3QgPSBuZXcgQXJyYXkoIDMwICkuZmlsbCggMCApO1xuICAgIGl0LmRhdGVMaXN0SW5kZXggPSAwO1xuICAgIGl0LnRvdGFsRnJhbWVzID0gMDtcbiAgICBpdC5mcHMgPSAwO1xuICAgIGl0LmN1cnJlbnRJbmRleCA9IDA7XG4gICAgaXQudmlld05hbWUgPSBcIlwiO1xuICAgIGl0LnZpZXdJbmRleCA9IDA7XG5cbiAgICBsZXQgZ2wgPSBnbENhdC5nbDtcbiAgICBsZXQgdmJvUXVhZCA9IGdsQ2F0LmNyZWF0ZVZlcnRleGJ1ZmZlciggWyAtMSwgLTEsIDEsIC0xLCAtMSwgMSwgMSwgMSBdICk7XG4gICAgaXQuYWRkKCB7XG4gICAgICBfX1BhdGhHdWlSZXR1cm46IHtcbiAgICAgICAgd2lkdGg6IGl0LnBhcmFtcy5jYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogaXQucGFyYW1zLmNhbnZhcy5oZWlnaHQsXG4gICAgICAgIHZlcnQ6IFwiYXR0cmlidXRlIHZlYzIgcDt2b2lkIG1haW4oKXtnbF9Qb3NpdGlvbj12ZWM0KHAsMCwxKTt9XCIsXG4gICAgICAgIGZyYWc6IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O3VuaWZvcm0gdmVjMiByO3VuaWZvcm0gc2FtcGxlcjJEIHM7dm9pZCBtYWluKCl7Z2xfRnJhZ0NvbG9yPXRleHR1cmUyRChzLGdsX0ZyYWdDb29yZC54eS9yKTt9XCIsXG4gICAgICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuT05FIF0sXG4gICAgICAgIGNsZWFyOiBbIDAuMCwgMC4wLCAwLjAsIDEuMCBdLFxuICAgICAgICBmdW5jOiAoIF9wLCBwYXJhbXMgKSA9PiB7XG4gICAgICAgICAgZ2wudmlld3BvcnQoIDAsIDAsIGl0LnBhcmFtcy5jYW52YXMud2lkdGgsIGl0LnBhcmFtcy5jYW52YXMuaGVpZ2h0ICk7XG4gICAgICAgICAgZ2xDYXQudW5pZm9ybTJmdiggJ3InLCBbIGl0LnBhcmFtcy5jYW52YXMud2lkdGgsIGl0LnBhcmFtcy5jYW52YXMuaGVpZ2h0IF0gKTtcbiAgICBcbiAgICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xuICAgICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAncycsIHBhcmFtcy5pbnB1dCwgMCApO1xuICAgICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSApO1xuICB9XG5cbiAgYmVnaW4oKSB7XG4gICAgbGV0IGl0ID0gdGhpcztcblxuICAgIGl0LmN1cnJlbnRJbmRleCA9IDA7XG4gIH1cblxuICBlbmQoKSB7XG4gICAgbGV0IGl0ID0gdGhpcztcblxuICAgIGl0Lmd1aS5yYW5nZS5tYXggPSBNYXRoLm1heCggaXQuZ3VpLnJhbmdlLm1heCwgaXQuY3VycmVudEluZGV4ICk7XG4gICAgaXQuY3VycmVudEluZGV4ID0gMDtcblxuICAgIGxldCBub3cgPSArbmV3IERhdGUoKSAqIDFFLTM7XG4gICAgaXQuZGF0ZUxpc3RbIGl0LmRhdGVMaXN0SW5kZXggXSA9IG5vdztcbiAgICBpdC5kYXRlTGlzdEluZGV4ID0gKCBpdC5kYXRlTGlzdEluZGV4ICsgMSApICUgaXQuZGF0ZUxpc3QubGVuZ3RoO1xuICAgIGl0LmZwcyA9IChcbiAgICAgICggaXQuZGF0ZUxpc3QubGVuZ3RoIC0gMSApXG4gICAgICAvICggbm93IC0gaXQuZGF0ZUxpc3RbIGl0LmRhdGVMaXN0SW5kZXggXSApXG4gICAgKS50b0ZpeGVkKCAxICk7XG4gICAgXG4gICAgaXQudG90YWxGcmFtZXMgKys7XG5cbiAgICBpdC5ndWkuaW5mby5pbm5lclRleHQgPSAoXG4gICAgICBcIlBhdGg6IFwiICsgaXQudmlld05hbWUgKyBcIiAoXCIgKyBpdC52aWV3SW5kZXggKyBcIilcXG5cIlxuICAgICAgKyBpdC5mcHMgKyBcIiBGUFNcXG5cIlxuICAgICAgKyBpdC50b3RhbEZyYW1lcyArIFwiIGZyYW1lc1xcblwiXG4gICAgKTtcbiAgfVxuXG4gIHJlbmRlciggbmFtZSwgcGFyYW1zICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG4gICAgXG4gICAgaXQuY3VycmVudEluZGV4ICsrO1xuICAgIGxldCB2aWV3ID0gcGFyc2VJbnQoIGl0Lmd1aS5yYW5nZS52YWx1ZSApO1xuXG4gICAgaWYgKCBpdC5jdXJyZW50SW5kZXggPD0gdmlldyB8fCB2aWV3ID09PSAwICkge1xuICAgICAgaXQudmlld05hbWUgPSB2aWV3ID09PSAwID8gXCIqRnVsbCpcIiA6IG5hbWU7XG4gICAgICBpdC52aWV3SW5kZXggPSBpdC5jdXJyZW50SW5kZXg7XG5cbiAgICAgIHN1cGVyLnJlbmRlciggbmFtZSwgcGFyYW1zICk7XG5cbiAgICAgIGlmICggaXQuY3VycmVudEluZGV4ID09PSB2aWV3ICkge1xuICAgICAgICBsZXQgdCA9IChcbiAgICAgICAgICAoIHBhcmFtcyAmJiBwYXJhbXMudGFyZ2V0IClcbiAgICAgICAgICA/IHBhcmFtcy50YXJnZXRcbiAgICAgICAgICA6IGl0LnBhdGhzWyBuYW1lIF0uZnJhbWVidWZmZXJcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIHQgJiYgdC5mcmFtZWJ1ZmZlciApIHtcbiAgICAgICAgICBsZXQgaSA9IHQudGV4dHVyZXMgPyB0LnRleHR1cmVzWyAwIF0gOiB0LnRleHR1cmU7XG4gICAgICAgICAgaWYgKCBpdC5wYXJhbXMuc3RyZXRjaCApIHtcbiAgICAgICAgICAgIHN1cGVyLnJlbmRlciggXCJfX1BhdGhHdWlSZXR1cm5cIiwge1xuICAgICAgICAgICAgICB0YXJnZXQ6IFBhdGhHVUkubnVsbEZiLFxuICAgICAgICAgICAgICBpbnB1dDogaSxcbiAgICAgICAgICAgICAgd2lkdGg6IGl0LnBhcmFtcy5jYW52YXMud2lkdGgsXG4gICAgICAgICAgICAgIGhlaWdodDogaXQucGFyYW1zLmNhbnZhcy5oZWlnaHRcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXQucGFyYW1zLmNhbnZhcy53aWR0aCA9ICggcGFyYW1zID8gcGFyYW1zLndpZHRoIDogMCApIHx8IGl0LnBhdGhzWyBuYW1lIF0ud2lkdGggfHwgaXQucGFyYW1zLndpZHRoO1xuICAgICAgICAgICAgaXQucGFyYW1zLmNhbnZhcy5oZWlnaHQgPSAoIHBhcmFtcyA/IHBhcmFtcy5oZWlnaHQgOiAwICkgfHwgaXQucGF0aHNbIG5hbWUgXS5oZWlnaHQgfHwgaXQucGFyYW1zLmhlaWdodDtcbiAgICAgICAgICAgIHN1cGVyLnJlbmRlciggXCJfX1BhdGhHdWlSZXR1cm5cIiwge1xuICAgICAgICAgICAgICB0YXJnZXQ6IFBhdGhHVUkubnVsbEZiLFxuICAgICAgICAgICAgICBpbnB1dDogaVxuICAgICAgICAgICAgfSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgUGF0aEdVSTsiLCJjb25zdCBnbHNsaWZ5ID0gcmVxdWlyZSggJ2dsc2xpZnknICk7XG5cbmxldCByZXF1aXJlZEZpZWxkcyA9ICggb2JqZWN0LCBuYW5pdGhlZnVjaywgZmllbGRzICkgPT4ge1xuICBmaWVsZHMubWFwKCBmaWVsZCA9PiB7XG4gICAgaWYgKCB0eXBlb2Ygb2JqZWN0WyBmaWVsZCBdID09PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgdGhyb3cgXCJHTENhdC1QYXRoOiBcIiArIGZpZWxkICsgXCIgaXMgcmVxdWlyZWQgZm9yIFwiICsgbmFuaXRoZWZ1Y2s7XG4gICAgfVxuICB9ICk7XG59O1xuXG5sZXQgUGF0aCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoIGdsQ2F0LCBwYXJhbXMgKSB7XG4gICAgbGV0IGl0ID0gdGhpcztcblxuICAgIGl0LmdsQ2F0ID0gZ2xDYXQ7XG4gICAgaXQuZ2wgPSBnbENhdC5nbDtcblxuICAgIGl0LnBhdGhzID0ge307XG4gICAgaXQuZ2xvYmFsRnVuYyA9ICgpID0+IHt9O1xuICAgIGl0LnBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgfVxuXG4gIGFkZCggcGF0aHMgKSB7XG4gICAgbGV0IGl0ID0gdGhpcztcblxuICAgIGZvciAoIGxldCBuYW1lIGluIHBhdGhzICkge1xuICAgICAgbGV0IHBhdGggPSBwYXRoc1sgbmFtZSBdO1xuICAgICAgcmVxdWlyZWRGaWVsZHMoIHBhdGgsIFwicGF0aCBvYmplY3RcIiwgW1xuICAgICAgICBcInZlcnRcIixcbiAgICAgICAgXCJmcmFnXCJcbiAgICAgIF0gKTtcbiAgICAgIGl0LnBhdGhzWyBuYW1lIF0gPSBwYXRoO1xuXG4gICAgICBpZiAoIHR5cGVvZiBwYXRoLmRlcHRoVGVzdCA9PT0gXCJ1bmRlZmluZWRcIiApIHsgcGF0aC5kZXB0aFRlc3QgPSB0cnVlOyB9XG4gICAgICBpZiAoIHR5cGVvZiBwYXRoLmRlcHRoV3JpdGUgPT09IFwidW5kZWZpbmVkXCIgKSB7IHBhdGguZGVwdGhXcml0ZSA9IHRydWU7IH1cbiAgICAgIGlmICggdHlwZW9mIHBhdGguYmxlbmQgPT09IFwidW5kZWZpbmVkXCIgKSB7IHBhdGguYmxlbmQgPSBbIGl0LmdsLlNSQ19BTFBIQSwgaXQuZ2wuT05FX01JTlVTX1NSQ19BTFBIQSBdOyB9XG4gICAgICBpZiAoIHR5cGVvZiBwYXRoLmN1bGwgPT09IFwidW5kZWZpbmVkXCIgKSB7IHBhdGguY3VsbCA9IHRydWU7IH1cbiAgICAgIFxuICAgICAgaWYgKCBwYXRoLmZyYW1lYnVmZmVyICkge1xuICAgICAgICBpZiAoIHBhdGguZHJhd2J1ZmZlcnMgKSB7XG4gICAgICAgICAgcGF0aC5mcmFtZWJ1ZmZlciA9IGl0LmdsQ2F0LmNyZWF0ZURyYXdCdWZmZXJzKCBwYXRoLndpZHRoLCBwYXRoLmhlaWdodCwgcGF0aC5kcmF3YnVmZmVycyApO1xuICAgICAgICB9IGVsc2UgaWYgKCBwYXRoLmZsb2F0ICkge1xuICAgICAgICAgIHBhdGguZnJhbWVidWZmZXIgPSBpdC5nbENhdC5jcmVhdGVGbG9hdEZyYW1lYnVmZmVyKCBwYXRoLndpZHRoLCBwYXRoLmhlaWdodCApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGguZnJhbWVidWZmZXIgPSBpdC5nbENhdC5jcmVhdGVGcmFtZWJ1ZmZlciggcGF0aC53aWR0aCwgcGF0aC5oZWlnaHQgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwYXRoLnByb2dyYW0gPSBpdC5nbENhdC5jcmVhdGVQcm9ncmFtKCBwYXRoLnZlcnQsIHBhdGguZnJhZyApO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlciggbmFtZSwgcGFyYW1zICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG4gXG4gICAgbGV0IHBhdGggPSBpdC5wYXRoc1sgbmFtZSBdO1xuICAgIGlmICggIXBhdGggKSB7IHRocm93IFwiR0xDYXQtUGF0aDogVGhlIHBhdGggY2FsbGVkIFwiICsgbmFtZSArIFwiIGlzIG5vdCBkZWZpbmVkIVwiOyB9XG4gICAgXG4gICAgaWYgKCAhcGFyYW1zICkgeyBwYXJhbXMgPSB7fTsgfVxuICAgIHBhcmFtcy5mcmFtZWJ1ZmZlciA9IHR5cGVvZiBwYXJhbXMudGFyZ2V0ICE9PSBcInVuZGVmaW5lZFwiID8gcGFyYW1zLnRhcmdldC5mcmFtZWJ1ZmZlciA6IHBhdGguZnJhbWVidWZmZXIgPyBwYXRoLmZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyIDogbnVsbDtcblxuICAgIGxldCB3aWR0aCA9IHBhcmFtcy53aWR0aCB8fCBwYXRoLndpZHRoO1xuICAgIGxldCBoZWlnaHQgPSBwYXJhbXMuaGVpZ2h0IHx8IHBhdGguaGVpZ2h0O1xuXG4gICAgaWYgKCAhd2lkdGggfHwgIWhlaWdodCApIHtcbiAgICAgIHRocm93ICdHTENhdC1QYXRoOiB3aWR0aCBvciBoZWlnaHQgaXMgaW52YWxpZCc7XG4gICAgfVxuICAgIFxuICAgIGl0LmdsLnZpZXdwb3J0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgaXQuZ2xDYXQudXNlUHJvZ3JhbSggcGF0aC5wcm9ncmFtICk7XG4gICAgcGF0aC5jdWxsID8gaXQuZ2wuZW5hYmxlKCBpdC5nbC5DVUxMX0ZBQ0UgKSA6IGl0LmdsLmRpc2FibGUoIGl0LmdsLkNVTExfRkFDRSApO1xuICAgIGl0LmdsLmJpbmRGcmFtZWJ1ZmZlciggaXQuZ2wuRlJBTUVCVUZGRVIsIHBhcmFtcy5mcmFtZWJ1ZmZlciApO1xuICAgIGlmICggaXQucGFyYW1zLmRyYXdidWZmZXJzICkge1xuICAgICAgaXQuZ2xDYXQuZHJhd0J1ZmZlcnMoIHBhdGguZHJhd2J1ZmZlcnMgPyBwYXRoLmRyYXdidWZmZXJzIDogcGFyYW1zLmZyYW1lYnVmZmVyID09PSBudWxsID8gWyBpdC5nbC5CQUNLIF0gOiBbIGl0LmdsLkNPTE9SX0FUVEFDSE1FTlQwIF0gKTtcbiAgICB9XG4gICAgaXQuZ2wuYmxlbmRGdW5jKCAuLi5wYXRoLmJsZW5kICk7XG4gICAgaWYgKCBwYXRoLmNsZWFyICkgeyBpdC5nbENhdC5jbGVhciggLi4ucGF0aC5jbGVhciApOyB9XG4gICAgcGF0aC5kZXB0aFRlc3QgPyBpdC5nbC5lbmFibGUoIGl0LmdsLkRFUFRIX1RFU1QgKSA6IGl0LmdsLmRpc2FibGUoIGl0LmdsLkRFUFRIX1RFU1QgKTtcbiAgICBwYXRoLmRlcHRoV3JpdGUgPyBpdC5nbC5kZXB0aE1hc2soIHRydWUgKSA6IGl0LmdsLmRlcHRoTWFzayggZmFsc2UgKTtcbiBcbiAgICBpdC5nbENhdC51bmlmb3JtMmZ2KCAncmVzb2x1dGlvbicsIFsgd2lkdGgsIGhlaWdodCBdICk7XG4gICAgaXQuZ2xvYmFsRnVuYyggcGF0aCwgcGFyYW1zICk7XG5cbiAgICBpZiAoIHBhdGguZnVuYyApIHsgcGF0aC5mdW5jKCBwYXRoLCBwYXJhbXMgKTsgfVxuICB9XG5cbiAgcmVzaXplKCBuYW1lLCB3aWR0aCwgaGVpZ2h0ICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG5cbiAgICBsZXQgcGF0aCA9IGl0LnBhdGhzWyBuYW1lIF07XG5cbiAgICBwYXRoLndpZHRoID0gd2lkdGg7XG4gICAgcGF0aC5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICBpZiAoIHBhdGguZnJhbWVidWZmZXIgKSB7XG4gICAgICBpZiAoIGl0LnBhcmFtcy5kcmF3YnVmZmVycyAmJiBwYXRoLmRyYXdidWZmZXJzICkge1xuICAgICAgICBwYXRoLmZyYW1lYnVmZmVyID0gaXQuZ2xDYXQuY3JlYXRlRHJhd0J1ZmZlcnMoIHBhdGgud2lkdGgsIHBhdGguaGVpZ2h0LCBwYXRoLmRyYXdidWZmZXJzICk7XG4gICAgICB9IGVsc2UgaWYgKCBwYXRoLmZsb2F0ICkge1xuICAgICAgICBpdC5nbENhdC5yZXNpemVGbG9hdEZyYW1lYnVmZmVyKCBwYXRoLmZyYW1lYnVmZmVyLCBwYXRoLndpZHRoLCBwYXRoLmhlaWdodCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXQuZ2xDYXQucmVzaXplRnJhbWVidWZmZXIoIHBhdGguZnJhbWVidWZmZXIsIHBhdGgud2lkdGgsIHBhdGguaGVpZ2h0ICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCB0eXBlb2YgcGF0aC5vbnJlc2l6ZSA9PT0gXCJmdW5jdGlvblwiICkge1xuICAgICAgcGF0aC5vbnJlc2l6ZSggcGF0aCwgd2lkdGgsIGhlaWdodCApO1xuICAgIH1cbiAgfVxuXG4gIHNldEdsb2JhbEZ1bmMoIGZ1bmMgKSB7IHRoaXMuZ2xvYmFsRnVuYyA9IGZ1bmM7IH1cblxuICBmYiggbmFtZSApIHtcbiAgICBpZiAoICF0aGlzLnBhdGhzWyBuYW1lIF0gKSB7IHRocm93IFwiZ2xjYXQtcGF0aC5mYjogcGF0aCBjYWxsZWQgXCIgKyBuYW1lICsgXCIgaXMgbm90IGRlZmluZWRcIjsgfVxuICAgIGlmICggIXRoaXMucGF0aHNbIG5hbWUgXS5mcmFtZWJ1ZmZlciApIHsgdGhyb3cgXCJnbGNhdC1wYXRoLmZiOiB0aGVyZSBpcyBubyBmcmFtZWJ1ZmZlciBmb3IgdGhlIHBhdGggXCIgKyBuYW1lOyB9XG5cbiAgICByZXR1cm4gdGhpcy5wYXRoc1sgbmFtZSBdLmZyYW1lYnVmZmVyO1xuICB9XG59O1xuXG5QYXRoLm51bGxGYiA9IHsgZnJhbWVidWZmZXI6IG51bGwgfTtcblxuZXhwb3J0IGRlZmF1bHQgUGF0aDsiLCJsZXQgR0xDYXQgPSBjbGFzcyB7XG5cdGNvbnN0cnVjdG9yKCBfZ2wgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblxuXHRcdGl0LmdsID0gX2dsO1xuICAgIGxldCBnbCA9IGl0LmdsO1xuXG5cdCAgZ2wuZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XG5cdCAgZ2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcblx0ICBnbC5lbmFibGUoIGdsLkJMRU5EICk7XG5cdCAgZ2wuYmxlbmRGdW5jKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcblxuXHRcdGl0LmV4dGVuc2lvbnMgPSB7fTtcblxuXHRcdGl0LmN1cnJlbnRQcm9ncmFtID0gbnVsbDtcblx0fVxuXG5cdGdldEV4dGVuc2lvbiggX25hbWUsIF90aHJvdyApIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuICAgIGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0aWYgKCB0eXBlb2YgX25hbWUgPT09IFwib2JqZWN0XCIgJiYgX25hbWUuaXNBcnJheSgpICkge1xuXHRcdFx0cmV0dXJuIF9uYW1lLmV2ZXJ5KCBuYW1lID0+IGl0LmdldEV4dGVuc2lvbiggbmFtZSwgX3Rocm93ICkgKTtcblx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgX25hbWUgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIGl0LmV4dGVuc2lvbnNbIF9uYW1lIF0gKSB7XG5cdFx0XHRcdHJldHVybiBpdC5leHRlbnNpb25zWyBfbmFtZSBdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aXQuZXh0ZW5zaW9uc1sgX25hbWUgXSA9IGdsLmdldEV4dGVuc2lvbiggX25hbWUgKTtcblx0XHRcdFx0aWYgKCBpdC5leHRlbnNpb25zWyBfbmFtZSBdICkge1xuXHRcdFx0XHRcdHJldHVybiBpdC5leHRlbnNpb25zWyBfbmFtZSBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggX3Rocm93ICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgY29uc29sZS5lcnJvciggXCJUaGUgZXh0ZW5zaW9uIFxcXCJcIiArIF9uYW1lICsgXCJcXFwiIGlzIG5vdCBzdXBwb3J0ZWRcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiAhISggaXQuZXh0ZW5zaW9uc1sgX25hbWUgXSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBcIkdMQ2F0LmdldEV4dGVuc2lvbjogX25hbWUgbXVzdCBiZSBzdHJpbmcgb3IgYXJyYXlcIlxuXHRcdH1cblx0fVxuXG5cdGNyZWF0ZVByb2dyYW0oIF92ZXJ0LCBfZnJhZywgX29uRXJyb3IgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdGxldCBlcnJvcjtcblx0XHRpZiAoIHR5cGVvZiBfb25FcnJvciA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdGVycm9yID0gX29uRXJyb3I7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVycm9yID0gKCBfc3RyICkgPT4geyBjb25zb2xlLmVycm9yKCBfc3RyICk7IH1cblx0XHR9XG5cblx0XHRsZXQgdmVydCA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuVkVSVEVYX1NIQURFUiApO1xuXHRcdGdsLnNoYWRlclNvdXJjZSggdmVydCwgX3ZlcnQgKTtcblx0XHRnbC5jb21waWxlU2hhZGVyKCB2ZXJ0ICk7XG5cdFx0aWYgKCAhZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKCB2ZXJ0LCBnbC5DT01QSUxFX1NUQVRVUyApICkge1xuXHRcdFx0ZXJyb3IoIGdsLmdldFNoYWRlckluZm9Mb2coIHZlcnQgKSApO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0bGV0IGZyYWcgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLkZSQUdNRU5UX1NIQURFUiApO1xuXHRcdGdsLnNoYWRlclNvdXJjZSggZnJhZywgX2ZyYWcgKTtcblx0XHRnbC5jb21waWxlU2hhZGVyKCBmcmFnICk7XG5cdFx0aWYgKCAhZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKCBmcmFnLCBnbC5DT01QSUxFX1NUQVRVUyApICkge1xuXHRcdFx0ZXJyb3IoIGdsLmdldFNoYWRlckluZm9Mb2coIGZyYWcgKSApO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0bGV0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCB2ZXJ0ICk7XG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnICk7XG5cdFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcblx0XHRpZiAoIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkxJTktfU1RBVFVTICkgKSB7XG5cdCAgICBwcm9ncmFtLmxvY2F0aW9ucyA9IHt9O1xuXHRcdFx0cmV0dXJuIHByb2dyYW07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVycm9yKCBnbC5nZXRQcm9ncmFtSW5mb0xvZyggcHJvZ3JhbSApICk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH1cblxuXHR1c2VQcm9ncmFtKCBfcHJvZ3JhbSApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0Z2wudXNlUHJvZ3JhbSggX3Byb2dyYW0gKTtcblx0XHRpdC5jdXJyZW50UHJvZ3JhbSA9IF9wcm9ncmFtO1xuXHR9XG5cblx0Y3JlYXRlVmVydGV4YnVmZmVyKCBfYXJyYXkgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHQgIGxldCBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdGlmICggX2FycmF5ICkgeyBpdC5zZXRWZXJ0ZXhidWZmZXIoIGJ1ZmZlciwgX2FycmF5ICk7IH1cblxuXHQgIHJldHVybiBidWZmZXI7XG5cdH1cblxuXHRzZXRWZXJ0ZXhidWZmZXIoIF9idWZmZXIsIF9hcnJheSwgX21vZGUgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdGxldCBtb2RlID0gX21vZGUgfHwgZ2wuU1RBVElDX0RSQVc7XG5cblx0ICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIF9idWZmZXIgKTtcblx0ICBnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoIF9hcnJheSApLCBtb2RlICk7XG5cdCAgZ2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCBudWxsICk7XG5cblx0ICBfYnVmZmVyLmxlbmd0aCA9IF9hcnJheS5sZW5ndGg7XG5cdH1cblxuXHRjcmVhdGVJbmRleGJ1ZmZlciggX2FycmF5ICkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0ICBsZXQgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cblx0XHRpZiAoIF9hcnJheSApIHsgaXQuc2V0SW5kZXhidWZmZXIoIGJ1ZmZlciwgX2FycmF5ICk7IH1cblxuXHQgIHJldHVybiBidWZmZXI7XG5cdH1cblxuXHRzZXRJbmRleGJ1ZmZlciggX2J1ZmZlciwgX2FycmF5LCBfbW9kZSApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0bGV0IG1vZGUgPSBfbW9kZSB8fCBnbC5TVEFUSUNfRFJBVztcblxuXHQgIGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBfYnVmZmVyICk7XG5cdCAgZ2wuYnVmZmVyRGF0YSggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG5ldyBJbnQxNkFycmF5KCBfYXJyYXkgKSwgbW9kZSApO1xuXHQgIGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBudWxsICk7XG5cblx0ICBfYnVmZmVyLmxlbmd0aCA9IF9hcnJheS5sZW5ndGg7XG5cdH1cblxuXHRnZXRBdHRyaWJMb2NhdGlvbiggX25hbWUgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdGxldCBsb2NhdGlvbjtcblx0ICBpZiAoIGl0LmN1cnJlbnRQcm9ncmFtLmxvY2F0aW9uc1sgX25hbWUgXSApIHtcblx0ICAgIGxvY2F0aW9uID0gaXQuY3VycmVudFByb2dyYW0ubG9jYXRpb25zWyBfbmFtZSBdO1xuXHQgIH0gZWxzZSB7XG5cdCAgICBsb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKCBpdC5jdXJyZW50UHJvZ3JhbSwgX25hbWUgKTtcblx0ICAgIGl0LmN1cnJlbnRQcm9ncmFtLmxvY2F0aW9uc1sgX25hbWUgXSA9IGxvY2F0aW9uO1xuXHQgIH1cblxuXHRcdHJldHVybiBsb2NhdGlvbjtcblx0fVxuXG5cdGF0dHJpYnV0ZSggX25hbWUsIF9idWZmZXIsIF9zdHJpZGUsIF9kaXYgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdGlmICggX2RpdiApIHtcblx0XHRcdGl0LmdldEV4dGVuc2lvbiggXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIsIHRydWUgKTtcblx0XHR9XG5cblx0ICBsZXQgbG9jYXRpb24gPSBpdC5nZXRBdHRyaWJMb2NhdGlvbiggX25hbWUgKTtcblxuXHQgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgX2J1ZmZlciApO1xuXHQgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBsb2NhdGlvbiApO1xuXHQgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGxvY2F0aW9uLCBfc3RyaWRlLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcblxuXHRcdGxldCBleHQgPSBpdC5nZXRFeHRlbnNpb24oIFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiICk7XG5cdFx0aWYgKCBleHQgKSB7XG5cdFx0XHRsZXQgZGl2ID0gX2RpdiB8fCAwO1xuXHRcdFx0ZXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRSggbG9jYXRpb24sIGRpdiApO1xuXHRcdH1cblxuXHQgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgbnVsbCApO1xuXHR9XG5cblx0Z2V0VW5pZm9ybUxvY2F0aW9uKCBfbmFtZSApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdCAgbGV0IGxvY2F0aW9uO1xuXG5cdFx0aWYgKCB0eXBlb2YgaXQuY3VycmVudFByb2dyYW0ubG9jYXRpb25zWyBfbmFtZSBdICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0bG9jYXRpb24gPSBpdC5jdXJyZW50UHJvZ3JhbS5sb2NhdGlvbnNbIF9uYW1lIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBpdC5jdXJyZW50UHJvZ3JhbSwgX25hbWUgKTtcblx0XHRcdGl0LmN1cnJlbnRQcm9ncmFtLmxvY2F0aW9uc1sgX25hbWUgXSA9IGxvY2F0aW9uO1xuXHRcdH1cblxuXHQgIHJldHVybiBsb2NhdGlvbjtcblx0fVxuXG5cdHVuaWZvcm0xaSggX25hbWUsIF92YWx1ZSApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0bGV0IGxvY2F0aW9uID0gaXQuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbmFtZSApO1xuXHRcdGdsLnVuaWZvcm0xaSggbG9jYXRpb24sIF92YWx1ZSApO1xuXHR9XG5cblx0dW5pZm9ybTFmKCBfbmFtZSwgX3ZhbHVlICkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0XHRsZXQgbG9jYXRpb24gPSBpdC5nZXRVbmlmb3JtTG9jYXRpb24oIF9uYW1lICk7XG5cdFx0Z2wudW5pZm9ybTFmKCBsb2NhdGlvbiwgX3ZhbHVlICk7XG5cdH1cblxuXHR1bmlmb3JtMmZ2KCBfbmFtZSwgX3ZhbHVlICkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0XHRsZXQgbG9jYXRpb24gPSBpdC5nZXRVbmlmb3JtTG9jYXRpb24oIF9uYW1lICk7XG5cdFx0Z2wudW5pZm9ybTJmdiggbG9jYXRpb24sIF92YWx1ZSApO1xuXHR9XG5cblx0dW5pZm9ybTNmdiggX25hbWUsIF92YWx1ZSApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0bGV0IGxvY2F0aW9uID0gaXQuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbmFtZSApO1xuXHRcdGdsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCBfdmFsdWUgKTtcblx0fVxuXG5cdHVuaWZvcm00ZnYoIF9uYW1lLCBfdmFsdWUgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdGxldCBsb2NhdGlvbiA9IGl0LmdldFVuaWZvcm1Mb2NhdGlvbiggX25hbWUgKTtcblx0XHRnbC51bmlmb3JtNGZ2KCBsb2NhdGlvbiwgX3ZhbHVlICk7XG5cdH1cblxuXHR1bmlmb3JtTWF0cml4NGZ2KCBfbmFtZSwgX3ZhbHVlLCBfdHJhbnNwb3NlICkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0XHRsZXQgbG9jYXRpb24gPSBpdC5nZXRVbmlmb3JtTG9jYXRpb24oIF9uYW1lICk7XG5cdFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggbG9jYXRpb24sIF90cmFuc3Bvc2UgfHwgZmFsc2UsIF92YWx1ZSApO1xuXHR9XG5cblx0dW5pZm9ybUN1YmVtYXAoIF9uYW1lLCBfdGV4dHVyZSwgX251bWJlciApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0bGV0IGxvY2F0aW9uID0gaXQuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbmFtZSApO1xuXHQgIGdsLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICsgX251bWJlciApO1xuXHQgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFX0NVQkVfTUFQLCBfdGV4dHVyZSApO1xuXHQgIGdsLnVuaWZvcm0xaSggbG9jYXRpb24sIF9udW1iZXIgKTtcblx0fVxuXG5cdHVuaWZvcm1UZXh0dXJlKCBfbmFtZSwgX3RleHR1cmUsIF9udW1iZXIgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdGxldCBsb2NhdGlvbiA9IGl0LmdldFVuaWZvcm1Mb2NhdGlvbiggX25hbWUgKTtcblx0ICBnbC5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCArIF9udW1iZXIgKTtcblx0ICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgX3RleHR1cmUgKTtcblx0ICBnbC51bmlmb3JtMWkoIGxvY2F0aW9uLCBfbnVtYmVyICk7XG5cdH1cblxuXHRjcmVhdGVUZXh0dXJlKCkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0XHRsZXQgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSApO1xuXHQgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSICk7XG5cdCAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIgKTtcblx0ICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xuXHQgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XG5cdFx0Z2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXHR9XG5cblx0dGV4dHVyZUZpbHRlciggX3RleHR1cmUsIF9maWx0ZXIgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBfdGV4dHVyZSApO1xuXHQgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgX2ZpbHRlciApO1xuXHQgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgX2ZpbHRlciApO1xuXHRcdGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG5cdH1cblxuXHR0ZXh0dXJlV3JhcCggX3RleHR1cmUsIF93cmFwICkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgX3RleHR1cmUgKTtcblx0ICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgX3dyYXAgKTtcblx0ICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgX3dyYXAgKTtcblx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXHR9XG5cblx0c2V0VGV4dHVyZSggX3RleHR1cmUsIF9pbWFnZSApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0Z2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIF90ZXh0dXJlICk7XG5cdFx0Z2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgX2ltYWdlICk7XG5cdFx0Z2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcblx0fVxuXG5cdHNldFRleHR1cmVGcm9tQXJyYXkoIF90ZXh0dXJlLCBfd2lkdGgsIF9oZWlnaHQsIF9hcnJheSApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0Z2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIF90ZXh0dXJlICk7XG5cdFx0Z2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgX3dpZHRoLCBfaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBuZXcgVWludDhBcnJheSggX2FycmF5ICkgKTtcblx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXHR9XG5cblx0c2V0VGV4dHVyZUZyb21GbG9hdEFycmF5KCBfdGV4dHVyZSwgX3dpZHRoLCBfaGVpZ2h0LCBfYXJyYXkgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdGl0LmdldEV4dGVuc2lvbiggXCJPRVNfdGV4dHVyZV9mbG9hdFwiLCB0cnVlICk7XG5cblx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgX3RleHR1cmUgKTtcblx0XHRnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBfd2lkdGgsIF9oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBuZXcgRmxvYXQzMkFycmF5KCBfYXJyYXkgKSApO1xuXHRcdGlmICggIWl0LmdldEV4dGVuc2lvbiggXCJPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXJcIiApICkgeyBpdC50ZXh0dXJlRmlsdGVyKCBfdGV4dHVyZSwgZ2wuTkVBUkVTVCApOyB9XG5cdFx0Z2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcblx0fVxuXG5cdGNvcHlUZXh0dXJlKCBfdGV4dHVyZSwgX3dpZHRoLCBfaGVpZ2h0ICkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgX3RleHR1cmUgKTtcblx0XHRnbC5jb3B5VGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgMCwgMCwgX3dpZHRoLCBfaGVpZ2h0LCAwICk7XG5cdFx0Z2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcblx0fVxuXG5cdGNyZWF0ZUN1YmVtYXAoIF9hcnJheU9mSW1hZ2UgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdC8vIG9yZGVyIDogWCssIFgtLCBZKywgWS0sIForLCBaLVxuXHRcdGxldCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG5cdFx0Z2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUgKTtcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXHRcdFx0Z2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgX2FycmF5T2ZJbWFnZVsgaSBdICk7XG5cdFx0fVxuXHRcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSICk7XG5cdCAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIgKTtcblx0ICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApO1xuXHQgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFICk7XG5cdFx0Z2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwgKTtcblxuXHRcdHJldHVybiB0ZXh0dXJlO1xuXHR9XG5cblx0Y3JlYXRlRnJhbWVidWZmZXIoIF93aWR0aCwgX2hlaWdodCApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdCAgbGV0IGZyYW1lYnVmZmVyID0ge307XG5cdFx0ZnJhbWVidWZmZXIuZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXHQgIGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyICk7XG5cblx0XHRmcmFtZWJ1ZmZlci5kZXB0aCA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXHRcdGdsLmJpbmRSZW5kZXJidWZmZXIoIGdsLlJFTkRFUkJVRkZFUiwgZnJhbWVidWZmZXIuZGVwdGggKTtcblx0XHRnbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX0NPTVBPTkVOVDE2LCBfd2lkdGgsIF9oZWlnaHQgKTtcblx0ICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgZnJhbWVidWZmZXIuZGVwdGggKTtcblxuXHRcdGZyYW1lYnVmZmVyLnRleHR1cmUgPSBpdC5jcmVhdGVUZXh0dXJlKCk7XG5cdCAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIGZyYW1lYnVmZmVyLnRleHR1cmUgKTtcblx0ICBnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBfd2lkdGgsIF9oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcblx0ICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG5cdCAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgZnJhbWVidWZmZXIudGV4dHVyZSwgMCApO1xuXHQgIGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcblxuXHQgIHJldHVybiBmcmFtZWJ1ZmZlcjtcblx0fVxuXG5cdHJlc2l6ZUZyYW1lYnVmZmVyKCBfZnJhbWVidWZmZXIsIF93aWR0aCwgX2hlaWdodCApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgX2ZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyICk7XG5cblx0XHRnbC5iaW5kUmVuZGVyYnVmZmVyKCBnbC5SRU5ERVJCVUZGRVIsIF9mcmFtZWJ1ZmZlci5kZXB0aCApO1xuXHRcdGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfQ09NUE9ORU5UMTYsIF93aWR0aCwgX2hlaWdodCApO1xuXHRcdGdsLmJpbmRSZW5kZXJidWZmZXIoIGdsLlJFTkRFUkJVRkZFUiwgbnVsbCApO1xuXHRcdFxuXHQgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBfZnJhbWVidWZmZXIudGV4dHVyZSApO1xuXHRcdGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIF93aWR0aCwgX2hlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCApO1xuXHQgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG5cdFx0XG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXHR9XG5cblx0Y3JlYXRlRmxvYXRGcmFtZWJ1ZmZlciggX3dpZHRoLCBfaGVpZ2h0ICkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0XHRpdC5nZXRFeHRlbnNpb24oIFwiT0VTX3RleHR1cmVfZmxvYXRcIiwgdHJ1ZSApO1xuXG5cdCAgbGV0IGZyYW1lYnVmZmVyID0ge307XG5cdFx0ZnJhbWVidWZmZXIuZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXHQgIGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyICk7XG5cblx0XHRmcmFtZWJ1ZmZlci5kZXB0aCA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXHRcdGdsLmJpbmRSZW5kZXJidWZmZXIoIGdsLlJFTkRFUkJVRkZFUiwgZnJhbWVidWZmZXIuZGVwdGggKTtcblx0XHRnbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX0NPTVBPTkVOVDE2LCBfd2lkdGgsIF9oZWlnaHQgKTtcblx0ICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgZnJhbWVidWZmZXIuZGVwdGggKTtcblxuXHRcdGZyYW1lYnVmZmVyLnRleHR1cmUgPSBpdC5jcmVhdGVUZXh0dXJlKCk7XG5cdCAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIGZyYW1lYnVmZmVyLnRleHR1cmUgKTtcblx0ICBnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBfd2lkdGgsIF9oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsICk7XG5cdFx0aWYgKCAhaXQuZ2V0RXh0ZW5zaW9uKCBcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiICkgKSB7IGl0LnRleHR1cmVGaWx0ZXIoIGZyYW1lYnVmZmVyLnRleHR1cmUsIGdsLk5FQVJFU1QgKTsgfVxuXHQgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG5cblx0ICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCBmcmFtZWJ1ZmZlci50ZXh0dXJlLCAwICk7XG5cdCAgZ2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXG5cdCAgcmV0dXJuIGZyYW1lYnVmZmVyO1xuXHR9XG5cblx0cmVzaXplRmxvYXRGcmFtZWJ1ZmZlciggX2ZyYW1lYnVmZmVyLCBfd2lkdGgsIF9oZWlnaHQgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIF9mcmFtZWJ1ZmZlci5mcmFtZWJ1ZmZlciApO1xuXG5cdFx0Z2wuYmluZFJlbmRlcmJ1ZmZlciggZ2wuUkVOREVSQlVGRkVSLCBfZnJhbWVidWZmZXIuZGVwdGggKTtcblx0XHRnbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX0NPTVBPTkVOVDE2LCBfd2lkdGgsIF9oZWlnaHQgKTtcblx0XHRnbC5iaW5kUmVuZGVyYnVmZmVyKCBnbC5SRU5ERVJCVUZGRVIsIG51bGwgKTtcblx0XHRcblx0ICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgX2ZyYW1lYnVmZmVyLnRleHR1cmUgKTtcblx0XHRnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBfd2lkdGgsIF9oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsICk7XG5cdCAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcblx0XHRcblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBudWxsICk7XG5cdH1cblxuXHRjcmVhdGVEcmF3QnVmZmVycyggX3dpZHRoLCBfaGVpZ2h0LCBfbnVtRHJhd0J1ZmZlcnMgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdGl0LmdldEV4dGVuc2lvbiggJ09FU190ZXh0dXJlX2Zsb2F0JywgdHJ1ZSApO1xuXHRcdGxldCBleHQgPSBpdC5nZXRFeHRlbnNpb24oICdXRUJHTF9kcmF3X2J1ZmZlcnMnLCB0cnVlICk7XG5cblx0XHRpZiAoIGV4dC5NQVhfRFJBV19CVUZGRVJTX1dFQkdMIDwgX251bURyYXdCdWZmZXJzICkge1xuXHRcdFx0dGhyb3cgXCJjcmVhdGVEcmF3QnVmZmVyczogTUFYX0RSQVdfQlVGRkVSU19XRUJHTCBpcyBcIiArIGV4dC5NQVhfRFJBV19CVUZGRVJTX1dFQkdMO1xuXHRcdH1cblxuXHRcdGxldCBmcmFtZWJ1ZmZlciA9IHt9O1xuXHRcdGZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlci5mcmFtZWJ1ZmZlciApO1xuXG5cdFx0ZnJhbWVidWZmZXIuZGVwdGggPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcblx0XHRnbC5iaW5kUmVuZGVyYnVmZmVyKCBnbC5SRU5ERVJCVUZGRVIsIGZyYW1lYnVmZmVyLmRlcHRoICk7XG5cdFx0Z2wucmVuZGVyYnVmZmVyU3RvcmFnZSggZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9DT01QT05FTlQxNiwgX3dpZHRoLCBfaGVpZ2h0ICk7XG5cdFx0Z2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIGZyYW1lYnVmZmVyLmRlcHRoICk7XG5cblx0XHRmcmFtZWJ1ZmZlci50ZXh0dXJlcyA9IFtdO1xuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IF9udW1EcmF3QnVmZmVyczsgaSArKyApIHtcblx0XHRcdGZyYW1lYnVmZmVyLnRleHR1cmVzWyBpIF0gPSBpdC5jcmVhdGVUZXh0dXJlKCk7XG5cdFx0ICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgZnJhbWVidWZmZXIudGV4dHVyZXNbIGkgXSApO1xuXHRcdFx0Z2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgX3dpZHRoLCBfaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCApO1xuXHRcdFx0aWYgKCAhaXQuZ2V0RXh0ZW5zaW9uKCBcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiICkgKSB7IGl0LnRleHR1cmVGaWx0ZXIoIGZyYW1lYnVmZmVyLnRleHR1cmVzWyBpIF0sIGdsLk5FQVJFU1QgKTsgfVxuXHRcdCAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcblxuXHRcdCAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIGdsLkZSQU1FQlVGRkVSLCBleHQuQ09MT1JfQVRUQUNITUVOVDBfV0VCR0wgKyBpLCBnbC5URVhUVVJFXzJELCBmcmFtZWJ1ZmZlci50ZXh0dXJlc1sgaSBdLCAwICk7XG5cdFx0fVxuXG5cdFx0bGV0IHN0YXR1cyA9IGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoIGdsLkZSQU1FQlVGRkVSICk7XG5cdFx0aWYgKCBzdGF0dXMgIT09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFICkge1xuXHRcdFx0dGhyb3cgXCJjcmVhdGVEcmF3QnVmZmVyczogZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyggZ2wuRlJBTUVCVUZGRVIgKSByZXR1cm5zIFwiICsgc3RhdHVzO1xuXHRcdH1cblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBudWxsICk7XG5cblx0XHRyZXR1cm4gZnJhbWVidWZmZXI7XG5cdH1cblxuXHRyZXNpemVEcmF3QnVmZmVycyggX2ZyYW1lYnVmZmVyLCBfd2lkdGgsIGhlaWdodCApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgX2ZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyICk7XG5cblx0XHRnbC5iaW5kUmVuZGVyYnVmZmVyKCBnbC5SRU5ERVJCVUZGRVIsIF9mcmFtZWJ1ZmZlci5kZXB0aCApO1xuXHRcdGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfQ09NUE9ORU5UMTYsIF93aWR0aCwgX2hlaWdodCApO1xuXHRcdGdsLmJpbmRSZW5kZXJidWZmZXIoIGdsLlJFTkRFUkJVRkZFUiwgbnVsbCApO1xuXHRcdFxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IF9mcmFtZWJ1ZmZlci50ZXh0dXJlcy5sZW5ndGg7IGkgKysgKSB7XG5cdFx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgX2ZyYW1lYnVmZmVyLnRleHR1cmVzWyBpIF0gKTtcblx0XHRcdGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIF93aWR0aCwgX2hlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwgKTtcblx0XHRcdGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG5cdFx0fVxuXHRcdFxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcblx0fVxuXG5cdGRyYXdCdWZmZXJzKCBfbnVtRHJhd0J1ZmZlcnMgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblx0XHRcblx0XHRsZXQgZXh0ID0gaXQuZ2V0RXh0ZW5zaW9uKCBcIldFQkdMX2RyYXdfYnVmZmVyc1wiLCB0cnVlICk7XG5cblx0XHRsZXQgYXJyYXkgPSBbXTtcblx0XHRpZiAoIHR5cGVvZiBfbnVtRHJhd0J1ZmZlcnMgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBfbnVtRHJhd0J1ZmZlcnM7IGkgKysgKSB7XG5cdFx0XHRcdGFycmF5LnB1c2goIGV4dC5DT0xPUl9BVFRBQ0hNRU5UMF9XRUJHTCArIGkgKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0YXJyYXkgPSBhcnJheS5jb25jYXQoIF9udW1EcmF3QnVmZmVycyApO1xuXHRcdH1cblx0XHRleHQuZHJhd0J1ZmZlcnNXRUJHTCggYXJyYXkgKTtcblx0fVxuXG5cdGNsZWFyKCBfciwgX2csIF9iLCBfYSwgX2QgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdGxldCByID0gX3IgfHwgMC4wO1xuXHRcdGxldCBnID0gX2cgfHwgMC4wO1xuXHRcdGxldCBiID0gX2IgfHwgMC4wO1xuXHRcdGxldCBhID0gdHlwZW9mIF9hID09PSAnbnVtYmVyJyA/IF9hIDogMS4wO1xuXHRcdGxldCBkID0gdHlwZW9mIF9kID09PSAnbnVtYmVyJyA/IF9kIDogMS4wO1xuXG5cdCAgZ2wuY2xlYXJDb2xvciggciwgZywgYiwgYSApO1xuXHQgIGdsLmNsZWFyRGVwdGgoIGQgKTtcblx0ICBnbC5jbGVhciggZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQgKTtcblx0fVxufTtcblxuZXhwb3J0IGRlZmF1bHQgR0xDYXQ7XG4iLCIvLyDjgavjgoPjg7zjgpNcclxuXHJcbmxldCBNYXRoQ2F0ID0ge307XHJcblxyXG4vKipcclxuICogYWRkcyBhIHR3byB2ZWNcclxuICogQHBhcmFtIHthcnJheX0gYSAtIHZlY1xyXG4gKiBAcGFyYW0ge2FycmF5fSBiIC0gdmVjXHJcbiAqL1xyXG5NYXRoQ2F0LnZlY0FkZCA9ICggYSwgYiApID0+IGEubWFwKCAoIGUsIGkgKSA9PiBlICsgYltpXSApO1xyXG5cclxuLyoqXHJcbiAqIHN1YnN0cmFjdHMgYSB2ZWMgZnJvbSBhbiBhbm90aGVyIHZlY1xyXG4gKiBAcGFyYW0ge2FycmF5fSBhIC0gdmVjXHJcbiAqIEBwYXJhbSB7YXJyYXl9IGIgLSB2ZWNcclxuICovXHJcbk1hdGhDYXQudmVjU3ViID0gKCBhLCBiICkgPT4gYS5tYXAoICggZSwgaSApID0+IGUgLSBiW2ldICk7XHJcblxyXG4vKipcclxuICogcmV0dXJucyBhIGNyb3NzIG9mIHR3byB2ZWMzc1xyXG4gKiBAcGFyYW0ge2FycmF5fSBhIC0gdmVjM1xyXG4gKiBAcGFyYW0ge2FycmF5fSBiIC0gdmVjM1xyXG4gKi9cclxuTWF0aENhdC52ZWMzQ3Jvc3MgPSAoIGEsIGIgKSA9PiBbXHJcbiAgYVsxXSAqIGJbMl0gLSBhWzJdICogYlsxXSxcclxuICBhWzJdICogYlswXSAtIGFbMF0gKiBiWzJdLFxyXG4gIGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF1cclxuXTtcclxuXHJcbi8qKlxyXG4gKiBzY2FsZXMgYSB2ZWMgYnkgc2NhbGFyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzIC0gc2NhbGFyXHJcbiAqIEBwYXJhbSB7YXJyYXl9IHYgLSB2ZWNcclxuICovXHJcbk1hdGhDYXQudmVjU2NhbGUgPSAoIHMsIHYgKSA9PiB2Lm1hcCggZSA9PiBlICogcyApO1xyXG5cclxuLyoqXHJcbiAqIHJldHVybnMgbGVuZ3RoIG9mIGEgdmVjXHJcbiAqIEBwYXJhbSB7YXJyYXl9IHYgLSB2ZWNcclxuICovXHJcbk1hdGhDYXQudmVjTGVuZ3RoID0gdiA9PiBNYXRoLnNxcnQoIHYucmVkdWNlKCAoIHAsIGMgKSA9PiBwICsgYyAqIGMsIDAuMCApICk7XHJcblxyXG4vKipcclxuICogbm9ybWFsaXplcyBhIHZlY1xyXG4gKiBAcGFyYW0ge2FycmF5fSB2IC0gdmVjXHJcbiAqL1xyXG5NYXRoQ2F0LnZlY05vcm1hbGl6ZSA9IHYgPT4gTWF0aENhdC52ZWNTY2FsZSggMS4wIC8gTWF0aENhdC52ZWNMZW5ndGgoIHYgKSwgdiApO1xyXG5cclxuLyoqXHJcbiAqIGFwcGxpZXMgdHdvIG1hdDRzXHJcbiAqIEBwYXJhbSB7YXJyYXl9IGEgLSBtYXQ0XHJcbiAqIEBwYXJhbSB7YXJyYXl9IGIgLSBtYXQ0XHJcbiAqL1xyXG5NYXRoQ2F0Lm1hdDRBcHBseSA9ICggYSwgYiApID0+IHtcclxuICByZXR1cm4gW1xyXG4gICAgYVsgMF0gKiBiWyAwXSArIGFbIDRdICogYlsgMV0gKyBhWyA4XSAqIGJbIDJdICsgYVsxMl0gKiBiWyAzXSxcclxuICAgIGFbIDFdICogYlsgMF0gKyBhWyA1XSAqIGJbIDFdICsgYVsgOV0gKiBiWyAyXSArIGFbMTNdICogYlsgM10sXHJcbiAgICBhWyAyXSAqIGJbIDBdICsgYVsgNl0gKiBiWyAxXSArIGFbMTBdICogYlsgMl0gKyBhWzE0XSAqIGJbIDNdLFxyXG4gICAgYVsgM10gKiBiWyAwXSArIGFbIDddICogYlsgMV0gKyBhWzExXSAqIGJbIDJdICsgYVsxNV0gKiBiWyAzXSxcclxuXHJcbiAgICBhWyAwXSAqIGJbIDRdICsgYVsgNF0gKiBiWyA1XSArIGFbIDhdICogYlsgNl0gKyBhWzEyXSAqIGJbIDddLFxyXG4gICAgYVsgMV0gKiBiWyA0XSArIGFbIDVdICogYlsgNV0gKyBhWyA5XSAqIGJbIDZdICsgYVsxM10gKiBiWyA3XSxcclxuICAgIGFbIDJdICogYlsgNF0gKyBhWyA2XSAqIGJbIDVdICsgYVsxMF0gKiBiWyA2XSArIGFbMTRdICogYlsgN10sXHJcbiAgICBhWyAzXSAqIGJbIDRdICsgYVsgN10gKiBiWyA1XSArIGFbMTFdICogYlsgNl0gKyBhWzE1XSAqIGJbIDddLFxyXG5cclxuICAgIGFbIDBdICogYlsgOF0gKyBhWyA0XSAqIGJbIDldICsgYVsgOF0gKiBiWzEwXSArIGFbMTJdICogYlsxMV0sXHJcbiAgICBhWyAxXSAqIGJbIDhdICsgYVsgNV0gKiBiWyA5XSArIGFbIDldICogYlsxMF0gKyBhWzEzXSAqIGJbMTFdLFxyXG4gICAgYVsgMl0gKiBiWyA4XSArIGFbIDZdICogYlsgOV0gKyBhWzEwXSAqIGJbMTBdICsgYVsxNF0gKiBiWzExXSxcclxuICAgIGFbIDNdICogYlsgOF0gKyBhWyA3XSAqIGJbIDldICsgYVsxMV0gKiBiWzEwXSArIGFbMTVdICogYlsxMV0sXHJcbiAgICBcclxuICAgIGFbIDBdICogYlsxMl0gKyBhWyA0XSAqIGJbMTNdICsgYVsgOF0gKiBiWzE0XSArIGFbMTJdICogYlsxNV0sXHJcbiAgICBhWyAxXSAqIGJbMTJdICsgYVsgNV0gKiBiWzEzXSArIGFbIDldICogYlsxNF0gKyBhWzEzXSAqIGJbMTVdLFxyXG4gICAgYVsgMl0gKiBiWzEyXSArIGFbIDZdICogYlsxM10gKyBhWzEwXSAqIGJbMTRdICsgYVsxNF0gKiBiWzE1XSxcclxuICAgIGFbIDNdICogYlsxMl0gKyBhWyA3XSAqIGJbMTNdICsgYVsxMV0gKiBiWzE0XSArIGFbMTVdICogYlsxNV1cclxuICBdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIHRyYW5zcG9zZSBhIG1hdDRcclxuICogQHBhcmFtIHthcnJheX0gbSAtIG1hdDRcclxuICovXHJcbk1hdGhDYXQubWF0NFRyYW5zcG9zZSA9IG0gPT4gW1xyXG4gIG1bIDBdLG1bIDRdLG1bIDhdLG1bMTJdLFxyXG4gIG1bIDFdLG1bIDVdLG1bIDldLG1bMTNdLFxyXG4gIG1bIDJdLG1bIDZdLG1bMTBdLG1bMTRdLFxyXG4gIG1bIDNdLG1bIDddLG1bMTFdLG1bMTVdXHJcbl07XHJcblxyXG4vKipcclxuICogcmV0dXJucyBhbiBpbmRlbnRpdHkgbWF0NFxyXG4gKi9cclxuTWF0aENhdC5tYXQ0SWRlbnRpdHkgPSAoKSA9PiBbMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMV07XHJcblxyXG5NYXRoQ2F0Lm1hdDRUcmFuc2xhdGUgPSAoIHYgKSA9PiBbMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsdlswXSx2WzFdLHZbMl0sMV07XHJcblxyXG5NYXRoQ2F0Lm1hdDRTY2FsZSA9ICggdiApID0+IFtcclxuICB2WzBdLDAsMCwwLFxyXG4gIDAsdlsxXSwwLDAsXHJcbiAgMCwwLHZbMl0sMCxcclxuICAwLDAsMCwxXHJcbl07XHJcblxyXG5NYXRoQ2F0Lm1hdDRTY2FsZVhZWiA9ICggcyApID0+IFtcclxuICBzLDAsMCwwLFxyXG4gIDAscywwLDAsXHJcbiAgMCwwLHMsMCxcclxuICAwLDAsMCwxXHJcbl07XHJcblxyXG5NYXRoQ2F0Lm1hdDRSb3RhdGVYID0gKCB0ICkgPT4gW1xyXG4gIDEsMCwwLDAsXHJcbiAgMCxNYXRoLmNvcyh0KSwtTWF0aC5zaW4odCksMCxcclxuICAwLE1hdGguc2luKHQpLE1hdGguY29zKHQpLDAsXHJcbiAgMCwwLDAsMVxyXG5dO1xyXG5cclxuTWF0aENhdC5tYXQ0Um90YXRlWSA9ICggdCApID0+IFtcclxuICBNYXRoLmNvcyh0KSwwLE1hdGguc2luKHQpLDAsXHJcbiAgMCwxLDAsMCxcclxuICAtTWF0aC5zaW4odCksMCxNYXRoLmNvcyh0KSwwLFxyXG4gIDAsMCwwLDFcclxuXTtcclxuXHJcbk1hdGhDYXQubWF0NFJvdGF0ZVogPSAoIHQgKSA9PiBbXHJcbiAgTWF0aC5jb3ModCksLU1hdGguc2luKHQpLDAsMCxcclxuICBNYXRoLnNpbih0KSxNYXRoLmNvcyh0KSwwLDAsXHJcbiAgMCwwLDEsMCxcclxuICAwLDAsMCwxXHJcbl07XHJcblxyXG5NYXRoQ2F0Lm1hdDRMb29rQXQgPSAoIHBvcywgdGFyLCBhaXIsIHJvdCApID0+IHtcclxuICBsZXQgZGlyID0gTWF0aENhdC52ZWNOb3JtYWxpemUoIE1hdGhDYXQudmVjU3ViKCB0YXIsIHBvcyApICk7XHJcbiAgbGV0IHNpZCA9IE1hdGhDYXQudmVjTm9ybWFsaXplKCBNYXRoQ2F0LnZlYzNDcm9zcyggZGlyLCBhaXIgKSApO1xyXG4gIGxldCB0b3AgPSBNYXRoQ2F0LnZlYzNDcm9zcyggc2lkLCBkaXIgKTtcclxuICBzaWQgPSBNYXRoQ2F0LnZlY0FkZChcclxuICAgIE1hdGhDYXQudmVjU2NhbGUoIE1hdGguY29zKCByb3QgKSwgc2lkICksXHJcbiAgICBNYXRoQ2F0LnZlY1NjYWxlKCBNYXRoLnNpbiggcm90ICksIHRvcCApXHJcbiAgKTtcclxuICB0b3AgPSBNYXRoQ2F0LnZlYzNDcm9zcyggc2lkLCBkaXIgKTtcclxuXHJcbiAgcmV0dXJuIFtcclxuICAgIHNpZFswXSwgdG9wWzBdLCBkaXJbMF0sIDAuMCxcclxuICAgIHNpZFsxXSwgdG9wWzFdLCBkaXJbMV0sIDAuMCxcclxuICAgIHNpZFsyXSwgdG9wWzJdLCBkaXJbMl0sIDAuMCxcclxuICAgIC0gc2lkWzBdICogcG9zWzBdIC0gc2lkWzFdICogcG9zWzFdIC0gc2lkWzJdICogcG9zWzJdLFxyXG4gICAgLSB0b3BbMF0gKiBwb3NbMF0gLSB0b3BbMV0gKiBwb3NbMV0gLSB0b3BbMl0gKiBwb3NbMl0sXHJcbiAgICAtIGRpclswXSAqIHBvc1swXSAtIGRpclsxXSAqIHBvc1sxXSAtIGRpclsyXSAqIHBvc1syXSxcclxuICAgIDEuMFxyXG4gIF07XHJcbn07XHJcblxyXG5NYXRoQ2F0Lm1hdDRQZXJzcGVjdGl2ZSA9ICggZm92LCBuZWFyLCBmYXIgKSA9PiB7XHJcbiAgbGV0IHAgPSAxLjAgLyBNYXRoLnRhbiggZm92ICogTWF0aC5QSSAvIDM2MC4wICk7XHJcbiAgbGV0IGQgPSAoIGZhciAtIG5lYXIgKTtcclxuICByZXR1cm4gW1xyXG4gICAgcCwgMC4wLCAwLjAsIDAuMCxcclxuICAgIDAuMCwgcCwgMC4wLCAwLjAsXHJcbiAgICAwLjAsIDAuMCwgKCBmYXIgKyBuZWFyICkgLyBkLCAxLjAsXHJcbiAgICAwLjAsIDAuMCwgLTIgKiBmYXIgKiBuZWFyIC8gZCwgMC4wXHJcbiAgXTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1hdGhDYXQ7IiwibGV0IHN0ZXAgPSAoIF9vYmogKSA9PiB7XHJcbiAgbGV0IG9iaiA9IF9vYmo7XHJcbiAgbGV0IGNvdW50ID0gLTE7XHJcblxyXG4gIGxldCBmdW5jID0gKCkgPT4ge1xyXG4gICAgY291bnQgKys7XHJcbiAgICBpZiAoIHR5cGVvZiBvYmpbIGNvdW50IF0gPT09ICdmdW5jdGlvbicgKSB7XHJcbiAgICAgIG9ialsgY291bnQgXSggZnVuYyApO1xyXG4gICAgfVxyXG4gIH07XHJcbiAgZnVuYygpO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgc3RlcDtcclxuIiwibGV0IFR3ZWFrID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvciggX2VsICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG5cbiAgICBpdC5wYXJlbnQgPSBfZWw7XG4gICAgaXQudmFsdWVzID0ge307XG4gICAgaXQuZWxlbWVudHMgPSB7fTtcbiAgfVxuXG4gIGJ1dHRvbiggX25hbWUsIF9wcm9wcyApIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuXG4gICAgbGV0IHByb3BzID0gX3Byb3BzIHx8IHt9O1xuXG4gICAgaWYgKCB0eXBlb2YgaXQudmFsdWVzWyBfbmFtZSBdID09PSAndW5kZWZpbmVkJyApIHtcbiAgICAgIGxldCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuICAgICAgaXQucGFyZW50LmFwcGVuZENoaWxkKCBkaXYgKTtcblxuICAgICAgbGV0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2lucHV0JyApO1xuICAgICAgZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuICAgICAgaW5wdXQudHlwZSA9ICdidXR0b24nO1xuICAgICAgaW5wdXQudmFsdWUgPSBfbmFtZTtcblxuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICBpdC52YWx1ZXNbIF9uYW1lIF0gPSB0cnVlO1xuICAgICAgfSApO1xuXG4gICAgICBpdC5lbGVtZW50c1sgX25hbWUgXSA9IHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIGlucHV0OiBpbnB1dFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZXQgdGVtcHZhbHVlID0gaXQudmFsdWVzWyBfbmFtZSBdO1xuICAgIGl0LnZhbHVlc1sgX25hbWUgXSA9IGZhbHNlO1xuICAgIGlmICggdHlwZW9mIHByb3BzLnNldCA9PT0gJ2Jvb2xlYW4nICkge1xuICAgICAgaXQudmFsdWVzWyBfbmFtZSBdID0gcHJvcHMuc2V0O1xuICAgIH1cblxuICAgIHJldHVybiB0ZW1wdmFsdWU7XG4gIH1cblxuICBjaGVja2JveCggX25hbWUsIF9wcm9wcyApIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuXG4gICAgbGV0IHByb3BzID0gX3Byb3BzIHx8IHt9O1xuXG4gICAgbGV0IHZhbHVlO1xuXG4gICAgaWYgKCB0eXBlb2YgaXQudmFsdWVzWyBfbmFtZSBdID09PSAndW5kZWZpbmVkJyApIHtcbiAgICAgIHZhbHVlID0gcHJvcHMudmFsdWUgfHwgZmFsc2U7XG5cbiAgICAgIGxldCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuICAgICAgaXQucGFyZW50LmFwcGVuZENoaWxkKCBkaXYgKTtcblxuICAgICAgbGV0IG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnc3BhbicgKTtcbiAgICAgIGRpdi5hcHBlbmRDaGlsZCggbmFtZSApO1xuICAgICAgbmFtZS5pbm5lclRleHQgPSBfbmFtZTtcblxuICAgICAgbGV0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2lucHV0JyApO1xuICAgICAgZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuICAgICAgaW5wdXQudHlwZSA9ICdjaGVja2JveCc7XG4gICAgICBpbnB1dC5jaGVja2VkID0gdmFsdWU7XG5cbiAgICAgIGl0LmVsZW1lbnRzWyBfbmFtZSBdID0ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgaW5wdXQ6IGlucHV0XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IGl0LmVsZW1lbnRzWyBfbmFtZSBdLmlucHV0LmNoZWNrZWQ7XG4gICAgfVxuXG4gICAgaWYgKCB0eXBlb2YgcHJvcHMuc2V0ID09PSAnYm9vbGVhbicgKSB7XG4gICAgICB2YWx1ZSA9IHByb3BzLnNldDtcbiAgICB9XG5cbiAgICBpdC5lbGVtZW50c1sgX25hbWUgXS5pbnB1dC5jaGVja2VkID0gdmFsdWU7XG4gICAgaXQudmFsdWVzWyBfbmFtZSBdID0gdmFsdWU7XG5cbiAgICByZXR1cm4gaXQudmFsdWVzWyBfbmFtZSBdO1xuICB9XG5cbiAgcmFuZ2UoIF9uYW1lLCBfcHJvcHMgKSB7XG4gICAgbGV0IGl0ID0gdGhpcztcblxuICAgIGxldCBwcm9wcyA9IF9wcm9wcyB8fCB7fTtcblxuICAgIGxldCB2YWx1ZTtcblxuICAgIGlmICggdHlwZW9mIGl0LnZhbHVlc1sgX25hbWUgXSA9PT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICBsZXQgbWluID0gcHJvcHMubWluIHx8IDAuMDtcbiAgICAgIGxldCBtYXggPSBwcm9wcy5tYXggfHwgMS4wO1xuICAgICAgbGV0IHN0ZXAgPSBwcm9wcy5zdGVwIHx8IDAuMDAxO1xuICAgICAgdmFsdWUgPSBwcm9wcy52YWx1ZSB8fCBtaW47XG5cbiAgICAgIGxldCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuICAgICAgaXQucGFyZW50LmFwcGVuZENoaWxkKCBkaXYgKTtcblxuICAgICAgbGV0IG5hbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnc3BhbicgKTtcbiAgICAgIGRpdi5hcHBlbmRDaGlsZCggbmFtZSApO1xuICAgICAgbmFtZS5pbm5lclRleHQgPSBfbmFtZTtcblxuICAgICAgbGV0IGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2lucHV0JyApO1xuICAgICAgZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuICAgICAgaW5wdXQudHlwZSA9ICdyYW5nZSc7XG4gICAgICBpbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgICAgaW5wdXQubWluID0gbWluO1xuICAgICAgaW5wdXQubWF4ID0gbWF4O1xuICAgICAgaW5wdXQuc3RlcCA9IHN0ZXA7XG5cbiAgICAgIGxldCB2YWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnc3BhbicgKTtcbiAgICAgIHZhbC5pbm5lclRleHQgPSB2YWx1ZS50b0ZpeGVkKCAzICk7XG4gICAgICBkaXYuYXBwZW5kQ2hpbGQoIHZhbCApO1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lciggJ2lucHV0JywgKCBfZXZlbnQgKSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcnNlRmxvYXQoIGlucHV0LnZhbHVlICk7XG4gICAgICAgIHZhbC5pbm5lclRleHQgPSB2YWx1ZS50b0ZpeGVkKCAzICk7XG4gICAgICB9ICk7XG5cbiAgICAgIGl0LmVsZW1lbnRzWyBfbmFtZSBdID0ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgaW5wdXQ6IGlucHV0LFxuICAgICAgICB2YWw6IHZhbFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KCBpdC5lbGVtZW50c1sgX25hbWUgXS5pbnB1dC52YWx1ZSApO1xuICAgIH1cblxuICAgIGlmICggdHlwZW9mIHByb3BzLnNldCA9PT0gJ251bWJlcicgKSB7XG4gICAgICB2YWx1ZSA9IHByb3BzLnNldDtcbiAgICB9XG5cbiAgICBpdC52YWx1ZXNbIF9uYW1lIF0gPSB2YWx1ZTtcbiAgICBpdC5lbGVtZW50c1sgX25hbWUgXS5pbnB1dC52YWx1ZSA9IHZhbHVlO1xuXG4gICAgcmV0dXJuIGl0LnZhbHVlc1sgX25hbWUgXTtcbiAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFR3ZWFrO1xuIiwibGV0IHNlZWQ7XG5sZXQgeG9yc2hpZnQgPSAoIF9zZWVkICkgPT4ge1xuICBzZWVkID0gX3NlZWQgfHwgc2VlZCB8fCAxO1xuICBzZWVkID0gc2VlZCBeICggc2VlZCA8PCAxMyApO1xuICBzZWVkID0gc2VlZCBeICggc2VlZCA+Pj4gMTcgKTtcbiAgc2VlZCA9IHNlZWQgXiAoIHNlZWQgPDwgNSApO1xuICByZXR1cm4gc2VlZCAvIE1hdGgucG93KCAyLCAzMiApICsgMC41O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgeG9yc2hpZnQ7XG4iLCJpbXBvcnQgeG9yc2hpZnQgZnJvbSAnLi9saWJzL3hvcnNoaWZ0JztcbmltcG9ydCBUd2VhayBmcm9tICcuL2xpYnMvdHdlYWsnO1xuaW1wb3J0IEdMQ2F0IGZyb20gJy4vbGlicy9nbGNhdCc7XG5pbXBvcnQgR0xDYXRQYXRoIGZyb20gJy4vbGlicy9nbGNhdC1wYXRoLWd1aSc7XG5pbXBvcnQgTWF0aENhdCBmcm9tICcuL2xpYnMvbWF0aGNhdCc7XG5pbXBvcnQgc3RlcCBmcm9tICcuL2xpYnMvc3RlcCc7XG5cbmltcG9ydCBwYXRoTG9maVBhdGggZnJvbSAnLi9wYXRoLWxvZmlwYXRoJztcbmltcG9ydCBwYXRoUGllY2VzIGZyb20gJy4vcGF0aC1waWVjZXMnO1xuaW1wb3J0IHBhdGhQb3N0ZnggZnJvbSAnLi9wYXRoLXBvc3RmeCc7XG5pbXBvcnQgcGF0aENvbnNvbGUgZnJvbSAnLi9wYXRoLWNvbnNvbGUnO1xuaW1wb3J0IHBhdGhHcmlkIGZyb20gJy4vcGF0aC1ncmlkJztcblxubGV0IGdsc2xpZnkgPSByZXF1aXJlKCAnZ2xzbGlmeScgKTtcblxuLy8gLS0tLS0tXG5cbnhvcnNoaWZ0KCAzMjY3ODkxNTc4OTAgKTtcblxuLy8gLS0tLS0tXG5cbmxldCB3aWR0aCA9IGNhbnZhcy53aWR0aCA9IDQ4MDtcbmxldCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0ID0gNDgwO1xuXG5sZXQgcmVuZGVyQSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdhJyApO1xuXG5sZXQgc2F2ZUZyYW1lID0gKCkgPT4ge1xuICByZW5kZXJBLmhyZWYgPSBjYW52YXMudG9EYXRhVVJMKCk7XG4gIHJlbmRlckEuZG93bmxvYWQgPSAoICcwMDAwJyArIHRvdGFsRnJhbWUgKS5zbGljZSggLTUgKSArICcucG5nJztcbiAgcmVuZGVyQS5jbGljaygpO1xufTtcblxuLy8gLS0tLS0tXG5cbmxldCBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnd2ViZ2wnICk7XG5nbC5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xuXG5sZXQgZ2xDYXQgPSBuZXcgR0xDYXQoIGdsICk7XG5cbmdsQ2F0LmdldEV4dGVuc2lvbiggJ09FU190ZXh0dXJlX2Zsb2F0JywgdHJ1ZSApO1xuZ2xDYXQuZ2V0RXh0ZW5zaW9uKCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJywgdHJ1ZSApO1xuZ2xDYXQuZ2V0RXh0ZW5zaW9uKCAnRVhUX2ZyYWdfZGVwdGgnLCB0cnVlICk7XG5nbENhdC5nZXRFeHRlbnNpb24oICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJywgdHJ1ZSApO1xuXG5sZXQgZ2xDYXRQYXRoID0gbmV3IEdMQ2F0UGF0aCggZ2xDYXQsIHtcbiAgZWw6IGRpdlBhdGgsXG4gIGNhbnZhczogY2FudmFzLFxuICBzdHJldGNoOiB0cnVlXG59ICk7XG5cbi8vIC0tLS0tLVxuXG5sZXQgdHdlYWsgPSBuZXcgVHdlYWsoIGRpdlR3ZWFrICk7XG5cbi8vIC0tLS0tLVxuXG5sZXQgdG90YWxGcmFtZSA9IDA7XG5sZXQgaW5pdCA9IGZhbHNlO1xuXG5sZXQgYXV0b21hdG9uID0gbmV3IEF1dG9tYXRvbigge1xuICBndWk6IGRpdkF1dG9tYXRvbixcbiAgZnBzOiA2MCxcbiAgZGF0YTogYFxuICB7XCJ2XCI6XCIxLjEuMVwiLFwibGVuZ3RoXCI6MyxcInJlc29sdXRpb25cIjoxMDAwLFwicGFyYW1zXCI6e1wiY2FtZXJhUG9zWFwiOlt7XCJ0aW1lXCI6MCxcInZhbHVlXCI6MCxcIm1vZGVcIjoxLFwicGFyYW1zXCI6e30sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjAuNSxcInZhbHVlXCI6MCxcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwMDAsXCJkYW1wXCI6MX0sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjEsXCJ2YWx1ZVwiOjAuMzY4NTA4NDU0MTA2Mjc5MSxcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwMDAsXCJkYW1wXCI6MX0sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjEuNjI1LFwidmFsdWVcIjotMC4zMjg1MDI0MTU0NTg5Mzk1NSxcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwMDAsXCJkYW1wXCI6MX0sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjIsXCJ2YWx1ZVwiOjAuMzMxODIzNjcxNDk3NTg0NixcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwMDAsXCJkYW1wXCI6MX0sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjMsXCJ2YWx1ZVwiOjAsXCJtb2RlXCI6NCxcInBhcmFtc1wiOntcInJhdGVcIjoyMDAwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19XSxcInBhdGhCZWdpblwiOlt7XCJ0aW1lXCI6MCxcInZhbHVlXCI6MC4yLFwibW9kZVwiOjEsXCJwYXJhbXNcIjp7fSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6MyxcInZhbHVlXCI6MCxcIm1vZGVcIjoxLFwicGFyYW1zXCI6e30sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX1dLFwicGF0aFNlZ3NcIjpbe1widGltZVwiOjAsXCJ2YWx1ZVwiOjMwLjAwMDAwMDAwMDAwMDAwNyxcIm1vZGVcIjoxLFwicGFyYW1zXCI6e30sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjEuMjUsXCJ2YWx1ZVwiOjQsXCJtb2RlXCI6NCxcInBhcmFtc1wiOntcInJhdGVcIjozMCxcImRhbXBcIjoxfSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6MyxcInZhbHVlXCI6MzAsXCJtb2RlXCI6NCxcInBhcmFtc1wiOntcInJhdGVcIjozMCxcImRhbXBcIjoxfSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfV0sXCJkZWZvcm1BbXBcIjpbe1widGltZVwiOjAsXCJ2YWx1ZVwiOjUsXCJtb2RlXCI6MSxcInBhcmFtc1wiOnt9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19LHtcInRpbWVcIjoxLjI1LFwidmFsdWVcIjo1Ljc0NDgwMDAwMzI0MzU5NixcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19LHtcInRpbWVcIjoyLjQzMTQ4Njg4MDQ2NjQ3MjcsXCJ2YWx1ZVwiOjAsXCJtb2RlXCI6NCxcInBhcmFtc1wiOntcInJhdGVcIjo5MSxcImRhbXBcIjoxfSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6Mi42ODUxMzExOTUzMzUyNzcsXCJ2YWx1ZVwiOjEuNzkzOTE3NjA0MjQxNjg5MSxcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwMCxcImRhbXBcIjoxfSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6MyxcInZhbHVlXCI6NSxcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwMCxcImRhbXBcIjoxfSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfV0sXCJkZWZvcm1GcmVxXCI6W3tcInRpbWVcIjowLFwidmFsdWVcIjoxLFwibW9kZVwiOjEsXCJwYXJhbXNcIjp7fSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6MS4yNSxcInZhbHVlXCI6MC4xNTE2MTU3NDA2NDc1NzEzMyxcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19LHtcInRpbWVcIjozLFwidmFsdWVcIjoxLFwibW9kZVwiOjQsXCJwYXJhbXNcIjp7XCJyYXRlXCI6NTAwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19XSxcImRlZm9ybU9mZnNldFwiOlt7XCJ0aW1lXCI6MCxcInZhbHVlXCI6MCxcIm1vZGVcIjoxLFwicGFyYW1zXCI6e30sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjMsXCJ2YWx1ZVwiOjEuMDAxNDU3MzAzOTE4NjMxNCxcIm1vZGVcIjoxLFwicGFyYW1zXCI6e30sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX1dLFwiY2FtZXJhUG9zWVwiOlt7XCJ0aW1lXCI6MCxcInZhbHVlXCI6MCxcIm1vZGVcIjoxLFwicGFyYW1zXCI6e30sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjAuNzUsXCJ2YWx1ZVwiOjAsXCJtb2RlXCI6NCxcInBhcmFtc1wiOntcInJhdGVcIjo1MDAwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19LHtcInRpbWVcIjoxLjI1LFwidmFsdWVcIjowLjQwMTI2ODExNTk0MjAyOTI3LFwibW9kZVwiOjQsXCJwYXJhbXNcIjp7XCJyYXRlXCI6NTAwMCxcImRhbXBcIjoxfSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6MS44NzUsXCJ2YWx1ZVwiOi0wLjczNTk2MDE0NDkyNzUzNyxcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwMDAsXCJkYW1wXCI6MX0sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjIsXCJ2YWx1ZVwiOjAuNDAxMjY4MTE1OTQyMDI4NCxcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwMDAsXCJkYW1wXCI6MX0sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjMsXCJ2YWx1ZVwiOjAsXCJtb2RlXCI6NCxcInBhcmFtc1wiOntcInJhdGVcIjo1MDAwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19XSxcImNhbWVyYVBvc1pcIjpbe1widGltZVwiOjAsXCJ2YWx1ZVwiOjEwLFwibW9kZVwiOjEsXCJwYXJhbXNcIjp7fSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6MS4yNSxcInZhbHVlXCI6MTguMDgwNTE5MTkyMDU1NjY0LFwibW9kZVwiOjQsXCJwYXJhbXNcIjp7XCJyYXRlXCI6MjUwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19LHtcInRpbWVcIjoyLFwidmFsdWVcIjo5LjU3MjQ2Mzc2ODExNTk0MyxcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjI1MCxcImRhbXBcIjoxfSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6MyxcInZhbHVlXCI6MTAsXCJtb2RlXCI6NCxcInBhcmFtc1wiOntcInJhdGVcIjo1MDAwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19XSxcImdsaXRjaFwiOlt7XCJ0aW1lXCI6MCxcInZhbHVlXCI6MC4zNjUwNTQyMDA5OTkxMTQ4LFwibW9kZVwiOjEsXCJwYXJhbXNcIjp7fSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6Mi41LFwidmFsdWVcIjowLFwibW9kZVwiOjQsXCJwYXJhbXNcIjp7XCJyYXRlXCI6MTkwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSx7XCJmcmVxXCI6MSxcImFtcFwiOjAuMDI0LFwicmVzb1wiOjgsXCJyZWN1cnNpb25cIjo0LFwic2VlZFwiOjIwLjA3fSx7XCJmcmVxXCI6MTl9XX0se1widGltZVwiOjMsXCJ2YWx1ZVwiOjAuMzExNDY2NTQwNjU1MzY0MTcsXCJtb2RlXCI6MixcInBhcmFtc1wiOnt9LFwibW9kc1wiOlt7XCJ2ZWxvY2l0eVwiOjB9LGZhbHNlLGZhbHNlLGZhbHNlXX1dLFwiZ2xpdGNoU2VlZFwiOlt7XCJ0aW1lXCI6MCxcInZhbHVlXCI6MCxcIm1vZGVcIjoxLFwicGFyYW1zXCI6e30sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjAuMDQwNTQwNTQwNTQwNTQwNTQsXCJ2YWx1ZVwiOjAuMDUzMTQwMDk2NjE4MzU3NDQ2LFwibW9kZVwiOjAsXCJwYXJhbXNcIjp7fSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6MC40NzIzMDMyMDY5OTcwODQ2LFwidmFsdWVcIjowLjE4MzU3NDg3OTIyNzA1MzE4LFwibW9kZVwiOjAsXCJwYXJhbXNcIjp7fSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6Mi41NTA5ODEwMTAxNjQ2ODM1LFwidmFsdWVcIjowLjcyNDg4MzAwMTIwNzcyOTQsXCJtb2RlXCI6MSxcInBhcmFtc1wiOnt9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSx7XCJmcmVxXCI6MzF9XX0se1widGltZVwiOjIuOTIxLFwidmFsdWVcIjowLjg4NDA1Nzk3MTAxNDQ5MzIsXCJtb2RlXCI6MCxcInBhcmFtc1wiOnt9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19LHtcInRpbWVcIjozLFwidmFsdWVcIjoxLFwibW9kZVwiOjEsXCJwYXJhbXNcIjp7fSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfV0sXCJtZWFzdXJlUGhhc2UxXCI6W3tcInRpbWVcIjowLFwidmFsdWVcIjoxLFwibW9kZVwiOjEsXCJwYXJhbXNcIjp7fSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6MS4yNSxcInZhbHVlXCI6NS41NTExMTUxMjMxMjU3ODNlLTE3LFwibW9kZVwiOjQsXCJwYXJhbXNcIjp7XCJyYXRlXCI6NTAwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19LHtcInRpbWVcIjozLFwidmFsdWVcIjoxLFwibW9kZVwiOjQsXCJwYXJhbXNcIjp7XCJyYXRlXCI6NTAwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19XSxcIm1lYXN1cmVQaGFzZTJcIjpbe1widGltZVwiOjAsXCJ2YWx1ZVwiOjEsXCJtb2RlXCI6MSxcInBhcmFtc1wiOnt9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19LHtcInRpbWVcIjoxLjU4MDExNTgzMDExNTgzMDUsXCJ2YWx1ZVwiOjAuMDA0ODMwOTE3ODc0Mzk2MTAxLFwibW9kZVwiOjQsXCJwYXJhbXNcIjp7XCJyYXRlXCI6NTAwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19LHtcInRpbWVcIjozLFwidmFsdWVcIjoxLFwibW9kZVwiOjQsXCJwYXJhbXNcIjp7XCJyYXRlXCI6NTAwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19XX0sXCJndWlcIjp7XCJzbmFwXCI6e1wiZW5hYmxlXCI6dHJ1ZSxcImJwbVwiOlwiNjBcIixcIm9mZnNldFwiOlwiMFwifX19XG5gXG59ICk7XG5sZXQgYXV0byA9IGF1dG9tYXRvbi5hdXRvO1xuXG4vLyAtLS0tLS1cblxubGV0IGNhbWVyYVBvcyA9IFsgMC4wLCAwLjAsIDEwLjAgXTtcbmxldCBjYW1lcmFUYXIgPSBbIDAuMCwgMC4wLCAwLjAgXTtcbmxldCBjYW1lcmFSb2xsID0gMC4wO1xubGV0IGNhbWVyYUZvdiA9IDcwLjA7XG5cbmxldCBjYW1lcmFOZWFyID0gMC4xO1xubGV0IGNhbWVyYUZhciA9IDEwMC4wO1xuXG5sZXQgbGlnaHRQb3MgPSBbIDEwLjAsIDguMCwgMTAuMCBdO1xuXG5sZXQgbWF0UDtcbmxldCBtYXRWO1xubGV0IG1hdFBMO1xubGV0IG1hdFZMO1xuXG5sZXQgdXBkYXRlTWF0cmljZXMgPSAoKSA9PiB7XG4gIGNhbWVyYVBvc1sgMCBdID0gYXV0byggJ2NhbWVyYVBvc1gnICk7XG4gIGNhbWVyYVBvc1sgMSBdID0gYXV0byggJ2NhbWVyYVBvc1knICk7XG4gIGNhbWVyYVBvc1sgMiBdID0gYXV0byggJ2NhbWVyYVBvc1onICk7XG5cbiAgbWF0UCA9IE1hdGhDYXQubWF0NFBlcnNwZWN0aXZlKCBjYW1lcmFGb3YsIGNhbWVyYU5lYXIsIGNhbWVyYUZhciApO1xuICBtYXRWID0gTWF0aENhdC5tYXQ0TG9va0F0KCBjYW1lcmFQb3MsIGNhbWVyYVRhciwgWyAwLjAsIDEuMCwgMC4wIF0sIGNhbWVyYVJvbGwgKTtcblxuICBtYXRQTCA9IE1hdGhDYXQubWF0NFBlcnNwZWN0aXZlKCBjYW1lcmFGb3YsIGNhbWVyYU5lYXIsIGNhbWVyYUZhciApO1xuICBtYXRWTCA9IE1hdGhDYXQubWF0NExvb2tBdCggbGlnaHRQb3MsIGNhbWVyYVRhciwgWyAwLjAsIDEuMCwgMC4wIF0sIDAuMCApO1xufTtcbnVwZGF0ZU1hdHJpY2VzKCk7XG5cbi8vIC0tLS0tLVxuXG5sZXQgbW91c2VYID0gMC4wO1xubGV0IG1vdXNlWSA9IDAuMDtcblxuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCAoIGV2ZW50ICkgPT4ge1xuICBtb3VzZVggPSBldmVudC5vZmZzZXRYO1xuICBtb3VzZVkgPSBldmVudC5vZmZzZXRZO1xufSApO1xuXG4vLyAtLS0tLS1cblxubGV0IHZib1F1YWQgPSBnbENhdC5jcmVhdGVWZXJ0ZXhidWZmZXIoIFsgLTEsIC0xLCAxLCAtMSwgLTEsIDEsIDEsIDEgXSApO1xuXG4vLyAtLS0tLS1cblxubGV0IGJnQ29sb3IgPSBbIDAuMDEsIDAuMDEsIDAuMDEsIDEuMCBdO1xuXG4vLyAtLS0tLS1cblxuZ2xDYXRQYXRoLnNldEdsb2JhbEZ1bmMoICgpID0+IHtcbiAgZ2xDYXQudW5pZm9ybTFpKCAnaW5pdCcsIGluaXQgKTtcbiAgZ2xDYXQudW5pZm9ybTFmKCAndGltZScsIGF1dG9tYXRvbi50aW1lICk7XG4gIGdsQ2F0LnVuaWZvcm0xZiggJ2RlbHRhVGltZScsIGF1dG9tYXRvbi5kZWx0YVRpbWUgKTtcblxuICBnbENhdC51bmlmb3JtMWYoICd0b3RhbEZyYW1lJywgdG90YWxGcmFtZSApO1xuICBnbENhdC51bmlmb3JtMmZ2KCAnbW91c2UnLCBbIG1vdXNlWCwgbW91c2VZIF0gKTtcblxuICBnbENhdC51bmlmb3JtM2Z2KCAnY2FtZXJhUG9zJywgY2FtZXJhUG9zICk7XG4gIGdsQ2F0LnVuaWZvcm0zZnYoICdjYW1lcmFUYXInLCBjYW1lcmFUYXIgKTtcbiAgZ2xDYXQudW5pZm9ybTFmKCAnY2FtZXJhUm9sbCcsIGNhbWVyYVJvbGwgKTtcbiAgZ2xDYXQudW5pZm9ybTFmKCAnY2FtZXJhRm92JywgY2FtZXJhRm92ICk7XG4gIGdsQ2F0LnVuaWZvcm0xZiggJ2NhbWVyYU5lYXInLCBjYW1lcmFOZWFyICk7XG4gIGdsQ2F0LnVuaWZvcm0xZiggJ2NhbWVyYUZhcicsIGNhbWVyYUZhciApO1xuICBnbENhdC51bmlmb3JtM2Z2KCAnbGlnaHRQb3MnLCBsaWdodFBvcyApO1xuXG4gIGdsQ2F0LnVuaWZvcm1NYXRyaXg0ZnYoICdtYXRQJywgbWF0UCApO1xuICBnbENhdC51bmlmb3JtTWF0cml4NGZ2KCAnbWF0VicsIG1hdFYgKTtcbiAgZ2xDYXQudW5pZm9ybU1hdHJpeDRmdiggJ21hdFBMJywgbWF0UEwgKTtcbiAgZ2xDYXQudW5pZm9ybU1hdHJpeDRmdiggJ21hdFZMJywgbWF0VkwgKTtcbiAgZ2xDYXQudW5pZm9ybTRmdiggJ2JnQ29sb3InLCBiZ0NvbG9yICk7XG59ICk7XG5cbmdsQ2F0UGF0aC5hZGQoIHtcbiAgcmV0dXJuOiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHZlcnQ6IGdsc2xpZnkoICcuL3NoYWRlci9xdWFkLnZlcnQnICksXG4gICAgZnJhZzogZ2xzbGlmeSggJy4vc2hhZGVyL3JldHVybi5mcmFnJyApLFxuICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuWkVSTyBdLFxuICAgIGNsZWFyOiBbIDAuMCwgMC4wLCAwLjAsIDEuMCBdLFxuICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xuICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcbiAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlcjAnLCBwYXJhbXMuaW5wdXQsIDAgKTtcbiAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XG4gICAgfVxuICB9LFxuXG4gIGluc3BlY3Rvcjoge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB2ZXJ0OiBnbHNsaWZ5KCAnLi9zaGFkZXIvcXVhZC52ZXJ0JyApLFxuICAgIGZyYWc6IGdsc2xpZnkoICcuL3NoYWRlci9pbnNwZWN0b3IuZnJhZycgKSxcbiAgICBibGVuZDogWyBnbC5PTkUsIGdsLlpFUk8gXSxcbiAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAxLjAgXSxcbiAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcbiAgICAgIGdsQ2F0LmF0dHJpYnV0ZSggJ3AnLCB2Ym9RdWFkLCAyICk7XG4gICAgICBnbENhdC51bmlmb3JtM2Z2KCAnY2lyY2xlQ29sb3InLCBbIDEuMCwgMS4wLCAxLjAgXSApO1xuICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyMCcsIHBhcmFtcy5pbnB1dCwgMCApO1xuICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICB9XG4gIH0sXG5cbiAgJ3RhcmdldCc6IHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgdmVydDogZ2xzbGlmeSggJy4vc2hhZGVyL3F1YWQudmVydCcgKSxcbiAgICBmcmFnOiBnbHNsaWZ5KCAnLi9zaGFkZXIvYmcuZnJhZycgKSxcbiAgICBibGVuZDogWyBnbC5PTkUsIGdsLlpFUk8gXSxcbiAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAxLjAgXSxcbiAgICBmcmFtZWJ1ZmZlcjogdHJ1ZSxcbiAgICBmbG9hdDogdHJ1ZSxcbiAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICBmdW5jOiAoKSA9PiB7XG4gICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xuICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICB9XG4gIH0sXG59ICk7XG5cbi8vIC0tLS0tLVxuXG5sZXQgdXBkYXRlVUkgPSAoKSA9PiB7XG4gIGxldCBub3cgPSBuZXcgRGF0ZSgpO1xuICBsZXQgZGVhZGxpbmUgPSBuZXcgRGF0ZSggMjAxOCwgMiwgMTYsIDAsIDAgKTtcblxuICBkaXZDb3VudGRvd24uaW5uZXJUZXh0ID0gJ0RlYWRsaW5lOiAnICsgTWF0aC5mbG9vciggKCBkZWFkbGluZSAtIG5vdyApIC8gMTAwMCApO1xufTtcblxuLy8gLS0tLS0tXG5cbmxldCB1cGRhdGUgPSAoKSA9PiB7XG4gIGlmICggIXR3ZWFrLmNoZWNrYm94KCAncGxheScsIHsgdmFsdWU6IHRydWUgfSApICkge1xuICAgIHNldFRpbWVvdXQoIHVwZGF0ZSwgMTAwICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXV0b21hdG9uLnVwZGF0ZSgpO1xuXG4gIHVwZGF0ZVVJKCk7XG4gIHVwZGF0ZU1hdHJpY2VzKCk7XG5cbiAgLy8gLS0tLS0tXG5cbiAgZ2xDYXRQYXRoLmJlZ2luKCk7XG5cbiAgZ2xDYXRQYXRoLnJlbmRlciggJ3RhcmdldCcgKTtcblxuICBnbENhdFBhdGgucmVuZGVyKCAncGllY2VzQ29tcHV0ZVJldHVybicgKTtcbiAgZ2xDYXRQYXRoLnJlbmRlciggJ3BpZWNlc0NvbXB1dGUnICk7XG5cbiAgZ2xDYXRQYXRoLnJlbmRlciggJ2xvZmlwYXRoJywge1xuICAgIHRhcmdldDogZ2xDYXRQYXRoLmZiKCAndGFyZ2V0JyApLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBiZWdpbjogYXV0byggJ3BhdGhCZWdpbicgKSxcbiAgICBzZWdzOiBhdXRvKCAncGF0aFNlZ3MnIClcbiAgfSApO1xuXG4gIGdsQ2F0UGF0aC5yZW5kZXIoICdwaWVjZXNSZW5kZXInLCB7XG4gICAgdGFyZ2V0OiBnbENhdFBhdGguZmIoICd0YXJnZXQnICksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH0gKTtcblxuICBnbENhdFBhdGgucmVuZGVyKCAnY29uc29sZScsIHtcbiAgICB0YXJnZXQ6IGdsQ2F0UGF0aC5mYiggJ3RhcmdldCcgKSxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgdGltZTogYXV0b21hdG9uLnRpbWUsXG4gICAgZnJhbWU6IGF1dG9tYXRvbi5mcmFtZSxcbiAgICBjYW1lcmFYOiBjYW1lcmFQb3NbIDAgXSxcbiAgICBjYW1lcmFZOiBjYW1lcmFQb3NbIDEgXSxcbiAgICBjYW1lcmFaOiBjYW1lcmFQb3NbIDIgXVxuICB9ICk7XG5cbiAgZ2xDYXRQYXRoLnJlbmRlciggJ21lYXN1cmUnLCB7XG4gICAgdGFyZ2V0OiBnbENhdFBhdGguZmIoICd0YXJnZXQnICksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHBoYXNlMTogYXV0byggJ21lYXN1cmVQaGFzZTEnICksXG4gICAgcGhhc2UyOiBhdXRvKCAnbWVhc3VyZVBoYXNlMicgKVxuICB9ICk7XG5cbiAgZ2xDYXRQYXRoLnJlbmRlciggJ2dyaWQnLCB7XG4gICAgdGFyZ2V0OiBnbENhdFBhdGguZmIoICd0YXJnZXQnICksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH0gKTtcblxuICBnbENhdFBhdGgucmVuZGVyKCAnZ2xpdGNoJywge1xuICAgIGlucHV0OiBnbENhdFBhdGguZmIoICd0YXJnZXQnICkudGV4dHVyZSxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgYW1wOiBhdXRvKCAnZ2xpdGNoJyApLFxuICAgIHNlZWQ6IGF1dG8oICdnbGl0Y2hTZWVkJyApXG4gIH0gKTtcblxuICBnbENhdFBhdGgucmVuZGVyKCAncG9zdCcsIHtcbiAgICB0YXJnZXQ6IEdMQ2F0UGF0aC5udWxsRmIsXG4gICAgaW5wdXQ6IGdsQ2F0UGF0aC5mYiggJ2dsaXRjaCcgKS50ZXh0dXJlLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgfSApO1xuXG4gIGdsQ2F0UGF0aC5lbmQoKTtcblxuICBpbml0ID0gZmFsc2U7XG4gIHRvdGFsRnJhbWUgKys7XG5cbiAgLy8gLS0tLS0tXG5cbiAgaWYgKCB0d2Vhay5jaGVja2JveCggJ3NhdmUnLCB7IHZhbHVlOiBmYWxzZSB9ICkgKSB7XG4gICAgc2F2ZUZyYW1lKCk7XG4gIH1cblxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHVwZGF0ZSApO1xufVxuXG5cbnN0ZXAoIHtcbiAgMDogKCBzdGVwICkgPT4ge1xuICAgIHBhdGhMb2ZpUGF0aCggZ2xDYXRQYXRoLCBhdXRvLCBzdGVwICk7XG4gICAgcGF0aFBvc3RmeCggZ2xDYXRQYXRoLCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgcGF0aENvbnNvbGUoIGdsQ2F0UGF0aCwgd2lkdGgsIGhlaWdodCApO1xuICAgIHBhdGhQaWVjZXMoIGdsQ2F0UGF0aCwgYXV0b21hdG9uICk7XG4gICAgcGF0aEdyaWQoIGdsQ2F0UGF0aCApO1xuICB9LFxuXG4gIDE6ICggc3RlcCApID0+IHtcbiAgICB1cGRhdGUoKTtcbiAgfVxufSApO1xuXG4vLyAtLS0tLS1cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgKCBfZSApID0+IHtcbiAgaWYgKCBfZS53aGljaCA9PT0gMjcgKSB7XG4gICAgdHdlYWsuY2hlY2tib3goICdwbGF5JywgeyBzZXQ6IGZhbHNlIH0gKTtcbiAgfVxufSApO1xuIiwiY29uc3QgZ2xzbGlmeSA9IHJlcXVpcmUoICdnbHNsaWZ5JyApO1xyXG5cclxuLy8gLS0tLS0tXHJcblxyXG5sZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcclxubGV0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xyXG5cclxuLy8gLS0tLS0tXHJcblxyXG5sZXQgdGV4dFdpdGhCZyA9ICggdGV4dCwgeCwgeSApID0+IHtcclxuICBjb250ZXh0LmZvbnQgPSAnNTAwIDIwcHggV3QtUG9zaXRpb24nO1xyXG4gIGNvbnRleHQudGV4dEFsaWduID0gJ2xlZnQnO1xyXG4gIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2hhbmdpbmcnO1xyXG5cclxuICBsZXQgbXQgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KCB0ZXh0ICk7XHJcblxyXG4gIGNvbnRleHQuZmlsbFN0eWxlID0gJyNmZmYnO1xyXG4gIGNvbnRleHQuZmlsbFJlY3QoIHggLSA0LCB5IC0gNCwgbXQud2lkdGggKyA4LCAyMCApO1xyXG5cclxuICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjMDAwJztcclxuICBjb250ZXh0LmZpbGxUZXh0KCB0ZXh0LCB4LCB5ICk7XHJcbn07XHJcblxyXG5sZXQgdGV4dEJvdHRvbSA9ICggdGV4dCwgc2l6ZSwgeCwgeSApID0+IHtcclxuICBjb250ZXh0LmZvbnQgPSAnOTAwICcgKyBzaXplICsgJ3B4IEhlbHZldGljYSBOZXVlJztcclxuICBjb250ZXh0LnRleHRBbGlnbiA9ICdyaWdodCc7XHJcbiAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XHJcblxyXG4gIGNvbnRleHQuZmlsbFN0eWxlID0gJyNmZmYnO1xyXG4gIGNvbnRleHQuZmlsbFRleHQoIHRleHQsIHgsIHkgKTtcclxufTtcclxuXHJcbi8vIC0tLS0tLVxyXG5cclxubGV0IHBhdGhDb25zb2xlID0gKCBnbENhdFBhdGgsIHdpZHRoLCBoZWlnaHQgKSA9PiB7XHJcbiAgbGV0IGdsQ2F0ID0gZ2xDYXRQYXRoLmdsQ2F0O1xyXG4gIGxldCBnbCA9IGdsQ2F0LmdsO1xyXG5cclxuICAvLyAtLS0tLS1cclxuXHJcbiAgbGV0IHcgPSBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICBsZXQgaCA9IGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gIGxldCB2Ym9RdWFkID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBbIC0xLCAtMSwgMSwgLTEsIC0xLCAxLCAxLCAxIF0gKTtcclxuICBsZXQgdGV4dHVyZSA9IGdsQ2F0LmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcbiAgLy8gLS0tLS0tXHJcblxyXG4gIGdsQ2F0UGF0aC5hZGQoIHtcclxuICAgIGNvbnNvbGU6IHtcclxuICAgICAgdmVydDogZ2xzbGlmeSggJy4vc2hhZGVyL3F1YWQudmVydCcgKSxcclxuICAgICAgZnJhZzogZ2xzbGlmeSggJy4vc2hhZGVyL3JldHVybi15aW52ZXJ0LmZyYWcnICksXHJcbiAgICAgIGZsb2F0OiB0cnVlLFxyXG4gICAgICBibGVuZDogWyBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgXSxcclxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXHJcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXHJcbiAgICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xyXG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KCAwLCAwLCB3LCBoICk7XHJcblxyXG4gICAgICAgIHRleHRXaXRoQmcoICdSQU5ET00gRiolI0lORyBOVU1CRVI6ICcgKyAoIDI1Ni4wICogTWF0aC5yYW5kb20oKSApLnRvRml4ZWQoIDMgKSwgMTAsIDEwICk7XHJcbiAgICAgICAgdGV4dFdpdGhCZyggJ0NBTUVSQSBYOiAnICsgcGFyYW1zLmNhbWVyYVgudG9GaXhlZCggMyApLCAxMCwgNDAgKTtcclxuICAgICAgICB0ZXh0V2l0aEJnKCAnQ0FNRVJBIFk6ICcgKyBwYXJhbXMuY2FtZXJhWS50b0ZpeGVkKCAzICksIDEwLCA3MCApO1xyXG4gICAgICAgIHRleHRXaXRoQmcoICdDQU1FUkEgWjogJyArIHBhcmFtcy5jYW1lcmFaLnRvRml4ZWQoIDMgKSwgMTAsIDEwMCApO1xyXG5cclxuICAgICAgICB0ZXh0Qm90dG9tKCBwYXJhbXMudGltZS50b0ZpeGVkKCAzICksIDMwLCB3aWR0aCAtIDEwLCBoZWlnaHQgLSA4MCApO1xyXG4gICAgICAgIHRleHRCb3R0b20oICd1bmRlZmluZWQnLCAzMCwgd2lkdGggLSAxMCwgaGVpZ2h0IC0gNTAgKTtcclxuICAgICAgICB0ZXh0Qm90dG9tKCAnW1BsYWNlaG9sZGVyXScsIDQwLCB3aWR0aCAtIDEwLCBoZWlnaHQgLSAxMCApO1xyXG5cclxuICAgICAgICBnbENhdC5zZXRUZXh0dXJlKCB0ZXh0dXJlLCBjYW52YXMgKTtcclxuXHJcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcclxuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXIwJywgdGV4dHVyZSwgMCApO1xyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgfSApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgcGF0aENvbnNvbGU7IiwiaW1wb3J0IE1hdGhDYXQgZnJvbSAnLi9saWJzL21hdGhjYXQnO1xyXG5jb25zdCBnbHNsaWZ5ID0gcmVxdWlyZSggJ2dsc2xpZnknICk7XHJcblxyXG4vLyAtLS0tLS1cclxuXHJcbmxldCBwYXRoR3JpZCA9ICggZ2xDYXRQYXRoICkgPT4ge1xyXG4gIGxldCBnbENhdCA9IGdsQ2F0UGF0aC5nbENhdDtcclxuICBsZXQgZ2wgPSBnbENhdC5nbDtcclxuXHJcbiAgLy8gLS0tLS0tXHJcblxyXG4gIGxldCB2Ym9RdWFkID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBbIC0xLCAtMSwgMSwgLTEsIC0xLCAxLCAxLCAxIF0gKTtcclxuXHJcbiAgbGV0IGxheWVyID0gW107XHJcbiAgZm9yICggbGV0IGkgPSAtMzsgaSA8IDA7IGkgKysgKSB7XHJcbiAgICBsYXllci5wdXNoKCAoIGkgKyAwLjUgKSAqIDAuMDUgKTtcclxuICB9XHJcbiAgbGV0IHZib0xheWVyID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBsYXllciApO1xyXG5cclxuICAvLyAtLS0tLS1cclxuXHJcbiAgZ2xDYXRQYXRoLmFkZCgge1xyXG4gICAgZ3JpZDoge1xyXG4gICAgICB2ZXJ0OiBnbHNsaWZ5KCAnLi9zaGFkZXIvcGF0aDJkei52ZXJ0JyApLFxyXG4gICAgICBmcmFnOiBnbHNsaWZ5KCAnLi9zaGFkZXIvZ3JpZC5mcmFnJyApLFxyXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcclxuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICd6JywgdmJvTGF5ZXIsIDEsIDEgKTtcclxuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xyXG5cclxuICAgICAgICBsZXQgbWF0TSA9IE1hdGhDYXQubWF0NElkZW50aXR5KCk7XHJcbiAgICAgICAgbWF0TSA9IE1hdGhDYXQubWF0NEFwcGx5KCBNYXRoQ2F0Lm1hdDRTY2FsZVhZWiggMTAwLjAgKSwgbWF0TSApO1xyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm1NYXRyaXg0ZnYoICdtYXRNJywgbWF0TSApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0zZnYoICdjb2xvcicsIFsgMS4wLCAxLjAsIDEuMCBdICk7XHJcblxyXG4gICAgICAgIGxldCBleHQgPSBnbENhdC5nZXRFeHRlbnNpb24oIFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiICk7XHJcbiAgICAgICAgZXh0LmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQsIHZib0xheWVyLmxlbmd0aCApO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1lYXN1cmU6IHtcclxuICAgICAgdmVydDogZ2xzbGlmeSggJy4vc2hhZGVyL3BhdGgyZC52ZXJ0JyApLFxyXG4gICAgICBmcmFnOiBnbHNsaWZ5KCAnLi9zaGFkZXIvbWVhc3VyZS5mcmFnJyApLFxyXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcclxuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xyXG5cclxuICAgICAgICBsZXQgbWF0TSA9IE1hdGhDYXQubWF0NElkZW50aXR5KCk7XHJcbiAgICAgICAgbWF0TSA9IE1hdGhDYXQubWF0NEFwcGx5KCBNYXRoQ2F0Lm1hdDRTY2FsZVhZWiggMTAwLjAgKSwgbWF0TSApO1xyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm1NYXRyaXg0ZnYoICdtYXRNJywgbWF0TSApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ3BoYXNlMScsIHBhcmFtcy5waGFzZTEgKTtcclxuICAgICAgICBnbENhdC51bmlmb3JtMWYoICdwaGFzZTInLCBwYXJhbXMucGhhc2UyICk7XHJcbiAgICAgICAgZ2xDYXQudW5pZm9ybTNmdiggJ2NvbG9yJywgWyAxLjAsIDEuMCwgMS4wIF0gKTtcclxuXHJcbiAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICB9ICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBwYXRoR3JpZDsiLCJpbXBvcnQgc3ZnUGF0aCBmcm9tICcuL3N2Zy1wYXRoJztcclxuaW1wb3J0IE1hdGhDYXQgZnJvbSAnLi9saWJzL21hdGhjYXQnO1xyXG5pbXBvcnQgVmVydFBoYXNlciBmcm9tICcuL3ZlcnRwaGFzZXInO1xyXG5pbXBvcnQgKiBhcyBvcGVudHlwZSBmcm9tICdvcGVudHlwZS5qcyc7XHJcbmNvbnN0IGdsc2xpZnkgPSByZXF1aXJlKCAnZ2xzbGlmeScgKTtcclxuXHJcbi8vIC0tLS0tLVxyXG5cclxubGV0IHBhdGhMb2ZpUGF0aCA9ICggZ2xDYXRQYXRoLCBhdXRvLCBjYWxsYmFjayApID0+IHtcclxuICBsZXQgZ2xDYXQgPSBnbENhdFBhdGguZ2xDYXQ7XHJcbiAgbGV0IGdsID0gZ2xDYXQuZ2w7XHJcblxyXG4gIC8vIC0tLS0tLVxyXG5cclxuICBsZXQgcGhhc2VycztcclxuXHJcbiAgb3BlbnR5cGUubG9hZCggJ2ZvbnRzL09yYml0cm9uLUJsYWNrLnR0ZicsIGZ1bmN0aW9uKCBlcnJvciwgZm9udCApIHtcclxuICAgIGlmICggZXJyb3IgKSB7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBsZXQgZm9udFNpemUgPSAxMi4wO1xyXG4gICAgbGV0IHRleHQgPSAnVmVjJztcclxuICAgIGxldCB3aWQgPSBmb250LmdldEFkdmFuY2VXaWR0aCggdGV4dCwgZm9udFNpemUgKTtcclxuICAgIGxldCBwYXRoID0gZm9udC5nZXRQYXRoKCB0ZXh0LCAwLCAwLCBmb250U2l6ZSApLnRvUGF0aERhdGEoKTtcclxuICAgIGxldCB2cyA9IHN2Z1BhdGgoIHBhdGgsIHsgY3VydmVTZWdzOiA4IH0gKTtcclxuICAgIHBoYXNlcnMgPSB2cy5tYXAoICggdiApID0+IHtcclxuICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgdi5sZW5ndGggLyAyOyBpICsrICkge1xyXG4gICAgICAgIHZbIGkgKiAyICsgMCBdID0gICggdlsgaSAqIDIgKyAwIF0gLSB3aWQgLyAyICk7XHJcbiAgICAgICAgdlsgaSAqIDIgKyAxIF0gPSAtKCB2WyBpICogMiArIDEgXSArIGZvbnRTaXplICogMC4zNSApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXcgVmVydFBoYXNlciggdiApO1xyXG4gICAgfSApO1xyXG5cclxuICAgIGNhbGxiYWNrKCk7XHJcbiAgfSApO1xyXG5cclxuICBsZXQgdmJvUG9zID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBmYWxzZSApO1xyXG5cclxuICAvLyAtLS0tLS1cclxuXHJcbiAgZ2xDYXRQYXRoLmFkZCgge1xyXG4gICAgbG9maXBhdGg6IHtcclxuICAgICAgdmVydDogZ2xzbGlmeSggJy4vc2hhZGVyL3BhdGgtZGVmb3JtZXIudmVydCcgKSxcclxuICAgICAgZnJhZzogZ2xzbGlmeSggJy4vc2hhZGVyL3BvaW50LWNpcmNsZS5mcmFnJyApLFxyXG4gICAgICBmbG9hdDogdHJ1ZSxcclxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXHJcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXHJcbiAgICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xyXG4gICAgICAgIGxldCBtYXRNID0gTWF0aENhdC5tYXQ0SWRlbnRpdHkoKTtcclxuICAgICAgICBtYXRNID0gTWF0aENhdC5tYXQ0QXBwbHkoIE1hdGhDYXQubWF0NFNjYWxlWFlaKCAwLjQgKSwgbWF0TSApO1xyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm1NYXRyaXg0ZnYoICdtYXRNJywgbWF0TSApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0zZnYoICdjb2xvcicsIFsgMS4wLCAxLjAsIDEuMCBdICk7XHJcblxyXG4gICAgICAgIC8vIC0tLS0tLVxyXG5cclxuICAgICAgICBwaGFzZXJzLm1hcCggcGhhc2VyID0+IHtcclxuICAgICAgICAgIGxldCBiZWdpbiA9IHBhcmFtcy5iZWdpbiB8fCAwLjA7XHJcbiAgICAgICAgICBsZXQgc2VncyA9IE1hdGgubWF4KCAzLCBwYXJhbXMuc2VncyB8fCAzICk7XHJcbiAgICAgICAgICBsZXQgYXJyID0gcGhhc2VyLmxvZmkoIGJlZ2luLCBzZWdzICk7XHJcblxyXG4gICAgICAgICAgZ2xDYXQuc2V0VmVydGV4YnVmZmVyKCB2Ym9Qb3MsIGFyciwgZ2wuRFlOQU1JQ19EUkFXICk7XHJcblxyXG4gICAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1BvcywgMiApO1xyXG5cclxuICAgICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ2RlZm9ybUFtcCcsIGF1dG8oICdkZWZvcm1BbXAnICkgKTtcclxuICAgICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ2RlZm9ybUZyZXEnLCBhdXRvKCAnZGVmb3JtRnJlcScgKSApO1xyXG4gICAgICAgICAgZ2xDYXQudW5pZm9ybTFmKCAnZGVmb3JtT2Zmc2V0JywgYXV0byggJ2RlZm9ybU9mZnNldCcgKSApO1xyXG5cclxuICAgICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLkxJTkVfU1RSSVAsIDAsIGFyci5sZW5ndGggLyAyICk7XHJcbiAgICAgICAgICBnbC5kcmF3QXJyYXlzKCBnbC5QT0lOVFMsIDAsIGFyci5sZW5ndGggLyAyICk7XHJcbiAgICAgICAgfSApO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIH0gKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHBhdGhMb2ZpUGF0aDsiLCJpbXBvcnQgTWF0aENhdCBmcm9tICcuL2xpYnMvbWF0aGNhdCc7XHJcbmltcG9ydCB4b3JzaGlmdCBmcm9tICcuL2xpYnMveG9yc2hpZnQnO1xyXG5jb25zdCBnbHNsaWZ5ID0gcmVxdWlyZSggJ2dsc2xpZnknICk7XHJcblxyXG54b3JzaGlmdCggNDg3NzIzICk7XHJcblxyXG4vLyAtLS0tLS1cclxuXHJcbmxldCBwYXJ0aWNsZVBpeGVscyA9IDI7XHJcbmxldCBwYXJ0aWNsZXNTcXJ0ID0gODtcclxubGV0IHBhcnRpY2xlcyA9IHBhcnRpY2xlc1NxcnQgKiBwYXJ0aWNsZXNTcXJ0O1xyXG4vLyBsZXQgdmVydHNQZXJQYXJ0aWNsZSA9IGx1bmFMZW4gLyAzO1xyXG5cclxuLy8gLS0tLS0tXHJcblxyXG5sZXQgcGF0aFBpZWNlcyA9ICggZ2xDYXRQYXRoLCBhdXRvbWF0b24gKSA9PiB7XHJcbiAgbGV0IGdsQ2F0ID0gZ2xDYXRQYXRoLmdsQ2F0O1xyXG4gIGxldCBnbCA9IGdsQ2F0LmdsO1xyXG5cclxuICAvLyAtLS0tLS1cclxuXHJcbiAgbGV0IHZib1F1YWQgPSBnbENhdC5jcmVhdGVWZXJ0ZXhidWZmZXIoIFsgLTEsIC0xLCAxLCAtMSwgLTEsIDEsIDEsIDEgXSApO1xyXG5cclxuICBsZXQgdmJvUGFydGljbGVVViA9IGdsQ2F0LmNyZWF0ZVZlcnRleGJ1ZmZlciggKCAoKSA9PiB7XHJcbiAgICBsZXQgcmV0ID0gW107XHJcbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBwYXJ0aWNsZXM7IGkgKysgKSB7XHJcbiAgICAgIGxldCBpeCA9IGkgJSBwYXJ0aWNsZXNTcXJ0O1xyXG4gICAgICBsZXQgaXkgPSBNYXRoLmZsb29yKCBpIC8gcGFydGljbGVzU3FydCApO1xyXG4gICAgICBcclxuICAgICAgcmV0LnB1c2goIGl4ICogcGFydGljbGVQaXhlbHMgKTtcclxuICAgICAgcmV0LnB1c2goIGl5ICk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0O1xyXG4gIH0gKSgpICk7XHJcblxyXG4gIC8vIC0tLS0tLVxyXG5cclxuICBsZXQgdGV4dHVyZVJhbmRvbVNpemUgPSAzMjtcclxuICBsZXQgdGV4dHVyZVJhbmRvbVVwZGF0ZSA9ICggX3RleCApID0+IHtcclxuICAgIGdsQ2F0LnNldFRleHR1cmVGcm9tQXJyYXkoIF90ZXgsIHRleHR1cmVSYW5kb21TaXplLCB0ZXh0dXJlUmFuZG9tU2l6ZSwgKCAoKSA9PiB7XHJcbiAgICAgIGxldCBsZW4gPSB0ZXh0dXJlUmFuZG9tU2l6ZSAqIHRleHR1cmVSYW5kb21TaXplICogNDtcclxuICAgICAgbGV0IHJldCA9IG5ldyBVaW50OEFycmF5KCBsZW4gKTtcclxuICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgbGVuOyBpICsrICkge1xyXG4gICAgICAgIHJldFsgaSBdID0gTWF0aC5mbG9vciggeG9yc2hpZnQoKSAqIDI1Ni4wICk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJldDtcclxuICAgIH0gKSgpICk7XHJcbiAgfTtcclxuICBcclxuICBsZXQgdGV4dHVyZVJhbmRvbVN0YXRpYyA9IGdsQ2F0LmNyZWF0ZVRleHR1cmUoKTtcclxuICBnbENhdC50ZXh0dXJlV3JhcCggdGV4dHVyZVJhbmRvbVN0YXRpYywgZ2wuUkVQRUFUICk7XHJcbiAgdGV4dHVyZVJhbmRvbVVwZGF0ZSggdGV4dHVyZVJhbmRvbVN0YXRpYyApO1xyXG4gIFxyXG4gIGxldCB0ZXh0dXJlUmFuZG9tID0gZ2xDYXQuY3JlYXRlVGV4dHVyZSgpO1xyXG4gIGdsQ2F0LnRleHR1cmVXcmFwKCB0ZXh0dXJlUmFuZG9tLCBnbC5SRVBFQVQgKTtcclxuXHJcbiAgLy8gLS0tLS0tXHJcblxyXG4gIGdsQ2F0UGF0aC5hZGQoIHtcclxuICAgIHBpZWNlc0NvbXB1dGVSZXR1cm46IHtcclxuICAgICAgd2lkdGg6IHBhcnRpY2xlc1NxcnQgKiBwYXJ0aWNsZVBpeGVscyxcclxuICAgICAgaGVpZ2h0OiBwYXJ0aWNsZXNTcXJ0LFxyXG4gICAgICB2ZXJ0OiBnbHNsaWZ5KCAnLi9zaGFkZXIvcXVhZC52ZXJ0JyApLFxyXG4gICAgICBmcmFnOiBnbHNsaWZ5KCAnLi9zaGFkZXIvcmV0dXJuLmZyYWcnICksXHJcbiAgICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuWkVSTyBdLFxyXG4gICAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAwLjAgXSxcclxuICAgICAgZnJhbWVidWZmZXI6IHRydWUsXHJcbiAgICAgIGZsb2F0OiB0cnVlLFxyXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcclxuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlcjAnLCBnbENhdFBhdGguZmIoIFwicGllY2VzQ29tcHV0ZVwiICkudGV4dHVyZSwgMCApO1xyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgXHJcbiAgICBwaWVjZXNDb21wdXRlOiB7XHJcbiAgICAgIHdpZHRoOiBwYXJ0aWNsZXNTcXJ0ICogcGFydGljbGVQaXhlbHMsXHJcbiAgICAgIGhlaWdodDogcGFydGljbGVzU3FydCxcclxuICAgICAgdmVydDogZ2xzbGlmeSggJy4vc2hhZGVyL3F1YWQudmVydCcgKSxcclxuICAgICAgZnJhZzogZ2xzbGlmeSggJy4vc2hhZGVyL3BpZWNlcy1jb21wdXRlLmZyYWcnICksXHJcbiAgICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuWkVSTyBdLFxyXG4gICAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAwLjAgXSxcclxuICAgICAgZnJhbWVidWZmZXI6IHRydWUsXHJcbiAgICAgIGZsb2F0OiB0cnVlLFxyXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcclxuICAgICAgICBpZiAoIGF1dG9tYXRvbi5mcmFtZSA9PT0gMSApIHtcclxuICAgICAgICAgIHhvcnNoaWZ0KCA0ODc3MjMgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4dHVyZVJhbmRvbVVwZGF0ZSggdGV4dHVyZVJhbmRvbSApO1xyXG5cclxuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xyXG5cclxuICAgICAgICBnbENhdC51bmlmb3JtMWYoICdwYXJ0aWNsZXNTcXJ0JywgcGFydGljbGVzU3FydCApO1xyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ3BhcnRpY2xlUGl4ZWxzJywgcGFydGljbGVQaXhlbHMgKTtcclxuXHJcbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyUGNvbXB1dGUnLCBnbENhdFBhdGguZmIoIFwicGllY2VzQ29tcHV0ZVJldHVyblwiICkudGV4dHVyZSwgMCApO1xyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlclJhbmRvbScsIHRleHR1cmVSYW5kb20sIDEgKTtcclxuXHJcbiAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIFxyXG4gICAgcGllY2VzUmVuZGVyOiB7XHJcbiAgICAgIHZlcnQ6IGdsc2xpZnkoICcuL3NoYWRlci9waWVjZXMtcmVuZGVyLnZlcnQnICksXHJcbiAgICAgIGZyYWc6IGdsc2xpZnkoICcuL3NoYWRlci9waWVjZXMtcmVuZGVyLmZyYWcnICksXHJcbiAgICAgIGJsZW5kOiBbIGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSBdLFxyXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcclxuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdjb21wdXRlVVYnLCB2Ym9QYXJ0aWNsZVVWLCAyLCAxICk7XHJcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncmVjdCcsIHZib1F1YWQsIDIgKTtcclxuICBcclxuICAgICAgICBnbENhdC51bmlmb3JtMWYoICdwYXJ0aWNsZXNTcXJ0JywgcGFydGljbGVzU3FydCApO1xyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ3BhcnRpY2xlUGl4ZWxzJywgcGFydGljbGVQaXhlbHMgKTtcclxuXHJcbiAgICAgICAgZ2xDYXQudW5pZm9ybTJmdiggJ3Jlc29sdXRpb25QY29tcHV0ZScsIFsgcGFydGljbGVzU3FydCAqIHBhcnRpY2xlUGl4ZWxzLCBwYXJ0aWNsZXNTcXJ0IF0gKTtcclxuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXJQY29tcHV0ZScsIGdsQ2F0UGF0aC5mYiggXCJwaWVjZXNDb21wdXRlXCIgKS50ZXh0dXJlLCAxICk7XHJcbiAgXHJcbiAgICAgICAgbGV0IGV4dCA9IGdsQ2F0LmdldEV4dGVuc2lvbiggXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIgKTtcclxuICAgICAgICBleHQuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKCBnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCwgcGFydGljbGVzICk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgfSApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgcGF0aFBpZWNlczsiLCJpbXBvcnQgTWF0aENhdCBmcm9tICcuL2xpYnMvbWF0aGNhdCc7XHJcbmNvbnN0IGdsc2xpZnkgPSByZXF1aXJlKCAnZ2xzbGlmeScgKTtcclxuXHJcbi8vIC0tLS0tLVxyXG5cclxubGV0IHBhdGhQb3N0ZnggPSAoIGdsQ2F0UGF0aCwgd2lkdGgsIGhlaWdodCApID0+IHtcclxuICBsZXQgZ2xDYXQgPSBnbENhdFBhdGguZ2xDYXQ7XHJcbiAgbGV0IGdsID0gZ2xDYXQuZ2w7XHJcblxyXG4gIC8vIC0tLS0tLVxyXG5cclxuICBsZXQgdmJvUXVhZCA9IGdsQ2F0LmNyZWF0ZVZlcnRleGJ1ZmZlciggWyAtMSwgLTEsIDEsIC0xLCAtMSwgMSwgMSwgMSBdICk7XHJcblxyXG4gIC8vIC0tLS0tLVxyXG5cclxuICBnbENhdFBhdGguYWRkKCB7XHJcbiAgICBmeGFhOiB7XHJcbiAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgIHZlcnQ6IGdsc2xpZnkoICcuL3NoYWRlci9xdWFkLnZlcnQnICksXHJcbiAgICAgIGZyYWc6IGdsc2xpZnkoICcuL3NoYWRlci9meGFhLmZyYWcnICksXHJcbiAgICAgIGNsZWFyOiBbIDAuMCwgMC4wLCAwLjAsIDEuMCBdLFxyXG4gICAgICBmcmFtZWJ1ZmZlcjogdHJ1ZSxcclxuICAgICAgZmxvYXQ6IHRydWUsXHJcbiAgICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuWkVSTyBdLFxyXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcclxuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlcjAnLCBwYXJhbXMuaW5wdXQsIDAgKTtcclxuICAgICAgICBnbC5kcmF3QXJyYXlzKCBnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCApO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIFxyXG4gICAgcG9zdDoge1xyXG4gICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICB2ZXJ0OiBnbHNsaWZ5KCAnLi9zaGFkZXIvcXVhZC52ZXJ0JyApLFxyXG4gICAgICBmcmFnOiBnbHNsaWZ5KCAnLi9zaGFkZXIvcG9zdC5mcmFnJyApLFxyXG4gICAgICBibGVuZDogWyBnbC5PTkUsIGdsLlpFUk8gXSxcclxuICAgICAgY2xlYXI6IFsgMC4wLCAwLjAsIDAuMCwgMC4wIF0sXHJcbiAgICAgIGZyYW1lYnVmZmVyOiB0cnVlLFxyXG4gICAgICBmbG9hdDogdHJ1ZSxcclxuICAgICAgZnVuYzogKCBwYXRoLCBwYXJhbXMgKSA9PiB7XHJcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcclxuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXIwJywgcGFyYW1zLmlucHV0LCAwICk7XHJcbiAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICBcclxuICAgIGdsaXRjaDoge1xyXG4gICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICB2ZXJ0OiBnbHNsaWZ5KCAnLi9zaGFkZXIvcXVhZC52ZXJ0JyApLFxyXG4gICAgICBmcmFnOiBnbHNsaWZ5KCAnLi9zaGFkZXIvZ2xpdGNoLmZyYWcnICksXHJcbiAgICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuWkVSTyBdLFxyXG4gICAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAwLjAgXSxcclxuICAgICAgZnJhbWVidWZmZXI6IHRydWUsXHJcbiAgICAgIGZsb2F0OiB0cnVlLFxyXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcclxuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ2FtcCcsIHBhcmFtcy5hbXAgKTtcclxuICAgICAgICBnbENhdC51bmlmb3JtMWYoICdzZWVkJywgcGFyYW1zLnNlZWQgKTtcclxuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXIwJywgcGFyYW1zLmlucHV0LCAwICk7XHJcbiAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICB9ICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBwYXRoUG9zdGZ4OyIsImxldCByZU1vZGUgPSAvKFtNbUxsSGhWdlp6Q2NTc1FxVHRBYV0pLztcclxubGV0IHJlQ29tbWFuZCA9IC8oW01tTGxIaFZ2WnpDY1NzUXFUdEFhXXwtP1tcXGRdKyhcXC5cXGQrKT8pL2c7XHJcblxyXG5sZXQgc3ZnUGF0aCA9ICggX3N0ciwgX3BhcmFtcyApID0+IHtcclxuICBsZXQgc3RyID0gX3N0cjtcclxuICBsZXQgcGFyYW1zID0ge1xyXG4gICAgY3VydmVTZWdzOiA0XHJcbiAgfTtcclxuICBmb3IgKCBsZXQga2V5IGluIF9wYXJhbXMgKSB7XHJcbiAgICBwYXJhbXNbIGtleSBdID0gX3BhcmFtc1sga2V5IF07XHJcbiAgfVxyXG5cclxuICBsZXQgYXJyID0gc3RyLm1hdGNoKCByZUNvbW1hbmQgKTtcclxuXHJcbiAgbGV0IHBhdGhzID0gW107XHJcblxyXG4gIGxldCBoZWFkID0gMDtcclxuICBsZXQgeCA9IDA7XHJcbiAgbGV0IHkgPSAwO1xyXG4gIGxldCBjdXJQYXRoID0gbnVsbDtcclxuXHJcbiAgbGV0IHJlZnggPSAwO1xyXG4gIGxldCByZWZ5ID0gMDtcclxuICBsZXQgcHJldk1vZGUgPSAnJztcclxuICBsZXQgcHJldk1vZGVVID0gJyc7XHJcblxyXG4gIHdoaWxlICggaGVhZCA8IGFyci5sZW5ndGggKSB7XHJcbiAgICBsZXQgbW9kZSA9IGFyclsgaGVhZCBdO1xyXG4gICAgaWYgKCBtb2RlLm1hdGNoKCByZU1vZGUgKSApIHtcclxuICAgICAgaGVhZCArKztcclxuICAgIH0gZWxzZSB7IC8vIHN0cmVhayFcclxuICAgICAgbW9kZSA9IHByZXZNb2RlO1xyXG4gICAgfVxyXG4gICAgbGV0IG1vZGVVID0gbW9kZS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgbGV0IGFicyA9IG1vZGUgPT09IG1vZGVVO1xyXG5cclxuICAgIGxldCBheCA9IGFicyA/IDAgOiB4O1xyXG4gICAgbGV0IGF5ID0gYWJzID8gMCA6IHk7XHJcblxyXG4gICAgaWYgKCBtb2RlVSA9PT0gJ00nICkgeyAvLyBtb3ZlXHJcbiAgICAgIHggPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyAwIF0gKSArIGF4O1xyXG4gICAgICB5ID0gcGFyc2VGbG9hdCggYXJyWyBoZWFkICsgMSBdICkgKyBheTtcclxuXHJcbiAgICAgIGN1clBhdGggPSBbIHgsIHkgXTtcclxuICAgICAgcGF0aHMucHVzaCggY3VyUGF0aCApO1xyXG5cclxuICAgICAgaGVhZCArPSAyO1xyXG5cclxuICAgIH0gZWxzZSBpZiAoIG1vZGVVID09PSAnTCcgKSB7IC8vIGxpbmVcclxuICAgICAgeCA9IHBhcnNlRmxvYXQoIGFyclsgaGVhZCArIDAgXSApICsgYXg7XHJcbiAgICAgIHkgPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyAxIF0gKSArIGF5O1xyXG5cclxuICAgICAgY3VyUGF0aC5wdXNoKCB4LCB5ICk7XHJcblxyXG4gICAgICBoZWFkICs9IDI7XHJcblxyXG4gICAgfSBlbHNlIGlmICggbW9kZVUgPT09ICdIJyApIHsgLy8gaG9yaXpvbnRhbFxyXG4gICAgICB4ID0gcGFyc2VGbG9hdCggYXJyWyBoZWFkICsgMCBdICkgKyBheDtcclxuXHJcbiAgICAgIGN1clBhdGgucHVzaCggeCwgeSApO1xyXG5cclxuICAgICAgaGVhZCArPSAxO1xyXG5cclxuICAgIH0gZWxzZSBpZiAoIG1vZGVVID09PSAnVicgKSB7IC8vIHZlcnRpY2FsXHJcbiAgICAgIHkgPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyAwIF0gKSArIGF5O1xyXG5cclxuICAgICAgY3VyUGF0aC5wdXNoKCB4LCB5ICk7XHJcblxyXG4gICAgICBoZWFkICs9IDE7XHJcblxyXG4gICAgfSBlbHNlIGlmICggbW9kZVUgPT09ICdaJyApIHsgLy8gY2xvc2UgcGF0aFxyXG4gICAgICBjdXJQYXRoLnB1c2goIGN1clBhdGhbIDAgXSwgY3VyUGF0aFsgMSBdICk7XHJcblxyXG4gICAgfSBlbHNlIGlmICggbW9kZVUgPT09ICdDJyApIHsgLy8gY3ViaWMgYmV6aWVyXHJcbiAgICAgIGxldCB4MCA9IHg7XHJcbiAgICAgIGxldCB5MCA9IHk7XHJcbiAgICAgIGxldCB4MSA9IHBhcnNlRmxvYXQoIGFyclsgaGVhZCArIDAgXSApICsgYXg7XHJcbiAgICAgIGxldCB5MSA9IHBhcnNlRmxvYXQoIGFyclsgaGVhZCArIDEgXSApICsgYXk7XHJcbiAgICAgIGxldCB4MiA9IHBhcnNlRmxvYXQoIGFyclsgaGVhZCArIDIgXSApICsgYXg7XHJcbiAgICAgIGxldCB5MiA9IHBhcnNlRmxvYXQoIGFyclsgaGVhZCArIDMgXSApICsgYXk7XHJcbiAgICAgIHggPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyA0IF0gKSArIGF4O1xyXG4gICAgICB5ID0gcGFyc2VGbG9hdCggYXJyWyBoZWFkICsgNSBdICkgKyBheTtcclxuXHJcbiAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHBhcmFtcy5jdXJ2ZVNlZ3M7IGkgKysgKSB7XHJcbiAgICAgICAgbGV0IHQgPSAoIGkgKyAxICkgLyBwYXJhbXMuY3VydmVTZWdzO1xyXG4gICAgICAgIGxldCB1ID0gKCAxLjAgLSB0ICk7XHJcbiAgICAgICAgY3VyUGF0aC5wdXNoKFxyXG4gICAgICAgICAgdSAqIHUgKiB1ICogeDAgKyAzICogdCAqIHUgKiB1ICogeDEgKyAzICogdCAqIHQgKiB1ICogeDIgKyB0ICogdCAqIHQgKiB4LFxyXG4gICAgICAgICAgdSAqIHUgKiB1ICogeTAgKyAzICogdCAqIHUgKiB1ICogeTEgKyAzICogdCAqIHQgKiB1ICogeTIgKyB0ICogdCAqIHQgKiB5XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVmeCA9IDIgKiB4IC0geDI7XHJcbiAgICAgIHJlZnkgPSAyICogeSAtIHkyO1xyXG5cclxuICAgICAgaGVhZCArPSA2O1xyXG5cclxuICAgIH0gZWxzZSBpZiAoIG1vZGVVID09PSAnUycgKSB7IC8vIGN1YmljIGJlemllciwgd2l0aCByZWZsZWN0aW9uXHJcbiAgICAgIGxldCBwcmV2VmFsaWQgPSBwcmV2TW9kZVUgPT09ICdDJyB8fCBwcmV2TW9kZVUgPT09ICdTJztcclxuICAgICAgaWYgKCAhcHJldlZhbGlkICkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ3N2Z1BhdGg6IEludmFsaWQgUy9zIGNvbW1hbmQgdXNlIGRldGVjdGVkJyApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgeDAgPSB4O1xyXG4gICAgICBsZXQgeTAgPSB5O1xyXG4gICAgICBsZXQgeDEgPSBwcmV2VmFsaWQgPyByZWZ4IDogeDtcclxuICAgICAgbGV0IHkxID0gcHJldlZhbGlkID8gcmVmeSA6IHk7XHJcbiAgICAgIGxldCB4MiA9IHBhcnNlRmxvYXQoIGFyclsgaGVhZCArIDAgXSApICsgYXg7XHJcbiAgICAgIGxldCB5MiA9IHBhcnNlRmxvYXQoIGFyclsgaGVhZCArIDEgXSApICsgYXk7XHJcbiAgICAgIHggPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyAyIF0gKSArIGF4O1xyXG4gICAgICB5ID0gcGFyc2VGbG9hdCggYXJyWyBoZWFkICsgMyBdICkgKyBheTtcclxuXHJcbiAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHBhcmFtcy5jdXJ2ZVNlZ3M7IGkgKysgKSB7XHJcbiAgICAgICAgbGV0IHQgPSAoIGkgKyAxICkgLyBwYXJhbXMuY3VydmVTZWdzO1xyXG4gICAgICAgIGxldCB1ID0gKCAxLjAgLSB0ICk7XHJcbiAgICAgICAgY3VyUGF0aC5wdXNoKFxyXG4gICAgICAgICAgdSAqIHUgKiB1ICogeDAgKyAzICogdCAqIHUgKiB1ICogeDEgKyAzICogdCAqIHQgKiB1ICogeDIgKyB0ICogdCAqIHQgKiB4LFxyXG4gICAgICAgICAgdSAqIHUgKiB1ICogeTAgKyAzICogdCAqIHUgKiB1ICogeTEgKyAzICogdCAqIHQgKiB1ICogeTIgKyB0ICogdCAqIHQgKiB5XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVmeCA9IDIgKiB4IC0geDI7XHJcbiAgICAgIHJlZnkgPSAyICogeSAtIHkyO1xyXG5cclxuICAgICAgaGVhZCArPSA0O1xyXG5cclxuICAgIH0gZWxzZSBpZiAoIG1vZGVVID09PSAnUScgKSB7IC8vIHF1YWQgYmV6aWVyXHJcbiAgICAgIGxldCB4MCA9IHg7XHJcbiAgICAgIGxldCB5MCA9IHk7XHJcbiAgICAgIGxldCB4MSA9IHBhcnNlRmxvYXQoIGFyclsgaGVhZCArIDAgXSApICsgYXg7XHJcbiAgICAgIGxldCB5MSA9IHBhcnNlRmxvYXQoIGFyclsgaGVhZCArIDEgXSApICsgYXk7XHJcbiAgICAgIHggPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyAyIF0gKSArIGF4O1xyXG4gICAgICB5ID0gcGFyc2VGbG9hdCggYXJyWyBoZWFkICsgMyBdICkgKyBheTtcclxuXHJcbiAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHBhcmFtcy5jdXJ2ZVNlZ3M7IGkgKysgKSB7XHJcbiAgICAgICAgbGV0IHQgPSAoIGkgKyAxICkgLyBwYXJhbXMuY3VydmVTZWdzO1xyXG4gICAgICAgIGxldCB1ID0gKCAxLjAgLSB0ICk7XHJcbiAgICAgICAgY3VyUGF0aC5wdXNoKFxyXG4gICAgICAgICAgdSAqIHUgKiB4MCArIDIgKiB0ICogdSAqIHgxICsgdCAqIHQgKiB4LFxyXG4gICAgICAgICAgdSAqIHUgKiB5MCArIDIgKiB0ICogdSAqIHkxICsgdCAqIHQgKiB5XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVmeCA9IDIgKiB4IC0geDE7XHJcbiAgICAgIHJlZnkgPSAyICogeSAtIHkxO1xyXG5cclxuICAgICAgaGVhZCArPSA0O1xyXG5cclxuICAgIH0gZWxzZSBpZiAoIG1vZGVVID09PSAnVCcgKSB7IC8vIHF1YWQgYmV6aWVyLCB3aXRoIHJlZmxlY3Rpb25cclxuICAgICAgbGV0IHByZXZWYWxpZCA9IHByZXZNb2RlVSA9PT0gJ1EnIHx8IHByZXZNb2RlVSA9PT0gJ1QnO1xyXG4gICAgICBpZiAoICFwcmV2VmFsaWQgKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCAnc3ZnUGF0aDogSW52YWxpZCBUL3QgY29tbWFuZCB1c2UgZGV0ZWN0ZWQnICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGxldCB4MCA9IHg7XHJcbiAgICAgIGxldCB5MCA9IHk7XHJcbiAgICAgIGxldCB4MSA9IHByZXZWYWxpZCA/IHJlZnggOiB4O1xyXG4gICAgICBsZXQgeTEgPSBwcmV2VmFsaWQgPyByZWZ5IDogeTtcclxuICAgICAgeCA9IHBhcnNlRmxvYXQoIGFyclsgaGVhZCArIDAgXSApICsgYXg7XHJcbiAgICAgIHkgPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyAxIF0gKSArIGF5O1xyXG5cclxuICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgcGFyYW1zLmN1cnZlU2VnczsgaSArKyApIHtcclxuICAgICAgICBsZXQgdCA9ICggaSArIDEgKSAvIHBhcmFtcy5jdXJ2ZVNlZ3M7XHJcbiAgICAgICAgbGV0IHUgPSAoIDEuMCAtIHQgKTtcclxuICAgICAgICBjdXJQYXRoLnB1c2goXHJcbiAgICAgICAgICB1ICogdSAqIHgwICsgMiAqIHQgKiB1ICogeDEgKyB0ICogdCAqIHgsXHJcbiAgICAgICAgICB1ICogdSAqIHkwICsgMiAqIHQgKiB1ICogeTEgKyB0ICogdCAqIHlcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZWZ4ID0gMiAqIHggLSB4MTtcclxuICAgICAgcmVmeSA9IDIgKiB5IC0geTE7XHJcblxyXG4gICAgICBoZWFkICs9IDI7XHJcblxyXG4gICAgfSBlbHNlIGlmICggbW9kZVUgPT09ICdBJyApIHsgLy8gYXJjXHJcbiAgICAgIC8vIFRISVMuIElTLiBIRUxMLlxyXG4gICAgICAvLyByZWY6IGh0dHBzOi8vdHJpcGxlLXVuZGVyc2NvcmUuZ2l0aHViLmlvL1NWRzExL2ltcGxub3RlLmh0bWwjUGF0aEVsZW1lbnRJbXBsZW1lbnRhdGlvbk5vdGVzXHJcblxyXG4gICAgICBsZXQgeDAgPSB4O1xyXG4gICAgICBsZXQgeTAgPSB5O1xyXG4gICAgICBsZXQgcnggPSBNYXRoLmFicyggcGFyc2VGbG9hdCggYXJyWyBoZWFkICsgMCBdICkgKTtcclxuICAgICAgbGV0IHJ5ID0gTWF0aC5hYnMoIHBhcnNlRmxvYXQoIGFyclsgaGVhZCArIDEgXSApICk7XHJcbiAgICAgIGxldCByb3QgPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyAyIF0gKTtcclxuICAgICAgbGV0IGxhcmdlID0gYXJyWyBoZWFkICsgMyBdICE9PSBcIjBcIjtcclxuICAgICAgbGV0IHN3ZWVwID0gYXJyWyBoZWFkICsgNCBdICE9PSBcIjBcIjtcclxuICAgICAgeCA9IHBhcnNlRmxvYXQoIGFyclsgaGVhZCArIDUgXSApICsgYXg7XHJcbiAgICAgIHkgPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyA2IF0gKSArIGF5O1xyXG5cclxuICAgICAgaWYgKCB4MCA9PT0geCAmJiB5MCA9PT0geSApIHsgLy8gZW5kcG9pbnRzIGFyZSBzYW1lLCB3aWxsIGJlIG9taXR0ZWRcclxuICAgICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICAgIH0gZWxzZSBpZiAoIHJ4ID09PSAwIHx8IHJ5ID09PSAwICkgeyAvLyByYWRpdXMgaXMgMCwgd2lsbCBiZSBsaW5lXHJcbiAgICAgICAgY3VyUGF0aC5wdXNoKCB4LCB5ICk7XHJcbiAgICAgIH0gZWxzZSB7IC8vIGhlbGxcclxuICAgICAgICBsZXQgY29zciA9IE1hdGguY29zKCByb3QgLyAxODAgKiBNYXRoLlBJICk7XHJcbiAgICAgICAgbGV0IHNpbnIgPSBNYXRoLnNpbiggcm90IC8gMTgwICogTWF0aC5QSSApO1xyXG5cclxuICAgICAgICBsZXQgeDBwID0gY29zciAqICggeDAgLSB4ICkgLyAyICsgc2luciAqICggeTAgLSB5ICkgLyAyO1xyXG4gICAgICAgIGxldCB5MHAgPSAtc2luciAqICggeDAgLSB4ICkgLyAyICsgY29zciAqICggeTAgLSB5ICkgLyAyO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCB4MHAsIHkwcCApO1xyXG5cclxuICAgICAgICBsZXQgbGFtYmRhID0gKCB4MHAgKiB4MHAgKSAvICggcnggKiByeCApICsgKCB5MHAgKiB5MHAgKSAvICggcnkgKiByeSApO1xyXG4gICAgICAgIGlmICggMS4wIDwgbGFtYmRhICkge1xyXG4gICAgICAgICAgbGV0IGsgPSBNYXRoLnNxcnQoIGxhbWJkYSApO1xyXG4gICAgICAgICAgcnggKj0gcng7XHJcbiAgICAgICAgICByeSAqPSByeTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCB0MSA9IHJ4ICogcnggKiB5MHAgKiB5MHA7XHJcbiAgICAgICAgbGV0IHQyID0gcnkgKiByeSAqIHgwcCAqIHgwcDtcclxuICAgICAgICBsZXQgY3RwID0gTWF0aC5zcXJ0KFxyXG4gICAgICAgICAgKCByeCAqIHJ4ICogcnkgKiByeSAtIHQxIC0gdDIgKVxyXG4gICAgICAgICAgLyAoIHQxICsgdDIgKVxyXG4gICAgICAgICkgKiAoIGxhcmdlID09PSBzd2VlcCA/IC0xIDogMSApO1xyXG4gICAgICAgIGxldCBjeHAgPSBjdHAgKiByeCAqIHkwcCAvIHJ5O1xyXG4gICAgICAgIGxldCBjeXAgPSAtY3RwICogcnkgKiB4MHAgLyByeDtcclxuICAgICAgICBjb25zb2xlLmxvZyggY3hwLCBjeXAgKTtcclxuXHJcbiAgICAgICAgbGV0IGN4ID0gY29zciAqIGN4cCAtIHNpbnIgKiBjeXAgKyAoIHgwICsgeCApIC8gMjtcclxuICAgICAgICBsZXQgY3kgPSBzaW5yICogY3hwICsgY29zciAqIGN5cCArICggeTAgKyB5ICkgLyAyO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCBjeCwgY3kgKTtcclxuXHJcbiAgICAgICAgbGV0IHRoZXRhMCA9IE1hdGguYXRhbjIoICggeTBwIC0gY3lwICkgLyByeSwgKCB4MHAgLSBjeHAgKSAvIHJ4ICk7XHJcbiAgICAgICAgbGV0IHRoZXRhMSA9IE1hdGguYXRhbjIoICggLXkwcCAtIGN5cCApIC8gcnksICggLXgwcCAtIGN4cCApIC8gcnggKTtcclxuICAgICAgICBpZiAoIHRoZXRhMSA8IHRoZXRhMCAmJiBzd2VlcCApIHtcclxuICAgICAgICAgIHRoZXRhMSArPSBNYXRoLlBJICogMi4wO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIHRoZXRhMCA8IHRoZXRhMSAmJiAhc3dlZXAgKSB7XHJcbiAgICAgICAgICB0aGV0YTEgLT0gTWF0aC5QSSAqIDIuMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGR0aGV0YSA9IHRoZXRhMSAtIHRoZXRhMDtcclxuICAgICAgICBjb25zb2xlLmxvZyggdGhldGEwLCB0aGV0YTEgKTtcclxuXHJcbiAgICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgcGFyYW1zLmN1cnZlU2VnczsgaSArKyApIHtcclxuICAgICAgICAgIGxldCB0ID0gKCBpICsgMSApIC8gcGFyYW1zLmN1cnZlU2VncztcclxuICAgICAgICAgIGxldCB0aGV0YSA9IHRoZXRhMCArIGR0aGV0YSAqIHQ7XHJcblxyXG4gICAgICAgICAgbGV0IHhmID0gcnggKiBNYXRoLmNvcyggdGhldGEgKTtcclxuICAgICAgICAgIGxldCB5ZiA9IHJ5ICogTWF0aC5zaW4oIHRoZXRhICk7XHJcblxyXG4gICAgICAgICAgY3VyUGF0aC5wdXNoKFxyXG4gICAgICAgICAgICBjeCArIGNvc3IgKiB4ZiAtIHNpbnIgKiB5ZixcclxuICAgICAgICAgICAgY3kgKyBzaW5yICogeGYgKyBjb3NyICogeWZcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBoZWFkICs9IDc7XHJcblxyXG4gICAgfSBlbHNlIHsgLy8gaW52YWxpZFxyXG4gICAgICBjb25zb2xlLndhcm4oICdzdmdQYXRoOiBJbnZhbGlkIGNvbW1hbmQ6ICcgKyBtb2RlICk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByZXZNb2RlID0gbW9kZTtcclxuICAgIHByZXZNb2RlVSA9IG1vZGVVO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHBhdGhzO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgc3ZnUGF0aDsiLCJsZXQgbGVycCA9ICggYSwgYiwgeCApID0+IGEgKyAoIGIgLSBhICkgKiB4O1xubGV0IGRpc3QgPSAoIGF4LCBheSwgYngsIGJ5ICkgPT4gTWF0aC5zcXJ0KCAoIGJ4IC0gYXggKSAqICggYnggLSBheCApICsgKCBieSAtIGF5ICkgKiAoIGJ5IC0gYXkgKSApO1xuXG5sZXQgVmVydFBoYXNlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoIF92ZXJ0ICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG5cbiAgICBpdC52ZXJ0ID0gX3ZlcnQuY29uY2F0KCk7XG4gICAgaXQudG90YWxMZW5ndGggPSAwLjA7XG4gICAgaXQubGVuZ3RoTWFwID0gW107XG5cbiAgICBpdC5jYWxjTGVuZ3RoKCk7XG4gIH1cblxuICBjYWxjTGVuZ3RoKCkge1xuICAgIGxldCBpdCA9IHRoaXM7XG5cbiAgICBpdC50b3RhbExlbmd0aCA9IDAuMDtcbiAgICBpdC5sZW5ndGhNYXAgPSBbXTtcblxuICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGl0LnZlcnQubGVuZ3RoIC8gMiAtIDE7IGkgKysgKSB7XG4gICAgICBsZXQgbCA9IGRpc3QoXG4gICAgICAgIGl0LnZlcnRbIGkgKiAyICsgMCBdLFxuICAgICAgICBpdC52ZXJ0WyBpICogMiArIDEgXSxcbiAgICAgICAgaXQudmVydFsgaSAqIDIgKyAyIF0sXG4gICAgICAgIGl0LnZlcnRbIGkgKiAyICsgMyBdXG4gICAgICApO1xuICAgICAgaXQudG90YWxMZW5ndGggKz0gbDtcbiAgICAgIGl0Lmxlbmd0aE1hcC5wdXNoKCBsICk7XG4gICAgfVxuXG4gICAgbGV0IGwgPSBkaXN0KFxuICAgICAgaXQudmVydFsgaXQudmVydC5sZW5ndGggLSAyIF0sXG4gICAgICBpdC52ZXJ0WyBpdC52ZXJ0Lmxlbmd0aCAtIDEgXSxcbiAgICAgIGl0LnZlcnRbIDAgXSxcbiAgICAgIGl0LnZlcnRbIDEgXVxuICAgICk7XG4gICAgaXQudG90YWxMZW5ndGggKz0gbDtcbiAgICBpdC5sZW5ndGhNYXAucHVzaCggbCApO1xuICB9XG5cbiAgZ2V0UGhhc2VJbmZvKCBfcGhhc2UgKSB7XG4gICAgbGV0IGl0ID0gdGhpcztcblxuICAgIGxldCBwaGFzZSA9IF9waGFzZSAlIDEuMDtcbiAgICBsZXQgbGVuID0gcGhhc2UgKiBpdC50b3RhbExlbmd0aDtcblxuICAgIGxldCBpID0gMDtcbiAgICBsZXQgcHN1bSA9IDAuMDtcbiAgICBsZXQgc3VtID0gMC4wO1xuICAgIHdoaWxlICggc3VtIDw9IGxlbiApIHtcbiAgICAgIHBzdW0gPSBzdW07XG4gICAgICBzdW0gKz0gaXQubGVuZ3RoTWFwWyBpIF07XG4gICAgICBpICsrO1xuICAgIH1cblxuICAgIGxldCBwID0gKCBsZW4gLSBwc3VtICkgLyAoIHN1bSAtIHBzdW0gKTtcbiAgICBsZXQgeCA9IGxlcnAoXG4gICAgICBpdC52ZXJ0WyBpICogMiAtIDIgXSxcbiAgICAgIGl0LnZlcnRbICggaSAqIDIgKyAwICkgJSBpdC52ZXJ0Lmxlbmd0aCBdLFxuICAgICAgcFxuICAgICk7XG4gICAgbGV0IHkgPSBsZXJwKFxuICAgICAgaXQudmVydFsgaSAqIDIgLSAxIF0sXG4gICAgICBpdC52ZXJ0WyAoIGkgKiAyICsgMSApICUgaXQudmVydC5sZW5ndGggXSwgXG4gICAgICBwXG4gICAgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBwaGFzZTogcGhhc2UsXG4gICAgICBsZW5ndGg6IGxlbixcbiAgICAgIGk6IGksXG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIHA6IHBcbiAgICB9O1xuICB9XG5cbiAgZG8oIF9iZWdpbiwgX3BoYXNlICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG5cbiAgICBsZXQgYmVnaW4gPSBpdC5nZXRQaGFzZUluZm8oIF9iZWdpbiApO1xuICAgIGxldCBlbmQgPSBpdC5nZXRQaGFzZUluZm8oIF9iZWdpbiArIF9waGFzZSApO1xuXG4gICAgbGV0IHJldCA9IFsgYmVnaW4ueCwgYmVnaW4ueSBdO1xuICAgIGlmICggYmVnaW4ucGhhc2UgPD0gZW5kLnBoYXNlICkge1xuICAgICAgcmV0ID0gcmV0LmNvbmNhdCggaXQudmVydC5zbGljZSggYmVnaW4uaSAqIDIsIGVuZC5pICogMiApICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldCA9IHJldC5jb25jYXQoIGl0LnZlcnQuc2xpY2UoIGJlZ2luLmkgKiAyICkgKTtcbiAgICAgIHJldCA9IHJldC5jb25jYXQoIGl0LnZlcnQuc2xpY2UoIDAsIGVuZC5pICogMiApICk7XG4gICAgfVxuICAgIHJldC5wdXNoKCBlbmQueCwgZW5kLnkgKTtcblxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBsb2ZpKCBfYmVnaW4sIF9zZWdzICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG5cbiAgICBsZXQgc2VncyA9IF9zZWdzO1xuICAgIGlmICggc2VncyA8IDEgKSB7IHRocm93ICdWZXJ0UGhhc2VyLmxvZmk6IHNlZ3MgPCAxLCBpdFxcJ3MgaW52YWxpZCc7IH1cblxuICAgIGxldCBiZWdpbiA9IGl0LmdldFBoYXNlSW5mbyggX2JlZ2luICk7XG5cbiAgICBsZXQgcmV0ID0gWyBiZWdpbi54LCBiZWdpbi55IF07XG4gICAgZm9yICggbGV0IGkgPSAxOyBpIDwgTWF0aC5mbG9vciggc2VncyArIDEgKTsgaSArKyApIHtcbiAgICAgIGxldCBwID0gX2JlZ2luICsgaSAvIHNlZ3M7XG4gICAgICBsZXQgc2VnID0gaXQuZ2V0UGhhc2VJbmZvKCBwICk7XG4gICAgICByZXQucHVzaCggc2VnLngsIHNlZy55ICk7XG4gICAgfVxuICAgIHJldC5wdXNoKCBiZWdpbi54LCBiZWdpbi55ICk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBWZXJ0UGhhc2VyOyJdfQ==
