(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/node_modules/base64-js/index.js":[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/node_modules/browser-resolve/empty.js":[function(require,module,exports){

},{}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/node_modules/buffer/index.js":[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/node_modules/base64-js/index.js","ieee754":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/node_modules/ieee754/index.js","isarray":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/node_modules/buffer/node_modules/isarray/index.js"}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/node_modules/buffer/node_modules/isarray/index.js":[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/node_modules/ieee754/index.js":[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/node_modules/opentype.js/dist/opentype.js":[function(require,module,exports){
(function (Buffer){
/**
 * https://opentype.js.org v0.8.0 | (c) Frederik De Bleser and other contributors | MIT License | Uses tiny-inflate by Devon Govett
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.opentype = global.opentype || {})));
}(this, (function (exports) { 'use strict';

var TINF_OK = 0;
var TINF_DATA_ERROR = -3;

function Tree() {
  this.table = new Uint16Array(16);   /* table of code length counts */
  this.trans = new Uint16Array(288);  /* code -> symbol translation table */
}

function Data(source, dest) {
  this.source = source;
  this.sourceIndex = 0;
  this.tag = 0;
  this.bitcount = 0;
  
  this.dest = dest;
  this.destLen = 0;
  
  this.ltree = new Tree();  /* dynamic length/symbol tree */
  this.dtree = new Tree();  /* dynamic distance tree */
}

/* --------------------------------------------------- *
 * -- uninitialized global data (static structures) -- *
 * --------------------------------------------------- */

var sltree = new Tree();
var sdtree = new Tree();

/* extra bits and base tables for length codes */
var length_bits = new Uint8Array(30);
var length_base = new Uint16Array(30);

/* extra bits and base tables for distance codes */
var dist_bits = new Uint8Array(30);
var dist_base = new Uint16Array(30);

/* special ordering of code length codes */
var clcidx = new Uint8Array([
  16, 17, 18, 0, 8, 7, 9, 6,
  10, 5, 11, 4, 12, 3, 13, 2,
  14, 1, 15
]);

/* used by tinf_decode_trees, avoids allocations every call */
var code_tree = new Tree();
var lengths = new Uint8Array(288 + 32);

/* ----------------------- *
 * -- utility functions -- *
 * ----------------------- */

/* build extra bits and base tables */
function tinf_build_bits_base(bits, base, delta, first) {
  var i, sum;

  /* build bits table */
  for (i = 0; i < delta; ++i) { bits[i] = 0; }
  for (i = 0; i < 30 - delta; ++i) { bits[i + delta] = i / delta | 0; }

  /* build base table */
  for (sum = first, i = 0; i < 30; ++i) {
    base[i] = sum;
    sum += 1 << bits[i];
  }
}

/* build the fixed huffman trees */
function tinf_build_fixed_trees(lt, dt) {
  var i;

  /* build fixed length tree */
  for (i = 0; i < 7; ++i) { lt.table[i] = 0; }

  lt.table[7] = 24;
  lt.table[8] = 152;
  lt.table[9] = 112;

  for (i = 0; i < 24; ++i) { lt.trans[i] = 256 + i; }
  for (i = 0; i < 144; ++i) { lt.trans[24 + i] = i; }
  for (i = 0; i < 8; ++i) { lt.trans[24 + 144 + i] = 280 + i; }
  for (i = 0; i < 112; ++i) { lt.trans[24 + 144 + 8 + i] = 144 + i; }

  /* build fixed distance tree */
  for (i = 0; i < 5; ++i) { dt.table[i] = 0; }

  dt.table[5] = 32;

  for (i = 0; i < 32; ++i) { dt.trans[i] = i; }
}

/* given an array of code lengths, build a tree */
var offs = new Uint16Array(16);

function tinf_build_tree(t, lengths, off, num) {
  var i, sum;

  /* clear code length count table */
  for (i = 0; i < 16; ++i) { t.table[i] = 0; }

  /* scan symbol lengths, and sum code length counts */
  for (i = 0; i < num; ++i) { t.table[lengths[off + i]]++; }

  t.table[0] = 0;

  /* compute offset table for distribution sort */
  for (sum = 0, i = 0; i < 16; ++i) {
    offs[i] = sum;
    sum += t.table[i];
  }

  /* create code->symbol translation table (symbols sorted by code) */
  for (i = 0; i < num; ++i) {
    if (lengths[off + i]) { t.trans[offs[lengths[off + i]]++] = i; }
  }
}

/* ---------------------- *
 * -- decode functions -- *
 * ---------------------- */

/* get one bit from source stream */
function tinf_getbit(d) {
  /* check if tag is empty */
  if (!d.bitcount--) {
    /* load next tag */
    d.tag = d.source[d.sourceIndex++];
    d.bitcount = 7;
  }

  /* shift bit out of tag */
  var bit = d.tag & 1;
  d.tag >>>= 1;

  return bit;
}

/* read a num bit value from a stream and add base */
function tinf_read_bits(d, num, base) {
  if (!num)
    { return base; }

  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }

  var val = d.tag & (0xffff >>> (16 - num));
  d.tag >>>= num;
  d.bitcount -= num;
  return val + base;
}

/* given a data stream and a tree, decode a symbol */
function tinf_decode_symbol(d, t) {
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  
  var sum = 0, cur = 0, len = 0;
  var tag = d.tag;

  /* get more bits while code value is above sum */
  do {
    cur = 2 * cur + (tag & 1);
    tag >>>= 1;
    ++len;

    sum += t.table[len];
    cur -= t.table[len];
  } while (cur >= 0);
  
  d.tag = tag;
  d.bitcount -= len;

  return t.trans[sum + cur];
}

/* given a data stream, decode dynamic trees from it */
function tinf_decode_trees(d, lt, dt) {
  var hlit, hdist, hclen;
  var i, num, length;

  /* get 5 bits HLIT (257-286) */
  hlit = tinf_read_bits(d, 5, 257);

  /* get 5 bits HDIST (1-32) */
  hdist = tinf_read_bits(d, 5, 1);

  /* get 4 bits HCLEN (4-19) */
  hclen = tinf_read_bits(d, 4, 4);

  for (i = 0; i < 19; ++i) { lengths[i] = 0; }

  /* read code lengths for code length alphabet */
  for (i = 0; i < hclen; ++i) {
    /* get 3 bits code length (0-7) */
    var clen = tinf_read_bits(d, 3, 0);
    lengths[clcidx[i]] = clen;
  }

  /* build code length tree */
  tinf_build_tree(code_tree, lengths, 0, 19);

  /* decode code lengths for the dynamic trees */
  for (num = 0; num < hlit + hdist;) {
    var sym = tinf_decode_symbol(d, code_tree);

    switch (sym) {
      case 16:
        /* copy previous code length 3-6 times (read 2 bits) */
        var prev = lengths[num - 1];
        for (length = tinf_read_bits(d, 2, 3); length; --length) {
          lengths[num++] = prev;
        }
        break;
      case 17:
        /* repeat code length 0 for 3-10 times (read 3 bits) */
        for (length = tinf_read_bits(d, 3, 3); length; --length) {
          lengths[num++] = 0;
        }
        break;
      case 18:
        /* repeat code length 0 for 11-138 times (read 7 bits) */
        for (length = tinf_read_bits(d, 7, 11); length; --length) {
          lengths[num++] = 0;
        }
        break;
      default:
        /* values 0-15 represent the actual code lengths */
        lengths[num++] = sym;
        break;
    }
  }

  /* build dynamic trees */
  tinf_build_tree(lt, lengths, 0, hlit);
  tinf_build_tree(dt, lengths, hlit, hdist);
}

/* ----------------------------- *
 * -- block inflate functions -- *
 * ----------------------------- */

/* given a stream and two trees, inflate a block of data */
function tinf_inflate_block_data(d, lt, dt) {
  while (1) {
    var sym = tinf_decode_symbol(d, lt);

    /* check for end of block */
    if (sym === 256) {
      return TINF_OK;
    }

    if (sym < 256) {
      d.dest[d.destLen++] = sym;
    } else {
      var length, dist, offs;
      var i;

      sym -= 257;

      /* possibly get more bits from length code */
      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);

      dist = tinf_decode_symbol(d, dt);

      /* possibly get more bits from distance code */
      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);

      /* copy match */
      for (i = offs; i < offs + length; ++i) {
        d.dest[d.destLen++] = d.dest[i];
      }
    }
  }
}

/* inflate an uncompressed block of data */
function tinf_inflate_uncompressed_block(d) {
  var length, invlength;
  var i;
  
  /* unread from bitbuffer */
  while (d.bitcount > 8) {
    d.sourceIndex--;
    d.bitcount -= 8;
  }

  /* get length */
  length = d.source[d.sourceIndex + 1];
  length = 256 * length + d.source[d.sourceIndex];

  /* get one's complement of length */
  invlength = d.source[d.sourceIndex + 3];
  invlength = 256 * invlength + d.source[d.sourceIndex + 2];

  /* check length */
  if (length !== (~invlength & 0x0000ffff))
    { return TINF_DATA_ERROR; }

  d.sourceIndex += 4;

  /* copy block */
  for (i = length; i; --i)
    { d.dest[d.destLen++] = d.source[d.sourceIndex++]; }

  /* make sure we start next block on a byte boundary */
  d.bitcount = 0;

  return TINF_OK;
}

/* inflate stream from source to dest */
function tinf_uncompress(source, dest) {
  var d = new Data(source, dest);
  var bfinal, btype, res;

  do {
    /* read final block flag */
    bfinal = tinf_getbit(d);

    /* read block type (2 bits) */
    btype = tinf_read_bits(d, 2, 0);

    /* decompress block */
    switch (btype) {
      case 0:
        /* decompress uncompressed block */
        res = tinf_inflate_uncompressed_block(d);
        break;
      case 1:
        /* decompress block with fixed huffman trees */
        res = tinf_inflate_block_data(d, sltree, sdtree);
        break;
      case 2:
        /* decompress block with dynamic huffman trees */
        tinf_decode_trees(d, d.ltree, d.dtree);
        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
        break;
      default:
        res = TINF_DATA_ERROR;
    }

    if (res !== TINF_OK)
      { throw new Error('Data error'); }

  } while (!bfinal);

  if (d.destLen < d.dest.length) {
    if (typeof d.dest.slice === 'function')
      { return d.dest.slice(0, d.destLen); }
    else
      { return d.dest.subarray(0, d.destLen); }
  }
  
  return d.dest;
}

/* -------------------- *
 * -- initialization -- *
 * -------------------- */

/* build fixed huffman trees */
tinf_build_fixed_trees(sltree, sdtree);

/* build extra bits and base tables */
tinf_build_bits_base(length_bits, length_base, 4, 3);
tinf_build_bits_base(dist_bits, dist_base, 2, 1);

/* fix a special case */
length_bits[28] = 0;
length_base[28] = 258;

var tinyInflate = tinf_uncompress;

// The Bounding Box object

function derive(v0, v1, v2, v3, t) {
    return Math.pow(1 - t, 3) * v0 +
        3 * Math.pow(1 - t, 2) * t * v1 +
        3 * (1 - t) * Math.pow(t, 2) * v2 +
        Math.pow(t, 3) * v3;
}
/**
 * A bounding box is an enclosing box that describes the smallest measure within which all the points lie.
 * It is used to calculate the bounding box of a glyph or text path.
 *
 * On initialization, x1/y1/x2/y2 will be NaN. Check if the bounding box is empty using `isEmpty()`.
 *
 * @exports opentype.BoundingBox
 * @class
 * @constructor
 */
function BoundingBox() {
    this.x1 = Number.NaN;
    this.y1 = Number.NaN;
    this.x2 = Number.NaN;
    this.y2 = Number.NaN;
}

/**
 * Returns true if the bounding box is empty, that is, no points have been added to the box yet.
 */
BoundingBox.prototype.isEmpty = function() {
    return isNaN(this.x1) || isNaN(this.y1) || isNaN(this.x2) || isNaN(this.y2);
};

/**
 * Add the point to the bounding box.
 * The x1/y1/x2/y2 coordinates of the bounding box will now encompass the given point.
 * @param {number} x - The X coordinate of the point.
 * @param {number} y - The Y coordinate of the point.
 */
BoundingBox.prototype.addPoint = function(x, y) {
    if (typeof x === 'number') {
        if (isNaN(this.x1) || isNaN(this.x2)) {
            this.x1 = x;
            this.x2 = x;
        }
        if (x < this.x1) {
            this.x1 = x;
        }
        if (x > this.x2) {
            this.x2 = x;
        }
    }
    if (typeof y === 'number') {
        if (isNaN(this.y1) || isNaN(this.y2)) {
            this.y1 = y;
            this.y2 = y;
        }
        if (y < this.y1) {
            this.y1 = y;
        }
        if (y > this.y2) {
            this.y2 = y;
        }
    }
};

/**
 * Add a X coordinate to the bounding box.
 * This extends the bounding box to include the X coordinate.
 * This function is used internally inside of addBezier.
 * @param {number} x - The X coordinate of the point.
 */
BoundingBox.prototype.addX = function(x) {
    this.addPoint(x, null);
};

/**
 * Add a Y coordinate to the bounding box.
 * This extends the bounding box to include the Y coordinate.
 * This function is used internally inside of addBezier.
 * @param {number} y - The Y coordinate of the point.
 */
BoundingBox.prototype.addY = function(y) {
    this.addPoint(null, y);
};

/**
 * Add a Bézier curve to the bounding box.
 * This extends the bounding box to include the entire Bézier.
 * @param {number} x0 - The starting X coordinate.
 * @param {number} y0 - The starting Y coordinate.
 * @param {number} x1 - The X coordinate of the first control point.
 * @param {number} y1 - The Y coordinate of the first control point.
 * @param {number} x2 - The X coordinate of the second control point.
 * @param {number} y2 - The Y coordinate of the second control point.
 * @param {number} x - The ending X coordinate.
 * @param {number} y - The ending Y coordinate.
 */
BoundingBox.prototype.addBezier = function(x0, y0, x1, y1, x2, y2, x, y) {
    var this$1 = this;

    // This code is based on http://nishiohirokazu.blogspot.com/2009/06/how-to-calculate-bezier-curves-bounding.html
    // and https://github.com/icons8/svg-path-bounding-box

    var p0 = [x0, y0];
    var p1 = [x1, y1];
    var p2 = [x2, y2];
    var p3 = [x, y];

    this.addPoint(x0, y0);
    this.addPoint(x, y);

    for (var i = 0; i <= 1; i++) {
        var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
        var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
        var c = 3 * p1[i] - 3 * p0[i];

        if (a === 0) {
            if (b === 0) { continue; }
            var t = -c / b;
            if (0 < t && t < 1) {
                if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t)); }
                if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t)); }
            }
            continue;
        }

        var b2ac = Math.pow(b, 2) - 4 * c * a;
        if (b2ac < 0) { continue; }
        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
        if (0 < t1 && t1 < 1) {
            if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
            if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t1)); }
        }
        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
        if (0 < t2 && t2 < 1) {
            if (i === 0) { this$1.addX(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
            if (i === 1) { this$1.addY(derive(p0[i], p1[i], p2[i], p3[i], t2)); }
        }
    }
};

/**
 * Add a quadratic curve to the bounding box.
 * This extends the bounding box to include the entire quadratic curve.
 * @param {number} x0 - The starting X coordinate.
 * @param {number} y0 - The starting Y coordinate.
 * @param {number} x1 - The X coordinate of the control point.
 * @param {number} y1 - The Y coordinate of the control point.
 * @param {number} x - The ending X coordinate.
 * @param {number} y - The ending Y coordinate.
 */
BoundingBox.prototype.addQuad = function(x0, y0, x1, y1, x, y) {
    var cp1x = x0 + 2 / 3 * (x1 - x0);
    var cp1y = y0 + 2 / 3 * (y1 - y0);
    var cp2x = cp1x + 1 / 3 * (x - x0);
    var cp2y = cp1y + 1 / 3 * (y - y0);
    this.addBezier(x0, y0, cp1x, cp1y, cp2x, cp2y, x, y);
};

// Geometric objects

/**
 * A bézier path containing a set of path commands similar to a SVG path.
 * Paths can be drawn on a context using `draw`.
 * @exports opentype.Path
 * @class
 * @constructor
 */
function Path() {
    this.commands = [];
    this.fill = 'black';
    this.stroke = null;
    this.strokeWidth = 1;
}

/**
 * @param  {number} x
 * @param  {number} y
 */
Path.prototype.moveTo = function(x, y) {
    this.commands.push({
        type: 'M',
        x: x,
        y: y
    });
};

/**
 * @param  {number} x
 * @param  {number} y
 */
Path.prototype.lineTo = function(x, y) {
    this.commands.push({
        type: 'L',
        x: x,
        y: y
    });
};

/**
 * Draws cubic curve
 * @function
 * curveTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control 1
 * @param  {number} y1 - y of control 1
 * @param  {number} x2 - x of control 2
 * @param  {number} y2 - y of control 2
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 */

/**
 * Draws cubic curve
 * @function
 * bezierCurveTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control 1
 * @param  {number} y1 - y of control 1
 * @param  {number} x2 - x of control 2
 * @param  {number} y2 - y of control 2
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 * @see curveTo
 */
Path.prototype.curveTo = Path.prototype.bezierCurveTo = function(x1, y1, x2, y2, x, y) {
    this.commands.push({
        type: 'C',
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        x: x,
        y: y
    });
};

/**
 * Draws quadratic curve
 * @function
 * quadraticCurveTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control
 * @param  {number} y1 - y of control
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 */

/**
 * Draws quadratic curve
 * @function
 * quadTo
 * @memberof opentype.Path.prototype
 * @param  {number} x1 - x of control
 * @param  {number} y1 - y of control
 * @param  {number} x - x of path point
 * @param  {number} y - y of path point
 */
Path.prototype.quadTo = Path.prototype.quadraticCurveTo = function(x1, y1, x, y) {
    this.commands.push({
        type: 'Q',
        x1: x1,
        y1: y1,
        x: x,
        y: y
    });
};

/**
 * Closes the path
 * @function closePath
 * @memberof opentype.Path.prototype
 */

/**
 * Close the path
 * @function close
 * @memberof opentype.Path.prototype
 */
Path.prototype.close = Path.prototype.closePath = function() {
    this.commands.push({
        type: 'Z'
    });
};

/**
 * Add the given path or list of commands to the commands of this path.
 * @param  {Array} pathOrCommands - another opentype.Path, an opentype.BoundingBox, or an array of commands.
 */
Path.prototype.extend = function(pathOrCommands) {
    if (pathOrCommands.commands) {
        pathOrCommands = pathOrCommands.commands;
    } else if (pathOrCommands instanceof BoundingBox) {
        var box = pathOrCommands;
        this.moveTo(box.x1, box.y1);
        this.lineTo(box.x2, box.y1);
        this.lineTo(box.x2, box.y2);
        this.lineTo(box.x1, box.y2);
        this.close();
        return;
    }

    Array.prototype.push.apply(this.commands, pathOrCommands);
};

/**
 * Calculate the bounding box of the path.
 * @returns {opentype.BoundingBox}
 */
Path.prototype.getBoundingBox = function() {
    var this$1 = this;

    var box = new BoundingBox();

    var startX = 0;
    var startY = 0;
    var prevX = 0;
    var prevY = 0;
    for (var i = 0; i < this.commands.length; i++) {
        var cmd = this$1.commands[i];
        switch (cmd.type) {
            case 'M':
                box.addPoint(cmd.x, cmd.y);
                startX = prevX = cmd.x;
                startY = prevY = cmd.y;
                break;
            case 'L':
                box.addPoint(cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'Q':
                box.addQuad(prevX, prevY, cmd.x1, cmd.y1, cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'C':
                box.addBezier(prevX, prevY, cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                prevX = cmd.x;
                prevY = cmd.y;
                break;
            case 'Z':
                prevX = startX;
                prevY = startY;
                break;
            default:
                throw new Error('Unexpected path command ' + cmd.type);
        }
    }
    if (box.isEmpty()) {
        box.addPoint(0, 0);
    }
    return box;
};

/**
 * Draw the path to a 2D context.
 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context.
 */
Path.prototype.draw = function(ctx) {
    var this$1 = this;

    ctx.beginPath();
    for (var i = 0; i < this.commands.length; i += 1) {
        var cmd = this$1.commands[i];
        if (cmd.type === 'M') {
            ctx.moveTo(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            ctx.lineTo(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            ctx.closePath();
        }
    }

    if (this.fill) {
        ctx.fillStyle = this.fill;
        ctx.fill();
    }

    if (this.stroke) {
        ctx.strokeStyle = this.stroke;
        ctx.lineWidth = this.strokeWidth;
        ctx.stroke();
    }
};

/**
 * Convert the Path to a string of path data instructions
 * See http://www.w3.org/TR/SVG/paths.html#PathData
 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
 * @return {string}
 */
Path.prototype.toPathData = function(decimalPlaces) {
    var this$1 = this;

    decimalPlaces = decimalPlaces !== undefined ? decimalPlaces : 2;

    function floatToString(v) {
        if (Math.round(v) === v) {
            return '' + Math.round(v);
        } else {
            return v.toFixed(decimalPlaces);
        }
    }

    function packValues() {
        var arguments$1 = arguments;

        var s = '';
        for (var i = 0; i < arguments.length; i += 1) {
            var v = arguments$1[i];
            if (v >= 0 && i > 0) {
                s += ' ';
            }

            s += floatToString(v);
        }

        return s;
    }

    var d = '';
    for (var i = 0; i < this.commands.length; i += 1) {
        var cmd = this$1.commands[i];
        if (cmd.type === 'M') {
            d += 'M' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'L') {
            d += 'L' + packValues(cmd.x, cmd.y);
        } else if (cmd.type === 'C') {
            d += 'C' + packValues(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
        } else if (cmd.type === 'Q') {
            d += 'Q' + packValues(cmd.x1, cmd.y1, cmd.x, cmd.y);
        } else if (cmd.type === 'Z') {
            d += 'Z';
        }
    }

    return d;
};

/**
 * Convert the path to an SVG <path> element, as a string.
 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
 * @return {string}
 */
Path.prototype.toSVG = function(decimalPlaces) {
    var svg = '<path d="';
    svg += this.toPathData(decimalPlaces);
    svg += '"';
    if (this.fill && this.fill !== 'black') {
        if (this.fill === null) {
            svg += ' fill="none"';
        } else {
            svg += ' fill="' + this.fill + '"';
        }
    }

    if (this.stroke) {
        svg += ' stroke="' + this.stroke + '" stroke-width="' + this.strokeWidth + '"';
    }

    svg += '/>';
    return svg;
};

/**
 * Convert the path to a DOM element.
 * @param  {number} [decimalPlaces=2] - The amount of decimal places for floating-point values
 * @return {SVGPathElement}
 */
Path.prototype.toDOMElement = function(decimalPlaces) {
    var temporaryPath = this.toPathData(decimalPlaces);
    var newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');

    newPath.setAttribute('d', temporaryPath);

    return newPath;
};

// Run-time checking of preconditions.

function fail(message) {
    throw new Error(message);
}

// Precondition function that checks if the given predicate is true.
// If not, it will throw an error.
function argument(predicate, message) {
    if (!predicate) {
        fail(message);
    }
}

var check = { fail: fail, argument: argument, assert: argument };

// Data types used in the OpenType font file.
// All OpenType fonts use Motorola-style byte ordering (Big Endian)

var LIMIT16 = 32768; // The limit at which a 16-bit number switches signs == 2^15
var LIMIT32 = 2147483648; // The limit at which a 32-bit number switches signs == 2 ^ 31

/**
 * @exports opentype.decode
 * @class
 */
var decode = {};
/**
 * @exports opentype.encode
 * @class
 */
var encode = {};
/**
 * @exports opentype.sizeOf
 * @class
 */
var sizeOf = {};

// Return a function that always returns the same value.
function constant(v) {
    return function() {
        return v;
    };
}

// OpenType data types //////////////////////////////////////////////////////

/**
 * Convert an 8-bit unsigned integer to a list of 1 byte.
 * @param {number}
 * @returns {Array}
 */
encode.BYTE = function(v) {
    check.argument(v >= 0 && v <= 255, 'Byte value should be between 0 and 255.');
    return [v];
};
/**
 * @constant
 * @type {number}
 */
sizeOf.BYTE = constant(1);

/**
 * Convert a 8-bit signed integer to a list of 1 byte.
 * @param {string}
 * @returns {Array}
 */
encode.CHAR = function(v) {
    return [v.charCodeAt(0)];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.CHAR = constant(1);

/**
 * Convert an ASCII string to a list of bytes.
 * @param {string}
 * @returns {Array}
 */
encode.CHARARRAY = function(v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        b[i] = v.charCodeAt(i);
    }

    return b;
};

/**
 * @param {Array}
 * @returns {number}
 */
sizeOf.CHARARRAY = function(v) {
    return v.length;
};

/**
 * Convert a 16-bit unsigned integer to a list of 2 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.USHORT = function(v) {
    return [(v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.USHORT = constant(2);

/**
 * Convert a 16-bit signed integer to a list of 2 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.SHORT = function(v) {
    // Two's complement
    if (v >= LIMIT16) {
        v = -(2 * LIMIT16 - v);
    }

    return [(v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.SHORT = constant(2);

/**
 * Convert a 24-bit unsigned integer to a list of 3 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.UINT24 = function(v) {
    return [(v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.UINT24 = constant(3);

/**
 * Convert a 32-bit unsigned integer to a list of 4 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.ULONG = function(v) {
    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.ULONG = constant(4);

/**
 * Convert a 32-bit unsigned integer to a list of 4 bytes.
 * @param {number}
 * @returns {Array}
 */
encode.LONG = function(v) {
    // Two's complement
    if (v >= LIMIT32) {
        v = -(2 * LIMIT32 - v);
    }

    return [(v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.LONG = constant(4);

encode.FIXED = encode.ULONG;
sizeOf.FIXED = sizeOf.ULONG;

encode.FWORD = encode.SHORT;
sizeOf.FWORD = sizeOf.SHORT;

encode.UFWORD = encode.USHORT;
sizeOf.UFWORD = sizeOf.USHORT;

/**
 * Convert a 32-bit Apple Mac timestamp integer to a list of 8 bytes, 64-bit timestamp.
 * @param {number}
 * @returns {Array}
 */
encode.LONGDATETIME = function(v) {
    return [0, 0, 0, 0, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.LONGDATETIME = constant(8);

/**
 * Convert a 4-char tag to a list of 4 bytes.
 * @param {string}
 * @returns {Array}
 */
encode.TAG = function(v) {
    check.argument(v.length === 4, 'Tag should be exactly 4 ASCII characters.');
    return [v.charCodeAt(0),
            v.charCodeAt(1),
            v.charCodeAt(2),
            v.charCodeAt(3)];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.TAG = constant(4);

// CFF data types ///////////////////////////////////////////////////////////

encode.Card8 = encode.BYTE;
sizeOf.Card8 = sizeOf.BYTE;

encode.Card16 = encode.USHORT;
sizeOf.Card16 = sizeOf.USHORT;

encode.OffSize = encode.BYTE;
sizeOf.OffSize = sizeOf.BYTE;

encode.SID = encode.USHORT;
sizeOf.SID = sizeOf.USHORT;

// Convert a numeric operand or charstring number to a variable-size list of bytes.
/**
 * Convert a numeric operand or charstring number to a variable-size list of bytes.
 * @param {number}
 * @returns {Array}
 */
encode.NUMBER = function(v) {
    if (v >= -107 && v <= 107) {
        return [v + 139];
    } else if (v >= 108 && v <= 1131) {
        v = v - 108;
        return [(v >> 8) + 247, v & 0xFF];
    } else if (v >= -1131 && v <= -108) {
        v = -v - 108;
        return [(v >> 8) + 251, v & 0xFF];
    } else if (v >= -32768 && v <= 32767) {
        return encode.NUMBER16(v);
    } else {
        return encode.NUMBER32(v);
    }
};

/**
 * @param {number}
 * @returns {number}
 */
sizeOf.NUMBER = function(v) {
    return encode.NUMBER(v).length;
};

/**
 * Convert a signed number between -32768 and +32767 to a three-byte value.
 * This ensures we always use three bytes, but is not the most compact format.
 * @param {number}
 * @returns {Array}
 */
encode.NUMBER16 = function(v) {
    return [28, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.NUMBER16 = constant(3);

/**
 * Convert a signed number between -(2^31) and +(2^31-1) to a five-byte value.
 * This is useful if you want to be sure you always use four bytes,
 * at the expense of wasting a few bytes for smaller numbers.
 * @param {number}
 * @returns {Array}
 */
encode.NUMBER32 = function(v) {
    return [29, (v >> 24) & 0xFF, (v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF];
};

/**
 * @constant
 * @type {number}
 */
sizeOf.NUMBER32 = constant(5);

/**
 * @param {number}
 * @returns {Array}
 */
encode.REAL = function(v) {
    var value = v.toString();

    // Some numbers use an epsilon to encode the value. (e.g. JavaScript will store 0.0000001 as 1e-7)
    // This code converts it back to a number without the epsilon.
    var m = /\.(\d*?)(?:9{5,20}|0{5,20})\d{0,2}(?:e(.+)|$)/.exec(value);
    if (m) {
        var epsilon = parseFloat('1e' + ((m[2] ? +m[2] : 0) + m[1].length));
        value = (Math.round(v * epsilon) / epsilon).toString();
    }

    var nibbles = '';
    for (var i = 0, ii = value.length; i < ii; i += 1) {
        var c = value[i];
        if (c === 'e') {
            nibbles += value[++i] === '-' ? 'c' : 'b';
        } else if (c === '.') {
            nibbles += 'a';
        } else if (c === '-') {
            nibbles += 'e';
        } else {
            nibbles += c;
        }
    }

    nibbles += (nibbles.length & 1) ? 'f' : 'ff';
    var out = [30];
    for (var i$1 = 0, ii$1 = nibbles.length; i$1 < ii$1; i$1 += 2) {
        out.push(parseInt(nibbles.substr(i$1, 2), 16));
    }

    return out;
};

/**
 * @param {number}
 * @returns {number}
 */
sizeOf.REAL = function(v) {
    return encode.REAL(v).length;
};

encode.NAME = encode.CHARARRAY;
sizeOf.NAME = sizeOf.CHARARRAY;

encode.STRING = encode.CHARARRAY;
sizeOf.STRING = sizeOf.CHARARRAY;

/**
 * @param {DataView} data
 * @param {number} offset
 * @param {number} numBytes
 * @returns {string}
 */
decode.UTF8 = function(data, offset, numBytes) {
    var codePoints = [];
    var numChars = numBytes;
    for (var j = 0; j < numChars; j++, offset += 1) {
        codePoints[j] = data.getUint8(offset);
    }

    return String.fromCharCode.apply(null, codePoints);
};

/**
 * @param {DataView} data
 * @param {number} offset
 * @param {number} numBytes
 * @returns {string}
 */
decode.UTF16 = function(data, offset, numBytes) {
    var codePoints = [];
    var numChars = numBytes / 2;
    for (var j = 0; j < numChars; j++, offset += 2) {
        codePoints[j] = data.getUint16(offset);
    }

    return String.fromCharCode.apply(null, codePoints);
};

/**
 * Convert a JavaScript string to UTF16-BE.
 * @param {string}
 * @returns {Array}
 */
encode.UTF16 = function(v) {
    var b = [];
    for (var i = 0; i < v.length; i += 1) {
        var codepoint = v.charCodeAt(i);
        b[b.length] = (codepoint >> 8) & 0xFF;
        b[b.length] = codepoint & 0xFF;
    }

    return b;
};

/**
 * @param {string}
 * @returns {number}
 */
sizeOf.UTF16 = function(v) {
    return v.length * 2;
};

// Data for converting old eight-bit Macintosh encodings to Unicode.
// This representation is optimized for decoding; encoding is slower
// and needs more memory. The assumption is that all opentype.js users
// want to open fonts, but saving a font will be comparatively rare
// so it can be more expensive. Keyed by IANA character set name.
//
// Python script for generating these strings:
//
//     s = u''.join([chr(c).decode('mac_greek') for c in range(128, 256)])
//     print(s.encode('utf-8'))
/**
 * @private
 */
var eightBitMacEncodings = {
    'x-mac-croatian':  // Python: 'mac_croatian'
    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø' +
    '¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊©⁄€‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ',
    'x-mac-cyrillic':  // Python: 'mac_cyrillic'
    'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњ' +
    'јЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю',
    'x-mac-gaelic': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/GAELIC.TXT
    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØḂ±≤≥ḃĊċḊḋḞḟĠġṀæø' +
    'ṁṖṗɼƒſṠ«»… ÀÃÕŒœ–—“”‘’ṡẛÿŸṪ€‹›Ŷŷṫ·Ỳỳ⁊ÂÊÁËÈÍÎÏÌÓÔ♣ÒÚÛÙıÝýŴŵẄẅẀẁẂẃ',
    'x-mac-greek':  // Python: 'mac_greek'
    'Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦€ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩ' +
    'άΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ\u00AD',
    'x-mac-icelandic':  // Python: 'mac_iceland'
    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
    'x-mac-inuit': // http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/INUIT.TXT
    'ᐃᐄᐅᐆᐊᐋᐱᐲᐳᐴᐸᐹᑉᑎᑏᑐᑑᑕᑖᑦᑭᑮᑯᑰᑲᑳᒃᒋᒌᒍᒎᒐᒑ°ᒡᒥᒦ•¶ᒧ®©™ᒨᒪᒫᒻᓂᓃᓄᓅᓇᓈᓐᓯᓰᓱᓲᓴᓵᔅᓕᓖᓗ' +
    'ᓘᓚᓛᓪᔨᔩᔪᔫᔭ… ᔮᔾᕕᕖᕗ–—“”‘’ᕘᕙᕚᕝᕆᕇᕈᕉᕋᕌᕐᕿᖀᖁᖂᖃᖄᖅᖏᖐᖑᖒᖓᖔᖕᙱᙲᙳᙴᙵᙶᖖᖠᖡᖢᖣᖤᖥᖦᕼŁł',
    'x-mac-ce':  // Python: 'mac_latin2'
    'ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅ' +
    'ņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ',
    macintosh:  // Python: 'mac_roman'
    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
    'x-mac-romanian':  // Python: 'mac_romanian'
    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂȘ∞±≤≥¥µ∂∑∏π∫ªºΩăș' +
    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›Țț‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ',
    'x-mac-turkish':  // Python: 'mac_turkish'
    'ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø' +
    '¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙˆ˜¯˘˙˚¸˝˛ˇ'
};

/**
 * Decodes an old-style Macintosh string. Returns either a Unicode JavaScript
 * string, or 'undefined' if the encoding is unsupported. For example, we do
 * not support Chinese, Japanese or Korean because these would need large
 * mapping tables.
 * @param {DataView} dataView
 * @param {number} offset
 * @param {number} dataLength
 * @param {string} encoding
 * @returns {string}
 */
decode.MACSTRING = function(dataView, offset, dataLength, encoding) {
    var table = eightBitMacEncodings[encoding];
    if (table === undefined) {
        return undefined;
    }

    var result = '';
    for (var i = 0; i < dataLength; i++) {
        var c = dataView.getUint8(offset + i);
        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
        // mapped to U+0000..U+007F; we only need to look up the others.
        if (c <= 0x7F) {
            result += String.fromCharCode(c);
        } else {
            result += table[c & 0x7F];
        }
    }

    return result;
};

// Helper function for encode.MACSTRING. Returns a dictionary for mapping
// Unicode character codes to their 8-bit MacOS equivalent. This table
// is not exactly a super cheap data structure, but we do not care because
// encoding Macintosh strings is only rarely needed in typical applications.
var macEncodingTableCache = typeof WeakMap === 'function' && new WeakMap();
var macEncodingCacheKeys;
var getMacEncodingTable = function (encoding) {
    // Since we use encoding as a cache key for WeakMap, it has to be
    // a String object and not a literal. And at least on NodeJS 2.10.1,
    // WeakMap requires that the same String instance is passed for cache hits.
    if (!macEncodingCacheKeys) {
        macEncodingCacheKeys = {};
        for (var e in eightBitMacEncodings) {
            /*jshint -W053 */  // Suppress "Do not use String as a constructor."
            macEncodingCacheKeys[e] = new String(e);
        }
    }

    var cacheKey = macEncodingCacheKeys[encoding];
    if (cacheKey === undefined) {
        return undefined;
    }

    // We can't do "if (cache.has(key)) {return cache.get(key)}" here:
    // since garbage collection may run at any time, it could also kick in
    // between the calls to cache.has() and cache.get(). In that case,
    // we would return 'undefined' even though we do support the encoding.
    if (macEncodingTableCache) {
        var cachedTable = macEncodingTableCache.get(cacheKey);
        if (cachedTable !== undefined) {
            return cachedTable;
        }
    }

    var decodingTable = eightBitMacEncodings[encoding];
    if (decodingTable === undefined) {
        return undefined;
    }

    var encodingTable = {};
    for (var i = 0; i < decodingTable.length; i++) {
        encodingTable[decodingTable.charCodeAt(i)] = i + 0x80;
    }

    if (macEncodingTableCache) {
        macEncodingTableCache.set(cacheKey, encodingTable);
    }

    return encodingTable;
};

/**
 * Encodes an old-style Macintosh string. Returns a byte array upon success.
 * If the requested encoding is unsupported, or if the input string contains
 * a character that cannot be expressed in the encoding, the function returns
 * 'undefined'.
 * @param {string} str
 * @param {string} encoding
 * @returns {Array}
 */
encode.MACSTRING = function(str, encoding) {
    var table = getMacEncodingTable(encoding);
    if (table === undefined) {
        return undefined;
    }

    var result = [];
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);

        // In all eight-bit Mac encodings, the characters 0x00..0x7F are
        // mapped to U+0000..U+007F; we only need to look up the others.
        if (c >= 0x80) {
            c = table[c];
            if (c === undefined) {
                // str contains a Unicode character that cannot be encoded
                // in the requested encoding.
                return undefined;
            }
        }
        result[i] = c;
        // result.push(c);
    }

    return result;
};

/**
 * @param {string} str
 * @param {string} encoding
 * @returns {number}
 */
sizeOf.MACSTRING = function(str, encoding) {
    var b = encode.MACSTRING(str, encoding);
    if (b !== undefined) {
        return b.length;
    } else {
        return 0;
    }
};

// Helper for encode.VARDELTAS
function isByteEncodable(value) {
    return value >= -128 && value <= 127;
}

// Helper for encode.VARDELTAS
function encodeVarDeltaRunAsZeroes(deltas, pos, result) {
    var runLength = 0;
    var numDeltas = deltas.length;
    while (pos < numDeltas && runLength < 64 && deltas[pos] === 0) {
        ++pos;
        ++runLength;
    }
    result.push(0x80 | (runLength - 1));
    return pos;
}

// Helper for encode.VARDELTAS
function encodeVarDeltaRunAsBytes(deltas, offset, result) {
    var runLength = 0;
    var numDeltas = deltas.length;
    var pos = offset;
    while (pos < numDeltas && runLength < 64) {
        var value = deltas[pos];
        if (!isByteEncodable(value)) {
            break;
        }

        // Within a byte-encoded run of deltas, a single zero is best
        // stored literally as 0x00 value. However, if we have two or
        // more zeroes in a sequence, it is better to start a new run.
        // Fore example, the sequence of deltas [15, 15, 0, 15, 15]
        // becomes 6 bytes (04 0F 0F 00 0F 0F) when storing the zero
        // within the current run, but 7 bytes (01 0F 0F 80 01 0F 0F)
        // when starting a new run.
        if (value === 0 && pos + 1 < numDeltas && deltas[pos + 1] === 0) {
            break;
        }

        ++pos;
        ++runLength;
    }
    result.push(runLength - 1);
    for (var i = offset; i < pos; ++i) {
        result.push((deltas[i] + 256) & 0xff);
    }
    return pos;
}

// Helper for encode.VARDELTAS
function encodeVarDeltaRunAsWords(deltas, offset, result) {
    var runLength = 0;
    var numDeltas = deltas.length;
    var pos = offset;
    while (pos < numDeltas && runLength < 64) {
        var value = deltas[pos];

        // Within a word-encoded run of deltas, it is easiest to start
        // a new run (with a different encoding) whenever we encounter
        // a zero value. For example, the sequence [0x6666, 0, 0x7777]
        // needs 7 bytes when storing the zero inside the current run
        // (42 66 66 00 00 77 77), and equally 7 bytes when starting a
        // new run (40 66 66 80 40 77 77).
        if (value === 0) {
            break;
        }

        // Within a word-encoded run of deltas, a single value in the
        // range (-128..127) should be encoded within the current run
        // because it is more compact. For example, the sequence
        // [0x6666, 2, 0x7777] becomes 7 bytes when storing the value
        // literally (42 66 66 00 02 77 77), but 8 bytes when starting
        // a new run (40 66 66 00 02 40 77 77).
        if (isByteEncodable(value) && pos + 1 < numDeltas && isByteEncodable(deltas[pos + 1])) {
            break;
        }

        ++pos;
        ++runLength;
    }
    result.push(0x40 | (runLength - 1));
    for (var i = offset; i < pos; ++i) {
        var val = deltas[i];
        result.push(((val + 0x10000) >> 8) & 0xff, (val + 0x100) & 0xff);
    }
    return pos;
}

/**
 * Encode a list of variation adjustment deltas.
 *
 * Variation adjustment deltas are used in ‘gvar’ and ‘cvar’ tables.
 * They indicate how points (in ‘gvar’) or values (in ‘cvar’) get adjusted
 * when generating instances of variation fonts.
 *
 * @see https://www.microsoft.com/typography/otspec/gvar.htm
 * @see https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6gvar.html
 * @param {Array}
 * @return {Array}
 */
encode.VARDELTAS = function(deltas) {
    var pos = 0;
    var result = [];
    while (pos < deltas.length) {
        var value = deltas[pos];
        if (value === 0) {
            pos = encodeVarDeltaRunAsZeroes(deltas, pos, result);
        } else if (value >= -128 && value <= 127) {
            pos = encodeVarDeltaRunAsBytes(deltas, pos, result);
        } else {
            pos = encodeVarDeltaRunAsWords(deltas, pos, result);
        }
    }
    return result;
};

// Convert a list of values to a CFF INDEX structure.
// The values should be objects containing name / type / value.
/**
 * @param {Array} l
 * @returns {Array}
 */
encode.INDEX = function(l) {
    //var offset, offsets, offsetEncoder, encodedOffsets, encodedOffset, data,
    //    i, v;
    // Because we have to know which data type to use to encode the offsets,
    // we have to go through the values twice: once to encode the data and
    // calculate the offsets, then again to encode the offsets using the fitting data type.
    var offset = 1; // First offset is always 1.
    var offsets = [offset];
    var data = [];
    for (var i = 0; i < l.length; i += 1) {
        var v = encode.OBJECT(l[i]);
        Array.prototype.push.apply(data, v);
        offset += v.length;
        offsets.push(offset);
    }

    if (data.length === 0) {
        return [0, 0];
    }

    var encodedOffsets = [];
    var offSize = (1 + Math.floor(Math.log(offset) / Math.log(2)) / 8) | 0;
    var offsetEncoder = [undefined, encode.BYTE, encode.USHORT, encode.UINT24, encode.ULONG][offSize];
    for (var i$1 = 0; i$1 < offsets.length; i$1 += 1) {
        var encodedOffset = offsetEncoder(offsets[i$1]);
        Array.prototype.push.apply(encodedOffsets, encodedOffset);
    }

    return Array.prototype.concat(encode.Card16(l.length),
                           encode.OffSize(offSize),
                           encodedOffsets,
                           data);
};

/**
 * @param {Array}
 * @returns {number}
 */
sizeOf.INDEX = function(v) {
    return encode.INDEX(v).length;
};

/**
 * Convert an object to a CFF DICT structure.
 * The keys should be numeric.
 * The values should be objects containing name / type / value.
 * @param {Object} m
 * @returns {Array}
 */
encode.DICT = function(m) {
    var d = [];
    var keys = Object.keys(m);
    var length = keys.length;

    for (var i = 0; i < length; i += 1) {
        // Object.keys() return string keys, but our keys are always numeric.
        var k = parseInt(keys[i], 0);
        var v = m[k];
        // Value comes before the key.
        d = d.concat(encode.OPERAND(v.value, v.type));
        d = d.concat(encode.OPERATOR(k));
    }

    return d;
};

/**
 * @param {Object}
 * @returns {number}
 */
sizeOf.DICT = function(m) {
    return encode.DICT(m).length;
};

/**
 * @param {number}
 * @returns {Array}
 */
encode.OPERATOR = function(v) {
    if (v < 1200) {
        return [v];
    } else {
        return [12, v - 1200];
    }
};

/**
 * @param {Array} v
 * @param {string}
 * @returns {Array}
 */
encode.OPERAND = function(v, type) {
    var d = [];
    if (Array.isArray(type)) {
        for (var i = 0; i < type.length; i += 1) {
            check.argument(v.length === type.length, 'Not enough arguments given for type' + type);
            d = d.concat(encode.OPERAND(v[i], type[i]));
        }
    } else {
        if (type === 'SID') {
            d = d.concat(encode.NUMBER(v));
        } else if (type === 'offset') {
            // We make it easy for ourselves and always encode offsets as
            // 4 bytes. This makes offset calculation for the top dict easier.
            d = d.concat(encode.NUMBER32(v));
        } else if (type === 'number') {
            d = d.concat(encode.NUMBER(v));
        } else if (type === 'real') {
            d = d.concat(encode.REAL(v));
        } else {
            throw new Error('Unknown operand type ' + type);
            // FIXME Add support for booleans
        }
    }

    return d;
};

encode.OP = encode.BYTE;
sizeOf.OP = sizeOf.BYTE;

// memoize charstring encoding using WeakMap if available
var wmm = typeof WeakMap === 'function' && new WeakMap();

/**
 * Convert a list of CharString operations to bytes.
 * @param {Array}
 * @returns {Array}
 */
encode.CHARSTRING = function(ops) {
    // See encode.MACSTRING for why we don't do "if (wmm && wmm.has(ops))".
    if (wmm) {
        var cachedValue = wmm.get(ops);
        if (cachedValue !== undefined) {
            return cachedValue;
        }
    }

    var d = [];
    var length = ops.length;

    for (var i = 0; i < length; i += 1) {
        var op = ops[i];
        d = d.concat(encode[op.type](op.value));
    }

    if (wmm) {
        wmm.set(ops, d);
    }

    return d;
};

/**
 * @param {Array}
 * @returns {number}
 */
sizeOf.CHARSTRING = function(ops) {
    return encode.CHARSTRING(ops).length;
};

// Utility functions ////////////////////////////////////////////////////////

/**
 * Convert an object containing name / type / value to bytes.
 * @param {Object}
 * @returns {Array}
 */
encode.OBJECT = function(v) {
    var encodingFunction = encode[v.type];
    check.argument(encodingFunction !== undefined, 'No encoding function for type ' + v.type);
    return encodingFunction(v.value);
};

/**
 * @param {Object}
 * @returns {number}
 */
sizeOf.OBJECT = function(v) {
    var sizeOfFunction = sizeOf[v.type];
    check.argument(sizeOfFunction !== undefined, 'No sizeOf function for type ' + v.type);
    return sizeOfFunction(v.value);
};

/**
 * Convert a table object to bytes.
 * A table contains a list of fields containing the metadata (name, type and default value).
 * The table itself has the field values set as attributes.
 * @param {opentype.Table}
 * @returns {Array}
 */
encode.TABLE = function(table) {
    var d = [];
    var length = table.fields.length;
    var subtables = [];
    var subtableOffsets = [];

    for (var i = 0; i < length; i += 1) {
        var field = table.fields[i];
        var encodingFunction = encode[field.type];
        check.argument(encodingFunction !== undefined, 'No encoding function for field type ' + field.type + ' (' + field.name + ')');
        var value = table[field.name];
        if (value === undefined) {
            value = field.value;
        }

        var bytes = encodingFunction(value);

        if (field.type === 'TABLE') {
            subtableOffsets.push(d.length);
            d = d.concat([0, 0]);
            subtables.push(bytes);
        } else {
            d = d.concat(bytes);
        }
    }

    for (var i$1 = 0; i$1 < subtables.length; i$1 += 1) {
        var o = subtableOffsets[i$1];
        var offset = d.length;
        check.argument(offset < 65536, 'Table ' + table.tableName + ' too big.');
        d[o] = offset >> 8;
        d[o + 1] = offset & 0xff;
        d = d.concat(subtables[i$1]);
    }

    return d;
};

/**
 * @param {opentype.Table}
 * @returns {number}
 */
sizeOf.TABLE = function(table) {
    var numBytes = 0;
    var length = table.fields.length;

    for (var i = 0; i < length; i += 1) {
        var field = table.fields[i];
        var sizeOfFunction = sizeOf[field.type];
        check.argument(sizeOfFunction !== undefined, 'No sizeOf function for field type ' + field.type + ' (' + field.name + ')');
        var value = table[field.name];
        if (value === undefined) {
            value = field.value;
        }

        numBytes += sizeOfFunction(value);

        // Subtables take 2 more bytes for offsets.
        if (field.type === 'TABLE') {
            numBytes += 2;
        }
    }

    return numBytes;
};

encode.RECORD = encode.TABLE;
sizeOf.RECORD = sizeOf.TABLE;

// Merge in a list of bytes.
encode.LITERAL = function(v) {
    return v;
};

sizeOf.LITERAL = function(v) {
    return v.length;
};

// Table metadata

/**
 * @exports opentype.Table
 * @class
 * @param {string} tableName
 * @param {Array} fields
 * @param {Object} options
 * @constructor
 */
function Table(tableName, fields, options) {
    var this$1 = this;

    for (var i = 0; i < fields.length; i += 1) {
        var field = fields[i];
        this$1[field.name] = field.value;
    }

    this.tableName = tableName;
    this.fields = fields;
    if (options) {
        var optionKeys = Object.keys(options);
        for (var i$1 = 0; i$1 < optionKeys.length; i$1 += 1) {
            var k = optionKeys[i$1];
            var v = options[k];
            if (this$1[k] !== undefined) {
                this$1[k] = v;
            }
        }
    }
}

/**
 * Encodes the table and returns an array of bytes
 * @return {Array}
 */
Table.prototype.encode = function() {
    return encode.TABLE(this);
};

/**
 * Get the size of the table.
 * @return {number}
 */
Table.prototype.sizeOf = function() {
    return sizeOf.TABLE(this);
};

/**
 * @private
 */
function ushortList(itemName, list, count) {
    if (count === undefined) {
        count = list.length;
    }
    var fields = new Array(list.length + 1);
    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
    for (var i = 0; i < list.length; i++) {
        fields[i + 1] = {name: itemName + i, type: 'USHORT', value: list[i]};
    }
    return fields;
}

/**
 * @private
 */
function tableList(itemName, records, itemCallback) {
    var count = records.length;
    var fields = new Array(count + 1);
    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
    for (var i = 0; i < count; i++) {
        fields[i + 1] = {name: itemName + i, type: 'TABLE', value: itemCallback(records[i], i)};
    }
    return fields;
}

/**
 * @private
 */
function recordList(itemName, records, itemCallback) {
    var count = records.length;
    var fields = [];
    fields[0] = {name: itemName + 'Count', type: 'USHORT', value: count};
    for (var i = 0; i < count; i++) {
        fields = fields.concat(itemCallback(records[i], i));
    }
    return fields;
}

// Common Layout Tables

/**
 * @exports opentype.Coverage
 * @class
 * @param {opentype.Table}
 * @constructor
 * @extends opentype.Table
 */
function Coverage(coverageTable) {
    if (coverageTable.format === 1) {
        Table.call(this, 'coverageTable',
            [{name: 'coverageFormat', type: 'USHORT', value: 1}]
            .concat(ushortList('glyph', coverageTable.glyphs))
        );
    } else {
        check.assert(false, 'Can\'t create coverage table format 2 yet.');
    }
}
Coverage.prototype = Object.create(Table.prototype);
Coverage.prototype.constructor = Coverage;

function ScriptList(scriptListTable) {
    Table.call(this, 'scriptListTable',
        recordList('scriptRecord', scriptListTable, function(scriptRecord, i) {
            var script = scriptRecord.script;
            var defaultLangSys = script.defaultLangSys;
            check.assert(!!defaultLangSys, 'Unable to write GSUB: script ' + scriptRecord.tag + ' has no default language system.');
            return [
                {name: 'scriptTag' + i, type: 'TAG', value: scriptRecord.tag},
                {name: 'script' + i, type: 'TABLE', value: new Table('scriptTable', [
                    {name: 'defaultLangSys', type: 'TABLE', value: new Table('defaultLangSys', [
                        {name: 'lookupOrder', type: 'USHORT', value: 0},
                        {name: 'reqFeatureIndex', type: 'USHORT', value: defaultLangSys.reqFeatureIndex}]
                        .concat(ushortList('featureIndex', defaultLangSys.featureIndexes)))}
                    ].concat(recordList('langSys', script.langSysRecords, function(langSysRecord, i) {
                        var langSys = langSysRecord.langSys;
                        return [
                            {name: 'langSysTag' + i, type: 'TAG', value: langSysRecord.tag},
                            {name: 'langSys' + i, type: 'TABLE', value: new Table('langSys', [
                                {name: 'lookupOrder', type: 'USHORT', value: 0},
                                {name: 'reqFeatureIndex', type: 'USHORT', value: langSys.reqFeatureIndex}
                                ].concat(ushortList('featureIndex', langSys.featureIndexes)))}
                        ];
                    })))}
            ];
        })
    );
}
ScriptList.prototype = Object.create(Table.prototype);
ScriptList.prototype.constructor = ScriptList;

/**
 * @exports opentype.FeatureList
 * @class
 * @param {opentype.Table}
 * @constructor
 * @extends opentype.Table
 */
function FeatureList(featureListTable) {
    Table.call(this, 'featureListTable',
        recordList('featureRecord', featureListTable, function(featureRecord, i) {
            var feature = featureRecord.feature;
            return [
                {name: 'featureTag' + i, type: 'TAG', value: featureRecord.tag},
                {name: 'feature' + i, type: 'TABLE', value: new Table('featureTable', [
                    {name: 'featureParams', type: 'USHORT', value: feature.featureParams} ].concat(ushortList('lookupListIndex', feature.lookupListIndexes)))}
            ];
        })
    );
}
FeatureList.prototype = Object.create(Table.prototype);
FeatureList.prototype.constructor = FeatureList;

/**
 * @exports opentype.LookupList
 * @class
 * @param {opentype.Table}
 * @param {Object}
 * @constructor
 * @extends opentype.Table
 */
function LookupList(lookupListTable, subtableMakers) {
    Table.call(this, 'lookupListTable', tableList('lookup', lookupListTable, function(lookupTable) {
        var subtableCallback = subtableMakers[lookupTable.lookupType];
        check.assert(!!subtableCallback, 'Unable to write GSUB lookup type ' + lookupTable.lookupType + ' tables.');
        return new Table('lookupTable', [
            {name: 'lookupType', type: 'USHORT', value: lookupTable.lookupType},
            {name: 'lookupFlag', type: 'USHORT', value: lookupTable.lookupFlag}
        ].concat(tableList('subtable', lookupTable.subtables, subtableCallback)));
    }));
}
LookupList.prototype = Object.create(Table.prototype);
LookupList.prototype.constructor = LookupList;

// Record = same as Table, but inlined (a Table has an offset and its data is further in the stream)
// Don't use offsets inside Records (probable bug), only in Tables.
var table = {
    Table: Table,
    Record: Table,
    Coverage: Coverage,
    ScriptList: ScriptList,
    FeatureList: FeatureList,
    LookupList: LookupList,
    ushortList: ushortList,
    tableList: tableList,
    recordList: recordList,
};

// Parsing utility functions

// Retrieve an unsigned byte from the DataView.
function getByte(dataView, offset) {
    return dataView.getUint8(offset);
}

// Retrieve an unsigned 16-bit short from the DataView.
// The value is stored in big endian.
function getUShort(dataView, offset) {
    return dataView.getUint16(offset, false);
}

// Retrieve a signed 16-bit short from the DataView.
// The value is stored in big endian.
function getShort(dataView, offset) {
    return dataView.getInt16(offset, false);
}

// Retrieve an unsigned 32-bit long from the DataView.
// The value is stored in big endian.
function getULong(dataView, offset) {
    return dataView.getUint32(offset, false);
}

// Retrieve a 32-bit signed fixed-point number (16.16) from the DataView.
// The value is stored in big endian.
function getFixed(dataView, offset) {
    var decimal = dataView.getInt16(offset, false);
    var fraction = dataView.getUint16(offset + 2, false);
    return decimal + fraction / 65535;
}

// Retrieve a 4-character tag from the DataView.
// Tags are used to identify tables.
function getTag(dataView, offset) {
    var tag = '';
    for (var i = offset; i < offset + 4; i += 1) {
        tag += String.fromCharCode(dataView.getInt8(i));
    }

    return tag;
}

// Retrieve an offset from the DataView.
// Offsets are 1 to 4 bytes in length, depending on the offSize argument.
function getOffset(dataView, offset, offSize) {
    var v = 0;
    for (var i = 0; i < offSize; i += 1) {
        v <<= 8;
        v += dataView.getUint8(offset + i);
    }

    return v;
}

// Retrieve a number of bytes from start offset to the end offset from the DataView.
function getBytes(dataView, startOffset, endOffset) {
    var bytes = [];
    for (var i = startOffset; i < endOffset; i += 1) {
        bytes.push(dataView.getUint8(i));
    }

    return bytes;
}

// Convert the list of bytes to a string.
function bytesToString(bytes) {
    var s = '';
    for (var i = 0; i < bytes.length; i += 1) {
        s += String.fromCharCode(bytes[i]);
    }

    return s;
}

var typeOffsets = {
    byte: 1,
    uShort: 2,
    short: 2,
    uLong: 4,
    fixed: 4,
    longDateTime: 8,
    tag: 4
};

// A stateful parser that changes the offset whenever a value is retrieved.
// The data is a DataView.
function Parser(data, offset) {
    this.data = data;
    this.offset = offset;
    this.relativeOffset = 0;
}

Parser.prototype.parseByte = function() {
    var v = this.data.getUint8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseChar = function() {
    var v = this.data.getInt8(this.offset + this.relativeOffset);
    this.relativeOffset += 1;
    return v;
};

Parser.prototype.parseCard8 = Parser.prototype.parseByte;

Parser.prototype.parseUShort = function() {
    var v = this.data.getUint16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseCard16 = Parser.prototype.parseUShort;
Parser.prototype.parseSID = Parser.prototype.parseUShort;
Parser.prototype.parseOffset16 = Parser.prototype.parseUShort;

Parser.prototype.parseShort = function() {
    var v = this.data.getInt16(this.offset + this.relativeOffset);
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseF2Dot14 = function() {
    var v = this.data.getInt16(this.offset + this.relativeOffset) / 16384;
    this.relativeOffset += 2;
    return v;
};

Parser.prototype.parseULong = function() {
    var v = getULong(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseOffset32 = Parser.prototype.parseULong;

Parser.prototype.parseFixed = function() {
    var v = getFixed(this.data, this.offset + this.relativeOffset);
    this.relativeOffset += 4;
    return v;
};

Parser.prototype.parseString = function(length) {
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    var string = '';
    this.relativeOffset += length;
    for (var i = 0; i < length; i++) {
        string += String.fromCharCode(dataView.getUint8(offset + i));
    }

    return string;
};

Parser.prototype.parseTag = function() {
    return this.parseString(4);
};

// LONGDATETIME is a 64-bit integer.
// JavaScript and unix timestamps traditionally use 32 bits, so we
// only take the last 32 bits.
// + Since until 2038 those bits will be filled by zeros we can ignore them.
Parser.prototype.parseLongDateTime = function() {
    var v = getULong(this.data, this.offset + this.relativeOffset + 4);
    // Subtract seconds between 01/01/1904 and 01/01/1970
    // to convert Apple Mac timestamp to Standard Unix timestamp
    v -= 2082844800;
    this.relativeOffset += 8;
    return v;
};

Parser.prototype.parseVersion = function(minorBase) {
    var major = getUShort(this.data, this.offset + this.relativeOffset);

    // How to interpret the minor version is very vague in the spec. 0x5000 is 5, 0x1000 is 1
    // Default returns the correct number if minor = 0xN000 where N is 0-9
    // Set minorBase to 1 for tables that use minor = N where N is 0-9
    var minor = getUShort(this.data, this.offset + this.relativeOffset + 2);
    this.relativeOffset += 4;
    if (minorBase === undefined) { minorBase = 0x1000; }
    return major + minor / minorBase / 10;
};

Parser.prototype.skip = function(type, amount) {
    if (amount === undefined) {
        amount = 1;
    }

    this.relativeOffset += typeOffsets[type] * amount;
};

///// Parsing lists and records ///////////////////////////////

// Parse a list of 32 bit unsigned integers.
Parser.prototype.parseULongList = function(count) {
    if (count === undefined) { count = this.parseULong(); }
    var offsets = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        offsets[i] = dataView.getUint32(offset);
        offset += 4;
    }

    this.relativeOffset += count * 4;
    return offsets;
};

// Parse a list of 16 bit unsigned integers. The length of the list can be read on the stream
// or provided as an argument.
Parser.prototype.parseOffset16List =
Parser.prototype.parseUShortList = function(count) {
    if (count === undefined) { count = this.parseUShort(); }
    var offsets = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        offsets[i] = dataView.getUint16(offset);
        offset += 2;
    }

    this.relativeOffset += count * 2;
    return offsets;
};

// Parses a list of 16 bit signed integers.
Parser.prototype.parseShortList = function(count) {
    var list = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        list[i] = dataView.getInt16(offset);
        offset += 2;
    }

    this.relativeOffset += count * 2;
    return list;
};

// Parses a list of bytes.
Parser.prototype.parseByteList = function(count) {
    var list = new Array(count);
    var dataView = this.data;
    var offset = this.offset + this.relativeOffset;
    for (var i = 0; i < count; i++) {
        list[i] = dataView.getUint8(offset++);
    }

    this.relativeOffset += count;
    return list;
};

/**
 * Parse a list of items.
 * Record count is optional, if omitted it is read from the stream.
 * itemCallback is one of the Parser methods.
 */
Parser.prototype.parseList = function(count, itemCallback) {
    var this$1 = this;

    if (!itemCallback) {
        itemCallback = count;
        count = this.parseUShort();
    }
    var list = new Array(count);
    for (var i = 0; i < count; i++) {
        list[i] = itemCallback.call(this$1);
    }
    return list;
};

Parser.prototype.parseList32 = function(count, itemCallback) {
    var this$1 = this;

    if (!itemCallback) {
        itemCallback = count;
        count = this.parseULong();
    }
    var list = new Array(count);
    for (var i = 0; i < count; i++) {
        list[i] = itemCallback.call(this$1);
    }
    return list;
};

/**
 * Parse a list of records.
 * Record count is optional, if omitted it is read from the stream.
 * Example of recordDescription: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
 */
Parser.prototype.parseRecordList = function(count, recordDescription) {
    var this$1 = this;

    // If the count argument is absent, read it in the stream.
    if (!recordDescription) {
        recordDescription = count;
        count = this.parseUShort();
    }
    var records = new Array(count);
    var fields = Object.keys(recordDescription);
    for (var i = 0; i < count; i++) {
        var rec = {};
        for (var j = 0; j < fields.length; j++) {
            var fieldName = fields[j];
            var fieldType = recordDescription[fieldName];
            rec[fieldName] = fieldType.call(this$1);
        }
        records[i] = rec;
    }
    return records;
};

Parser.prototype.parseRecordList32 = function(count, recordDescription) {
    var this$1 = this;

    // If the count argument is absent, read it in the stream.
    if (!recordDescription) {
        recordDescription = count;
        count = this.parseULong();
    }
    var records = new Array(count);
    var fields = Object.keys(recordDescription);
    for (var i = 0; i < count; i++) {
        var rec = {};
        for (var j = 0; j < fields.length; j++) {
            var fieldName = fields[j];
            var fieldType = recordDescription[fieldName];
            rec[fieldName] = fieldType.call(this$1);
        }
        records[i] = rec;
    }
    return records;
};

// Parse a data structure into an object
// Example of description: { sequenceIndex: Parser.uShort, lookupListIndex: Parser.uShort }
Parser.prototype.parseStruct = function(description) {
    var this$1 = this;

    if (typeof description === 'function') {
        return description.call(this);
    } else {
        var fields = Object.keys(description);
        var struct = {};
        for (var j = 0; j < fields.length; j++) {
            var fieldName = fields[j];
            var fieldType = description[fieldName];
            struct[fieldName] = fieldType.call(this$1);
        }
        return struct;
    }
};

/**
 * Parse a GPOS valueRecord
 * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
 * valueFormat is optional, if omitted it is read from the stream.
 */
Parser.prototype.parseValueRecord = function(valueFormat) {
    if (valueFormat === undefined) {
        valueFormat = this.parseUShort();
    }
    if (valueFormat === 0) {
        // valueFormat2 in kerning pairs is most often 0
        // in this case return undefined instead of an empty object, to save space
        return;
    }
    var valueRecord = {};

    if (valueFormat & 0x0001) { valueRecord.xPlacement = this.parseShort(); }
    if (valueFormat & 0x0002) { valueRecord.yPlacement = this.parseShort(); }
    if (valueFormat & 0x0004) { valueRecord.xAdvance = this.parseShort(); }
    if (valueFormat & 0x0008) { valueRecord.yAdvance = this.parseShort(); }

    // Device table (non-variable font) / VariationIndex table (variable font) not supported
    // https://docs.microsoft.com/fr-fr/typography/opentype/spec/chapter2#devVarIdxTbls
    if (valueFormat & 0x0010) { valueRecord.xPlaDevice = undefined; this.parseShort(); }
    if (valueFormat & 0x0020) { valueRecord.yPlaDevice = undefined; this.parseShort(); }
    if (valueFormat & 0x0040) { valueRecord.xAdvDevice = undefined; this.parseShort(); }
    if (valueFormat & 0x0080) { valueRecord.yAdvDevice = undefined; this.parseShort(); }

    return valueRecord;
};

/**
 * Parse a list of GPOS valueRecords
 * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#value-record
 * valueFormat and valueCount are read from the stream.
 */
Parser.prototype.parseValueRecordList = function() {
    var this$1 = this;

    var valueFormat = this.parseUShort();
    var valueCount = this.parseUShort();
    var values = new Array(valueCount);
    for (var i = 0; i < valueCount; i++) {
        values[i] = this$1.parseValueRecord(valueFormat);
    }
    return values;
};

Parser.prototype.parsePointer = function(description) {
    var structOffset = this.parseOffset16();
    if (structOffset > 0) {
        // NULL offset => return undefined
        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
    }
    return undefined;
};

Parser.prototype.parsePointer32 = function(description) {
    var structOffset = this.parseOffset32();
    if (structOffset > 0) {
        // NULL offset => return undefined
        return new Parser(this.data, this.offset + structOffset).parseStruct(description);
    }
    return undefined;
};

/**
 * Parse a list of offsets to lists of 16-bit integers,
 * or a list of offsets to lists of offsets to any kind of items.
 * If itemCallback is not provided, a list of list of UShort is assumed.
 * If provided, itemCallback is called on each item and must parse the item.
 * See examples in tables/gsub.js
 */
Parser.prototype.parseListOfLists = function(itemCallback) {
    var this$1 = this;

    var offsets = this.parseOffset16List();
    var count = offsets.length;
    var relativeOffset = this.relativeOffset;
    var list = new Array(count);
    for (var i = 0; i < count; i++) {
        var start = offsets[i];
        if (start === 0) {
            // NULL offset
            // Add i as owned property to list. Convenient with assert.
            list[i] = undefined;
            continue;
        }
        this$1.relativeOffset = start;
        if (itemCallback) {
            var subOffsets = this$1.parseOffset16List();
            var subList = new Array(subOffsets.length);
            for (var j = 0; j < subOffsets.length; j++) {
                this$1.relativeOffset = start + subOffsets[j];
                subList[j] = itemCallback.call(this$1);
            }
            list[i] = subList;
        } else {
            list[i] = this$1.parseUShortList();
        }
    }
    this.relativeOffset = relativeOffset;
    return list;
};

///// Complex tables parsing //////////////////////////////////

// Parse a coverage table in a GSUB, GPOS or GDEF table.
// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
// parser.offset must point to the start of the table containing the coverage.
Parser.prototype.parseCoverage = function() {
    var this$1 = this;

    var startOffset = this.offset + this.relativeOffset;
    var format = this.parseUShort();
    var count = this.parseUShort();
    if (format === 1) {
        return {
            format: 1,
            glyphs: this.parseUShortList(count)
        };
    } else if (format === 2) {
        var ranges = new Array(count);
        for (var i = 0; i < count; i++) {
            ranges[i] = {
                start: this$1.parseUShort(),
                end: this$1.parseUShort(),
                index: this$1.parseUShort()
            };
        }
        return {
            format: 2,
            ranges: ranges
        };
    }
    throw new Error('0x' + startOffset.toString(16) + ': Coverage format must be 1 or 2.');
};

// Parse a Class Definition Table in a GSUB, GPOS or GDEF table.
// https://www.microsoft.com/typography/OTSPEC/chapter2.htm
Parser.prototype.parseClassDef = function() {
    var startOffset = this.offset + this.relativeOffset;
    var format = this.parseUShort();
    if (format === 1) {
        return {
            format: 1,
            startGlyph: this.parseUShort(),
            classes: this.parseUShortList()
        };
    } else if (format === 2) {
        return {
            format: 2,
            ranges: this.parseRecordList({
                start: Parser.uShort,
                end: Parser.uShort,
                classId: Parser.uShort
            })
        };
    }
    throw new Error('0x' + startOffset.toString(16) + ': ClassDef format must be 1 or 2.');
};

///// Static methods ///////////////////////////////////
// These convenience methods can be used as callbacks and should be called with "this" context set to a Parser instance.

Parser.list = function(count, itemCallback) {
    return function() {
        return this.parseList(count, itemCallback);
    };
};

Parser.list32 = function(count, itemCallback) {
    return function() {
        return this.parseList32(count, itemCallback);
    };
};

Parser.recordList = function(count, recordDescription) {
    return function() {
        return this.parseRecordList(count, recordDescription);
    };
};

Parser.recordList32 = function(count, recordDescription) {
    return function() {
        return this.parseRecordList32(count, recordDescription);
    };
};

Parser.pointer = function(description) {
    return function() {
        return this.parsePointer(description);
    };
};

Parser.pointer32 = function(description) {
    return function() {
        return this.parsePointer32(description);
    };
};

Parser.tag = Parser.prototype.parseTag;
Parser.byte = Parser.prototype.parseByte;
Parser.uShort = Parser.offset16 = Parser.prototype.parseUShort;
Parser.uShortList = Parser.prototype.parseUShortList;
Parser.uLong = Parser.offset32 = Parser.prototype.parseULong;
Parser.uLongList = Parser.prototype.parseULongList;
Parser.struct = Parser.prototype.parseStruct;
Parser.coverage = Parser.prototype.parseCoverage;
Parser.classDef = Parser.prototype.parseClassDef;

///// Script, Feature, Lookup lists ///////////////////////////////////////////////
// https://www.microsoft.com/typography/OTSPEC/chapter2.htm

var langSysTable = {
    reserved: Parser.uShort,
    reqFeatureIndex: Parser.uShort,
    featureIndexes: Parser.uShortList
};

Parser.prototype.parseScriptList = function() {
    return this.parsePointer(Parser.recordList({
        tag: Parser.tag,
        script: Parser.pointer({
            defaultLangSys: Parser.pointer(langSysTable),
            langSysRecords: Parser.recordList({
                tag: Parser.tag,
                langSys: Parser.pointer(langSysTable)
            })
        })
    })) || [];
};

Parser.prototype.parseFeatureList = function() {
    return this.parsePointer(Parser.recordList({
        tag: Parser.tag,
        feature: Parser.pointer({
            featureParams: Parser.offset16,
            lookupListIndexes: Parser.uShortList
        })
    })) || [];
};

Parser.prototype.parseLookupList = function(lookupTableParsers) {
    return this.parsePointer(Parser.list(Parser.pointer(function() {
        var lookupType = this.parseUShort();
        check.argument(1 <= lookupType && lookupType <= 9, 'GPOS/GSUB lookup type ' + lookupType + ' unknown.');
        var lookupFlag = this.parseUShort();
        var useMarkFilteringSet = lookupFlag & 0x10;
        return {
            lookupType: lookupType,
            lookupFlag: lookupFlag,
            subtables: this.parseList(Parser.pointer(lookupTableParsers[lookupType])),
            markFilteringSet: useMarkFilteringSet ? this.parseUShort() : undefined
        };
    }))) || [];
};

Parser.prototype.parseFeatureVariationsList = function() {
    return this.parsePointer32(function() {
        var majorVersion = this.parseUShort();
        var minorVersion = this.parseUShort();
        check.argument(majorVersion === 1 && minorVersion < 1, 'GPOS/GSUB feature variations table unknown.');
        var featureVariations = this.parseRecordList32({
            conditionSetOffset: Parser.offset32,
            featureTableSubstitutionOffset: Parser.offset32
        });
        return featureVariations;
    }) || [];
};

var parse = {
    getByte: getByte,
    getCard8: getByte,
    getUShort: getUShort,
    getCard16: getUShort,
    getShort: getShort,
    getULong: getULong,
    getFixed: getFixed,
    getTag: getTag,
    getOffset: getOffset,
    getBytes: getBytes,
    bytesToString: bytesToString,
    Parser: Parser,
};

// The `cmap` table stores the mappings from characters to glyphs.
// https://www.microsoft.com/typography/OTSPEC/cmap.htm

function parseCmapTableFormat12(cmap, p) {
    //Skip reserved.
    p.parseUShort();

    // Length in bytes of the sub-tables.
    cmap.length = p.parseULong();
    cmap.language = p.parseULong();

    var groupCount;
    cmap.groupCount = groupCount = p.parseULong();
    cmap.glyphIndexMap = {};

    for (var i = 0; i < groupCount; i += 1) {
        var startCharCode = p.parseULong();
        var endCharCode = p.parseULong();
        var startGlyphId = p.parseULong();

        for (var c = startCharCode; c <= endCharCode; c += 1) {
            cmap.glyphIndexMap[c] = startGlyphId;
            startGlyphId++;
        }
    }
}

function parseCmapTableFormat4(cmap, p, data, start, offset) {
    // Length in bytes of the sub-tables.
    cmap.length = p.parseUShort();
    cmap.language = p.parseUShort();

    // segCount is stored x 2.
    var segCount;
    cmap.segCount = segCount = p.parseUShort() >> 1;

    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);

    // The "unrolled" mapping from character codes to glyph indices.
    cmap.glyphIndexMap = {};
    var endCountParser = new parse.Parser(data, start + offset + 14);
    var startCountParser = new parse.Parser(data, start + offset + 16 + segCount * 2);
    var idDeltaParser = new parse.Parser(data, start + offset + 16 + segCount * 4);
    var idRangeOffsetParser = new parse.Parser(data, start + offset + 16 + segCount * 6);
    var glyphIndexOffset = start + offset + 16 + segCount * 8;
    for (var i = 0; i < segCount - 1; i += 1) {
        var glyphIndex = (void 0);
        var endCount = endCountParser.parseUShort();
        var startCount = startCountParser.parseUShort();
        var idDelta = idDeltaParser.parseShort();
        var idRangeOffset = idRangeOffsetParser.parseUShort();
        for (var c = startCount; c <= endCount; c += 1) {
            if (idRangeOffset !== 0) {
                // The idRangeOffset is relative to the current position in the idRangeOffset array.
                // Take the current offset in the idRangeOffset array.
                glyphIndexOffset = (idRangeOffsetParser.offset + idRangeOffsetParser.relativeOffset - 2);

                // Add the value of the idRangeOffset, which will move us into the glyphIndex array.
                glyphIndexOffset += idRangeOffset;

                // Then add the character index of the current segment, multiplied by 2 for USHORTs.
                glyphIndexOffset += (c - startCount) * 2;
                glyphIndex = parse.getUShort(data, glyphIndexOffset);
                if (glyphIndex !== 0) {
                    glyphIndex = (glyphIndex + idDelta) & 0xFFFF;
                }
            } else {
                glyphIndex = (c + idDelta) & 0xFFFF;
            }

            cmap.glyphIndexMap[c] = glyphIndex;
        }
    }
}

// Parse the `cmap` table. This table stores the mappings from characters to glyphs.
// There are many available formats, but we only support the Windows format 4 and 12.
// This function returns a `CmapEncoding` object or null if no supported format could be found.
function parseCmapTable(data, start) {
    var cmap = {};
    cmap.version = parse.getUShort(data, start);
    check.argument(cmap.version === 0, 'cmap table version should be 0.');

    // The cmap table can contain many sub-tables, each with their own format.
    // We're only interested in a "platform 3" table. This is a Windows format.
    cmap.numTables = parse.getUShort(data, start + 2);
    var offset = -1;
    for (var i = cmap.numTables - 1; i >= 0; i -= 1) {
        var platformId = parse.getUShort(data, start + 4 + (i * 8));
        var encodingId = parse.getUShort(data, start + 4 + (i * 8) + 2);
        if (platformId === 3 && (encodingId === 0 || encodingId === 1 || encodingId === 10)) {
            offset = parse.getULong(data, start + 4 + (i * 8) + 4);
            break;
        }
    }

    if (offset === -1) {
        // There is no cmap table in the font that we support.
        throw new Error('No valid cmap sub-tables found.');
    }

    var p = new parse.Parser(data, start + offset);
    cmap.format = p.parseUShort();

    if (cmap.format === 12) {
        parseCmapTableFormat12(cmap, p);
    } else if (cmap.format === 4) {
        parseCmapTableFormat4(cmap, p, data, start, offset);
    } else {
        throw new Error('Only format 4 and 12 cmap tables are supported (found format ' + cmap.format + ').');
    }

    return cmap;
}

function addSegment(t, code, glyphIndex) {
    t.segments.push({
        end: code,
        start: code,
        delta: -(code - glyphIndex),
        offset: 0,
        glyphIndex: glyphIndex
    });
}

function addTerminatorSegment(t) {
    t.segments.push({
        end: 0xFFFF,
        start: 0xFFFF,
        delta: 1,
        offset: 0
    });
}

// Make cmap table, format 4 by default, 12 if needed only
function makeCmapTable(glyphs) {
    // Plan 0 is the base Unicode Plan but emojis, for example are on another plan, and needs cmap 12 format (with 32bit)
    var isPlan0Only = true;
    var i;

    // Check if we need to add cmap format 12 or if format 4 only is fine
    for (i = glyphs.length - 1; i > 0; i -= 1) {
        var g = glyphs.get(i);
        if (g.unicode > 65535) {
            console.log('Adding CMAP format 12 (needed!)');
            isPlan0Only = false;
            break;
        }
    }

    var cmapTable = [
        {name: 'version', type: 'USHORT', value: 0},
        {name: 'numTables', type: 'USHORT', value: isPlan0Only ? 1 : 2},

        // CMAP 4 header
        {name: 'platformID', type: 'USHORT', value: 3},
        {name: 'encodingID', type: 'USHORT', value: 1},
        {name: 'offset', type: 'ULONG', value: isPlan0Only ? 12 : (12 + 8)}
    ];

    if (!isPlan0Only)
        { cmapTable = cmapTable.concat([
            // CMAP 12 header
            {name: 'cmap12PlatformID', type: 'USHORT', value: 3}, // We encode only for PlatformID = 3 (Windows) because it is supported everywhere
            {name: 'cmap12EncodingID', type: 'USHORT', value: 10},
            {name: 'cmap12Offset', type: 'ULONG', value: 0}
        ]); }

    cmapTable = cmapTable.concat([
        // CMAP 4 Subtable
        {name: 'format', type: 'USHORT', value: 4},
        {name: 'cmap4Length', type: 'USHORT', value: 0},
        {name: 'language', type: 'USHORT', value: 0},
        {name: 'segCountX2', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);

    var t = new table.Table('cmap', cmapTable);

    t.segments = [];
    for (i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        for (var j = 0; j < glyph.unicodes.length; j += 1) {
            addSegment(t, glyph.unicodes[j], i);
        }

        t.segments = t.segments.sort(function (a, b) {
            return a.start - b.start;
        });
    }

    addTerminatorSegment(t);

    var segCount = t.segments.length;
    var segCountToRemove = 0;

    // CMAP 4
    // Set up parallel segment arrays.
    var endCounts = [];
    var startCounts = [];
    var idDeltas = [];
    var idRangeOffsets = [];
    var glyphIds = [];

    // CMAP 12
    var cmap12Groups = [];

    // Reminder this loop is not following the specification at 100%
    // The specification -> find suites of characters and make a group
    // Here we're doing one group for each letter
    // Doing as the spec can save 8 times (or more) space
    for (i = 0; i < segCount; i += 1) {
        var segment = t.segments[i];

        // CMAP 4
        if (segment.end <= 65535 && segment.start <= 65535) {
            endCounts = endCounts.concat({name: 'end_' + i, type: 'USHORT', value: segment.end});
            startCounts = startCounts.concat({name: 'start_' + i, type: 'USHORT', value: segment.start});
            idDeltas = idDeltas.concat({name: 'idDelta_' + i, type: 'SHORT', value: segment.delta});
            idRangeOffsets = idRangeOffsets.concat({name: 'idRangeOffset_' + i, type: 'USHORT', value: segment.offset});
            if (segment.glyphId !== undefined) {
                glyphIds = glyphIds.concat({name: 'glyph_' + i, type: 'USHORT', value: segment.glyphId});
            }
        } else {
            // Skip Unicode > 65535 (16bit unsigned max) for CMAP 4, will be added in CMAP 12
            segCountToRemove += 1;
        }

        // CMAP 12
        // Skip Terminator Segment
        if (!isPlan0Only && segment.glyphIndex !== undefined) {
            cmap12Groups = cmap12Groups.concat({name: 'cmap12Start_' + i, type: 'ULONG', value: segment.start});
            cmap12Groups = cmap12Groups.concat({name: 'cmap12End_' + i, type: 'ULONG', value: segment.end});
            cmap12Groups = cmap12Groups.concat({name: 'cmap12Glyph_' + i, type: 'ULONG', value: segment.glyphIndex});
        }
    }

    // CMAP 4 Subtable
    t.segCountX2 = (segCount - segCountToRemove) * 2;
    t.searchRange = Math.pow(2, Math.floor(Math.log((segCount - segCountToRemove)) / Math.log(2))) * 2;
    t.entrySelector = Math.log(t.searchRange / 2) / Math.log(2);
    t.rangeShift = t.segCountX2 - t.searchRange;

    t.fields = t.fields.concat(endCounts);
    t.fields.push({name: 'reservedPad', type: 'USHORT', value: 0});
    t.fields = t.fields.concat(startCounts);
    t.fields = t.fields.concat(idDeltas);
    t.fields = t.fields.concat(idRangeOffsets);
    t.fields = t.fields.concat(glyphIds);

    t.cmap4Length = 14 + // Subtable header
        endCounts.length * 2 +
        2 + // reservedPad
        startCounts.length * 2 +
        idDeltas.length * 2 +
        idRangeOffsets.length * 2 +
        glyphIds.length * 2;

    if (!isPlan0Only) {
        // CMAP 12 Subtable
        var cmap12Length = 16 + // Subtable header
            cmap12Groups.length * 4;

        t.cmap12Offset = 12 + (2 * 2) + 4 + t.cmap4Length;
        t.fields = t.fields.concat([
            {name: 'cmap12Format', type: 'USHORT', value: 12},
            {name: 'cmap12Reserved', type: 'USHORT', value: 0},
            {name: 'cmap12Length', type: 'ULONG', value: cmap12Length},
            {name: 'cmap12Language', type: 'ULONG', value: 0},
            {name: 'cmap12nGroups', type: 'ULONG', value: cmap12Groups.length / 3}
        ]);

        t.fields = t.fields.concat(cmap12Groups);
    }

    return t;
}

var cmap = { parse: parseCmapTable, make: makeCmapTable };

// Glyph encoding

var cffStandardStrings = [
    '.notdef', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'exclamdown', 'cent', 'sterling',
    'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle', 'quotedblleft', 'guillemotleft',
    'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'endash', 'dagger', 'daggerdbl', 'periodcentered', 'paragraph',
    'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright', 'guillemotright', 'ellipsis', 'perthousand',
    'questiondown', 'grave', 'acute', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'dieresis', 'ring',
    'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'emdash', 'AE', 'ordfeminine', 'Lslash', 'Oslash', 'OE',
    'ordmasculine', 'ae', 'dotlessi', 'lslash', 'oslash', 'oe', 'germandbls', 'onesuperior', 'logicalnot', 'mu',
    'trademark', 'Eth', 'onehalf', 'plusminus', 'Thorn', 'onequarter', 'divide', 'brokenbar', 'degree', 'thorn',
    'threequarters', 'twosuperior', 'registered', 'minus', 'eth', 'multiply', 'threesuperior', 'copyright',
    'Aacute', 'Acircumflex', 'Adieresis', 'Agrave', 'Aring', 'Atilde', 'Ccedilla', 'Eacute', 'Ecircumflex',
    'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Ntilde', 'Oacute', 'Ocircumflex',
    'Odieresis', 'Ograve', 'Otilde', 'Scaron', 'Uacute', 'Ucircumflex', 'Udieresis', 'Ugrave', 'Yacute',
    'Ydieresis', 'Zcaron', 'aacute', 'acircumflex', 'adieresis', 'agrave', 'aring', 'atilde', 'ccedilla', 'eacute',
    'ecircumflex', 'edieresis', 'egrave', 'iacute', 'icircumflex', 'idieresis', 'igrave', 'ntilde', 'oacute',
    'ocircumflex', 'odieresis', 'ograve', 'otilde', 'scaron', 'uacute', 'ucircumflex', 'udieresis', 'ugrave',
    'yacute', 'ydieresis', 'zcaron', 'exclamsmall', 'Hungarumlautsmall', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', '266 ff', 'onedotenleader',
    'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle', 'fouroldstyle', 'fiveoldstyle', 'sixoldstyle',
    'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'commasuperior', 'threequartersemdash', 'periodsuperior',
    'questionsmall', 'asuperior', 'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', 'isuperior', 'lsuperior',
    'msuperior', 'nsuperior', 'osuperior', 'rsuperior', 'ssuperior', 'tsuperior', 'ff', 'ffi', 'ffl',
    'parenleftinferior', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', 'exclamdownsmall',
    'centoldstyle', 'Lslashsmall', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall', 'Brevesmall', 'Caronsmall',
    'Dotaccentsmall', 'Macronsmall', 'figuredash', 'hypheninferior', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds',
    'zerosuperior', 'foursuperior', 'fivesuperior', 'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior',
    'zeroinferior', 'oneinferior', 'twoinferior', 'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior',
    'seveninferior', 'eightinferior', 'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior',
    'commainferior', 'Agravesmall', 'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall',
    'Aringsmall', 'AEsmall', 'Ccedillasmall', 'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall',
    'Igravesmall', 'Iacutesmall', 'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall',
    'Oacutesmall', 'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall',
    'Uacutesmall', 'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall', '001.000',
    '001.001', '001.002', '001.003', 'Black', 'Bold', 'Book', 'Light', 'Medium', 'Regular', 'Roman', 'Semibold'];

var cffStandardEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quoteright',
    'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two',
    'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater',
    'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',
    'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore',
    'quoteleft', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
    'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', '', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdown', 'cent', 'sterling', 'fraction', 'yen', 'florin', 'section', 'currency', 'quotesingle',
    'quotedblleft', 'guillemotleft', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', '', 'endash', 'dagger',
    'daggerdbl', 'periodcentered', '', 'paragraph', 'bullet', 'quotesinglbase', 'quotedblbase', 'quotedblright',
    'guillemotright', 'ellipsis', 'perthousand', '', 'questiondown', '', 'grave', 'acute', 'circumflex', 'tilde',
    'macron', 'breve', 'dotaccent', 'dieresis', '', 'ring', 'cedilla', '', 'hungarumlaut', 'ogonek', 'caron',
    'emdash', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', 'AE', '', 'ordfeminine', '', '', '',
    '', 'Lslash', 'Oslash', 'OE', 'ordmasculine', '', '', '', '', '', 'ae', '', '', '', 'dotlessi', '', '',
    'lslash', 'oslash', 'oe', 'germandbls'];

var cffExpertEncoding = [
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    '', '', '', '', 'space', 'exclamsmall', 'Hungarumlautsmall', '', 'dollaroldstyle', 'dollarsuperior',
    'ampersandsmall', 'Acutesmall', 'parenleftsuperior', 'parenrightsuperior', 'twodotenleader', 'onedotenleader',
    'comma', 'hyphen', 'period', 'fraction', 'zerooldstyle', 'oneoldstyle', 'twooldstyle', 'threeoldstyle',
    'fouroldstyle', 'fiveoldstyle', 'sixoldstyle', 'sevenoldstyle', 'eightoldstyle', 'nineoldstyle', 'colon',
    'semicolon', 'commasuperior', 'threequartersemdash', 'periodsuperior', 'questionsmall', '', 'asuperior',
    'bsuperior', 'centsuperior', 'dsuperior', 'esuperior', '', '', 'isuperior', '', '', 'lsuperior', 'msuperior',
    'nsuperior', 'osuperior', '', '', 'rsuperior', 'ssuperior', 'tsuperior', '', 'ff', 'fi', 'fl', 'ffi', 'ffl',
    'parenleftinferior', '', 'parenrightinferior', 'Circumflexsmall', 'hyphensuperior', 'Gravesmall', 'Asmall',
    'Bsmall', 'Csmall', 'Dsmall', 'Esmall', 'Fsmall', 'Gsmall', 'Hsmall', 'Ismall', 'Jsmall', 'Ksmall', 'Lsmall',
    'Msmall', 'Nsmall', 'Osmall', 'Psmall', 'Qsmall', 'Rsmall', 'Ssmall', 'Tsmall', 'Usmall', 'Vsmall', 'Wsmall',
    'Xsmall', 'Ysmall', 'Zsmall', 'colonmonetary', 'onefitted', 'rupiah', 'Tildesmall', '', '', '', '', '', '', '',
    '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',
    'exclamdownsmall', 'centoldstyle', 'Lslashsmall', '', '', 'Scaronsmall', 'Zcaronsmall', 'Dieresissmall',
    'Brevesmall', 'Caronsmall', '', 'Dotaccentsmall', '', '', 'Macronsmall', '', '', 'figuredash', 'hypheninferior',
    '', '', 'Ogoneksmall', 'Ringsmall', 'Cedillasmall', '', '', '', 'onequarter', 'onehalf', 'threequarters',
    'questiondownsmall', 'oneeighth', 'threeeighths', 'fiveeighths', 'seveneighths', 'onethird', 'twothirds', '',
    '', 'zerosuperior', 'onesuperior', 'twosuperior', 'threesuperior', 'foursuperior', 'fivesuperior',
    'sixsuperior', 'sevensuperior', 'eightsuperior', 'ninesuperior', 'zeroinferior', 'oneinferior', 'twoinferior',
    'threeinferior', 'fourinferior', 'fiveinferior', 'sixinferior', 'seveninferior', 'eightinferior',
    'nineinferior', 'centinferior', 'dollarinferior', 'periodinferior', 'commainferior', 'Agravesmall',
    'Aacutesmall', 'Acircumflexsmall', 'Atildesmall', 'Adieresissmall', 'Aringsmall', 'AEsmall', 'Ccedillasmall',
    'Egravesmall', 'Eacutesmall', 'Ecircumflexsmall', 'Edieresissmall', 'Igravesmall', 'Iacutesmall',
    'Icircumflexsmall', 'Idieresissmall', 'Ethsmall', 'Ntildesmall', 'Ogravesmall', 'Oacutesmall',
    'Ocircumflexsmall', 'Otildesmall', 'Odieresissmall', 'OEsmall', 'Oslashsmall', 'Ugravesmall', 'Uacutesmall',
    'Ucircumflexsmall', 'Udieresissmall', 'Yacutesmall', 'Thornsmall', 'Ydieresissmall'];

var standardNames = [
    '.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent',
    'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash',
    'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less',
    'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright',
    'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde',
    'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave',
    'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis',
    'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis',
    'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section',
    'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal',
    'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation',
    'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown',
    'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright',
    'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft',
    'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction',
    'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase',
    'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute',
    'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex',
    'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut',
    'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth',
    'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior',
    'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla',
    'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];

/**
 * This is the encoding used for fonts created from scratch.
 * It loops through all glyphs and finds the appropriate unicode value.
 * Since it's linear time, other encodings will be faster.
 * @exports opentype.DefaultEncoding
 * @class
 * @constructor
 * @param {opentype.Font}
 */
function DefaultEncoding(font) {
    this.font = font;
}

DefaultEncoding.prototype.charToGlyphIndex = function(c) {
    var code = c.charCodeAt(0);
    var glyphs = this.font.glyphs;
    if (glyphs) {
        for (var i = 0; i < glyphs.length; i += 1) {
            var glyph = glyphs.get(i);
            for (var j = 0; j < glyph.unicodes.length; j += 1) {
                if (glyph.unicodes[j] === code) {
                    return i;
                }
            }
        }
    }
    return null;
};

/**
 * @exports opentype.CmapEncoding
 * @class
 * @constructor
 * @param {Object} cmap - a object with the cmap encoded data
 */
function CmapEncoding(cmap) {
    this.cmap = cmap;
}

/**
 * @param  {string} c - the character
 * @return {number} The glyph index.
 */
CmapEncoding.prototype.charToGlyphIndex = function(c) {
    return this.cmap.glyphIndexMap[c.charCodeAt(0)] || 0;
};

/**
 * @exports opentype.CffEncoding
 * @class
 * @constructor
 * @param {string} encoding - The encoding
 * @param {Array} charset - The character set.
 */
function CffEncoding(encoding, charset) {
    this.encoding = encoding;
    this.charset = charset;
}

/**
 * @param  {string} s - The character
 * @return {number} The index.
 */
CffEncoding.prototype.charToGlyphIndex = function(s) {
    var code = s.charCodeAt(0);
    var charName = this.encoding[code];
    return this.charset.indexOf(charName);
};

/**
 * @exports opentype.GlyphNames
 * @class
 * @constructor
 * @param {Object} post
 */
function GlyphNames(post) {
    var this$1 = this;

    switch (post.version) {
        case 1:
            this.names = standardNames.slice();
            break;
        case 2:
            this.names = new Array(post.numberOfGlyphs);
            for (var i = 0; i < post.numberOfGlyphs; i++) {
                if (post.glyphNameIndex[i] < standardNames.length) {
                    this$1.names[i] = standardNames[post.glyphNameIndex[i]];
                } else {
                    this$1.names[i] = post.names[post.glyphNameIndex[i] - standardNames.length];
                }
            }

            break;
        case 2.5:
            this.names = new Array(post.numberOfGlyphs);
            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
                this$1.names[i$1] = standardNames[i$1 + post.glyphNameIndex[i$1]];
            }

            break;
        case 3:
            this.names = [];
            break;
        default:
            this.names = [];
            break;
    }
}

/**
 * Gets the index of a glyph by name.
 * @param  {string} name - The glyph name
 * @return {number} The index
 */
GlyphNames.prototype.nameToGlyphIndex = function(name) {
    return this.names.indexOf(name);
};

/**
 * @param  {number} gid
 * @return {string}
 */
GlyphNames.prototype.glyphIndexToName = function(gid) {
    return this.names[gid];
};

/**
 * @alias opentype.addGlyphNames
 * @param {opentype.Font}
 */
function addGlyphNames(font) {
    var glyph;
    var glyphIndexMap = font.tables.cmap.glyphIndexMap;
    var charCodes = Object.keys(glyphIndexMap);

    for (var i = 0; i < charCodes.length; i += 1) {
        var c = charCodes[i];
        var glyphIndex = glyphIndexMap[c];
        glyph = font.glyphs.get(glyphIndex);
        glyph.addUnicode(parseInt(c));
    }

    for (var i$1 = 0; i$1 < font.glyphs.length; i$1 += 1) {
        glyph = font.glyphs.get(i$1);
        if (font.cffEncoding) {
            if (font.isCIDFont) {
                glyph.name = 'gid' + i$1;
            } else {
                glyph.name = font.cffEncoding.charset[i$1];
            }
        } else if (font.glyphNames.names) {
            glyph.name = font.glyphNames.glyphIndexToName(i$1);
        }
    }
}

// Drawing utility functions.

// Draw a line on the given context from point `x1,y1` to point `x2,y2`.
function line(ctx, x1, y1, x2, y2) {
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
}

var draw = { line: line };

// The `glyf` table describes the glyphs in TrueType outline format.
// http://www.microsoft.com/typography/otspec/glyf.htm

// Parse the coordinate data for a glyph.
function parseGlyphCoordinate(p, flag, previousValue, shortVectorBitMask, sameBitMask) {
    var v;
    if ((flag & shortVectorBitMask) > 0) {
        // The coordinate is 1 byte long.
        v = p.parseByte();
        // The `same` bit is re-used for short values to signify the sign of the value.
        if ((flag & sameBitMask) === 0) {
            v = -v;
        }

        v = previousValue + v;
    } else {
        //  The coordinate is 2 bytes long.
        // If the `same` bit is set, the coordinate is the same as the previous coordinate.
        if ((flag & sameBitMask) > 0) {
            v = previousValue;
        } else {
            // Parse the coordinate as a signed 16-bit delta value.
            v = previousValue + p.parseShort();
        }
    }

    return v;
}

// Parse a TrueType glyph.
function parseGlyph(glyph, data, start) {
    var p = new parse.Parser(data, start);
    glyph.numberOfContours = p.parseShort();
    glyph._xMin = p.parseShort();
    glyph._yMin = p.parseShort();
    glyph._xMax = p.parseShort();
    glyph._yMax = p.parseShort();
    var flags;
    var flag;

    if (glyph.numberOfContours > 0) {
        // This glyph is not a composite.
        var endPointIndices = glyph.endPointIndices = [];
        for (var i = 0; i < glyph.numberOfContours; i += 1) {
            endPointIndices.push(p.parseUShort());
        }

        glyph.instructionLength = p.parseUShort();
        glyph.instructions = [];
        for (var i$1 = 0; i$1 < glyph.instructionLength; i$1 += 1) {
            glyph.instructions.push(p.parseByte());
        }

        var numberOfCoordinates = endPointIndices[endPointIndices.length - 1] + 1;
        flags = [];
        for (var i$2 = 0; i$2 < numberOfCoordinates; i$2 += 1) {
            flag = p.parseByte();
            flags.push(flag);
            // If bit 3 is set, we repeat this flag n times, where n is the next byte.
            if ((flag & 8) > 0) {
                var repeatCount = p.parseByte();
                for (var j = 0; j < repeatCount; j += 1) {
                    flags.push(flag);
                    i$2 += 1;
                }
            }
        }

        check.argument(flags.length === numberOfCoordinates, 'Bad flags.');

        if (endPointIndices.length > 0) {
            var points = [];
            var point;
            // X/Y coordinates are relative to the previous point, except for the first point which is relative to 0,0.
            if (numberOfCoordinates > 0) {
                for (var i$3 = 0; i$3 < numberOfCoordinates; i$3 += 1) {
                    flag = flags[i$3];
                    point = {};
                    point.onCurve = !!(flag & 1);
                    point.lastPointOfContour = endPointIndices.indexOf(i$3) >= 0;
                    points.push(point);
                }

                var px = 0;
                for (var i$4 = 0; i$4 < numberOfCoordinates; i$4 += 1) {
                    flag = flags[i$4];
                    point = points[i$4];
                    point.x = parseGlyphCoordinate(p, flag, px, 2, 16);
                    px = point.x;
                }

                var py = 0;
                for (var i$5 = 0; i$5 < numberOfCoordinates; i$5 += 1) {
                    flag = flags[i$5];
                    point = points[i$5];
                    point.y = parseGlyphCoordinate(p, flag, py, 4, 32);
                    py = point.y;
                }
            }

            glyph.points = points;
        } else {
            glyph.points = [];
        }
    } else if (glyph.numberOfContours === 0) {
        glyph.points = [];
    } else {
        glyph.isComposite = true;
        glyph.points = [];
        glyph.components = [];
        var moreComponents = true;
        while (moreComponents) {
            flags = p.parseUShort();
            var component = {
                glyphIndex: p.parseUShort(),
                xScale: 1,
                scale01: 0,
                scale10: 0,
                yScale: 1,
                dx: 0,
                dy: 0
            };
            if ((flags & 1) > 0) {
                // The arguments are words
                if ((flags & 2) > 0) {
                    // values are offset
                    component.dx = p.parseShort();
                    component.dy = p.parseShort();
                } else {
                    // values are matched points
                    component.matchedPoints = [p.parseUShort(), p.parseUShort()];
                }

            } else {
                // The arguments are bytes
                if ((flags & 2) > 0) {
                    // values are offset
                    component.dx = p.parseChar();
                    component.dy = p.parseChar();
                } else {
                    // values are matched points
                    component.matchedPoints = [p.parseByte(), p.parseByte()];
                }
            }

            if ((flags & 8) > 0) {
                // We have a scale
                component.xScale = component.yScale = p.parseF2Dot14();
            } else if ((flags & 64) > 0) {
                // We have an X / Y scale
                component.xScale = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            } else if ((flags & 128) > 0) {
                // We have a 2x2 transformation
                component.xScale = p.parseF2Dot14();
                component.scale01 = p.parseF2Dot14();
                component.scale10 = p.parseF2Dot14();
                component.yScale = p.parseF2Dot14();
            }

            glyph.components.push(component);
            moreComponents = !!(flags & 32);
        }
        if (flags & 0x100) {
            // We have instructions
            glyph.instructionLength = p.parseUShort();
            glyph.instructions = [];
            for (var i$6 = 0; i$6 < glyph.instructionLength; i$6 += 1) {
                glyph.instructions.push(p.parseByte());
            }
        }
    }
}

// Transform an array of points and return a new array.
function transformPoints(points, transform) {
    var newPoints = [];
    for (var i = 0; i < points.length; i += 1) {
        var pt = points[i];
        var newPt = {
            x: transform.xScale * pt.x + transform.scale01 * pt.y + transform.dx,
            y: transform.scale10 * pt.x + transform.yScale * pt.y + transform.dy,
            onCurve: pt.onCurve,
            lastPointOfContour: pt.lastPointOfContour
        };
        newPoints.push(newPt);
    }

    return newPoints;
}

function getContours(points) {
    var contours = [];
    var currentContour = [];
    for (var i = 0; i < points.length; i += 1) {
        var pt = points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }

    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
}

// Convert the TrueType glyph outline to a Path.
function getPath(points) {
    var p = new Path();
    if (!points) {
        return p;
    }

    var contours = getContours(points);

    for (var contourIndex = 0; contourIndex < contours.length; ++contourIndex) {
        var contour = contours[contourIndex];

        var prev = null;
        var curr = contour[contour.length - 1];
        var next = contour[0];

        if (curr.onCurve) {
            p.moveTo(curr.x, curr.y);
        } else {
            if (next.onCurve) {
                p.moveTo(next.x, next.y);
            } else {
                // If both first and last points are off-curve, start at their middle.
                var start = {x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5};
                p.moveTo(start.x, start.y);
            }
        }

        for (var i = 0; i < contour.length; ++i) {
            prev = curr;
            curr = next;
            next = contour[(i + 1) % contour.length];

            if (curr.onCurve) {
                // This is a straight line.
                p.lineTo(curr.x, curr.y);
            } else {
                var prev2 = prev;
                var next2 = next;

                if (!prev.onCurve) {
                    prev2 = { x: (curr.x + prev.x) * 0.5, y: (curr.y + prev.y) * 0.5 };
                    p.lineTo(prev2.x, prev2.y);
                }

                if (!next.onCurve) {
                    next2 = { x: (curr.x + next.x) * 0.5, y: (curr.y + next.y) * 0.5 };
                }

                p.lineTo(prev2.x, prev2.y);
                p.quadraticCurveTo(curr.x, curr.y, next2.x, next2.y);
            }
        }

        p.closePath();
    }
    return p;
}

function buildPath(glyphs, glyph) {
    if (glyph.isComposite) {
        for (var j = 0; j < glyph.components.length; j += 1) {
            var component = glyph.components[j];
            var componentGlyph = glyphs.get(component.glyphIndex);
            // Force the ttfGlyphLoader to parse the glyph.
            componentGlyph.getPath();
            if (componentGlyph.points) {
                var transformedPoints = (void 0);
                if (component.matchedPoints === undefined) {
                    // component positioned by offset
                    transformedPoints = transformPoints(componentGlyph.points, component);
                } else {
                    // component positioned by matched points
                    if ((component.matchedPoints[0] > glyph.points.length - 1) ||
                        (component.matchedPoints[1] > componentGlyph.points.length - 1)) {
                        throw Error('Matched points out of range in ' + glyph.name);
                    }
                    var firstPt = glyph.points[component.matchedPoints[0]];
                    var secondPt = componentGlyph.points[component.matchedPoints[1]];
                    var transform = {
                        xScale: component.xScale, scale01: component.scale01,
                        scale10: component.scale10, yScale: component.yScale,
                        dx: 0, dy: 0
                    };
                    secondPt = transformPoints([secondPt], transform)[0];
                    transform.dx = firstPt.x - secondPt.x;
                    transform.dy = firstPt.y - secondPt.y;
                    transformedPoints = transformPoints(componentGlyph.points, transform);
                }
                glyph.points = glyph.points.concat(transformedPoints);
            }
        }
    }

    return getPath(glyph.points);
}

// Parse all the glyphs according to the offsets from the `loca` table.
function parseGlyfTable(data, start, loca, font) {
    var glyphs = new glyphset.GlyphSet(font);

    // The last element of the loca table is invalid.
    for (var i = 0; i < loca.length - 1; i += 1) {
        var offset = loca[i];
        var nextOffset = loca[i + 1];
        if (offset !== nextOffset) {
            glyphs.push(i, glyphset.ttfGlyphLoader(font, i, parseGlyph, data, start + offset, buildPath));
        } else {
            glyphs.push(i, glyphset.glyphLoader(font, i));
        }
    }

    return glyphs;
}

var glyf = { getPath: getPath, parse: parseGlyfTable };

// The Glyph object

function getPathDefinition(glyph, path) {
    var _path = path || new Path();
    return {
        configurable: true,

        get: function() {
            if (typeof _path === 'function') {
                _path = _path();
            }

            return _path;
        },

        set: function(p) {
            _path = p;
        }
    };
}
/**
 * @typedef GlyphOptions
 * @type Object
 * @property {string} [name] - The glyph name
 * @property {number} [unicode]
 * @property {Array} [unicodes]
 * @property {number} [xMin]
 * @property {number} [yMin]
 * @property {number} [xMax]
 * @property {number} [yMax]
 * @property {number} [advanceWidth]
 */

// A Glyph is an individual mark that often corresponds to a character.
// Some glyphs, such as ligatures, are a combination of many characters.
// Glyphs are the basic building blocks of a font.
//
// The `Glyph` class contains utility methods for drawing the path and its points.
/**
 * @exports opentype.Glyph
 * @class
 * @param {GlyphOptions}
 * @constructor
 */
function Glyph(options) {
    // By putting all the code on a prototype function (which is only declared once)
    // we reduce the memory requirements for larger fonts by some 2%
    this.bindConstructorValues(options);
}

/**
 * @param  {GlyphOptions}
 */
Glyph.prototype.bindConstructorValues = function(options) {
    this.index = options.index || 0;

    // These three values cannot be deferred for memory optimization:
    this.name = options.name || null;
    this.unicode = options.unicode || undefined;
    this.unicodes = options.unicodes || options.unicode !== undefined ? [options.unicode] : [];

    // But by binding these values only when necessary, we reduce can
    // the memory requirements by almost 3% for larger fonts.
    if (options.xMin) {
        this.xMin = options.xMin;
    }

    if (options.yMin) {
        this.yMin = options.yMin;
    }

    if (options.xMax) {
        this.xMax = options.xMax;
    }

    if (options.yMax) {
        this.yMax = options.yMax;
    }

    if (options.advanceWidth) {
        this.advanceWidth = options.advanceWidth;
    }

    // The path for a glyph is the most memory intensive, and is bound as a value
    // with a getter/setter to ensure we actually do path parsing only once the
    // path is actually needed by anything.
    Object.defineProperty(this, 'path', getPathDefinition(this, options.path));
};

/**
 * @param {number}
 */
Glyph.prototype.addUnicode = function(unicode) {
    if (this.unicodes.length === 0) {
        this.unicode = unicode;
    }

    this.unicodes.push(unicode);
};

/**
 * Calculate the minimum bounding box for this glyph.
 * @return {opentype.BoundingBox}
 */
Glyph.prototype.getBoundingBox = function() {
    return this.path.getBoundingBox();
};

/**
 * Convert the glyph to a Path we can draw on a drawing context.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {Object=} options - xScale, yScale to stretch the glyph.
 * @param  {opentype.Font} if hinting is to be used, the font
 * @return {opentype.Path}
 */
Glyph.prototype.getPath = function(x, y, fontSize, options, font) {
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    var commands;
    var hPoints;
    if (!options) { options = { }; }
    var xScale = options.xScale;
    var yScale = options.yScale;

    if (options.hinting && font && font.hinting) {
        // in case of hinting, the hinting engine takes care
        // of scaling the points (not the path) before hinting.
        hPoints = this.path && font.hinting.exec(this, fontSize);
        // in case the hinting engine failed hPoints is undefined
        // and thus reverts to plain rending
    }

    if (hPoints) {
        commands = glyf.getPath(hPoints).commands;
        x = Math.round(x);
        y = Math.round(y);
        // TODO in case of hinting xyScaling is not yet supported
        xScale = yScale = 1;
    } else {
        commands = this.path.commands;
        var scale = 1 / this.path.unitsPerEm * fontSize;
        if (xScale === undefined) { xScale = scale; }
        if (yScale === undefined) { yScale = scale; }
    }

    var p = new Path();
    for (var i = 0; i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type === 'M') {
            p.moveTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'L') {
            p.lineTo(x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'Q') {
            p.quadraticCurveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
                               x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'C') {
            p.curveTo(x + (cmd.x1 * xScale), y + (-cmd.y1 * yScale),
                      x + (cmd.x2 * xScale), y + (-cmd.y2 * yScale),
                      x + (cmd.x * xScale), y + (-cmd.y * yScale));
        } else if (cmd.type === 'Z') {
            p.closePath();
        }
    }

    return p;
};

/**
 * Split the glyph into contours.
 * This function is here for backwards compatibility, and to
 * provide raw access to the TrueType glyph outlines.
 * @return {Array}
 */
Glyph.prototype.getContours = function() {
    var this$1 = this;

    if (this.points === undefined) {
        return [];
    }

    var contours = [];
    var currentContour = [];
    for (var i = 0; i < this.points.length; i += 1) {
        var pt = this$1.points[i];
        currentContour.push(pt);
        if (pt.lastPointOfContour) {
            contours.push(currentContour);
            currentContour = [];
        }
    }

    check.argument(currentContour.length === 0, 'There are still points left in the current contour.');
    return contours;
};

/**
 * Calculate the xMin/yMin/xMax/yMax/lsb/rsb for a Glyph.
 * @return {Object}
 */
Glyph.prototype.getMetrics = function() {
    var commands = this.path.commands;
    var xCoords = [];
    var yCoords = [];
    for (var i = 0; i < commands.length; i += 1) {
        var cmd = commands[i];
        if (cmd.type !== 'Z') {
            xCoords.push(cmd.x);
            yCoords.push(cmd.y);
        }

        if (cmd.type === 'Q' || cmd.type === 'C') {
            xCoords.push(cmd.x1);
            yCoords.push(cmd.y1);
        }

        if (cmd.type === 'C') {
            xCoords.push(cmd.x2);
            yCoords.push(cmd.y2);
        }
    }

    var metrics = {
        xMin: Math.min.apply(null, xCoords),
        yMin: Math.min.apply(null, yCoords),
        xMax: Math.max.apply(null, xCoords),
        yMax: Math.max.apply(null, yCoords),
        leftSideBearing: this.leftSideBearing
    };

    if (!isFinite(metrics.xMin)) {
        metrics.xMin = 0;
    }

    if (!isFinite(metrics.xMax)) {
        metrics.xMax = this.advanceWidth;
    }

    if (!isFinite(metrics.yMin)) {
        metrics.yMin = 0;
    }

    if (!isFinite(metrics.yMax)) {
        metrics.yMax = 0;
    }

    metrics.rightSideBearing = this.advanceWidth - metrics.leftSideBearing - (metrics.xMax - metrics.xMin);
    return metrics;
};

/**
 * Draw the glyph on the given context.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {Object=} options - xScale, yScale to stretch the glyph.
 */
Glyph.prototype.draw = function(ctx, x, y, fontSize, options) {
    this.getPath(x, y, fontSize, options).draw(ctx);
};

/**
 * Draw the points of the glyph.
 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 */
Glyph.prototype.drawPoints = function(ctx, x, y, fontSize) {
    function drawCircles(l, x, y, scale) {
        var PI_SQ = Math.PI * 2;
        ctx.beginPath();
        for (var j = 0; j < l.length; j += 1) {
            ctx.moveTo(x + (l[j].x * scale), y + (l[j].y * scale));
            ctx.arc(x + (l[j].x * scale), y + (l[j].y * scale), 2, 0, PI_SQ, false);
        }

        ctx.closePath();
        ctx.fill();
    }

    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    var scale = 1 / this.path.unitsPerEm * fontSize;

    var blueCircles = [];
    var redCircles = [];
    var path = this.path;
    for (var i = 0; i < path.commands.length; i += 1) {
        var cmd = path.commands[i];
        if (cmd.x !== undefined) {
            blueCircles.push({x: cmd.x, y: -cmd.y});
        }

        if (cmd.x1 !== undefined) {
            redCircles.push({x: cmd.x1, y: -cmd.y1});
        }

        if (cmd.x2 !== undefined) {
            redCircles.push({x: cmd.x2, y: -cmd.y2});
        }
    }

    ctx.fillStyle = 'blue';
    drawCircles(blueCircles, x, y, scale);
    ctx.fillStyle = 'red';
    drawCircles(redCircles, x, y, scale);
};

/**
 * Draw lines indicating important font measurements.
 * Black lines indicate the origin of the coordinate system (point 0,0).
 * Blue lines indicate the glyph bounding box.
 * Green line indicates the advance width of the glyph.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 */
Glyph.prototype.drawMetrics = function(ctx, x, y, fontSize) {
    var scale;
    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 24;
    scale = 1 / this.path.unitsPerEm * fontSize;
    ctx.lineWidth = 1;

    // Draw the origin
    ctx.strokeStyle = 'black';
    draw.line(ctx, x, -10000, x, 10000);
    draw.line(ctx, -10000, y, 10000, y);

    // This code is here due to memory optimization: by not using
    // defaults in the constructor, we save a notable amount of memory.
    var xMin = this.xMin || 0;
    var yMin = this.yMin || 0;
    var xMax = this.xMax || 0;
    var yMax = this.yMax || 0;
    var advanceWidth = this.advanceWidth || 0;

    // Draw the glyph box
    ctx.strokeStyle = 'blue';
    draw.line(ctx, x + (xMin * scale), -10000, x + (xMin * scale), 10000);
    draw.line(ctx, x + (xMax * scale), -10000, x + (xMax * scale), 10000);
    draw.line(ctx, -10000, y + (-yMin * scale), 10000, y + (-yMin * scale));
    draw.line(ctx, -10000, y + (-yMax * scale), 10000, y + (-yMax * scale));

    // Draw the advance width
    ctx.strokeStyle = 'green';
    draw.line(ctx, x + (advanceWidth * scale), -10000, x + (advanceWidth * scale), 10000);
};

// The GlyphSet object

// Define a property on the glyph that depends on the path being loaded.
function defineDependentProperty(glyph, externalName, internalName) {
    Object.defineProperty(glyph, externalName, {
        get: function() {
            // Request the path property to make sure the path is loaded.
            glyph.path; // jshint ignore:line
            return glyph[internalName];
        },
        set: function(newValue) {
            glyph[internalName] = newValue;
        },
        enumerable: true,
        configurable: true
    });
}

/**
 * A GlyphSet represents all glyphs available in the font, but modelled using
 * a deferred glyph loader, for retrieving glyphs only once they are absolutely
 * necessary, to keep the memory footprint down.
 * @exports opentype.GlyphSet
 * @class
 * @param {opentype.Font}
 * @param {Array}
 */
function GlyphSet(font, glyphs) {
    var this$1 = this;

    this.font = font;
    this.glyphs = {};
    if (Array.isArray(glyphs)) {
        for (var i = 0; i < glyphs.length; i++) {
            this$1.glyphs[i] = glyphs[i];
        }
    }

    this.length = (glyphs && glyphs.length) || 0;
}

/**
 * @param  {number} index
 * @return {opentype.Glyph}
 */
GlyphSet.prototype.get = function(index) {
    if (typeof this.glyphs[index] === 'function') {
        this.glyphs[index] = this.glyphs[index]();
    }

    return this.glyphs[index];
};

/**
 * @param  {number} index
 * @param  {Object}
 */
GlyphSet.prototype.push = function(index, loader) {
    this.glyphs[index] = loader;
    this.length++;
};

/**
 * @alias opentype.glyphLoader
 * @param  {opentype.Font} font
 * @param  {number} index
 * @return {opentype.Glyph}
 */
function glyphLoader(font, index) {
    return new Glyph({index: index, font: font});
}

/**
 * Generate a stub glyph that can be filled with all metadata *except*
 * the "points" and "path" properties, which must be loaded only once
 * the glyph's path is actually requested for text shaping.
 * @alias opentype.ttfGlyphLoader
 * @param  {opentype.Font} font
 * @param  {number} index
 * @param  {Function} parseGlyph
 * @param  {Object} data
 * @param  {number} position
 * @param  {Function} buildPath
 * @return {opentype.Glyph}
 */
function ttfGlyphLoader(font, index, parseGlyph, data, position, buildPath) {
    return function() {
        var glyph = new Glyph({index: index, font: font});

        glyph.path = function() {
            parseGlyph(glyph, data, position);
            var path = buildPath(font.glyphs, glyph);
            path.unitsPerEm = font.unitsPerEm;
            return path;
        };

        defineDependentProperty(glyph, 'xMin', '_xMin');
        defineDependentProperty(glyph, 'xMax', '_xMax');
        defineDependentProperty(glyph, 'yMin', '_yMin');
        defineDependentProperty(glyph, 'yMax', '_yMax');

        return glyph;
    };
}
/**
 * @alias opentype.cffGlyphLoader
 * @param  {opentype.Font} font
 * @param  {number} index
 * @param  {Function} parseCFFCharstring
 * @param  {string} charstring
 * @return {opentype.Glyph}
 */
function cffGlyphLoader(font, index, parseCFFCharstring, charstring) {
    return function() {
        var glyph = new Glyph({index: index, font: font});

        glyph.path = function() {
            var path = parseCFFCharstring(font, glyph, charstring);
            path.unitsPerEm = font.unitsPerEm;
            return path;
        };

        return glyph;
    };
}

var glyphset = { GlyphSet: GlyphSet, glyphLoader: glyphLoader, ttfGlyphLoader: ttfGlyphLoader, cffGlyphLoader: cffGlyphLoader };

// The `CFF` table contains the glyph outlines in PostScript format.
// https://www.microsoft.com/typography/OTSPEC/cff.htm
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/cff.pdf
// http://download.microsoft.com/download/8/0/1/801a191c-029d-4af3-9642-555f6fe514ee/type2.pdf

// Custom equals function that can also check lists.
function equals(a, b) {
    if (a === b) {
        return true;
    } else if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return false;
        }

        for (var i = 0; i < a.length; i += 1) {
            if (!equals(a[i], b[i])) {
                return false;
            }
        }

        return true;
    } else {
        return false;
    }
}

// Subroutines are encoded using the negative half of the number space.
// See type 2 chapter 4.7 "Subroutine operators".
function calcCFFSubroutineBias(subrs) {
    var bias;
    if (subrs.length < 1240) {
        bias = 107;
    } else if (subrs.length < 33900) {
        bias = 1131;
    } else {
        bias = 32768;
    }

    return bias;
}

// Parse a `CFF` INDEX array.
// An index array consists of a list of offsets, then a list of objects at those offsets.
function parseCFFIndex(data, start, conversionFn) {
    var offsets = [];
    var objects = [];
    var count = parse.getCard16(data, start);
    var objectOffset;
    var endOffset;
    if (count !== 0) {
        var offsetSize = parse.getByte(data, start + 2);
        objectOffset = start + ((count + 1) * offsetSize) + 2;
        var pos = start + 3;
        for (var i = 0; i < count + 1; i += 1) {
            offsets.push(parse.getOffset(data, pos, offsetSize));
            pos += offsetSize;
        }

        // The total size of the index array is 4 header bytes + the value of the last offset.
        endOffset = objectOffset + offsets[count];
    } else {
        endOffset = start + 2;
    }

    for (var i$1 = 0; i$1 < offsets.length - 1; i$1 += 1) {
        var value = parse.getBytes(data, objectOffset + offsets[i$1], objectOffset + offsets[i$1 + 1]);
        if (conversionFn) {
            value = conversionFn(value);
        }

        objects.push(value);
    }

    return {objects: objects, startOffset: start, endOffset: endOffset};
}

// Parse a `CFF` DICT real value.
function parseFloatOperand(parser) {
    var s = '';
    var eof = 15;
    var lookup = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'E', 'E-', null, '-'];
    while (true) {
        var b = parser.parseByte();
        var n1 = b >> 4;
        var n2 = b & 15;

        if (n1 === eof) {
            break;
        }

        s += lookup[n1];

        if (n2 === eof) {
            break;
        }

        s += lookup[n2];
    }

    return parseFloat(s);
}

// Parse a `CFF` DICT operand.
function parseOperand(parser, b0) {
    var b1;
    var b2;
    var b3;
    var b4;
    if (b0 === 28) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        return b1 << 8 | b2;
    }

    if (b0 === 29) {
        b1 = parser.parseByte();
        b2 = parser.parseByte();
        b3 = parser.parseByte();
        b4 = parser.parseByte();
        return b1 << 24 | b2 << 16 | b3 << 8 | b4;
    }

    if (b0 === 30) {
        return parseFloatOperand(parser);
    }

    if (b0 >= 32 && b0 <= 246) {
        return b0 - 139;
    }

    if (b0 >= 247 && b0 <= 250) {
        b1 = parser.parseByte();
        return (b0 - 247) * 256 + b1 + 108;
    }

    if (b0 >= 251 && b0 <= 254) {
        b1 = parser.parseByte();
        return -(b0 - 251) * 256 - b1 - 108;
    }

    throw new Error('Invalid b0 ' + b0);
}

// Convert the entries returned by `parseDict` to a proper dictionary.
// If a value is a list of one, it is unpacked.
function entriesToObject(entries) {
    var o = {};
    for (var i = 0; i < entries.length; i += 1) {
        var key = entries[i][0];
        var values = entries[i][1];
        var value = (void 0);
        if (values.length === 1) {
            value = values[0];
        } else {
            value = values;
        }

        if (o.hasOwnProperty(key) && !isNaN(o[key])) {
            throw new Error('Object ' + o + ' already has key ' + key);
        }

        o[key] = value;
    }

    return o;
}

// Parse a `CFF` DICT object.
// A dictionary contains key-value pairs in a compact tokenized format.
function parseCFFDict(data, start, size) {
    start = start !== undefined ? start : 0;
    var parser = new parse.Parser(data, start);
    var entries = [];
    var operands = [];
    size = size !== undefined ? size : data.length;

    while (parser.relativeOffset < size) {
        var op = parser.parseByte();

        // The first byte for each dict item distinguishes between operator (key) and operand (value).
        // Values <= 21 are operators.
        if (op <= 21) {
            // Two-byte operators have an initial escape byte of 12.
            if (op === 12) {
                op = 1200 + parser.parseByte();
            }

            entries.push([op, operands]);
            operands = [];
        } else {
            // Since the operands (values) come before the operators (keys), we store all operands in a list
            // until we encounter an operator.
            operands.push(parseOperand(parser, op));
        }
    }

    return entriesToObject(entries);
}

// Given a String Index (SID), return the value of the string.
// Strings below index 392 are standard CFF strings and are not encoded in the font.
function getCFFString(strings, index) {
    if (index <= 390) {
        index = cffStandardStrings[index];
    } else {
        index = strings[index - 391];
    }

    return index;
}

// Interpret a dictionary and return a new dictionary with readable keys and values for missing entries.
// This function takes `meta` which is a list of objects containing `operand`, `name` and `default`.
function interpretDict(dict, meta, strings) {
    var newDict = {};
    var value;

    // Because we also want to include missing values, we start out from the meta list
    // and lookup values in the dict.
    for (var i = 0; i < meta.length; i += 1) {
        var m = meta[i];

        if (Array.isArray(m.type)) {
            var values = [];
            values.length = m.type.length;
            for (var j = 0; j < m.type.length; j++) {
                value = dict[m.op] !== undefined ? dict[m.op][j] : undefined;
                if (value === undefined) {
                    value = m.value !== undefined && m.value[j] !== undefined ? m.value[j] : null;
                }
                if (m.type[j] === 'SID') {
                    value = getCFFString(strings, value);
                }
                values[j] = value;
            }
            newDict[m.name] = values;
        } else {
            value = dict[m.op];
            if (value === undefined) {
                value = m.value !== undefined ? m.value : null;
            }

            if (m.type === 'SID') {
                value = getCFFString(strings, value);
            }
            newDict[m.name] = value;
        }
    }

    return newDict;
}

// Parse the CFF header.
function parseCFFHeader(data, start) {
    var header = {};
    header.formatMajor = parse.getCard8(data, start);
    header.formatMinor = parse.getCard8(data, start + 1);
    header.size = parse.getCard8(data, start + 2);
    header.offsetSize = parse.getCard8(data, start + 3);
    header.startOffset = start;
    header.endOffset = start + 4;
    return header;
}

var TOP_DICT_META = [
    {name: 'version', op: 0, type: 'SID'},
    {name: 'notice', op: 1, type: 'SID'},
    {name: 'copyright', op: 1200, type: 'SID'},
    {name: 'fullName', op: 2, type: 'SID'},
    {name: 'familyName', op: 3, type: 'SID'},
    {name: 'weight', op: 4, type: 'SID'},
    {name: 'isFixedPitch', op: 1201, type: 'number', value: 0},
    {name: 'italicAngle', op: 1202, type: 'number', value: 0},
    {name: 'underlinePosition', op: 1203, type: 'number', value: -100},
    {name: 'underlineThickness', op: 1204, type: 'number', value: 50},
    {name: 'paintType', op: 1205, type: 'number', value: 0},
    {name: 'charstringType', op: 1206, type: 'number', value: 2},
    {
        name: 'fontMatrix',
        op: 1207,
        type: ['real', 'real', 'real', 'real', 'real', 'real'],
        value: [0.001, 0, 0, 0.001, 0, 0]
    },
    {name: 'uniqueId', op: 13, type: 'number'},
    {name: 'fontBBox', op: 5, type: ['number', 'number', 'number', 'number'], value: [0, 0, 0, 0]},
    {name: 'strokeWidth', op: 1208, type: 'number', value: 0},
    {name: 'xuid', op: 14, type: [], value: null},
    {name: 'charset', op: 15, type: 'offset', value: 0},
    {name: 'encoding', op: 16, type: 'offset', value: 0},
    {name: 'charStrings', op: 17, type: 'offset', value: 0},
    {name: 'private', op: 18, type: ['number', 'offset'], value: [0, 0]},
    {name: 'ros', op: 1230, type: ['SID', 'SID', 'number']},
    {name: 'cidFontVersion', op: 1231, type: 'number', value: 0},
    {name: 'cidFontRevision', op: 1232, type: 'number', value: 0},
    {name: 'cidFontType', op: 1233, type: 'number', value: 0},
    {name: 'cidCount', op: 1234, type: 'number', value: 8720},
    {name: 'uidBase', op: 1235, type: 'number'},
    {name: 'fdArray', op: 1236, type: 'offset'},
    {name: 'fdSelect', op: 1237, type: 'offset'},
    {name: 'fontName', op: 1238, type: 'SID'}
];

var PRIVATE_DICT_META = [
    {name: 'subrs', op: 19, type: 'offset', value: 0},
    {name: 'defaultWidthX', op: 20, type: 'number', value: 0},
    {name: 'nominalWidthX', op: 21, type: 'number', value: 0}
];

// Parse the CFF top dictionary. A CFF table can contain multiple fonts, each with their own top dictionary.
// The top dictionary contains the essential metadata for the font, together with the private dictionary.
function parseCFFTopDict(data, strings) {
    var dict = parseCFFDict(data, 0, data.byteLength);
    return interpretDict(dict, TOP_DICT_META, strings);
}

// Parse the CFF private dictionary. We don't fully parse out all the values, only the ones we need.
function parseCFFPrivateDict(data, start, size, strings) {
    var dict = parseCFFDict(data, start, size);
    return interpretDict(dict, PRIVATE_DICT_META, strings);
}

// Returns a list of "Top DICT"s found using an INDEX list.
// Used to read both the usual high-level Top DICTs and also the FDArray
// discovered inside CID-keyed fonts.  When a Top DICT has a reference to
// a Private DICT that is read and saved into the Top DICT.
//
// In addition to the expected/optional values as outlined in TOP_DICT_META
// the following values might be saved into the Top DICT.
//
//    _subrs []        array of local CFF subroutines from Private DICT
//    _subrsBias       bias value computed from number of subroutines
//                      (see calcCFFSubroutineBias() and parseCFFCharstring())
//    _defaultWidthX   default widths for CFF characters
//    _nominalWidthX   bias added to width embedded within glyph description
//
//    _privateDict     saved copy of parsed Private DICT from Top DICT
function gatherCFFTopDicts(data, start, cffIndex, strings) {
    var topDictArray = [];
    for (var iTopDict = 0; iTopDict < cffIndex.length; iTopDict += 1) {
        var topDictData = new DataView(new Uint8Array(cffIndex[iTopDict]).buffer);
        var topDict = parseCFFTopDict(topDictData, strings);
        topDict._subrs = [];
        topDict._subrsBias = 0;
        var privateSize = topDict.private[0];
        var privateOffset = topDict.private[1];
        if (privateSize !== 0 && privateOffset !== 0) {
            var privateDict = parseCFFPrivateDict(data, privateOffset + start, privateSize, strings);
            topDict._defaultWidthX = privateDict.defaultWidthX;
            topDict._nominalWidthX = privateDict.nominalWidthX;
            if (privateDict.subrs !== 0) {
                var subrOffset = privateOffset + privateDict.subrs;
                var subrIndex = parseCFFIndex(data, subrOffset + start);
                topDict._subrs = subrIndex.objects;
                topDict._subrsBias = calcCFFSubroutineBias(topDict._subrs);
            }
            topDict._privateDict = privateDict;
        }
        topDictArray.push(topDict);
    }
    return topDictArray;
}

// Parse the CFF charset table, which contains internal names for all the glyphs.
// This function will return a list of glyph names.
// See Adobe TN #5176 chapter 13, "Charsets".
function parseCFFCharset(data, start, nGlyphs, strings) {
    var sid;
    var count;
    var parser = new parse.Parser(data, start);

    // The .notdef glyph is not included, so subtract 1.
    nGlyphs -= 1;
    var charset = ['.notdef'];

    var format = parser.parseCard8();
    if (format === 0) {
        for (var i = 0; i < nGlyphs; i += 1) {
            sid = parser.parseSID();
            charset.push(getCFFString(strings, sid));
        }
    } else if (format === 1) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard8();
            for (var i$1 = 0; i$1 <= count; i$1 += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else if (format === 2) {
        while (charset.length <= nGlyphs) {
            sid = parser.parseSID();
            count = parser.parseCard16();
            for (var i$2 = 0; i$2 <= count; i$2 += 1) {
                charset.push(getCFFString(strings, sid));
                sid += 1;
            }
        }
    } else {
        throw new Error('Unknown charset format ' + format);
    }

    return charset;
}

// Parse the CFF encoding data. Only one encoding can be specified per font.
// See Adobe TN #5176 chapter 12, "Encodings".
function parseCFFEncoding(data, start, charset) {
    var code;
    var enc = {};
    var parser = new parse.Parser(data, start);
    var format = parser.parseCard8();
    if (format === 0) {
        var nCodes = parser.parseCard8();
        for (var i = 0; i < nCodes; i += 1) {
            code = parser.parseCard8();
            enc[code] = i;
        }
    } else if (format === 1) {
        var nRanges = parser.parseCard8();
        code = 1;
        for (var i$1 = 0; i$1 < nRanges; i$1 += 1) {
            var first = parser.parseCard8();
            var nLeft = parser.parseCard8();
            for (var j = first; j <= first + nLeft; j += 1) {
                enc[j] = code;
                code += 1;
            }
        }
    } else {
        throw new Error('Unknown encoding format ' + format);
    }

    return new CffEncoding(enc, charset);
}

// Take in charstring code and return a Glyph object.
// The encoding is described in the Type 2 Charstring Format
// https://www.microsoft.com/typography/OTSPEC/charstr2.htm
function parseCFFCharstring(font, glyph, code) {
    var c1x;
    var c1y;
    var c2x;
    var c2y;
    var p = new Path();
    var stack = [];
    var nStems = 0;
    var haveWidth = false;
    var open = false;
    var x = 0;
    var y = 0;
    var subrs;
    var subrsBias;
    var defaultWidthX;
    var nominalWidthX;
    if (font.isCIDFont) {
        var fdIndex = font.tables.cff.topDict._fdSelect[glyph.index];
        var fdDict = font.tables.cff.topDict._fdArray[fdIndex];
        subrs = fdDict._subrs;
        subrsBias = fdDict._subrsBias;
        defaultWidthX = fdDict._defaultWidthX;
        nominalWidthX = fdDict._nominalWidthX;
    } else {
        subrs = font.tables.cff.topDict._subrs;
        subrsBias = font.tables.cff.topDict._subrsBias;
        defaultWidthX = font.tables.cff.topDict._defaultWidthX;
        nominalWidthX = font.tables.cff.topDict._nominalWidthX;
    }
    var width = defaultWidthX;

    function newContour(x, y) {
        if (open) {
            p.closePath();
        }

        p.moveTo(x, y);
        open = true;
    }

    function parseStems() {
        var hasWidthArg;

        // The number of stem operators on the stack is always even.
        // If the value is uneven, that means a width is specified.
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
            width = stack.shift() + nominalWidthX;
        }

        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
    }

    function parse$$1(code) {
        var b1;
        var b2;
        var b3;
        var b4;
        var codeIndex;
        var subrCode;
        var jpx;
        var jpy;
        var c3x;
        var c3y;
        var c4x;
        var c4y;

        var i = 0;
        while (i < code.length) {
            var v = code[i];
            i += 1;
            switch (v) {
                case 1: // hstem
                    parseStems();
                    break;
                case 3: // vstem
                    parseStems();
                    break;
                case 4: // vmoveto
                    if (stack.length > 1 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }

                    y += stack.pop();
                    newContour(x, y);
                    break;
                case 5: // rlineto
                    while (stack.length > 0) {
                        x += stack.shift();
                        y += stack.shift();
                        p.lineTo(x, y);
                    }

                    break;
                case 6: // hlineto
                    while (stack.length > 0) {
                        x += stack.shift();
                        p.lineTo(x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        y += stack.shift();
                        p.lineTo(x, y);
                    }

                    break;
                case 7: // vlineto
                    while (stack.length > 0) {
                        y += stack.shift();
                        p.lineTo(x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        x += stack.shift();
                        p.lineTo(x, y);
                    }

                    break;
                case 8: // rrcurveto
                    while (stack.length > 0) {
                        c1x = x + stack.shift();
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 10: // callsubr
                    codeIndex = stack.pop() + subrsBias;
                    subrCode = subrs[codeIndex];
                    if (subrCode) {
                        parse$$1(subrCode);
                    }

                    break;
                case 11: // return
                    return;
                case 12: // flex operators
                    v = code[i];
                    i += 1;
                    switch (v) {
                        case 35: // flex
                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 fd flex (12 35) |-
                            c1x = x   + stack.shift();    // dx1
                            c1y = y   + stack.shift();    // dy1
                            c2x = c1x + stack.shift();    // dx2
                            c2y = c1y + stack.shift();    // dy2
                            jpx = c2x + stack.shift();    // dx3
                            jpy = c2y + stack.shift();    // dy3
                            c3x = jpx + stack.shift();    // dx4
                            c3y = jpy + stack.shift();    // dy4
                            c4x = c3x + stack.shift();    // dx5
                            c4y = c3y + stack.shift();    // dy5
                            x = c4x   + stack.shift();    // dx6
                            y = c4y   + stack.shift();    // dy6
                            stack.shift();                // flex depth
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 34: // hflex
                            // |- dx1 dx2 dy2 dx3 dx4 dx5 dx6 hflex (12 34) |-
                            c1x = x   + stack.shift();    // dx1
                            c1y = y;                      // dy1
                            c2x = c1x + stack.shift();    // dx2
                            c2y = c1y + stack.shift();    // dy2
                            jpx = c2x + stack.shift();    // dx3
                            jpy = c2y;                    // dy3
                            c3x = jpx + stack.shift();    // dx4
                            c3y = c2y;                    // dy4
                            c4x = c3x + stack.shift();    // dx5
                            c4y = y;                      // dy5
                            x = c4x + stack.shift();      // dx6
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 36: // hflex1
                            // |- dx1 dy1 dx2 dy2 dx3 dx4 dx5 dy5 dx6 hflex1 (12 36) |-
                            c1x = x   + stack.shift();    // dx1
                            c1y = y   + stack.shift();    // dy1
                            c2x = c1x + stack.shift();    // dx2
                            c2y = c1y + stack.shift();    // dy2
                            jpx = c2x + stack.shift();    // dx3
                            jpy = c2y;                    // dy3
                            c3x = jpx + stack.shift();    // dx4
                            c3y = c2y;                    // dy4
                            c4x = c3x + stack.shift();    // dx5
                            c4y = c3y + stack.shift();    // dy5
                            x = c4x + stack.shift();      // dx6
                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        case 37: // flex1
                            // |- dx1 dy1 dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 d6 flex1 (12 37) |-
                            c1x = x   + stack.shift();    // dx1
                            c1y = y   + stack.shift();    // dy1
                            c2x = c1x + stack.shift();    // dx2
                            c2y = c1y + stack.shift();    // dy2
                            jpx = c2x + stack.shift();    // dx3
                            jpy = c2y + stack.shift();    // dy3
                            c3x = jpx + stack.shift();    // dx4
                            c3y = jpy + stack.shift();    // dy4
                            c4x = c3x + stack.shift();    // dx5
                            c4y = c3y + stack.shift();    // dy5
                            if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
                                x = c4x + stack.shift();
                            } else {
                                y = c4y + stack.shift();
                            }

                            p.curveTo(c1x, c1y, c2x, c2y, jpx, jpy);
                            p.curveTo(c3x, c3y, c4x, c4y, x, y);
                            break;
                        default:
                            console.log('Glyph ' + glyph.index + ': unknown operator ' + 1200 + v);
                            stack.length = 0;
                    }
                    break;
                case 14: // endchar
                    if (stack.length > 0 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }

                    if (open) {
                        p.closePath();
                        open = false;
                    }

                    break;
                case 18: // hstemhm
                    parseStems();
                    break;
                case 19: // hintmask
                case 20: // cntrmask
                    parseStems();
                    i += (nStems + 7) >> 3;
                    break;
                case 21: // rmoveto
                    if (stack.length > 2 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }

                    y += stack.pop();
                    x += stack.pop();
                    newContour(x, y);
                    break;
                case 22: // hmoveto
                    if (stack.length > 1 && !haveWidth) {
                        width = stack.shift() + nominalWidthX;
                        haveWidth = true;
                    }

                    x += stack.pop();
                    newContour(x, y);
                    break;
                case 23: // vstemhm
                    parseStems();
                    break;
                case 24: // rcurveline
                    while (stack.length > 2) {
                        c1x = x + stack.shift();
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    x += stack.shift();
                    y += stack.shift();
                    p.lineTo(x, y);
                    break;
                case 25: // rlinecurve
                    while (stack.length > 6) {
                        x += stack.shift();
                        y += stack.shift();
                        p.lineTo(x, y);
                    }

                    c1x = x + stack.shift();
                    c1y = y + stack.shift();
                    c2x = c1x + stack.shift();
                    c2y = c1y + stack.shift();
                    x = c2x + stack.shift();
                    y = c2y + stack.shift();
                    p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    break;
                case 26: // vvcurveto
                    if (stack.length % 2) {
                        x += stack.shift();
                    }

                    while (stack.length > 0) {
                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x;
                        y = c2y + stack.shift();
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 27: // hhcurveto
                    if (stack.length % 2) {
                        y += stack.shift();
                    }

                    while (stack.length > 0) {
                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y;
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 28: // shortint
                    b1 = code[i];
                    b2 = code[i + 1];
                    stack.push(((b1 << 24) | (b2 << 16)) >> 16);
                    i += 2;
                    break;
                case 29: // callgsubr
                    codeIndex = stack.pop() + font.gsubrsBias;
                    subrCode = font.gsubrs[codeIndex];
                    if (subrCode) {
                        parse$$1(subrCode);
                    }

                    break;
                case 30: // vhcurveto
                    while (stack.length > 0) {
                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        y = c2y + stack.shift();
                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                case 31: // hvcurveto
                    while (stack.length > 0) {
                        c1x = x + stack.shift();
                        c1y = y;
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        y = c2y + stack.shift();
                        x = c2x + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                        if (stack.length === 0) {
                            break;
                        }

                        c1x = x;
                        c1y = y + stack.shift();
                        c2x = c1x + stack.shift();
                        c2y = c1y + stack.shift();
                        x = c2x + stack.shift();
                        y = c2y + (stack.length === 1 ? stack.shift() : 0);
                        p.curveTo(c1x, c1y, c2x, c2y, x, y);
                    }

                    break;
                default:
                    if (v < 32) {
                        console.log('Glyph ' + glyph.index + ': unknown operator ' + v);
                    } else if (v < 247) {
                        stack.push(v - 139);
                    } else if (v < 251) {
                        b1 = code[i];
                        i += 1;
                        stack.push((v - 247) * 256 + b1 + 108);
                    } else if (v < 255) {
                        b1 = code[i];
                        i += 1;
                        stack.push(-(v - 251) * 256 - b1 - 108);
                    } else {
                        b1 = code[i];
                        b2 = code[i + 1];
                        b3 = code[i + 2];
                        b4 = code[i + 3];
                        i += 4;
                        stack.push(((b1 << 24) | (b2 << 16) | (b3 << 8) | b4) / 65536);
                    }
            }
        }
    }

    parse$$1(code);

    glyph.advanceWidth = width;
    return p;
}

function parseCFFFDSelect(data, start, nGlyphs, fdArrayCount) {
    var fdSelect = [];
    var fdIndex;
    var parser = new parse.Parser(data, start);
    var format = parser.parseCard8();
    if (format === 0) {
        // Simple list of nGlyphs elements
        for (var iGid = 0; iGid < nGlyphs; iGid++) {
            fdIndex = parser.parseCard8();
            if (fdIndex >= fdArrayCount) {
                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
            }
            fdSelect.push(fdIndex);
        }
    } else if (format === 3) {
        // Ranges
        var nRanges = parser.parseCard16();
        var first = parser.parseCard16();
        if (first !== 0) {
            throw new Error('CFF Table CID Font FDSelect format 3 range has bad initial GID ' + first);
        }
        var next;
        for (var iRange = 0; iRange < nRanges; iRange++) {
            fdIndex = parser.parseCard8();
            next = parser.parseCard16();
            if (fdIndex >= fdArrayCount) {
                throw new Error('CFF table CID Font FDSelect has bad FD index value ' + fdIndex + ' (FD count ' + fdArrayCount + ')');
            }
            if (next > nGlyphs) {
                throw new Error('CFF Table CID Font FDSelect format 3 range has bad GID ' + next);
            }
            for (; first < next; first++) {
                fdSelect.push(fdIndex);
            }
            first = next;
        }
        if (next !== nGlyphs) {
            throw new Error('CFF Table CID Font FDSelect format 3 range has bad final GID ' + next);
        }
    } else {
        throw new Error('CFF Table CID Font FDSelect table has unsupported format ' + format);
    }
    return fdSelect;
}

// Parse the `CFF` table, which contains the glyph outlines in PostScript format.
function parseCFFTable(data, start, font) {
    font.tables.cff = {};
    var header = parseCFFHeader(data, start);
    var nameIndex = parseCFFIndex(data, header.endOffset, parse.bytesToString);
    var topDictIndex = parseCFFIndex(data, nameIndex.endOffset);
    var stringIndex = parseCFFIndex(data, topDictIndex.endOffset, parse.bytesToString);
    var globalSubrIndex = parseCFFIndex(data, stringIndex.endOffset);
    font.gsubrs = globalSubrIndex.objects;
    font.gsubrsBias = calcCFFSubroutineBias(font.gsubrs);

    var topDictArray = gatherCFFTopDicts(data, start, topDictIndex.objects, stringIndex.objects);
    if (topDictArray.length !== 1) {
        throw new Error('CFF table has too many fonts in \'FontSet\' - count of fonts NameIndex.length = ' + topDictArray.length);
    }

    var topDict = topDictArray[0];
    font.tables.cff.topDict = topDict;

    if (topDict._privateDict) {
        font.defaultWidthX = topDict._privateDict.defaultWidthX;
        font.nominalWidthX = topDict._privateDict.nominalWidthX;
    }

    if (topDict.ros[0] !== undefined && topDict.ros[1] !== undefined) {
        font.isCIDFont = true;
    }

    if (font.isCIDFont) {
        var fdArrayOffset = topDict.fdArray;
        var fdSelectOffset = topDict.fdSelect;
        if (fdArrayOffset === 0 || fdSelectOffset === 0) {
            throw new Error('Font is marked as a CID font, but FDArray and/or FDSelect information is missing');
        }
        fdArrayOffset += start;
        var fdArrayIndex = parseCFFIndex(data, fdArrayOffset);
        var fdArray = gatherCFFTopDicts(data, start, fdArrayIndex.objects, stringIndex.objects);
        topDict._fdArray = fdArray;
        fdSelectOffset += start;
        topDict._fdSelect = parseCFFFDSelect(data, fdSelectOffset, font.numGlyphs, fdArray.length);
    }

    var privateDictOffset = start + topDict.private[1];
    var privateDict = parseCFFPrivateDict(data, privateDictOffset, topDict.private[0], stringIndex.objects);
    font.defaultWidthX = privateDict.defaultWidthX;
    font.nominalWidthX = privateDict.nominalWidthX;

    if (privateDict.subrs !== 0) {
        var subrOffset = privateDictOffset + privateDict.subrs;
        var subrIndex = parseCFFIndex(data, subrOffset);
        font.subrs = subrIndex.objects;
        font.subrsBias = calcCFFSubroutineBias(font.subrs);
    } else {
        font.subrs = [];
        font.subrsBias = 0;
    }

    // Offsets in the top dict are relative to the beginning of the CFF data, so add the CFF start offset.
    var charStringsIndex = parseCFFIndex(data, start + topDict.charStrings);
    font.nGlyphs = charStringsIndex.objects.length;

    var charset = parseCFFCharset(data, start + topDict.charset, font.nGlyphs, stringIndex.objects);
    if (topDict.encoding === 0) {
        // Standard encoding
        font.cffEncoding = new CffEncoding(cffStandardEncoding, charset);
    } else if (topDict.encoding === 1) {
        // Expert encoding
        font.cffEncoding = new CffEncoding(cffExpertEncoding, charset);
    } else {
        font.cffEncoding = parseCFFEncoding(data, start + topDict.encoding, charset);
    }

    // Prefer the CMAP encoding to the CFF encoding.
    font.encoding = font.encoding || font.cffEncoding;

    font.glyphs = new glyphset.GlyphSet(font);
    for (var i = 0; i < font.nGlyphs; i += 1) {
        var charString = charStringsIndex.objects[i];
        font.glyphs.push(i, glyphset.cffGlyphLoader(font, i, parseCFFCharstring, charString));
    }
}

// Convert a string to a String ID (SID).
// The list of strings is modified in place.
function encodeString(s, strings) {
    var sid;

    // Is the string in the CFF standard strings?
    var i = cffStandardStrings.indexOf(s);
    if (i >= 0) {
        sid = i;
    }

    // Is the string already in the string index?
    i = strings.indexOf(s);
    if (i >= 0) {
        sid = i + cffStandardStrings.length;
    } else {
        sid = cffStandardStrings.length + strings.length;
        strings.push(s);
    }

    return sid;
}

function makeHeader() {
    return new table.Record('Header', [
        {name: 'major', type: 'Card8', value: 1},
        {name: 'minor', type: 'Card8', value: 0},
        {name: 'hdrSize', type: 'Card8', value: 4},
        {name: 'major', type: 'Card8', value: 1}
    ]);
}

function makeNameIndex(fontNames) {
    var t = new table.Record('Name INDEX', [
        {name: 'names', type: 'INDEX', value: []}
    ]);
    t.names = [];
    for (var i = 0; i < fontNames.length; i += 1) {
        t.names.push({name: 'name_' + i, type: 'NAME', value: fontNames[i]});
    }

    return t;
}

// Given a dictionary's metadata, create a DICT structure.
function makeDict(meta, attrs, strings) {
    var m = {};
    for (var i = 0; i < meta.length; i += 1) {
        var entry = meta[i];
        var value = attrs[entry.name];
        if (value !== undefined && !equals(value, entry.value)) {
            if (entry.type === 'SID') {
                value = encodeString(value, strings);
            }

            m[entry.op] = {name: entry.name, type: entry.type, value: value};
        }
    }

    return m;
}

// The Top DICT houses the global font attributes.
function makeTopDict(attrs, strings) {
    var t = new table.Record('Top DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(TOP_DICT_META, attrs, strings);
    return t;
}

function makeTopDictIndex(topDict) {
    var t = new table.Record('Top DICT INDEX', [
        {name: 'topDicts', type: 'INDEX', value: []}
    ]);
    t.topDicts = [{name: 'topDict_0', type: 'TABLE', value: topDict}];
    return t;
}

function makeStringIndex(strings) {
    var t = new table.Record('String INDEX', [
        {name: 'strings', type: 'INDEX', value: []}
    ]);
    t.strings = [];
    for (var i = 0; i < strings.length; i += 1) {
        t.strings.push({name: 'string_' + i, type: 'STRING', value: strings[i]});
    }

    return t;
}

function makeGlobalSubrIndex() {
    // Currently we don't use subroutines.
    return new table.Record('Global Subr INDEX', [
        {name: 'subrs', type: 'INDEX', value: []}
    ]);
}

function makeCharsets(glyphNames, strings) {
    var t = new table.Record('Charsets', [
        {name: 'format', type: 'Card8', value: 0}
    ]);
    for (var i = 0; i < glyphNames.length; i += 1) {
        var glyphName = glyphNames[i];
        var glyphSID = encodeString(glyphName, strings);
        t.fields.push({name: 'glyph_' + i, type: 'SID', value: glyphSID});
    }

    return t;
}

function glyphToOps(glyph) {
    var ops = [];
    var path = glyph.path;
    ops.push({name: 'width', type: 'NUMBER', value: glyph.advanceWidth});
    var x = 0;
    var y = 0;
    for (var i = 0; i < path.commands.length; i += 1) {
        var dx = (void 0);
        var dy = (void 0);
        var cmd = path.commands[i];
        if (cmd.type === 'Q') {
            // CFF only supports bézier curves, so convert the quad to a bézier.
            var _13 = 1 / 3;
            var _23 = 2 / 3;

            // We're going to create a new command so we don't change the original path.
            cmd = {
                type: 'C',
                x: cmd.x,
                y: cmd.y,
                x1: _13 * x + _23 * cmd.x1,
                y1: _13 * y + _23 * cmd.y1,
                x2: _13 * cmd.x + _23 * cmd.x1,
                y2: _13 * cmd.y + _23 * cmd.y1
            };
        }

        if (cmd.type === 'M') {
            dx = Math.round(cmd.x - x);
            dy = Math.round(cmd.y - y);
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rmoveto', type: 'OP', value: 21});
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        } else if (cmd.type === 'L') {
            dx = Math.round(cmd.x - x);
            dy = Math.round(cmd.y - y);
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rlineto', type: 'OP', value: 5});
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        } else if (cmd.type === 'C') {
            var dx1 = Math.round(cmd.x1 - x);
            var dy1 = Math.round(cmd.y1 - y);
            var dx2 = Math.round(cmd.x2 - cmd.x1);
            var dy2 = Math.round(cmd.y2 - cmd.y1);
            dx = Math.round(cmd.x - cmd.x2);
            dy = Math.round(cmd.y - cmd.y2);
            ops.push({name: 'dx1', type: 'NUMBER', value: dx1});
            ops.push({name: 'dy1', type: 'NUMBER', value: dy1});
            ops.push({name: 'dx2', type: 'NUMBER', value: dx2});
            ops.push({name: 'dy2', type: 'NUMBER', value: dy2});
            ops.push({name: 'dx', type: 'NUMBER', value: dx});
            ops.push({name: 'dy', type: 'NUMBER', value: dy});
            ops.push({name: 'rrcurveto', type: 'OP', value: 8});
            x = Math.round(cmd.x);
            y = Math.round(cmd.y);
        }

        // Contours are closed automatically.
    }

    ops.push({name: 'endchar', type: 'OP', value: 14});
    return ops;
}

function makeCharStringsIndex(glyphs) {
    var t = new table.Record('CharStrings INDEX', [
        {name: 'charStrings', type: 'INDEX', value: []}
    ]);

    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        var ops = glyphToOps(glyph);
        t.charStrings.push({name: glyph.name, type: 'CHARSTRING', value: ops});
    }

    return t;
}

function makePrivateDict(attrs, strings) {
    var t = new table.Record('Private DICT', [
        {name: 'dict', type: 'DICT', value: {}}
    ]);
    t.dict = makeDict(PRIVATE_DICT_META, attrs, strings);
    return t;
}

function makeCFFTable(glyphs, options) {
    var t = new table.Table('CFF ', [
        {name: 'header', type: 'RECORD'},
        {name: 'nameIndex', type: 'RECORD'},
        {name: 'topDictIndex', type: 'RECORD'},
        {name: 'stringIndex', type: 'RECORD'},
        {name: 'globalSubrIndex', type: 'RECORD'},
        {name: 'charsets', type: 'RECORD'},
        {name: 'charStringsIndex', type: 'RECORD'},
        {name: 'privateDict', type: 'RECORD'}
    ]);

    var fontScale = 1 / options.unitsPerEm;
    // We use non-zero values for the offsets so that the DICT encodes them.
    // This is important because the size of the Top DICT plays a role in offset calculation,
    // and the size shouldn't change after we've written correct offsets.
    var attrs = {
        version: options.version,
        fullName: options.fullName,
        familyName: options.familyName,
        weight: options.weightName,
        fontBBox: options.fontBBox || [0, 0, 0, 0],
        fontMatrix: [fontScale, 0, 0, fontScale, 0, 0],
        charset: 999,
        encoding: 0,
        charStrings: 999,
        private: [0, 999]
    };

    var privateAttrs = {};

    var glyphNames = [];
    var glyph;

    // Skip first glyph (.notdef)
    for (var i = 1; i < glyphs.length; i += 1) {
        glyph = glyphs.get(i);
        glyphNames.push(glyph.name);
    }

    var strings = [];

    t.header = makeHeader();
    t.nameIndex = makeNameIndex([options.postScriptName]);
    var topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);
    t.globalSubrIndex = makeGlobalSubrIndex();
    t.charsets = makeCharsets(glyphNames, strings);
    t.charStringsIndex = makeCharStringsIndex(glyphs);
    t.privateDict = makePrivateDict(privateAttrs, strings);

    // Needs to come at the end, to encode all custom strings used in the font.
    t.stringIndex = makeStringIndex(strings);

    var startOffset = t.header.sizeOf() +
        t.nameIndex.sizeOf() +
        t.topDictIndex.sizeOf() +
        t.stringIndex.sizeOf() +
        t.globalSubrIndex.sizeOf();
    attrs.charset = startOffset;

    // We use the CFF standard encoding; proper encoding will be handled in cmap.
    attrs.encoding = 0;
    attrs.charStrings = attrs.charset + t.charsets.sizeOf();
    attrs.private[1] = attrs.charStrings + t.charStringsIndex.sizeOf();

    // Recreate the Top DICT INDEX with the correct offsets.
    topDict = makeTopDict(attrs, strings);
    t.topDictIndex = makeTopDictIndex(topDict);

    return t;
}

var cff = { parse: parseCFFTable, make: makeCFFTable };

// The `head` table contains global information about the font.
// https://www.microsoft.com/typography/OTSPEC/head.htm

// Parse the header `head` table
function parseHeadTable(data, start) {
    var head = {};
    var p = new parse.Parser(data, start);
    head.version = p.parseVersion();
    head.fontRevision = Math.round(p.parseFixed() * 1000) / 1000;
    head.checkSumAdjustment = p.parseULong();
    head.magicNumber = p.parseULong();
    check.argument(head.magicNumber === 0x5F0F3CF5, 'Font header has wrong magic number.');
    head.flags = p.parseUShort();
    head.unitsPerEm = p.parseUShort();
    head.created = p.parseLongDateTime();
    head.modified = p.parseLongDateTime();
    head.xMin = p.parseShort();
    head.yMin = p.parseShort();
    head.xMax = p.parseShort();
    head.yMax = p.parseShort();
    head.macStyle = p.parseUShort();
    head.lowestRecPPEM = p.parseUShort();
    head.fontDirectionHint = p.parseShort();
    head.indexToLocFormat = p.parseShort();
    head.glyphDataFormat = p.parseShort();
    return head;
}

function makeHeadTable(options) {
    // Apple Mac timestamp epoch is 01/01/1904 not 01/01/1970
    var timestamp = Math.round(new Date().getTime() / 1000) + 2082844800;
    var createdTimestamp = timestamp;

    if (options.createdTimestamp) {
        createdTimestamp = options.createdTimestamp + 2082844800;
    }

    return new table.Table('head', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'fontRevision', type: 'FIXED', value: 0x00010000},
        {name: 'checkSumAdjustment', type: 'ULONG', value: 0},
        {name: 'magicNumber', type: 'ULONG', value: 0x5F0F3CF5},
        {name: 'flags', type: 'USHORT', value: 0},
        {name: 'unitsPerEm', type: 'USHORT', value: 1000},
        {name: 'created', type: 'LONGDATETIME', value: createdTimestamp},
        {name: 'modified', type: 'LONGDATETIME', value: timestamp},
        {name: 'xMin', type: 'SHORT', value: 0},
        {name: 'yMin', type: 'SHORT', value: 0},
        {name: 'xMax', type: 'SHORT', value: 0},
        {name: 'yMax', type: 'SHORT', value: 0},
        {name: 'macStyle', type: 'USHORT', value: 0},
        {name: 'lowestRecPPEM', type: 'USHORT', value: 0},
        {name: 'fontDirectionHint', type: 'SHORT', value: 2},
        {name: 'indexToLocFormat', type: 'SHORT', value: 0},
        {name: 'glyphDataFormat', type: 'SHORT', value: 0}
    ], options);
}

var head = { parse: parseHeadTable, make: makeHeadTable };

// The `hhea` table contains information for horizontal layout.
// https://www.microsoft.com/typography/OTSPEC/hhea.htm

// Parse the horizontal header `hhea` table
function parseHheaTable(data, start) {
    var hhea = {};
    var p = new parse.Parser(data, start);
    hhea.version = p.parseVersion();
    hhea.ascender = p.parseShort();
    hhea.descender = p.parseShort();
    hhea.lineGap = p.parseShort();
    hhea.advanceWidthMax = p.parseUShort();
    hhea.minLeftSideBearing = p.parseShort();
    hhea.minRightSideBearing = p.parseShort();
    hhea.xMaxExtent = p.parseShort();
    hhea.caretSlopeRise = p.parseShort();
    hhea.caretSlopeRun = p.parseShort();
    hhea.caretOffset = p.parseShort();
    p.relativeOffset += 8;
    hhea.metricDataFormat = p.parseShort();
    hhea.numberOfHMetrics = p.parseUShort();
    return hhea;
}

function makeHheaTable(options) {
    return new table.Table('hhea', [
        {name: 'version', type: 'FIXED', value: 0x00010000},
        {name: 'ascender', type: 'FWORD', value: 0},
        {name: 'descender', type: 'FWORD', value: 0},
        {name: 'lineGap', type: 'FWORD', value: 0},
        {name: 'advanceWidthMax', type: 'UFWORD', value: 0},
        {name: 'minLeftSideBearing', type: 'FWORD', value: 0},
        {name: 'minRightSideBearing', type: 'FWORD', value: 0},
        {name: 'xMaxExtent', type: 'FWORD', value: 0},
        {name: 'caretSlopeRise', type: 'SHORT', value: 1},
        {name: 'caretSlopeRun', type: 'SHORT', value: 0},
        {name: 'caretOffset', type: 'SHORT', value: 0},
        {name: 'reserved1', type: 'SHORT', value: 0},
        {name: 'reserved2', type: 'SHORT', value: 0},
        {name: 'reserved3', type: 'SHORT', value: 0},
        {name: 'reserved4', type: 'SHORT', value: 0},
        {name: 'metricDataFormat', type: 'SHORT', value: 0},
        {name: 'numberOfHMetrics', type: 'USHORT', value: 0}
    ], options);
}

var hhea = { parse: parseHheaTable, make: makeHheaTable };

// The `hmtx` table contains the horizontal metrics for all glyphs.
// https://www.microsoft.com/typography/OTSPEC/hmtx.htm

// Parse the `hmtx` table, which contains the horizontal metrics for all glyphs.
// This function augments the glyph array, adding the advanceWidth and leftSideBearing to each glyph.
function parseHmtxTable(data, start, numMetrics, numGlyphs, glyphs) {
    var advanceWidth;
    var leftSideBearing;
    var p = new parse.Parser(data, start);
    for (var i = 0; i < numGlyphs; i += 1) {
        // If the font is monospaced, only one entry is needed. This last entry applies to all subsequent glyphs.
        if (i < numMetrics) {
            advanceWidth = p.parseUShort();
            leftSideBearing = p.parseShort();
        }

        var glyph = glyphs.get(i);
        glyph.advanceWidth = advanceWidth;
        glyph.leftSideBearing = leftSideBearing;
    }
}

function makeHmtxTable(glyphs) {
    var t = new table.Table('hmtx', []);
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs.get(i);
        var advanceWidth = glyph.advanceWidth || 0;
        var leftSideBearing = glyph.leftSideBearing || 0;
        t.fields.push({name: 'advanceWidth_' + i, type: 'USHORT', value: advanceWidth});
        t.fields.push({name: 'leftSideBearing_' + i, type: 'SHORT', value: leftSideBearing});
    }

    return t;
}

var hmtx = { parse: parseHmtxTable, make: makeHmtxTable };

// The `ltag` table stores IETF BCP-47 language tags. It allows supporting
// languages for which TrueType does not assign a numeric code.
// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6ltag.html
// http://www.w3.org/International/articles/language-tags/
// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry

function makeLtagTable(tags) {
    var result = new table.Table('ltag', [
        {name: 'version', type: 'ULONG', value: 1},
        {name: 'flags', type: 'ULONG', value: 0},
        {name: 'numTags', type: 'ULONG', value: tags.length}
    ]);

    var stringPool = '';
    var stringPoolOffset = 12 + tags.length * 4;
    for (var i = 0; i < tags.length; ++i) {
        var pos = stringPool.indexOf(tags[i]);
        if (pos < 0) {
            pos = stringPool.length;
            stringPool += tags[i];
        }

        result.fields.push({name: 'offset ' + i, type: 'USHORT', value: stringPoolOffset + pos});
        result.fields.push({name: 'length ' + i, type: 'USHORT', value: tags[i].length});
    }

    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});
    return result;
}

function parseLtagTable(data, start) {
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseULong();
    check.argument(tableVersion === 1, 'Unsupported ltag table version.');
    // The 'ltag' specification does not define any flags; skip the field.
    p.skip('uLong', 1);
    var numTags = p.parseULong();

    var tags = [];
    for (var i = 0; i < numTags; i++) {
        var tag = '';
        var offset = start + p.parseUShort();
        var length = p.parseUShort();
        for (var j = offset; j < offset + length; ++j) {
            tag += String.fromCharCode(data.getInt8(j));
        }

        tags.push(tag);
    }

    return tags;
}

var ltag = { make: makeLtagTable, parse: parseLtagTable };

// The `maxp` table establishes the memory requirements for the font.
// We need it just to get the number of glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/maxp.htm

// Parse the maximum profile `maxp` table.
function parseMaxpTable(data, start) {
    var maxp = {};
    var p = new parse.Parser(data, start);
    maxp.version = p.parseVersion();
    maxp.numGlyphs = p.parseUShort();
    if (maxp.version === 1.0) {
        maxp.maxPoints = p.parseUShort();
        maxp.maxContours = p.parseUShort();
        maxp.maxCompositePoints = p.parseUShort();
        maxp.maxCompositeContours = p.parseUShort();
        maxp.maxZones = p.parseUShort();
        maxp.maxTwilightPoints = p.parseUShort();
        maxp.maxStorage = p.parseUShort();
        maxp.maxFunctionDefs = p.parseUShort();
        maxp.maxInstructionDefs = p.parseUShort();
        maxp.maxStackElements = p.parseUShort();
        maxp.maxSizeOfInstructions = p.parseUShort();
        maxp.maxComponentElements = p.parseUShort();
        maxp.maxComponentDepth = p.parseUShort();
    }

    return maxp;
}

function makeMaxpTable(numGlyphs) {
    return new table.Table('maxp', [
        {name: 'version', type: 'FIXED', value: 0x00005000},
        {name: 'numGlyphs', type: 'USHORT', value: numGlyphs}
    ]);
}

var maxp = { parse: parseMaxpTable, make: makeMaxpTable };

// The `name` naming table.
// https://www.microsoft.com/typography/OTSPEC/name.htm

// NameIDs for the name table.
var nameTableNames = [
    'copyright',              // 0
    'fontFamily',             // 1
    'fontSubfamily',          // 2
    'uniqueID',               // 3
    'fullName',               // 4
    'version',                // 5
    'postScriptName',         // 6
    'trademark',              // 7
    'manufacturer',           // 8
    'designer',               // 9
    'description',            // 10
    'manufacturerURL',        // 11
    'designerURL',            // 12
    'license',                // 13
    'licenseURL',             // 14
    'reserved',               // 15
    'preferredFamily',        // 16
    'preferredSubfamily',     // 17
    'compatibleFullName',     // 18
    'sampleText',             // 19
    'postScriptFindFontName', // 20
    'wwsFamily',              // 21
    'wwsSubfamily'            // 22
];

var macLanguages = {
    0: 'en',
    1: 'fr',
    2: 'de',
    3: 'it',
    4: 'nl',
    5: 'sv',
    6: 'es',
    7: 'da',
    8: 'pt',
    9: 'no',
    10: 'he',
    11: 'ja',
    12: 'ar',
    13: 'fi',
    14: 'el',
    15: 'is',
    16: 'mt',
    17: 'tr',
    18: 'hr',
    19: 'zh-Hant',
    20: 'ur',
    21: 'hi',
    22: 'th',
    23: 'ko',
    24: 'lt',
    25: 'pl',
    26: 'hu',
    27: 'es',
    28: 'lv',
    29: 'se',
    30: 'fo',
    31: 'fa',
    32: 'ru',
    33: 'zh',
    34: 'nl-BE',
    35: 'ga',
    36: 'sq',
    37: 'ro',
    38: 'cz',
    39: 'sk',
    40: 'si',
    41: 'yi',
    42: 'sr',
    43: 'mk',
    44: 'bg',
    45: 'uk',
    46: 'be',
    47: 'uz',
    48: 'kk',
    49: 'az-Cyrl',
    50: 'az-Arab',
    51: 'hy',
    52: 'ka',
    53: 'mo',
    54: 'ky',
    55: 'tg',
    56: 'tk',
    57: 'mn-CN',
    58: 'mn',
    59: 'ps',
    60: 'ks',
    61: 'ku',
    62: 'sd',
    63: 'bo',
    64: 'ne',
    65: 'sa',
    66: 'mr',
    67: 'bn',
    68: 'as',
    69: 'gu',
    70: 'pa',
    71: 'or',
    72: 'ml',
    73: 'kn',
    74: 'ta',
    75: 'te',
    76: 'si',
    77: 'my',
    78: 'km',
    79: 'lo',
    80: 'vi',
    81: 'id',
    82: 'tl',
    83: 'ms',
    84: 'ms-Arab',
    85: 'am',
    86: 'ti',
    87: 'om',
    88: 'so',
    89: 'sw',
    90: 'rw',
    91: 'rn',
    92: 'ny',
    93: 'mg',
    94: 'eo',
    128: 'cy',
    129: 'eu',
    130: 'ca',
    131: 'la',
    132: 'qu',
    133: 'gn',
    134: 'ay',
    135: 'tt',
    136: 'ug',
    137: 'dz',
    138: 'jv',
    139: 'su',
    140: 'gl',
    141: 'af',
    142: 'br',
    143: 'iu',
    144: 'gd',
    145: 'gv',
    146: 'ga',
    147: 'to',
    148: 'el-polyton',
    149: 'kl',
    150: 'az',
    151: 'nn'
};

// MacOS language ID → MacOS script ID
//
// Note that the script ID is not sufficient to determine what encoding
// to use in TrueType files. For some languages, MacOS used a modification
// of a mainstream script. For example, an Icelandic name would be stored
// with smRoman in the TrueType naming table, but the actual encoding
// is a special Icelandic version of the normal Macintosh Roman encoding.
// As another example, Inuktitut uses an 8-bit encoding for Canadian Aboriginal
// Syllables but MacOS had run out of available script codes, so this was
// done as a (pretty radical) "modification" of Ethiopic.
//
// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
var macLanguageToScript = {
    0: 0,  // langEnglish → smRoman
    1: 0,  // langFrench → smRoman
    2: 0,  // langGerman → smRoman
    3: 0,  // langItalian → smRoman
    4: 0,  // langDutch → smRoman
    5: 0,  // langSwedish → smRoman
    6: 0,  // langSpanish → smRoman
    7: 0,  // langDanish → smRoman
    8: 0,  // langPortuguese → smRoman
    9: 0,  // langNorwegian → smRoman
    10: 5,  // langHebrew → smHebrew
    11: 1,  // langJapanese → smJapanese
    12: 4,  // langArabic → smArabic
    13: 0,  // langFinnish → smRoman
    14: 6,  // langGreek → smGreek
    15: 0,  // langIcelandic → smRoman (modified)
    16: 0,  // langMaltese → smRoman
    17: 0,  // langTurkish → smRoman (modified)
    18: 0,  // langCroatian → smRoman (modified)
    19: 2,  // langTradChinese → smTradChinese
    20: 4,  // langUrdu → smArabic
    21: 9,  // langHindi → smDevanagari
    22: 21,  // langThai → smThai
    23: 3,  // langKorean → smKorean
    24: 29,  // langLithuanian → smCentralEuroRoman
    25: 29,  // langPolish → smCentralEuroRoman
    26: 29,  // langHungarian → smCentralEuroRoman
    27: 29,  // langEstonian → smCentralEuroRoman
    28: 29,  // langLatvian → smCentralEuroRoman
    29: 0,  // langSami → smRoman
    30: 0,  // langFaroese → smRoman (modified)
    31: 4,  // langFarsi → smArabic (modified)
    32: 7,  // langRussian → smCyrillic
    33: 25,  // langSimpChinese → smSimpChinese
    34: 0,  // langFlemish → smRoman
    35: 0,  // langIrishGaelic → smRoman (modified)
    36: 0,  // langAlbanian → smRoman
    37: 0,  // langRomanian → smRoman (modified)
    38: 29,  // langCzech → smCentralEuroRoman
    39: 29,  // langSlovak → smCentralEuroRoman
    40: 0,  // langSlovenian → smRoman (modified)
    41: 5,  // langYiddish → smHebrew
    42: 7,  // langSerbian → smCyrillic
    43: 7,  // langMacedonian → smCyrillic
    44: 7,  // langBulgarian → smCyrillic
    45: 7,  // langUkrainian → smCyrillic (modified)
    46: 7,  // langByelorussian → smCyrillic
    47: 7,  // langUzbek → smCyrillic
    48: 7,  // langKazakh → smCyrillic
    49: 7,  // langAzerbaijani → smCyrillic
    50: 4,  // langAzerbaijanAr → smArabic
    51: 24,  // langArmenian → smArmenian
    52: 23,  // langGeorgian → smGeorgian
    53: 7,  // langMoldavian → smCyrillic
    54: 7,  // langKirghiz → smCyrillic
    55: 7,  // langTajiki → smCyrillic
    56: 7,  // langTurkmen → smCyrillic
    57: 27,  // langMongolian → smMongolian
    58: 7,  // langMongolianCyr → smCyrillic
    59: 4,  // langPashto → smArabic
    60: 4,  // langKurdish → smArabic
    61: 4,  // langKashmiri → smArabic
    62: 4,  // langSindhi → smArabic
    63: 26,  // langTibetan → smTibetan
    64: 9,  // langNepali → smDevanagari
    65: 9,  // langSanskrit → smDevanagari
    66: 9,  // langMarathi → smDevanagari
    67: 13,  // langBengali → smBengali
    68: 13,  // langAssamese → smBengali
    69: 11,  // langGujarati → smGujarati
    70: 10,  // langPunjabi → smGurmukhi
    71: 12,  // langOriya → smOriya
    72: 17,  // langMalayalam → smMalayalam
    73: 16,  // langKannada → smKannada
    74: 14,  // langTamil → smTamil
    75: 15,  // langTelugu → smTelugu
    76: 18,  // langSinhalese → smSinhalese
    77: 19,  // langBurmese → smBurmese
    78: 20,  // langKhmer → smKhmer
    79: 22,  // langLao → smLao
    80: 30,  // langVietnamese → smVietnamese
    81: 0,  // langIndonesian → smRoman
    82: 0,  // langTagalog → smRoman
    83: 0,  // langMalayRoman → smRoman
    84: 4,  // langMalayArabic → smArabic
    85: 28,  // langAmharic → smEthiopic
    86: 28,  // langTigrinya → smEthiopic
    87: 28,  // langOromo → smEthiopic
    88: 0,  // langSomali → smRoman
    89: 0,  // langSwahili → smRoman
    90: 0,  // langKinyarwanda → smRoman
    91: 0,  // langRundi → smRoman
    92: 0,  // langNyanja → smRoman
    93: 0,  // langMalagasy → smRoman
    94: 0,  // langEsperanto → smRoman
    128: 0,  // langWelsh → smRoman (modified)
    129: 0,  // langBasque → smRoman
    130: 0,  // langCatalan → smRoman
    131: 0,  // langLatin → smRoman
    132: 0,  // langQuechua → smRoman
    133: 0,  // langGuarani → smRoman
    134: 0,  // langAymara → smRoman
    135: 7,  // langTatar → smCyrillic
    136: 4,  // langUighur → smArabic
    137: 26,  // langDzongkha → smTibetan
    138: 0,  // langJavaneseRom → smRoman
    139: 0,  // langSundaneseRom → smRoman
    140: 0,  // langGalician → smRoman
    141: 0,  // langAfrikaans → smRoman
    142: 0,  // langBreton → smRoman (modified)
    143: 28,  // langInuktitut → smEthiopic (modified)
    144: 0,  // langScottishGaelic → smRoman (modified)
    145: 0,  // langManxGaelic → smRoman (modified)
    146: 0,  // langIrishGaelicScript → smRoman (modified)
    147: 0,  // langTongan → smRoman
    148: 6,  // langGreekAncient → smRoman
    149: 0,  // langGreenlandic → smRoman
    150: 0,  // langAzerbaijanRoman → smRoman
    151: 0   // langNynorsk → smRoman
};

// While Microsoft indicates a region/country for all its language
// IDs, we omit the region code if it's equal to the "most likely
// region subtag" according to Unicode CLDR. For scripts, we omit
// the subtag if it is equal to the Suppress-Script entry in the
// IANA language subtag registry for IETF BCP 47.
//
// For example, Microsoft states that its language code 0x041A is
// Croatian in Croatia. We transform this to the BCP 47 language code 'hr'
// and not 'hr-HR' because Croatia is the default country for Croatian,
// according to Unicode CLDR. As another example, Microsoft states
// that 0x101A is Croatian (Latin) in Bosnia-Herzegovina. We transform
// this to 'hr-BA' and not 'hr-Latn-BA' because Latin is the default script
// for the Croatian language, according to IANA.
//
// http://www.unicode.org/cldr/charts/latest/supplemental/likely_subtags.html
// http://www.iana.org/assignments/language-subtag-registry/language-subtag-registry
var windowsLanguages = {
    0x0436: 'af',
    0x041C: 'sq',
    0x0484: 'gsw',
    0x045E: 'am',
    0x1401: 'ar-DZ',
    0x3C01: 'ar-BH',
    0x0C01: 'ar',
    0x0801: 'ar-IQ',
    0x2C01: 'ar-JO',
    0x3401: 'ar-KW',
    0x3001: 'ar-LB',
    0x1001: 'ar-LY',
    0x1801: 'ary',
    0x2001: 'ar-OM',
    0x4001: 'ar-QA',
    0x0401: 'ar-SA',
    0x2801: 'ar-SY',
    0x1C01: 'aeb',
    0x3801: 'ar-AE',
    0x2401: 'ar-YE',
    0x042B: 'hy',
    0x044D: 'as',
    0x082C: 'az-Cyrl',
    0x042C: 'az',
    0x046D: 'ba',
    0x042D: 'eu',
    0x0423: 'be',
    0x0845: 'bn',
    0x0445: 'bn-IN',
    0x201A: 'bs-Cyrl',
    0x141A: 'bs',
    0x047E: 'br',
    0x0402: 'bg',
    0x0403: 'ca',
    0x0C04: 'zh-HK',
    0x1404: 'zh-MO',
    0x0804: 'zh',
    0x1004: 'zh-SG',
    0x0404: 'zh-TW',
    0x0483: 'co',
    0x041A: 'hr',
    0x101A: 'hr-BA',
    0x0405: 'cs',
    0x0406: 'da',
    0x048C: 'prs',
    0x0465: 'dv',
    0x0813: 'nl-BE',
    0x0413: 'nl',
    0x0C09: 'en-AU',
    0x2809: 'en-BZ',
    0x1009: 'en-CA',
    0x2409: 'en-029',
    0x4009: 'en-IN',
    0x1809: 'en-IE',
    0x2009: 'en-JM',
    0x4409: 'en-MY',
    0x1409: 'en-NZ',
    0x3409: 'en-PH',
    0x4809: 'en-SG',
    0x1C09: 'en-ZA',
    0x2C09: 'en-TT',
    0x0809: 'en-GB',
    0x0409: 'en',
    0x3009: 'en-ZW',
    0x0425: 'et',
    0x0438: 'fo',
    0x0464: 'fil',
    0x040B: 'fi',
    0x080C: 'fr-BE',
    0x0C0C: 'fr-CA',
    0x040C: 'fr',
    0x140C: 'fr-LU',
    0x180C: 'fr-MC',
    0x100C: 'fr-CH',
    0x0462: 'fy',
    0x0456: 'gl',
    0x0437: 'ka',
    0x0C07: 'de-AT',
    0x0407: 'de',
    0x1407: 'de-LI',
    0x1007: 'de-LU',
    0x0807: 'de-CH',
    0x0408: 'el',
    0x046F: 'kl',
    0x0447: 'gu',
    0x0468: 'ha',
    0x040D: 'he',
    0x0439: 'hi',
    0x040E: 'hu',
    0x040F: 'is',
    0x0470: 'ig',
    0x0421: 'id',
    0x045D: 'iu',
    0x085D: 'iu-Latn',
    0x083C: 'ga',
    0x0434: 'xh',
    0x0435: 'zu',
    0x0410: 'it',
    0x0810: 'it-CH',
    0x0411: 'ja',
    0x044B: 'kn',
    0x043F: 'kk',
    0x0453: 'km',
    0x0486: 'quc',
    0x0487: 'rw',
    0x0441: 'sw',
    0x0457: 'kok',
    0x0412: 'ko',
    0x0440: 'ky',
    0x0454: 'lo',
    0x0426: 'lv',
    0x0427: 'lt',
    0x082E: 'dsb',
    0x046E: 'lb',
    0x042F: 'mk',
    0x083E: 'ms-BN',
    0x043E: 'ms',
    0x044C: 'ml',
    0x043A: 'mt',
    0x0481: 'mi',
    0x047A: 'arn',
    0x044E: 'mr',
    0x047C: 'moh',
    0x0450: 'mn',
    0x0850: 'mn-CN',
    0x0461: 'ne',
    0x0414: 'nb',
    0x0814: 'nn',
    0x0482: 'oc',
    0x0448: 'or',
    0x0463: 'ps',
    0x0415: 'pl',
    0x0416: 'pt',
    0x0816: 'pt-PT',
    0x0446: 'pa',
    0x046B: 'qu-BO',
    0x086B: 'qu-EC',
    0x0C6B: 'qu',
    0x0418: 'ro',
    0x0417: 'rm',
    0x0419: 'ru',
    0x243B: 'smn',
    0x103B: 'smj-NO',
    0x143B: 'smj',
    0x0C3B: 'se-FI',
    0x043B: 'se',
    0x083B: 'se-SE',
    0x203B: 'sms',
    0x183B: 'sma-NO',
    0x1C3B: 'sms',
    0x044F: 'sa',
    0x1C1A: 'sr-Cyrl-BA',
    0x0C1A: 'sr',
    0x181A: 'sr-Latn-BA',
    0x081A: 'sr-Latn',
    0x046C: 'nso',
    0x0432: 'tn',
    0x045B: 'si',
    0x041B: 'sk',
    0x0424: 'sl',
    0x2C0A: 'es-AR',
    0x400A: 'es-BO',
    0x340A: 'es-CL',
    0x240A: 'es-CO',
    0x140A: 'es-CR',
    0x1C0A: 'es-DO',
    0x300A: 'es-EC',
    0x440A: 'es-SV',
    0x100A: 'es-GT',
    0x480A: 'es-HN',
    0x080A: 'es-MX',
    0x4C0A: 'es-NI',
    0x180A: 'es-PA',
    0x3C0A: 'es-PY',
    0x280A: 'es-PE',
    0x500A: 'es-PR',

    // Microsoft has defined two different language codes for
    // “Spanish with modern sorting” and “Spanish with traditional
    // sorting”. This makes sense for collation APIs, and it would be
    // possible to express this in BCP 47 language tags via Unicode
    // extensions (eg., es-u-co-trad is Spanish with traditional
    // sorting). However, for storing names in fonts, the distinction
    // does not make sense, so we give “es” in both cases.
    0x0C0A: 'es',
    0x040A: 'es',

    0x540A: 'es-US',
    0x380A: 'es-UY',
    0x200A: 'es-VE',
    0x081D: 'sv-FI',
    0x041D: 'sv',
    0x045A: 'syr',
    0x0428: 'tg',
    0x085F: 'tzm',
    0x0449: 'ta',
    0x0444: 'tt',
    0x044A: 'te',
    0x041E: 'th',
    0x0451: 'bo',
    0x041F: 'tr',
    0x0442: 'tk',
    0x0480: 'ug',
    0x0422: 'uk',
    0x042E: 'hsb',
    0x0420: 'ur',
    0x0843: 'uz-Cyrl',
    0x0443: 'uz',
    0x042A: 'vi',
    0x0452: 'cy',
    0x0488: 'wo',
    0x0485: 'sah',
    0x0478: 'ii',
    0x046A: 'yo'
};

// Returns a IETF BCP 47 language code, for example 'zh-Hant'
// for 'Chinese in the traditional script'.
function getLanguageCode(platformID, languageID, ltag) {
    switch (platformID) {
        case 0:  // Unicode
            if (languageID === 0xFFFF) {
                return 'und';
            } else if (ltag) {
                return ltag[languageID];
            }

            break;

        case 1:  // Macintosh
            return macLanguages[languageID];

        case 3:  // Windows
            return windowsLanguages[languageID];
    }

    return undefined;
}

var utf16 = 'utf-16';

// MacOS script ID → encoding. This table stores the default case,
// which can be overridden by macLanguageEncodings.
var macScriptEncodings = {
    0: 'macintosh',           // smRoman
    1: 'x-mac-japanese',      // smJapanese
    2: 'x-mac-chinesetrad',   // smTradChinese
    3: 'x-mac-korean',        // smKorean
    6: 'x-mac-greek',         // smGreek
    7: 'x-mac-cyrillic',      // smCyrillic
    9: 'x-mac-devanagai',     // smDevanagari
    10: 'x-mac-gurmukhi',     // smGurmukhi
    11: 'x-mac-gujarati',     // smGujarati
    12: 'x-mac-oriya',        // smOriya
    13: 'x-mac-bengali',      // smBengali
    14: 'x-mac-tamil',        // smTamil
    15: 'x-mac-telugu',       // smTelugu
    16: 'x-mac-kannada',      // smKannada
    17: 'x-mac-malayalam',    // smMalayalam
    18: 'x-mac-sinhalese',    // smSinhalese
    19: 'x-mac-burmese',      // smBurmese
    20: 'x-mac-khmer',        // smKhmer
    21: 'x-mac-thai',         // smThai
    22: 'x-mac-lao',          // smLao
    23: 'x-mac-georgian',     // smGeorgian
    24: 'x-mac-armenian',     // smArmenian
    25: 'x-mac-chinesesimp',  // smSimpChinese
    26: 'x-mac-tibetan',      // smTibetan
    27: 'x-mac-mongolian',    // smMongolian
    28: 'x-mac-ethiopic',     // smEthiopic
    29: 'x-mac-ce',           // smCentralEuroRoman
    30: 'x-mac-vietnamese',   // smVietnamese
    31: 'x-mac-extarabic'     // smExtArabic
};

// MacOS language ID → encoding. This table stores the exceptional
// cases, which override macScriptEncodings. For writing MacOS naming
// tables, we need to emit a MacOS script ID. Therefore, we cannot
// merge macScriptEncodings into macLanguageEncodings.
//
// http://unicode.org/Public/MAPPINGS/VENDORS/APPLE/Readme.txt
var macLanguageEncodings = {
    15: 'x-mac-icelandic',    // langIcelandic
    17: 'x-mac-turkish',      // langTurkish
    18: 'x-mac-croatian',     // langCroatian
    24: 'x-mac-ce',           // langLithuanian
    25: 'x-mac-ce',           // langPolish
    26: 'x-mac-ce',           // langHungarian
    27: 'x-mac-ce',           // langEstonian
    28: 'x-mac-ce',           // langLatvian
    30: 'x-mac-icelandic',    // langFaroese
    37: 'x-mac-romanian',     // langRomanian
    38: 'x-mac-ce',           // langCzech
    39: 'x-mac-ce',           // langSlovak
    40: 'x-mac-ce',           // langSlovenian
    143: 'x-mac-inuit',       // langInuktitut
    146: 'x-mac-gaelic'       // langIrishGaelicScript
};

function getEncoding(platformID, encodingID, languageID) {
    switch (platformID) {
        case 0:  // Unicode
            return utf16;

        case 1:  // Apple Macintosh
            return macLanguageEncodings[languageID] || macScriptEncodings[encodingID];

        case 3:  // Microsoft Windows
            if (encodingID === 1 || encodingID === 10) {
                return utf16;
            }

            break;
    }

    return undefined;
}

// Parse the naming `name` table.
// FIXME: Format 1 additional fields are not supported yet.
// ltag is the content of the `ltag' table, such as ['en', 'zh-Hans', 'de-CH-1904'].
function parseNameTable(data, start, ltag) {
    var name = {};
    var p = new parse.Parser(data, start);
    var format = p.parseUShort();
    var count = p.parseUShort();
    var stringOffset = p.offset + p.parseUShort();
    for (var i = 0; i < count; i++) {
        var platformID = p.parseUShort();
        var encodingID = p.parseUShort();
        var languageID = p.parseUShort();
        var nameID = p.parseUShort();
        var property = nameTableNames[nameID] || nameID;
        var byteLength = p.parseUShort();
        var offset = p.parseUShort();
        var language = getLanguageCode(platformID, languageID, ltag);
        var encoding = getEncoding(platformID, encodingID, languageID);
        if (encoding !== undefined && language !== undefined) {
            var text = (void 0);
            if (encoding === utf16) {
                text = decode.UTF16(data, stringOffset + offset, byteLength);
            } else {
                text = decode.MACSTRING(data, stringOffset + offset, byteLength, encoding);
            }

            if (text) {
                var translations = name[property];
                if (translations === undefined) {
                    translations = name[property] = {};
                }

                translations[language] = text;
            }
        }
    }

    var langTagCount = 0;
    if (format === 1) {
        // FIXME: Also handle Microsoft's 'name' table 1.
        langTagCount = p.parseUShort();
    }

    return name;
}

// {23: 'foo'} → {'foo': 23}
// ['bar', 'baz'] → {'bar': 0, 'baz': 1}
function reverseDict(dict) {
    var result = {};
    for (var key in dict) {
        result[dict[key]] = parseInt(key);
    }

    return result;
}

function makeNameRecord(platformID, encodingID, languageID, nameID, length, offset) {
    return new table.Record('NameRecord', [
        {name: 'platformID', type: 'USHORT', value: platformID},
        {name: 'encodingID', type: 'USHORT', value: encodingID},
        {name: 'languageID', type: 'USHORT', value: languageID},
        {name: 'nameID', type: 'USHORT', value: nameID},
        {name: 'length', type: 'USHORT', value: length},
        {name: 'offset', type: 'USHORT', value: offset}
    ]);
}

// Finds the position of needle in haystack, or -1 if not there.
// Like String.indexOf(), but for arrays.
function findSubArray(needle, haystack) {
    var needleLength = needle.length;
    var limit = haystack.length - needleLength + 1;

    loop:
    for (var pos = 0; pos < limit; pos++) {
        for (; pos < limit; pos++) {
            for (var k = 0; k < needleLength; k++) {
                if (haystack[pos + k] !== needle[k]) {
                    continue loop;
                }
            }

            return pos;
        }
    }

    return -1;
}

function addStringToPool(s, pool) {
    var offset = findSubArray(s, pool);
    if (offset < 0) {
        offset = pool.length;
        var i = 0;
        var len = s.length;
        for (; i < len; ++i) {
            pool.push(s[i]);
        }

    }

    return offset;
}

function makeNameTable(names, ltag) {
    var nameID;
    var nameIDs = [];

    var namesWithNumericKeys = {};
    var nameTableIds = reverseDict(nameTableNames);
    for (var key in names) {
        var id = nameTableIds[key];
        if (id === undefined) {
            id = key;
        }

        nameID = parseInt(id);

        if (isNaN(nameID)) {
            throw new Error('Name table entry "' + key + '" does not exist, see nameTableNames for complete list.');
        }

        namesWithNumericKeys[nameID] = names[key];
        nameIDs.push(nameID);
    }

    var macLanguageIds = reverseDict(macLanguages);
    var windowsLanguageIds = reverseDict(windowsLanguages);

    var nameRecords = [];
    var stringPool = [];

    for (var i = 0; i < nameIDs.length; i++) {
        nameID = nameIDs[i];
        var translations = namesWithNumericKeys[nameID];
        for (var lang in translations) {
            var text = translations[lang];

            // For MacOS, we try to emit the name in the form that was introduced
            // in the initial version of the TrueType spec (in the late 1980s).
            // However, this can fail for various reasons: the requested BCP 47
            // language code might not have an old-style Mac equivalent;
            // we might not have a codec for the needed character encoding;
            // or the name might contain characters that cannot be expressed
            // in the old-style Macintosh encoding. In case of failure, we emit
            // the name in a more modern fashion (Unicode encoding with BCP 47
            // language tags) that is recognized by MacOS 10.5, released in 2009.
            // If fonts were only read by operating systems, we could simply
            // emit all names in the modern form; this would be much easier.
            // However, there are many applications and libraries that read
            // 'name' tables directly, and these will usually only recognize
            // the ancient form (silently skipping the unrecognized names).
            var macPlatform = 1;  // Macintosh
            var macLanguage = macLanguageIds[lang];
            var macScript = macLanguageToScript[macLanguage];
            var macEncoding = getEncoding(macPlatform, macScript, macLanguage);
            var macName = encode.MACSTRING(text, macEncoding);
            if (macName === undefined) {
                macPlatform = 0;  // Unicode
                macLanguage = ltag.indexOf(lang);
                if (macLanguage < 0) {
                    macLanguage = ltag.length;
                    ltag.push(lang);
                }

                macScript = 4;  // Unicode 2.0 and later
                macName = encode.UTF16(text);
            }

            var macNameOffset = addStringToPool(macName, stringPool);
            nameRecords.push(makeNameRecord(macPlatform, macScript, macLanguage,
                                            nameID, macName.length, macNameOffset));

            var winLanguage = windowsLanguageIds[lang];
            if (winLanguage !== undefined) {
                var winName = encode.UTF16(text);
                var winNameOffset = addStringToPool(winName, stringPool);
                nameRecords.push(makeNameRecord(3, 1, winLanguage,
                                                nameID, winName.length, winNameOffset));
            }
        }
    }

    nameRecords.sort(function(a, b) {
        return ((a.platformID - b.platformID) ||
                (a.encodingID - b.encodingID) ||
                (a.languageID - b.languageID) ||
                (a.nameID - b.nameID));
    });

    var t = new table.Table('name', [
        {name: 'format', type: 'USHORT', value: 0},
        {name: 'count', type: 'USHORT', value: nameRecords.length},
        {name: 'stringOffset', type: 'USHORT', value: 6 + nameRecords.length * 12}
    ]);

    for (var r = 0; r < nameRecords.length; r++) {
        t.fields.push({name: 'record_' + r, type: 'RECORD', value: nameRecords[r]});
    }

    t.fields.push({name: 'strings', type: 'LITERAL', value: stringPool});
    return t;
}

var _name = { parse: parseNameTable, make: makeNameTable };

// The `OS/2` table contains metrics required in OpenType fonts.
// https://www.microsoft.com/typography/OTSPEC/os2.htm

var unicodeRanges = [
    {begin: 0x0000, end: 0x007F}, // Basic Latin
    {begin: 0x0080, end: 0x00FF}, // Latin-1 Supplement
    {begin: 0x0100, end: 0x017F}, // Latin Extended-A
    {begin: 0x0180, end: 0x024F}, // Latin Extended-B
    {begin: 0x0250, end: 0x02AF}, // IPA Extensions
    {begin: 0x02B0, end: 0x02FF}, // Spacing Modifier Letters
    {begin: 0x0300, end: 0x036F}, // Combining Diacritical Marks
    {begin: 0x0370, end: 0x03FF}, // Greek and Coptic
    {begin: 0x2C80, end: 0x2CFF}, // Coptic
    {begin: 0x0400, end: 0x04FF}, // Cyrillic
    {begin: 0x0530, end: 0x058F}, // Armenian
    {begin: 0x0590, end: 0x05FF}, // Hebrew
    {begin: 0xA500, end: 0xA63F}, // Vai
    {begin: 0x0600, end: 0x06FF}, // Arabic
    {begin: 0x07C0, end: 0x07FF}, // NKo
    {begin: 0x0900, end: 0x097F}, // Devanagari
    {begin: 0x0980, end: 0x09FF}, // Bengali
    {begin: 0x0A00, end: 0x0A7F}, // Gurmukhi
    {begin: 0x0A80, end: 0x0AFF}, // Gujarati
    {begin: 0x0B00, end: 0x0B7F}, // Oriya
    {begin: 0x0B80, end: 0x0BFF}, // Tamil
    {begin: 0x0C00, end: 0x0C7F}, // Telugu
    {begin: 0x0C80, end: 0x0CFF}, // Kannada
    {begin: 0x0D00, end: 0x0D7F}, // Malayalam
    {begin: 0x0E00, end: 0x0E7F}, // Thai
    {begin: 0x0E80, end: 0x0EFF}, // Lao
    {begin: 0x10A0, end: 0x10FF}, // Georgian
    {begin: 0x1B00, end: 0x1B7F}, // Balinese
    {begin: 0x1100, end: 0x11FF}, // Hangul Jamo
    {begin: 0x1E00, end: 0x1EFF}, // Latin Extended Additional
    {begin: 0x1F00, end: 0x1FFF}, // Greek Extended
    {begin: 0x2000, end: 0x206F}, // General Punctuation
    {begin: 0x2070, end: 0x209F}, // Superscripts And Subscripts
    {begin: 0x20A0, end: 0x20CF}, // Currency Symbol
    {begin: 0x20D0, end: 0x20FF}, // Combining Diacritical Marks For Symbols
    {begin: 0x2100, end: 0x214F}, // Letterlike Symbols
    {begin: 0x2150, end: 0x218F}, // Number Forms
    {begin: 0x2190, end: 0x21FF}, // Arrows
    {begin: 0x2200, end: 0x22FF}, // Mathematical Operators
    {begin: 0x2300, end: 0x23FF}, // Miscellaneous Technical
    {begin: 0x2400, end: 0x243F}, // Control Pictures
    {begin: 0x2440, end: 0x245F}, // Optical Character Recognition
    {begin: 0x2460, end: 0x24FF}, // Enclosed Alphanumerics
    {begin: 0x2500, end: 0x257F}, // Box Drawing
    {begin: 0x2580, end: 0x259F}, // Block Elements
    {begin: 0x25A0, end: 0x25FF}, // Geometric Shapes
    {begin: 0x2600, end: 0x26FF}, // Miscellaneous Symbols
    {begin: 0x2700, end: 0x27BF}, // Dingbats
    {begin: 0x3000, end: 0x303F}, // CJK Symbols And Punctuation
    {begin: 0x3040, end: 0x309F}, // Hiragana
    {begin: 0x30A0, end: 0x30FF}, // Katakana
    {begin: 0x3100, end: 0x312F}, // Bopomofo
    {begin: 0x3130, end: 0x318F}, // Hangul Compatibility Jamo
    {begin: 0xA840, end: 0xA87F}, // Phags-pa
    {begin: 0x3200, end: 0x32FF}, // Enclosed CJK Letters And Months
    {begin: 0x3300, end: 0x33FF}, // CJK Compatibility
    {begin: 0xAC00, end: 0xD7AF}, // Hangul Syllables
    {begin: 0xD800, end: 0xDFFF}, // Non-Plane 0 *
    {begin: 0x10900, end: 0x1091F}, // Phoenicia
    {begin: 0x4E00, end: 0x9FFF}, // CJK Unified Ideographs
    {begin: 0xE000, end: 0xF8FF}, // Private Use Area (plane 0)
    {begin: 0x31C0, end: 0x31EF}, // CJK Strokes
    {begin: 0xFB00, end: 0xFB4F}, // Alphabetic Presentation Forms
    {begin: 0xFB50, end: 0xFDFF}, // Arabic Presentation Forms-A
    {begin: 0xFE20, end: 0xFE2F}, // Combining Half Marks
    {begin: 0xFE10, end: 0xFE1F}, // Vertical Forms
    {begin: 0xFE50, end: 0xFE6F}, // Small Form Variants
    {begin: 0xFE70, end: 0xFEFF}, // Arabic Presentation Forms-B
    {begin: 0xFF00, end: 0xFFEF}, // Halfwidth And Fullwidth Forms
    {begin: 0xFFF0, end: 0xFFFF}, // Specials
    {begin: 0x0F00, end: 0x0FFF}, // Tibetan
    {begin: 0x0700, end: 0x074F}, // Syriac
    {begin: 0x0780, end: 0x07BF}, // Thaana
    {begin: 0x0D80, end: 0x0DFF}, // Sinhala
    {begin: 0x1000, end: 0x109F}, // Myanmar
    {begin: 0x1200, end: 0x137F}, // Ethiopic
    {begin: 0x13A0, end: 0x13FF}, // Cherokee
    {begin: 0x1400, end: 0x167F}, // Unified Canadian Aboriginal Syllabics
    {begin: 0x1680, end: 0x169F}, // Ogham
    {begin: 0x16A0, end: 0x16FF}, // Runic
    {begin: 0x1780, end: 0x17FF}, // Khmer
    {begin: 0x1800, end: 0x18AF}, // Mongolian
    {begin: 0x2800, end: 0x28FF}, // Braille Patterns
    {begin: 0xA000, end: 0xA48F}, // Yi Syllables
    {begin: 0x1700, end: 0x171F}, // Tagalog
    {begin: 0x10300, end: 0x1032F}, // Old Italic
    {begin: 0x10330, end: 0x1034F}, // Gothic
    {begin: 0x10400, end: 0x1044F}, // Deseret
    {begin: 0x1D000, end: 0x1D0FF}, // Byzantine Musical Symbols
    {begin: 0x1D400, end: 0x1D7FF}, // Mathematical Alphanumeric Symbols
    {begin: 0xFF000, end: 0xFFFFD}, // Private Use (plane 15)
    {begin: 0xFE00, end: 0xFE0F}, // Variation Selectors
    {begin: 0xE0000, end: 0xE007F}, // Tags
    {begin: 0x1900, end: 0x194F}, // Limbu
    {begin: 0x1950, end: 0x197F}, // Tai Le
    {begin: 0x1980, end: 0x19DF}, // New Tai Lue
    {begin: 0x1A00, end: 0x1A1F}, // Buginese
    {begin: 0x2C00, end: 0x2C5F}, // Glagolitic
    {begin: 0x2D30, end: 0x2D7F}, // Tifinagh
    {begin: 0x4DC0, end: 0x4DFF}, // Yijing Hexagram Symbols
    {begin: 0xA800, end: 0xA82F}, // Syloti Nagri
    {begin: 0x10000, end: 0x1007F}, // Linear B Syllabary
    {begin: 0x10140, end: 0x1018F}, // Ancient Greek Numbers
    {begin: 0x10380, end: 0x1039F}, // Ugaritic
    {begin: 0x103A0, end: 0x103DF}, // Old Persian
    {begin: 0x10450, end: 0x1047F}, // Shavian
    {begin: 0x10480, end: 0x104AF}, // Osmanya
    {begin: 0x10800, end: 0x1083F}, // Cypriot Syllabary
    {begin: 0x10A00, end: 0x10A5F}, // Kharoshthi
    {begin: 0x1D300, end: 0x1D35F}, // Tai Xuan Jing Symbols
    {begin: 0x12000, end: 0x123FF}, // Cuneiform
    {begin: 0x1D360, end: 0x1D37F}, // Counting Rod Numerals
    {begin: 0x1B80, end: 0x1BBF}, // Sundanese
    {begin: 0x1C00, end: 0x1C4F}, // Lepcha
    {begin: 0x1C50, end: 0x1C7F}, // Ol Chiki
    {begin: 0xA880, end: 0xA8DF}, // Saurashtra
    {begin: 0xA900, end: 0xA92F}, // Kayah Li
    {begin: 0xA930, end: 0xA95F}, // Rejang
    {begin: 0xAA00, end: 0xAA5F}, // Cham
    {begin: 0x10190, end: 0x101CF}, // Ancient Symbols
    {begin: 0x101D0, end: 0x101FF}, // Phaistos Disc
    {begin: 0x102A0, end: 0x102DF}, // Carian
    {begin: 0x1F030, end: 0x1F09F}  // Domino Tiles
];

function getUnicodeRange(unicode) {
    for (var i = 0; i < unicodeRanges.length; i += 1) {
        var range = unicodeRanges[i];
        if (unicode >= range.begin && unicode < range.end) {
            return i;
        }
    }

    return -1;
}

// Parse the OS/2 and Windows metrics `OS/2` table
function parseOS2Table(data, start) {
    var os2 = {};
    var p = new parse.Parser(data, start);
    os2.version = p.parseUShort();
    os2.xAvgCharWidth = p.parseShort();
    os2.usWeightClass = p.parseUShort();
    os2.usWidthClass = p.parseUShort();
    os2.fsType = p.parseUShort();
    os2.ySubscriptXSize = p.parseShort();
    os2.ySubscriptYSize = p.parseShort();
    os2.ySubscriptXOffset = p.parseShort();
    os2.ySubscriptYOffset = p.parseShort();
    os2.ySuperscriptXSize = p.parseShort();
    os2.ySuperscriptYSize = p.parseShort();
    os2.ySuperscriptXOffset = p.parseShort();
    os2.ySuperscriptYOffset = p.parseShort();
    os2.yStrikeoutSize = p.parseShort();
    os2.yStrikeoutPosition = p.parseShort();
    os2.sFamilyClass = p.parseShort();
    os2.panose = [];
    for (var i = 0; i < 10; i++) {
        os2.panose[i] = p.parseByte();
    }

    os2.ulUnicodeRange1 = p.parseULong();
    os2.ulUnicodeRange2 = p.parseULong();
    os2.ulUnicodeRange3 = p.parseULong();
    os2.ulUnicodeRange4 = p.parseULong();
    os2.achVendID = String.fromCharCode(p.parseByte(), p.parseByte(), p.parseByte(), p.parseByte());
    os2.fsSelection = p.parseUShort();
    os2.usFirstCharIndex = p.parseUShort();
    os2.usLastCharIndex = p.parseUShort();
    os2.sTypoAscender = p.parseShort();
    os2.sTypoDescender = p.parseShort();
    os2.sTypoLineGap = p.parseShort();
    os2.usWinAscent = p.parseUShort();
    os2.usWinDescent = p.parseUShort();
    if (os2.version >= 1) {
        os2.ulCodePageRange1 = p.parseULong();
        os2.ulCodePageRange2 = p.parseULong();
    }

    if (os2.version >= 2) {
        os2.sxHeight = p.parseShort();
        os2.sCapHeight = p.parseShort();
        os2.usDefaultChar = p.parseUShort();
        os2.usBreakChar = p.parseUShort();
        os2.usMaxContent = p.parseUShort();
    }

    return os2;
}

function makeOS2Table(options) {
    return new table.Table('OS/2', [
        {name: 'version', type: 'USHORT', value: 0x0003},
        {name: 'xAvgCharWidth', type: 'SHORT', value: 0},
        {name: 'usWeightClass', type: 'USHORT', value: 0},
        {name: 'usWidthClass', type: 'USHORT', value: 0},
        {name: 'fsType', type: 'USHORT', value: 0},
        {name: 'ySubscriptXSize', type: 'SHORT', value: 650},
        {name: 'ySubscriptYSize', type: 'SHORT', value: 699},
        {name: 'ySubscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySubscriptYOffset', type: 'SHORT', value: 140},
        {name: 'ySuperscriptXSize', type: 'SHORT', value: 650},
        {name: 'ySuperscriptYSize', type: 'SHORT', value: 699},
        {name: 'ySuperscriptXOffset', type: 'SHORT', value: 0},
        {name: 'ySuperscriptYOffset', type: 'SHORT', value: 479},
        {name: 'yStrikeoutSize', type: 'SHORT', value: 49},
        {name: 'yStrikeoutPosition', type: 'SHORT', value: 258},
        {name: 'sFamilyClass', type: 'SHORT', value: 0},
        {name: 'bFamilyType', type: 'BYTE', value: 0},
        {name: 'bSerifStyle', type: 'BYTE', value: 0},
        {name: 'bWeight', type: 'BYTE', value: 0},
        {name: 'bProportion', type: 'BYTE', value: 0},
        {name: 'bContrast', type: 'BYTE', value: 0},
        {name: 'bStrokeVariation', type: 'BYTE', value: 0},
        {name: 'bArmStyle', type: 'BYTE', value: 0},
        {name: 'bLetterform', type: 'BYTE', value: 0},
        {name: 'bMidline', type: 'BYTE', value: 0},
        {name: 'bXHeight', type: 'BYTE', value: 0},
        {name: 'ulUnicodeRange1', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange2', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange3', type: 'ULONG', value: 0},
        {name: 'ulUnicodeRange4', type: 'ULONG', value: 0},
        {name: 'achVendID', type: 'CHARARRAY', value: 'XXXX'},
        {name: 'fsSelection', type: 'USHORT', value: 0},
        {name: 'usFirstCharIndex', type: 'USHORT', value: 0},
        {name: 'usLastCharIndex', type: 'USHORT', value: 0},
        {name: 'sTypoAscender', type: 'SHORT', value: 0},
        {name: 'sTypoDescender', type: 'SHORT', value: 0},
        {name: 'sTypoLineGap', type: 'SHORT', value: 0},
        {name: 'usWinAscent', type: 'USHORT', value: 0},
        {name: 'usWinDescent', type: 'USHORT', value: 0},
        {name: 'ulCodePageRange1', type: 'ULONG', value: 0},
        {name: 'ulCodePageRange2', type: 'ULONG', value: 0},
        {name: 'sxHeight', type: 'SHORT', value: 0},
        {name: 'sCapHeight', type: 'SHORT', value: 0},
        {name: 'usDefaultChar', type: 'USHORT', value: 0},
        {name: 'usBreakChar', type: 'USHORT', value: 0},
        {name: 'usMaxContext', type: 'USHORT', value: 0}
    ], options);
}

var os2 = { parse: parseOS2Table, make: makeOS2Table, unicodeRanges: unicodeRanges, getUnicodeRange: getUnicodeRange };

// The `post` table stores additional PostScript information, such as glyph names.
// https://www.microsoft.com/typography/OTSPEC/post.htm

// Parse the PostScript `post` table
function parsePostTable(data, start) {
    var post = {};
    var p = new parse.Parser(data, start);
    post.version = p.parseVersion();
    post.italicAngle = p.parseFixed();
    post.underlinePosition = p.parseShort();
    post.underlineThickness = p.parseShort();
    post.isFixedPitch = p.parseULong();
    post.minMemType42 = p.parseULong();
    post.maxMemType42 = p.parseULong();
    post.minMemType1 = p.parseULong();
    post.maxMemType1 = p.parseULong();
    switch (post.version) {
        case 1:
            post.names = standardNames.slice();
            break;
        case 2:
            post.numberOfGlyphs = p.parseUShort();
            post.glyphNameIndex = new Array(post.numberOfGlyphs);
            for (var i = 0; i < post.numberOfGlyphs; i++) {
                post.glyphNameIndex[i] = p.parseUShort();
            }

            post.names = [];
            for (var i$1 = 0; i$1 < post.numberOfGlyphs; i$1++) {
                if (post.glyphNameIndex[i$1] >= standardNames.length) {
                    var nameLength = p.parseChar();
                    post.names.push(p.parseString(nameLength));
                }
            }

            break;
        case 2.5:
            post.numberOfGlyphs = p.parseUShort();
            post.offset = new Array(post.numberOfGlyphs);
            for (var i$2 = 0; i$2 < post.numberOfGlyphs; i$2++) {
                post.offset[i$2] = p.parseChar();
            }

            break;
    }
    return post;
}

function makePostTable() {
    return new table.Table('post', [
        {name: 'version', type: 'FIXED', value: 0x00030000},
        {name: 'italicAngle', type: 'FIXED', value: 0},
        {name: 'underlinePosition', type: 'FWORD', value: 0},
        {name: 'underlineThickness', type: 'FWORD', value: 0},
        {name: 'isFixedPitch', type: 'ULONG', value: 0},
        {name: 'minMemType42', type: 'ULONG', value: 0},
        {name: 'maxMemType42', type: 'ULONG', value: 0},
        {name: 'minMemType1', type: 'ULONG', value: 0},
        {name: 'maxMemType1', type: 'ULONG', value: 0}
    ]);
}

var post = { parse: parsePostTable, make: makePostTable };

// The `GSUB` table contains ligatures, among other things.
// https://www.microsoft.com/typography/OTSPEC/gsub.htm

var subtableParsers = new Array(9);         // subtableParsers[0] is unused

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#SS
subtableParsers[1] = function parseLookup1() {
    var start = this.offset + this.relativeOffset;
    var substFormat = this.parseUShort();
    if (substFormat === 1) {
        return {
            substFormat: 1,
            coverage: this.parsePointer(Parser.coverage),
            deltaGlyphId: this.parseUShort()
        };
    } else if (substFormat === 2) {
        return {
            substFormat: 2,
            coverage: this.parsePointer(Parser.coverage),
            substitute: this.parseOffset16List()
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': lookup type 1 format must be 1 or 2.');
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#MS
subtableParsers[2] = function parseLookup2() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Multiple Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        sequences: this.parseListOfLists()
    };
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#AS
subtableParsers[3] = function parseLookup3() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Alternate Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        alternateSets: this.parseListOfLists()
    };
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#LS
subtableParsers[4] = function parseLookup4() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB ligature table identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        ligatureSets: this.parseListOfLists(function() {
            return {
                ligGlyph: this.parseUShort(),
                components: this.parseUShortList(this.parseUShort() - 1)
            };
        })
    };
};

var lookupRecordDesc = {
    sequenceIndex: Parser.uShort,
    lookupListIndex: Parser.uShort
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CSF
subtableParsers[5] = function parseLookup5() {
    var start = this.offset + this.relativeOffset;
    var substFormat = this.parseUShort();

    if (substFormat === 1) {
        return {
            substFormat: substFormat,
            coverage: this.parsePointer(Parser.coverage),
            ruleSets: this.parseListOfLists(function() {
                var glyphCount = this.parseUShort();
                var substCount = this.parseUShort();
                return {
                    input: this.parseUShortList(glyphCount - 1),
                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 2) {
        return {
            substFormat: substFormat,
            coverage: this.parsePointer(Parser.coverage),
            classDef: this.parsePointer(Parser.classDef),
            classSets: this.parseListOfLists(function() {
                var glyphCount = this.parseUShort();
                var substCount = this.parseUShort();
                return {
                    classes: this.parseUShortList(glyphCount - 1),
                    lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 3) {
        var glyphCount = this.parseUShort();
        var substCount = this.parseUShort();
        return {
            substFormat: substFormat,
            coverages: this.parseList(glyphCount, Parser.pointer(Parser.coverage)),
            lookupRecords: this.parseRecordList(substCount, lookupRecordDesc)
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': lookup type 5 format must be 1, 2 or 3.');
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#CC
subtableParsers[6] = function parseLookup6() {
    var start = this.offset + this.relativeOffset;
    var substFormat = this.parseUShort();
    if (substFormat === 1) {
        return {
            substFormat: 1,
            coverage: this.parsePointer(Parser.coverage),
            chainRuleSets: this.parseListOfLists(function() {
                return {
                    backtrack: this.parseUShortList(),
                    input: this.parseUShortList(this.parseShort() - 1),
                    lookahead: this.parseUShortList(),
                    lookupRecords: this.parseRecordList(lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 2) {
        return {
            substFormat: 2,
            coverage: this.parsePointer(Parser.coverage),
            backtrackClassDef: this.parsePointer(Parser.classDef),
            inputClassDef: this.parsePointer(Parser.classDef),
            lookaheadClassDef: this.parsePointer(Parser.classDef),
            chainClassSet: this.parseListOfLists(function() {
                return {
                    backtrack: this.parseUShortList(),
                    input: this.parseUShortList(this.parseShort() - 1),
                    lookahead: this.parseUShortList(),
                    lookupRecords: this.parseRecordList(lookupRecordDesc)
                };
            })
        };
    } else if (substFormat === 3) {
        return {
            substFormat: 3,
            backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            inputCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
            lookupRecords: this.parseRecordList(lookupRecordDesc)
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': lookup type 6 format must be 1, 2 or 3.');
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#ES
subtableParsers[7] = function parseLookup7() {
    // Extension Substitution subtable
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Extension Substitution subtable identifier-format must be 1');
    var extensionLookupType = this.parseUShort();
    var extensionParser = new Parser(this.data, this.offset + this.parseULong());
    return {
        substFormat: 1,
        lookupType: extensionLookupType,
        extension: subtableParsers[extensionLookupType].call(extensionParser)
    };
};

// https://www.microsoft.com/typography/OTSPEC/GSUB.htm#RCCS
subtableParsers[8] = function parseLookup8() {
    var substFormat = this.parseUShort();
    check.argument(substFormat === 1, 'GSUB Reverse Chaining Contextual Single Substitution Subtable identifier-format must be 1');
    return {
        substFormat: substFormat,
        coverage: this.parsePointer(Parser.coverage),
        backtrackCoverage: this.parseList(Parser.pointer(Parser.coverage)),
        lookaheadCoverage: this.parseList(Parser.pointer(Parser.coverage)),
        substitutes: this.parseUShortList()
    };
};

// https://www.microsoft.com/typography/OTSPEC/gsub.htm
function parseGsubTable(data, start) {
    start = start || 0;
    var p = new Parser(data, start);
    var tableVersion = p.parseVersion(1);
    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GSUB table version.');
    if (tableVersion === 1) {
        return {
            version: tableVersion,
            scripts: p.parseScriptList(),
            features: p.parseFeatureList(),
            lookups: p.parseLookupList(subtableParsers)
        };
    } else {
        return {
            version: tableVersion,
            scripts: p.parseScriptList(),
            features: p.parseFeatureList(),
            lookups: p.parseLookupList(subtableParsers),
            variations: p.parseFeatureVariationsList()
        };
    }

}

// GSUB Writing //////////////////////////////////////////////
var subtableMakers = new Array(9);

subtableMakers[1] = function makeLookup1(subtable) {
    if (subtable.substFormat === 1) {
        return new table.Table('substitutionTable', [
            {name: 'substFormat', type: 'USHORT', value: 1},
            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)},
            {name: 'deltaGlyphID', type: 'USHORT', value: subtable.deltaGlyphId}
        ]);
    } else {
        return new table.Table('substitutionTable', [
            {name: 'substFormat', type: 'USHORT', value: 2},
            {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
        ].concat(table.ushortList('substitute', subtable.substitute)));
    }
    check.fail('Lookup type 1 substFormat must be 1 or 2.');
};

subtableMakers[3] = function makeLookup3(subtable) {
    check.assert(subtable.substFormat === 1, 'Lookup type 3 substFormat must be 1.');
    return new table.Table('substitutionTable', [
        {name: 'substFormat', type: 'USHORT', value: 1},
        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
    ].concat(table.tableList('altSet', subtable.alternateSets, function(alternateSet) {
        return new table.Table('alternateSetTable', table.ushortList('alternate', alternateSet));
    })));
};

subtableMakers[4] = function makeLookup4(subtable) {
    check.assert(subtable.substFormat === 1, 'Lookup type 4 substFormat must be 1.');
    return new table.Table('substitutionTable', [
        {name: 'substFormat', type: 'USHORT', value: 1},
        {name: 'coverage', type: 'TABLE', value: new table.Coverage(subtable.coverage)}
    ].concat(table.tableList('ligSet', subtable.ligatureSets, function(ligatureSet) {
        return new table.Table('ligatureSetTable', table.tableList('ligature', ligatureSet, function(ligature) {
            return new table.Table('ligatureTable',
                [{name: 'ligGlyph', type: 'USHORT', value: ligature.ligGlyph}]
                .concat(table.ushortList('component', ligature.components, ligature.components.length + 1))
            );
        }));
    })));
};

function makeGsubTable(gsub) {
    return new table.Table('GSUB', [
        {name: 'version', type: 'ULONG', value: 0x10000},
        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gsub.scripts)},
        {name: 'features', type: 'TABLE', value: new table.FeatureList(gsub.features)},
        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gsub.lookups, subtableMakers)}
    ]);
}

var gsub = { parse: parseGsubTable, make: makeGsubTable };

// The `GPOS` table contains kerning pairs, among other things.
// https://www.microsoft.com/typography/OTSPEC/gpos.htm

// Parse the metadata `meta` table.
// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6meta.html
function parseMetaTable(data, start) {
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseULong();
    check.argument(tableVersion === 1, 'Unsupported META table version.');
    p.parseULong(); // flags - currently unused and set to 0
    p.parseULong(); // tableOffset
    var numDataMaps = p.parseULong();

    var tags = {};
    for (var i = 0; i < numDataMaps; i++) {
        var tag = p.parseTag();
        var dataOffset = p.parseULong();
        var dataLength = p.parseULong();
        var text = decode.UTF8(data, start + dataOffset, dataLength);

        tags[tag] = text;
    }
    return tags;
}

function makeMetaTable(tags) {
    var numTags = Object.keys(tags).length;
    var stringPool = '';
    var stringPoolOffset = 16 + numTags * 12;

    var result = new table.Table('meta', [
        {name: 'version', type: 'ULONG', value: 1},
        {name: 'flags', type: 'ULONG', value: 0},
        {name: 'offset', type: 'ULONG', value: stringPoolOffset},
        {name: 'numTags', type: 'ULONG', value: numTags}
    ]);

    for (var tag in tags) {
        var pos = stringPool.length;
        stringPool += tags[tag];

        result.fields.push({name: 'tag ' + tag, type: 'TAG', value: tag});
        result.fields.push({name: 'offset ' + tag, type: 'ULONG', value: stringPoolOffset + pos});
        result.fields.push({name: 'length ' + tag, type: 'ULONG', value: tags[tag].length});
    }

    result.fields.push({name: 'stringPool', type: 'CHARARRAY', value: stringPool});

    return result;
}

var meta = { parse: parseMetaTable, make: makeMetaTable };

// The `sfnt` wrapper provides organization for the tables in the font.
// It is the top-level data structure in a font.
// https://www.microsoft.com/typography/OTSPEC/otff.htm
// Recommendations for creating OpenType Fonts:
// http://www.microsoft.com/typography/otspec140/recom.htm

function log2(v) {
    return Math.log(v) / Math.log(2) | 0;
}

function computeCheckSum(bytes) {
    while (bytes.length % 4 !== 0) {
        bytes.push(0);
    }

    var sum = 0;
    for (var i = 0; i < bytes.length; i += 4) {
        sum += (bytes[i] << 24) +
            (bytes[i + 1] << 16) +
            (bytes[i + 2] << 8) +
            (bytes[i + 3]);
    }

    sum %= Math.pow(2, 32);
    return sum;
}

function makeTableRecord(tag, checkSum, offset, length) {
    return new table.Record('Table Record', [
        {name: 'tag', type: 'TAG', value: tag !== undefined ? tag : ''},
        {name: 'checkSum', type: 'ULONG', value: checkSum !== undefined ? checkSum : 0},
        {name: 'offset', type: 'ULONG', value: offset !== undefined ? offset : 0},
        {name: 'length', type: 'ULONG', value: length !== undefined ? length : 0}
    ]);
}

function makeSfntTable(tables) {
    var sfnt = new table.Table('sfnt', [
        {name: 'version', type: 'TAG', value: 'OTTO'},
        {name: 'numTables', type: 'USHORT', value: 0},
        {name: 'searchRange', type: 'USHORT', value: 0},
        {name: 'entrySelector', type: 'USHORT', value: 0},
        {name: 'rangeShift', type: 'USHORT', value: 0}
    ]);
    sfnt.tables = tables;
    sfnt.numTables = tables.length;
    var highestPowerOf2 = Math.pow(2, log2(sfnt.numTables));
    sfnt.searchRange = 16 * highestPowerOf2;
    sfnt.entrySelector = log2(highestPowerOf2);
    sfnt.rangeShift = sfnt.numTables * 16 - sfnt.searchRange;

    var recordFields = [];
    var tableFields = [];

    var offset = sfnt.sizeOf() + (makeTableRecord().sizeOf() * sfnt.numTables);
    while (offset % 4 !== 0) {
        offset += 1;
        tableFields.push({name: 'padding', type: 'BYTE', value: 0});
    }

    for (var i = 0; i < tables.length; i += 1) {
        var t = tables[i];
        check.argument(t.tableName.length === 4, 'Table name' + t.tableName + ' is invalid.');
        var tableLength = t.sizeOf();
        var tableRecord = makeTableRecord(t.tableName, computeCheckSum(t.encode()), offset, tableLength);
        recordFields.push({name: tableRecord.tag + ' Table Record', type: 'RECORD', value: tableRecord});
        tableFields.push({name: t.tableName + ' table', type: 'RECORD', value: t});
        offset += tableLength;
        check.argument(!isNaN(offset), 'Something went wrong calculating the offset.');
        while (offset % 4 !== 0) {
            offset += 1;
            tableFields.push({name: 'padding', type: 'BYTE', value: 0});
        }
    }

    // Table records need to be sorted alphabetically.
    recordFields.sort(function(r1, r2) {
        if (r1.value.tag > r2.value.tag) {
            return 1;
        } else {
            return -1;
        }
    });

    sfnt.fields = sfnt.fields.concat(recordFields);
    sfnt.fields = sfnt.fields.concat(tableFields);
    return sfnt;
}

// Get the metrics for a character. If the string has more than one character
// this function returns metrics for the first available character.
// You can provide optional fallback metrics if no characters are available.
function metricsForChar(font, chars, notFoundMetrics) {
    for (var i = 0; i < chars.length; i += 1) {
        var glyphIndex = font.charToGlyphIndex(chars[i]);
        if (glyphIndex > 0) {
            var glyph = font.glyphs.get(glyphIndex);
            return glyph.getMetrics();
        }
    }

    return notFoundMetrics;
}

function average(vs) {
    var sum = 0;
    for (var i = 0; i < vs.length; i += 1) {
        sum += vs[i];
    }

    return sum / vs.length;
}

// Convert the font object to a SFNT data structure.
// This structure contains all the necessary tables and metadata to create a binary OTF file.
function fontToSfntTable(font) {
    var xMins = [];
    var yMins = [];
    var xMaxs = [];
    var yMaxs = [];
    var advanceWidths = [];
    var leftSideBearings = [];
    var rightSideBearings = [];
    var firstCharIndex;
    var lastCharIndex = 0;
    var ulUnicodeRange1 = 0;
    var ulUnicodeRange2 = 0;
    var ulUnicodeRange3 = 0;
    var ulUnicodeRange4 = 0;

    for (var i = 0; i < font.glyphs.length; i += 1) {
        var glyph = font.glyphs.get(i);
        var unicode = glyph.unicode | 0;

        if (isNaN(glyph.advanceWidth)) {
            throw new Error('Glyph ' + glyph.name + ' (' + i + '): advanceWidth is not a number.');
        }

        if (firstCharIndex > unicode || firstCharIndex === undefined) {
            // ignore .notdef char
            if (unicode > 0) {
                firstCharIndex = unicode;
            }
        }

        if (lastCharIndex < unicode) {
            lastCharIndex = unicode;
        }

        var position = os2.getUnicodeRange(unicode);
        if (position < 32) {
            ulUnicodeRange1 |= 1 << position;
        } else if (position < 64) {
            ulUnicodeRange2 |= 1 << position - 32;
        } else if (position < 96) {
            ulUnicodeRange3 |= 1 << position - 64;
        } else if (position < 123) {
            ulUnicodeRange4 |= 1 << position - 96;
        } else {
            throw new Error('Unicode ranges bits > 123 are reserved for internal usage');
        }
        // Skip non-important characters.
        if (glyph.name === '.notdef') { continue; }
        var metrics = glyph.getMetrics();
        xMins.push(metrics.xMin);
        yMins.push(metrics.yMin);
        xMaxs.push(metrics.xMax);
        yMaxs.push(metrics.yMax);
        leftSideBearings.push(metrics.leftSideBearing);
        rightSideBearings.push(metrics.rightSideBearing);
        advanceWidths.push(glyph.advanceWidth);
    }

    var globals = {
        xMin: Math.min.apply(null, xMins),
        yMin: Math.min.apply(null, yMins),
        xMax: Math.max.apply(null, xMaxs),
        yMax: Math.max.apply(null, yMaxs),
        advanceWidthMax: Math.max.apply(null, advanceWidths),
        advanceWidthAvg: average(advanceWidths),
        minLeftSideBearing: Math.min.apply(null, leftSideBearings),
        maxLeftSideBearing: Math.max.apply(null, leftSideBearings),
        minRightSideBearing: Math.min.apply(null, rightSideBearings)
    };
    globals.ascender = font.ascender;
    globals.descender = font.descender;

    var headTable = head.make({
        flags: 3, // 00000011 (baseline for font at y=0; left sidebearing point at x=0)
        unitsPerEm: font.unitsPerEm,
        xMin: globals.xMin,
        yMin: globals.yMin,
        xMax: globals.xMax,
        yMax: globals.yMax,
        lowestRecPPEM: 3,
        createdTimestamp: font.createdTimestamp
    });

    var hheaTable = hhea.make({
        ascender: globals.ascender,
        descender: globals.descender,
        advanceWidthMax: globals.advanceWidthMax,
        minLeftSideBearing: globals.minLeftSideBearing,
        minRightSideBearing: globals.minRightSideBearing,
        xMaxExtent: globals.maxLeftSideBearing + (globals.xMax - globals.xMin),
        numberOfHMetrics: font.glyphs.length
    });

    var maxpTable = maxp.make(font.glyphs.length);

    var os2Table = os2.make({
        xAvgCharWidth: Math.round(globals.advanceWidthAvg),
        usWeightClass: font.tables.os2.usWeightClass,
        usWidthClass: font.tables.os2.usWidthClass,
        usFirstCharIndex: firstCharIndex,
        usLastCharIndex: lastCharIndex,
        ulUnicodeRange1: ulUnicodeRange1,
        ulUnicodeRange2: ulUnicodeRange2,
        ulUnicodeRange3: ulUnicodeRange3,
        ulUnicodeRange4: ulUnicodeRange4,
        fsSelection: font.tables.os2.fsSelection, // REGULAR
        // See http://typophile.com/node/13081 for more info on vertical metrics.
        // We get metrics for typical characters (such as "x" for xHeight).
        // We provide some fallback characters if characters are unavailable: their
        // ordering was chosen experimentally.
        sTypoAscender: globals.ascender,
        sTypoDescender: globals.descender,
        sTypoLineGap: 0,
        usWinAscent: globals.yMax,
        usWinDescent: Math.abs(globals.yMin),
        ulCodePageRange1: 1, // FIXME: hard-code Latin 1 support for now
        sxHeight: metricsForChar(font, 'xyvw', {yMax: Math.round(globals.ascender / 2)}).yMax,
        sCapHeight: metricsForChar(font, 'HIKLEFJMNTZBDPRAGOQSUVWXY', globals).yMax,
        usDefaultChar: font.hasChar(' ') ? 32 : 0, // Use space as the default character, if available.
        usBreakChar: font.hasChar(' ') ? 32 : 0 // Use space as the break character, if available.
    });

    var hmtxTable = hmtx.make(font.glyphs);
    var cmapTable = cmap.make(font.glyphs);

    var englishFamilyName = font.getEnglishName('fontFamily');
    var englishStyleName = font.getEnglishName('fontSubfamily');
    var englishFullName = englishFamilyName + ' ' + englishStyleName;
    var postScriptName = font.getEnglishName('postScriptName');
    if (!postScriptName) {
        postScriptName = englishFamilyName.replace(/\s/g, '') + '-' + englishStyleName;
    }

    var names = {};
    for (var n in font.names) {
        names[n] = font.names[n];
    }

    if (!names.uniqueID) {
        names.uniqueID = {en: font.getEnglishName('manufacturer') + ':' + englishFullName};
    }

    if (!names.postScriptName) {
        names.postScriptName = {en: postScriptName};
    }

    if (!names.preferredFamily) {
        names.preferredFamily = font.names.fontFamily;
    }

    if (!names.preferredSubfamily) {
        names.preferredSubfamily = font.names.fontSubfamily;
    }

    var languageTags = [];
    var nameTable = _name.make(names, languageTags);
    var ltagTable = (languageTags.length > 0 ? ltag.make(languageTags) : undefined);

    var postTable = post.make();
    var cffTable = cff.make(font.glyphs, {
        version: font.getEnglishName('version'),
        fullName: englishFullName,
        familyName: englishFamilyName,
        weightName: englishStyleName,
        postScriptName: postScriptName,
        unitsPerEm: font.unitsPerEm,
        fontBBox: [0, globals.yMin, globals.ascender, globals.advanceWidthMax]
    });

    var metaTable = (font.metas && Object.keys(font.metas).length > 0) ? meta.make(font.metas) : undefined;

    // The order does not matter because makeSfntTable() will sort them.
    var tables = [headTable, hheaTable, maxpTable, os2Table, nameTable, cmapTable, postTable, cffTable, hmtxTable];
    if (ltagTable) {
        tables.push(ltagTable);
    }
    // Optional tables
    if (font.tables.gsub) {
        tables.push(gsub.make(font.tables.gsub));
    }
    if (metaTable) {
        tables.push(metaTable);
    }

    var sfntTable = makeSfntTable(tables);

    // Compute the font's checkSum and store it in head.checkSumAdjustment.
    var bytes = sfntTable.encode();
    var checkSum = computeCheckSum(bytes);
    var tableFields = sfntTable.fields;
    var checkSumAdjusted = false;
    for (var i$1 = 0; i$1 < tableFields.length; i$1 += 1) {
        if (tableFields[i$1].name === 'head table') {
            tableFields[i$1].value.checkSumAdjustment = 0xB1B0AFBA - checkSum;
            checkSumAdjusted = true;
            break;
        }
    }

    if (!checkSumAdjusted) {
        throw new Error('Could not find head table with checkSum to adjust.');
    }

    return sfntTable;
}

var sfnt = { make: makeSfntTable, fontToTable: fontToSfntTable, computeCheckSum: computeCheckSum };

// The Layout object is the prototype of Substitution objects, and provides
// utility methods to manipulate common layout tables (GPOS, GSUB, GDEF...)

function searchTag(arr, tag) {
    /* jshint bitwise: false */
    var imin = 0;
    var imax = arr.length - 1;
    while (imin <= imax) {
        var imid = (imin + imax) >>> 1;
        var val = arr[imid].tag;
        if (val === tag) {
            return imid;
        } else if (val < tag) {
            imin = imid + 1;
        } else { imax = imid - 1; }
    }
    // Not found: return -1-insertion point
    return -imin - 1;
}

function binSearch(arr, value) {
    /* jshint bitwise: false */
    var imin = 0;
    var imax = arr.length - 1;
    while (imin <= imax) {
        var imid = (imin + imax) >>> 1;
        var val = arr[imid];
        if (val === value) {
            return imid;
        } else if (val < value) {
            imin = imid + 1;
        } else { imax = imid - 1; }
    }
    // Not found: return -1-insertion point
    return -imin - 1;
}

// binary search in a list of ranges (coverage, class definition)
function searchRange(ranges, value) {
    // jshint bitwise: false
    var range;
    var imin = 0;
    var imax = ranges.length - 1;
    while (imin <= imax) {
        var imid = (imin + imax) >>> 1;
        range = ranges[imid];
        var start = range.start;
        if (start === value) {
            return range;
        } else if (start < value) {
            imin = imid + 1;
        } else { imax = imid - 1; }
    }
    if (imin > 0) {
        range = ranges[imin - 1];
        if (value > range.end) { return 0; }
        return range;
    }
}

/**
 * @exports opentype.Layout
 * @class
 */
function Layout(font, tableName) {
    this.font = font;
    this.tableName = tableName;
}

Layout.prototype = {

    /**
     * Binary search an object by "tag" property
     * @instance
     * @function searchTag
     * @memberof opentype.Layout
     * @param  {Array} arr
     * @param  {string} tag
     * @return {number}
     */
    searchTag: searchTag,

    /**
     * Binary search in a list of numbers
     * @instance
     * @function binSearch
     * @memberof opentype.Layout
     * @param  {Array} arr
     * @param  {number} value
     * @return {number}
     */
    binSearch: binSearch,

    /**
     * Get or create the Layout table (GSUB, GPOS etc).
     * @param  {boolean} create - Whether to create a new one.
     * @return {Object} The GSUB or GPOS table.
     */
    getTable: function(create) {
        var layout = this.font.tables[this.tableName];
        if (!layout && create) {
            layout = this.font.tables[this.tableName] = this.createDefaultTable();
        }
        return layout;
    },

    /**
     * Returns all scripts in the substitution table.
     * @instance
     * @return {Array}
     */
    getScriptNames: function() {
        var layout = this.getTable();
        if (!layout) { return []; }
        return layout.scripts.map(function(script) {
            return script.tag;
        });
    },

    /**
     * Returns the best bet for a script name.
     * Returns 'DFLT' if it exists.
     * If not, returns 'latn' if it exists.
     * If neither exist, returns undefined.
     */
    getDefaultScriptName: function() {
        var layout = this.getTable();
        if (!layout) { return; }
        var hasLatn = false;
        for (var i = 0; i < layout.scripts.length; i++) {
            var name = layout.scripts[i].tag;
            if (name === 'DFLT') { return name; }
            if (name === 'latn') { hasLatn = true; }
        }
        if (hasLatn) { return 'latn'; }
    },

    /**
     * Returns all LangSysRecords in the given script.
     * @instance
     * @param {string} [script='DFLT']
     * @param {boolean} create - forces the creation of this script table if it doesn't exist.
     * @return {Object} An object with tag and script properties.
     */
    getScriptTable: function(script, create) {
        var layout = this.getTable(create);
        if (layout) {
            script = script || 'DFLT';
            var scripts = layout.scripts;
            var pos = searchTag(layout.scripts, script);
            if (pos >= 0) {
                return scripts[pos].script;
            } else if (create) {
                var scr = {
                    tag: script,
                    script: {
                        defaultLangSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []},
                        langSysRecords: []
                    }
                };
                scripts.splice(-1 - pos, 0, scr);
                return scr.script;
            }
        }
    },

    /**
     * Returns a language system table
     * @instance
     * @param {string} [script='DFLT']
     * @param {string} [language='dlft']
     * @param {boolean} create - forces the creation of this langSysTable if it doesn't exist.
     * @return {Object}
     */
    getLangSysTable: function(script, language, create) {
        var scriptTable = this.getScriptTable(script, create);
        if (scriptTable) {
            if (!language || language === 'dflt' || language === 'DFLT') {
                return scriptTable.defaultLangSys;
            }
            var pos = searchTag(scriptTable.langSysRecords, language);
            if (pos >= 0) {
                return scriptTable.langSysRecords[pos].langSys;
            } else if (create) {
                var langSysRecord = {
                    tag: language,
                    langSys: {reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: []}
                };
                scriptTable.langSysRecords.splice(-1 - pos, 0, langSysRecord);
                return langSysRecord.langSys;
            }
        }
    },

    /**
     * Get a specific feature table.
     * @instance
     * @param {string} [script='DFLT']
     * @param {string} [language='dlft']
     * @param {string} feature - One of the codes listed at https://www.microsoft.com/typography/OTSPEC/featurelist.htm
     * @param {boolean} create - forces the creation of the feature table if it doesn't exist.
     * @return {Object}
     */
    getFeatureTable: function(script, language, feature, create) {
        var langSysTable = this.getLangSysTable(script, language, create);
        if (langSysTable) {
            var featureRecord;
            var featIndexes = langSysTable.featureIndexes;
            var allFeatures = this.font.tables[this.tableName].features;
            // The FeatureIndex array of indices is in arbitrary order,
            // even if allFeatures is sorted alphabetically by feature tag.
            for (var i = 0; i < featIndexes.length; i++) {
                featureRecord = allFeatures[featIndexes[i]];
                if (featureRecord.tag === feature) {
                    return featureRecord.feature;
                }
            }
            if (create) {
                var index = allFeatures.length;
                // Automatic ordering of features would require to shift feature indexes in the script list.
                check.assert(index === 0 || feature >= allFeatures[index - 1].tag, 'Features must be added in alphabetical order.');
                featureRecord = {
                    tag: feature,
                    feature: { params: 0, lookupListIndexes: [] }
                };
                allFeatures.push(featureRecord);
                featIndexes.push(index);
                return featureRecord.feature;
            }
        }
    },

    /**
     * Get the lookup tables of a given type for a script/language/feature.
     * @instance
     * @param {string} [script='DFLT']
     * @param {string} [language='dlft']
     * @param {string} feature - 4-letter feature code
     * @param {number} lookupType - 1 to 9
     * @param {boolean} create - forces the creation of the lookup table if it doesn't exist, with no subtables.
     * @return {Object[]}
     */
    getLookupTables: function(script, language, feature, lookupType, create) {
        var featureTable = this.getFeatureTable(script, language, feature, create);
        var tables = [];
        if (featureTable) {
            var lookupTable;
            var lookupListIndexes = featureTable.lookupListIndexes;
            var allLookups = this.font.tables[this.tableName].lookups;
            // lookupListIndexes are in no particular order, so use naive search.
            for (var i = 0; i < lookupListIndexes.length; i++) {
                lookupTable = allLookups[lookupListIndexes[i]];
                if (lookupTable.lookupType === lookupType) {
                    tables.push(lookupTable);
                }
            }
            if (tables.length === 0 && create) {
                lookupTable = {
                    lookupType: lookupType,
                    lookupFlag: 0,
                    subtables: [],
                    markFilteringSet: undefined
                };
                var index = allLookups.length;
                allLookups.push(lookupTable);
                lookupListIndexes.push(index);
                return [lookupTable];
            }
        }
        return tables;
    },

    /**
     * Find a glyph in a class definition table
     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#class-definition-table
     * @param {object} classDefTable - an OpenType Layout class definition table
     * @param {number} glyphIndex - the index of the glyph to find
     * @returns {number} -1 if not found
     */
    getGlyphClass: function(classDefTable, glyphIndex) {
        switch (classDefTable.format) {
            case 1:
                if (classDefTable.startGlyph <= glyphIndex && glyphIndex < classDefTable.startGlyph + classDefTable.classes.length) {
                    return classDefTable.classes[glyphIndex - classDefTable.startGlyph];
                }
                return 0;
            case 2:
                var range = searchRange(classDefTable.ranges, glyphIndex);
                return range ? range.classId : 0;
        }
    },

    /**
     * Find a glyph in a coverage table
     * https://docs.microsoft.com/en-us/typography/opentype/spec/chapter2#coverage-table
     * @param {object} coverageTable - an OpenType Layout coverage table
     * @param {number} glyphIndex - the index of the glyph to find
     * @returns {number} -1 if not found
     */
    getCoverageIndex: function(coverageTable, glyphIndex) {
        switch (coverageTable.format) {
            case 1:
                var index = binSearch(coverageTable.glyphs, glyphIndex);
                return index >= 0 ? index : -1;
            case 2:
                var range = searchRange(coverageTable.ranges, glyphIndex);
                return range ? range.index + glyphIndex - range.start : -1;
        }
    },

    /**
     * Returns the list of glyph indexes of a coverage table.
     * Format 1: the list is stored raw
     * Format 2: compact list as range records.
     * @instance
     * @param  {Object} coverageTable
     * @return {Array}
     */
    expandCoverage: function(coverageTable) {
        if (coverageTable.format === 1) {
            return coverageTable.glyphs;
        } else {
            var glyphs = [];
            var ranges = coverageTable.ranges;
            for (var i = 0; i < ranges.length; i++) {
                var range = ranges[i];
                var start = range.start;
                var end = range.end;
                for (var j = start; j <= end; j++) {
                    glyphs.push(j);
                }
            }
            return glyphs;
        }
    }

};

// The Position object provides utility methods to manipulate
// the GPOS position table.

/**
 * @exports opentype.Position
 * @class
 * @extends opentype.Layout
 * @param {opentype.Font}
 * @constructor
 */
function Position(font) {
    Layout.call(this, font, 'gpos');
}

Position.prototype = Layout.prototype;

/**
 * Find a glyph pair in a list of lookup tables of type 2 and retrieve the xAdvance kerning value.
 *
 * @param {integer} leftIndex - left glyph index
 * @param {integer} rightIndex - right glyph index
 * @returns {integer}
 */
Position.prototype.getKerningValue = function(kerningLookups, leftIndex, rightIndex) {
    var this$1 = this;

    for (var i = 0; i < kerningLookups.length; i++) {
        var subtables = kerningLookups[i].subtables;
        for (var j = 0; j < subtables.length; j++) {
            var subtable = subtables[j];
            var covIndex = this$1.getCoverageIndex(subtable.coverage, leftIndex);
            if (covIndex < 0) { continue; }
            switch (subtable.posFormat) {
                case 1:
                    // Search Pair Adjustment Positioning Format 1
                    var pairSet = subtable.pairSets[covIndex];
                    for (var k = 0; k < pairSet.length; k++) {
                        var pair = pairSet[k];
                        if (pair.secondGlyph === rightIndex) {
                            return pair.value1 && pair.value1.xAdvance || 0;
                        }
                    }
                    break;      // left glyph found, not right glyph - try next subtable
                case 2:
                    // Search Pair Adjustment Positioning Format 2
                    var class1 = this$1.getGlyphClass(subtable.classDef1, leftIndex);
                    var class2 = this$1.getGlyphClass(subtable.classDef2, rightIndex);
                    var pair$1 = subtable.classRecords[class1][class2];
                    return pair$1.value1 && pair$1.value1.xAdvance || 0;
            }
        }
    }
    return 0;
};

/**
 * List all kerning lookup tables.
 *
 * @param {string} [script='DFLT'] - use font.position.getDefaultScriptName() for a better default value
 * @param {string} [language='dflt']
 * @return {object[]} The list of kerning lookup tables (may be empty), or undefined if there is no GPOS table (and we should use the kern table)
 */
Position.prototype.getKerningTables = function(script, language) {
    if (this.font.tables.gpos) {
        return this.getLookupTables(script, language, 'kern', 2);
    }
};

// The Substitution object provides utility methods to manipulate
// the GSUB substitution table.

/**
 * @exports opentype.Substitution
 * @class
 * @extends opentype.Layout
 * @param {opentype.Font}
 * @constructor
 */
function Substitution(font) {
    Layout.call(this, font, 'gsub');
}

// Check if 2 arrays of primitives are equal.
function arraysEqual(ar1, ar2) {
    var n = ar1.length;
    if (n !== ar2.length) { return false; }
    for (var i = 0; i < n; i++) {
        if (ar1[i] !== ar2[i]) { return false; }
    }
    return true;
}

// Find the first subtable of a lookup table in a particular format.
function getSubstFormat(lookupTable, format, defaultSubtable) {
    var subtables = lookupTable.subtables;
    for (var i = 0; i < subtables.length; i++) {
        var subtable = subtables[i];
        if (subtable.substFormat === format) {
            return subtable;
        }
    }
    if (defaultSubtable) {
        subtables.push(defaultSubtable);
        return defaultSubtable;
    }
    return undefined;
}

Substitution.prototype = Layout.prototype;

/**
 * Create a default GSUB table.
 * @return {Object} gsub - The GSUB table.
 */
Substitution.prototype.createDefaultTable = function() {
    // Generate a default empty GSUB table with just a DFLT script and dflt lang sys.
    return {
        version: 1,
        scripts: [{
            tag: 'DFLT',
            script: {
                defaultLangSys: { reserved: 0, reqFeatureIndex: 0xffff, featureIndexes: [] },
                langSysRecords: []
            }
        }],
        features: [],
        lookups: []
    };
};

/**
 * List all single substitutions (lookup type 1) for a given script, language, and feature.
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @param {string} feature - 4-character feature name ('aalt', 'salt', 'ss01'...)
 * @return {Array} substitutions - The list of substitutions.
 */
Substitution.prototype.getSingle = function(feature, script, language) {
    var this$1 = this;

    var substitutions = [];
    var lookupTables = this.getLookupTables(script, language, feature, 1);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this$1.expandCoverage(subtable.coverage);
            var j = (void 0);
            if (subtable.substFormat === 1) {
                var delta = subtable.deltaGlyphId;
                for (j = 0; j < glyphs.length; j++) {
                    var glyph = glyphs[j];
                    substitutions.push({ sub: glyph, by: glyph + delta });
                }
            } else {
                var substitute = subtable.substitute;
                for (j = 0; j < glyphs.length; j++) {
                    substitutions.push({ sub: glyphs[j], by: substitute[j] });
                }
            }
        }
    }
    return substitutions;
};

/**
 * List all alternates (lookup type 3) for a given script, language, and feature.
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @param {string} feature - 4-character feature name ('aalt', 'salt'...)
 * @return {Array} alternates - The list of alternates
 */
Substitution.prototype.getAlternates = function(feature, script, language) {
    var this$1 = this;

    var alternates = [];
    var lookupTables = this.getLookupTables(script, language, feature, 3);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this$1.expandCoverage(subtable.coverage);
            var alternateSets = subtable.alternateSets;
            for (var j = 0; j < glyphs.length; j++) {
                alternates.push({ sub: glyphs[j], by: alternateSets[j] });
            }
        }
    }
    return alternates;
};

/**
 * List all ligatures (lookup type 4) for a given script, language, and feature.
 * The result is an array of ligature objects like { sub: [ids], by: id }
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @return {Array} ligatures - The list of ligatures.
 */
Substitution.prototype.getLigatures = function(feature, script, language) {
    var this$1 = this;

    var ligatures = [];
    var lookupTables = this.getLookupTables(script, language, feature, 4);
    for (var idx = 0; idx < lookupTables.length; idx++) {
        var subtables = lookupTables[idx].subtables;
        for (var i = 0; i < subtables.length; i++) {
            var subtable = subtables[i];
            var glyphs = this$1.expandCoverage(subtable.coverage);
            var ligatureSets = subtable.ligatureSets;
            for (var j = 0; j < glyphs.length; j++) {
                var startGlyph = glyphs[j];
                var ligSet = ligatureSets[j];
                for (var k = 0; k < ligSet.length; k++) {
                    var lig = ligSet[k];
                    ligatures.push({
                        sub: [startGlyph].concat(lig.components),
                        by: lig.ligGlyph
                    });
                }
            }
        }
    }
    return ligatures;
};

/**
 * Add or modify a single substitution (lookup type 1)
 * Format 2, more flexible, is always used.
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {Object} substitution - { sub: id, delta: number } for format 1 or { sub: id, by: id } for format 2.
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.addSingle = function(feature, substitution, script, language) {
    var lookupTable = this.getLookupTables(script, language, feature, 1, true)[0];
    var subtable = getSubstFormat(lookupTable, 2, {                // lookup type 1 subtable, format 2, coverage format 1
        substFormat: 2,
        coverage: {format: 1, glyphs: []},
        substitute: []
    });
    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = substitution.sub;
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos < 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.substitute.splice(pos, 0, 0);
    }
    subtable.substitute[pos] = substitution.by;
};

/**
 * Add or modify an alternate substitution (lookup type 1)
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {Object} substitution - { sub: id, by: [ids] }
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.addAlternate = function(feature, substitution, script, language) {
    var lookupTable = this.getLookupTables(script, language, feature, 3, true)[0];
    var subtable = getSubstFormat(lookupTable, 1, {                // lookup type 3 subtable, format 1, coverage format 1
        substFormat: 1,
        coverage: {format: 1, glyphs: []},
        alternateSets: []
    });
    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = substitution.sub;
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos < 0) {
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.alternateSets.splice(pos, 0, 0);
    }
    subtable.alternateSets[pos] = substitution.by;
};

/**
 * Add a ligature (lookup type 4)
 * Ligatures with more components must be stored ahead of those with fewer components in order to be found
 * @param {string} feature - 4-letter feature name ('liga', 'rlig', 'dlig'...)
 * @param {Object} ligature - { sub: [ids], by: id }
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.addLigature = function(feature, ligature, script, language) {
    var lookupTable = this.getLookupTables(script, language, feature, 4, true)[0];
    var subtable = lookupTable.subtables[0];
    if (!subtable) {
        subtable = {                // lookup type 4 subtable, format 1, coverage format 1
            substFormat: 1,
            coverage: { format: 1, glyphs: [] },
            ligatureSets: []
        };
        lookupTable.subtables[0] = subtable;
    }
    check.assert(subtable.coverage.format === 1, 'Ligature: unable to modify coverage table format ' + subtable.coverage.format);
    var coverageGlyph = ligature.sub[0];
    var ligComponents = ligature.sub.slice(1);
    var ligatureTable = {
        ligGlyph: ligature.by,
        components: ligComponents
    };
    var pos = this.binSearch(subtable.coverage.glyphs, coverageGlyph);
    if (pos >= 0) {
        // ligatureSet already exists
        var ligatureSet = subtable.ligatureSets[pos];
        for (var i = 0; i < ligatureSet.length; i++) {
            // If ligature already exists, return.
            if (arraysEqual(ligatureSet[i].components, ligComponents)) {
                return;
            }
        }
        // ligature does not exist: add it.
        ligatureSet.push(ligatureTable);
    } else {
        // Create a new ligatureSet and add coverage for the first glyph.
        pos = -1 - pos;
        subtable.coverage.glyphs.splice(pos, 0, coverageGlyph);
        subtable.ligatureSets.splice(pos, 0, [ligatureTable]);
    }
};

/**
 * List all feature data for a given script and language.
 * @param {string} feature - 4-letter feature name
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 * @return {Array} substitutions - The list of substitutions.
 */
Substitution.prototype.getFeature = function(feature, script, language) {
    if (/ss\d\d/.test(feature)) {
        // ss01 - ss20
        return this.getSingle(feature, script, language);
    }
    switch (feature) {
        case 'aalt':
        case 'salt':
            return this.getSingle(feature, script, language)
                    .concat(this.getAlternates(feature, script, language));
        case 'dlig':
        case 'liga':
        case 'rlig': return this.getLigatures(feature, script, language);
    }
    return undefined;
};

/**
 * Add a substitution to a feature for a given script and language.
 * @param {string} feature - 4-letter feature name
 * @param {Object} sub - the substitution to add (an object like { sub: id or [ids], by: id or [ids] })
 * @param {string} [script='DFLT']
 * @param {string} [language='dflt']
 */
Substitution.prototype.add = function(feature, sub, script, language) {
    if (/ss\d\d/.test(feature)) {
        // ss01 - ss20
        return this.addSingle(feature, sub, script, language);
    }
    switch (feature) {
        case 'aalt':
        case 'salt':
            if (typeof sub.by === 'number') {
                return this.addSingle(feature, sub, script, language);
            }
            return this.addAlternate(feature, sub, script, language);
        case 'dlig':
        case 'liga':
        case 'rlig':
            return this.addLigature(feature, sub, script, language);
    }
    return undefined;
};

function isBrowser() {
    return typeof window !== 'undefined';
}

function nodeBufferToArrayBuffer(buffer) {
    var ab = new ArrayBuffer(buffer.length);
    var view = new Uint8Array(ab);
    for (var i = 0; i < buffer.length; ++i) {
        view[i] = buffer[i];
    }

    return ab;
}

function arrayBufferToNodeBuffer(ab) {
    var buffer = new Buffer(ab.byteLength);
    var view = new Uint8Array(ab);
    for (var i = 0; i < buffer.length; ++i) {
        buffer[i] = view[i];
    }

    return buffer;
}

function checkArgument(expression, message) {
    if (!expression) {
        throw message;
    }
}

/* A TrueType font hinting interpreter.
*
* (c) 2017 Axel Kittenberger
*
* This interpreter has been implemented according to this documentation:
* https://developer.apple.com/fonts/TrueType-Reference-Manual/RM05/Chap5.html
*
* According to the documentation F24DOT6 values are used for pixels.
* That means calculation is 1/64 pixel accurate and uses integer operations.
* However, Javascript has floating point operations by default and only
* those are available. One could make a case to simulate the 1/64 accuracy
* exactly by truncating after every division operation
* (for example with << 0) to get pixel exactly results as other TrueType
* implementations. It may make sense since some fonts are pixel optimized
* by hand using DELTAP instructions. The current implementation doesn't
* and rather uses full floating point precision.
*
* xScale, yScale and rotation is currently ignored.
*
* A few non-trivial instructions are missing as I didn't encounter yet
* a font that used them to test a possible implementation.
*
* Some fonts seem to use undocumented features regarding the twilight zone.
* Only some of them are implemented as they were encountered.
*
* The exports.DEBUG statements are removed on the minified distribution file.
*/
var instructionTable;
var exec;
var execGlyph;
var execComponent;

/*
* Creates a hinting object.
*
* There ought to be exactly one
* for each truetype font that is used for hinting.
*/
function Hinting(font) {
    // the font this hinting object is for
    this.font = font;

    // cached states
    this._fpgmState  =
    this._prepState  =
        undefined;

    // errorState
    // 0 ... all okay
    // 1 ... had an error in a glyf,
    //       continue working but stop spamming
    //       the console
    // 2 ... error at prep, stop hinting at this ppem
    // 3 ... error at fpeg, stop hinting for this font at all
    this._errorState = 0;
}

/*
* Not rounding.
*/
function roundOff(v) {
    return v;
}

/*
* Rounding to grid.
*/
function roundToGrid(v) {
    //Rounding in TT is supposed to "symmetrical around zero"
    return Math.sign(v) * Math.round(Math.abs(v));
}

/*
* Rounding to double grid.
*/
function roundToDoubleGrid(v) {
    return Math.sign(v) * Math.round(Math.abs(v * 2)) / 2;
}

/*
* Rounding to half grid.
*/
function roundToHalfGrid(v) {
    return Math.sign(v) * (Math.round(Math.abs(v) + 0.5) - 0.5);
}

/*
* Rounding to up to grid.
*/
function roundUpToGrid(v) {
    return Math.sign(v) * Math.ceil(Math.abs(v));
}

/*
* Rounding to down to grid.
*/
function roundDownToGrid(v) {
    return Math.sign(v) * Math.floor(Math.abs(v));
}

/*
* Super rounding.
*/
var roundSuper = function (v) {
    var period = this.srPeriod;
    var phase = this.srPhase;
    var threshold = this.srThreshold;
    var sign = 1;

    if (v < 0) {
        v = -v;
        sign = -1;
    }

    v += threshold - phase;

    v = Math.trunc(v / period) * period;

    v += phase;

    // according to http://xgridfit.sourceforge.net/round.html
    if (v < 0) { return phase * sign; }

    return v * sign;
};

/*
* Unit vector of x-axis.
*/
var xUnitVector = {
    x: 1,

    y: 0,

    axis: 'x',

    // Gets the projected distance between two points.
    // o1/o2 ... if true, respective original position is used.
    distance: function (p1, p2, o1, o2) {
        return (o1 ? p1.xo : p1.x) - (o2 ? p2.xo : p2.x);
    },

    // Moves point p so the moved position has the same relative
    // position to the moved positions of rp1 and rp2 than the
    // original positions had.
    //
    // See APPENDIX on INTERPOLATE at the bottom of this file.
    interpolate: function (p, rp1, rp2, pv) {
        var do1;
        var do2;
        var doa1;
        var doa2;
        var dm1;
        var dm2;
        var dt;

        if (!pv || pv === this) {
            do1 = p.xo - rp1.xo;
            do2 = p.xo - rp2.xo;
            dm1 = rp1.x - rp1.xo;
            dm2 = rp2.x - rp2.xo;
            doa1 = Math.abs(do1);
            doa2 = Math.abs(do2);
            dt = doa1 + doa2;

            if (dt === 0) {
                p.x = p.xo + (dm1 + dm2) / 2;
                return;
            }

            p.x = p.xo + (dm1 * doa2 + dm2 * doa1) / dt;
            return;
        }

        do1 = pv.distance(p, rp1, true, true);
        do2 = pv.distance(p, rp2, true, true);
        dm1 = pv.distance(rp1, rp1, false, true);
        dm2 = pv.distance(rp2, rp2, false, true);
        doa1 = Math.abs(do1);
        doa2 = Math.abs(do2);
        dt = doa1 + doa2;

        if (dt === 0) {
            xUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
            return;
        }

        xUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
    },

    // Slope of line normal to this
    normalSlope: Number.NEGATIVE_INFINITY,

    // Sets the point 'p' relative to point 'rp'
    // by the distance 'd'.
    //
    // See APPENDIX on SETRELATIVE at the bottom of this file.
    //
    // p   ... point to set
    // rp  ... reference point
    // d   ... distance on projection vector
    // pv  ... projection vector (undefined = this)
    // org ... if true, uses the original position of rp as reference.
    setRelative: function (p, rp, d, pv, org) {
        if (!pv || pv === this) {
            p.x = (org ? rp.xo : rp.x) + d;
            return;
        }

        var rpx = org ? rp.xo : rp.x;
        var rpy = org ? rp.yo : rp.y;
        var rpdx = rpx + d * pv.x;
        var rpdy = rpy + d * pv.y;

        p.x = rpdx + (p.y - rpdy) / pv.normalSlope;
    },

    // Slope of vector line.
    slope: 0,

    // Touches the point p.
    touch: function (p) {
        p.xTouched = true;
    },

    // Tests if a point p is touched.
    touched: function (p) {
        return p.xTouched;
    },

    // Untouches the point p.
    untouch: function (p) {
        p.xTouched = false;
    }
};

/*
* Unit vector of y-axis.
*/
var yUnitVector = {
    x: 0,

    y: 1,

    axis: 'y',

    // Gets the projected distance between two points.
    // o1/o2 ... if true, respective original position is used.
    distance: function (p1, p2, o1, o2) {
        return (o1 ? p1.yo : p1.y) - (o2 ? p2.yo : p2.y);
    },

    // Moves point p so the moved position has the same relative
    // position to the moved positions of rp1 and rp2 than the
    // original positions had.
    //
    // See APPENDIX on INTERPOLATE at the bottom of this file.
    interpolate: function (p, rp1, rp2, pv) {
        var do1;
        var do2;
        var doa1;
        var doa2;
        var dm1;
        var dm2;
        var dt;

        if (!pv || pv === this) {
            do1 = p.yo - rp1.yo;
            do2 = p.yo - rp2.yo;
            dm1 = rp1.y - rp1.yo;
            dm2 = rp2.y - rp2.yo;
            doa1 = Math.abs(do1);
            doa2 = Math.abs(do2);
            dt = doa1 + doa2;

            if (dt === 0) {
                p.y = p.yo + (dm1 + dm2) / 2;
                return;
            }

            p.y = p.yo + (dm1 * doa2 + dm2 * doa1) / dt;
            return;
        }

        do1 = pv.distance(p, rp1, true, true);
        do2 = pv.distance(p, rp2, true, true);
        dm1 = pv.distance(rp1, rp1, false, true);
        dm2 = pv.distance(rp2, rp2, false, true);
        doa1 = Math.abs(do1);
        doa2 = Math.abs(do2);
        dt = doa1 + doa2;

        if (dt === 0) {
            yUnitVector.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
            return;
        }

        yUnitVector.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
    },

    // Slope of line normal to this.
    normalSlope: 0,

    // Sets the point 'p' relative to point 'rp'
    // by the distance 'd'
    //
    // See APPENDIX on SETRELATIVE at the bottom of this file.
    //
    // p   ... point to set
    // rp  ... reference point
    // d   ... distance on projection vector
    // pv  ... projection vector (undefined = this)
    // org ... if true, uses the original position of rp as reference.
    setRelative: function (p, rp, d, pv, org) {
        if (!pv || pv === this) {
            p.y = (org ? rp.yo : rp.y) + d;
            return;
        }

        var rpx = org ? rp.xo : rp.x;
        var rpy = org ? rp.yo : rp.y;
        var rpdx = rpx + d * pv.x;
        var rpdy = rpy + d * pv.y;

        p.y = rpdy + pv.normalSlope * (p.x - rpdx);
    },

    // Slope of vector line.
    slope: Number.POSITIVE_INFINITY,

    // Touches the point p.
    touch: function (p) {
        p.yTouched = true;
    },

    // Tests if a point p is touched.
    touched: function (p) {
        return p.yTouched;
    },

    // Untouches the point p.
    untouch: function (p) {
        p.yTouched = false;
    }
};

Object.freeze(xUnitVector);
Object.freeze(yUnitVector);

/*
* Creates a unit vector that is not x- or y-axis.
*/
function UnitVector(x, y) {
    this.x = x;
    this.y = y;
    this.axis = undefined;
    this.slope = y / x;
    this.normalSlope = -x / y;
    Object.freeze(this);
}

/*
* Gets the projected distance between two points.
* o1/o2 ... if true, respective original position is used.
*/
UnitVector.prototype.distance = function(p1, p2, o1, o2) {
    return (
        this.x * xUnitVector.distance(p1, p2, o1, o2) +
        this.y * yUnitVector.distance(p1, p2, o1, o2)
    );
};

/*
* Moves point p so the moved position has the same relative
* position to the moved positions of rp1 and rp2 than the
* original positions had.
*
* See APPENDIX on INTERPOLATE at the bottom of this file.
*/
UnitVector.prototype.interpolate = function(p, rp1, rp2, pv) {
    var dm1;
    var dm2;
    var do1;
    var do2;
    var doa1;
    var doa2;
    var dt;

    do1 = pv.distance(p, rp1, true, true);
    do2 = pv.distance(p, rp2, true, true);
    dm1 = pv.distance(rp1, rp1, false, true);
    dm2 = pv.distance(rp2, rp2, false, true);
    doa1 = Math.abs(do1);
    doa2 = Math.abs(do2);
    dt = doa1 + doa2;

    if (dt === 0) {
        this.setRelative(p, p, (dm1 + dm2) / 2, pv, true);
        return;
    }

    this.setRelative(p, p, (dm1 * doa2 + dm2 * doa1) / dt, pv, true);
};

/*
* Sets the point 'p' relative to point 'rp'
* by the distance 'd'
*
* See APPENDIX on SETRELATIVE at the bottom of this file.
*
* p   ...  point to set
* rp  ... reference point
* d   ... distance on projection vector
* pv  ... projection vector (undefined = this)
* org ... if true, uses the original position of rp as reference.
*/
UnitVector.prototype.setRelative = function(p, rp, d, pv, org) {
    pv = pv || this;

    var rpx = org ? rp.xo : rp.x;
    var rpy = org ? rp.yo : rp.y;
    var rpdx = rpx + d * pv.x;
    var rpdy = rpy + d * pv.y;

    var pvns = pv.normalSlope;
    var fvs = this.slope;

    var px = p.x;
    var py = p.y;

    p.x = (fvs * px - pvns * rpdx + rpdy - py) / (fvs - pvns);
    p.y = fvs * (p.x - px) + py;
};

/*
* Touches the point p.
*/
UnitVector.prototype.touch = function(p) {
    p.xTouched = true;
    p.yTouched = true;
};

/*
* Returns a unit vector with x/y coordinates.
*/
function getUnitVector(x, y) {
    var d = Math.sqrt(x * x + y * y);

    x /= d;
    y /= d;

    if (x === 1 && y === 0) { return xUnitVector; }
    else if (x === 0 && y === 1) { return yUnitVector; }
    else { return new UnitVector(x, y); }
}

/*
* Creates a point in the hinting engine.
*/
function HPoint(
    x,
    y,
    lastPointOfContour,
    onCurve
) {
    this.x = this.xo = Math.round(x * 64) / 64; // hinted x value and original x-value
    this.y = this.yo = Math.round(y * 64) / 64; // hinted y value and original y-value

    this.lastPointOfContour = lastPointOfContour;
    this.onCurve = onCurve;
    this.prevPointOnContour = undefined;
    this.nextPointOnContour = undefined;
    this.xTouched = false;
    this.yTouched = false;

    Object.preventExtensions(this);
}

/*
* Returns the next touched point on the contour.
*
* v  ... unit vector to test touch axis.
*/
HPoint.prototype.nextTouched = function(v) {
    var p = this.nextPointOnContour;

    while (!v.touched(p) && p !== this) { p = p.nextPointOnContour; }

    return p;
};

/*
* Returns the previous touched point on the contour
*
* v  ... unit vector to test touch axis.
*/
HPoint.prototype.prevTouched = function(v) {
    var p = this.prevPointOnContour;

    while (!v.touched(p) && p !== this) { p = p.prevPointOnContour; }

    return p;
};

/*
* The zero point.
*/
var HPZero = Object.freeze(new HPoint(0, 0));

/*
* The default state of the interpreter.
*
* Note: Freezing the defaultState and then deriving from it
* makes the V8 Javascript engine going awkward,
* so this is avoided, albeit the defaultState shouldn't
* ever change.
*/
var defaultState = {
    cvCutIn: 17 / 16,    // control value cut in
    deltaBase: 9,
    deltaShift: 0.125,
    loop: 1,             // loops some instructions
    minDis: 1,           // minimum distance
    autoFlip: true
};

/*
* The current state of the interpreter.
*
* env  ... 'fpgm' or 'prep' or 'glyf'
* prog ... the program
*/
function State(env, prog) {
    this.env = env;
    this.stack = [];
    this.prog = prog;

    switch (env) {
        case 'glyf' :
            this.zp0 = this.zp1 = this.zp2 = 1;
            this.rp0 = this.rp1 = this.rp2 = 0;
            /* fall through */
        case 'prep' :
            this.fv = this.pv = this.dpv = xUnitVector;
            this.round = roundToGrid;
    }
}

/*
* Executes a glyph program.
*
* This does the hinting for each glyph.
*
* Returns an array of moved points.
*
* glyph: the glyph to hint
* ppem: the size the glyph is rendered for
*/
Hinting.prototype.exec = function(glyph, ppem) {
    if (typeof ppem !== 'number') {
        throw new Error('Point size is not a number!');
    }

    // Received a fatal error, don't do any hinting anymore.
    if (this._errorState > 2) { return; }

    var font = this.font;
    var prepState = this._prepState;

    if (!prepState || prepState.ppem !== ppem) {
        var fpgmState = this._fpgmState;

        if (!fpgmState) {
            // Executes the fpgm state.
            // This is used by fonts to define functions.
            State.prototype = defaultState;

            fpgmState =
            this._fpgmState =
                new State('fpgm', font.tables.fpgm);

            fpgmState.funcs = [ ];
            fpgmState.font = font;

            if (exports.DEBUG) {
                console.log('---EXEC FPGM---');
                fpgmState.step = -1;
            }

            try {
                exec(fpgmState);
            } catch (e) {
                console.log('Hinting error in FPGM:' + e);
                this._errorState = 3;
                return;
            }
        }

        // Executes the prep program for this ppem setting.
        // This is used by fonts to set cvt values
        // depending on to be rendered font size.

        State.prototype = fpgmState;
        prepState =
        this._prepState =
            new State('prep', font.tables.prep);

        prepState.ppem = ppem;

        // Creates a copy of the cvt table
        // and scales it to the current ppem setting.
        var oCvt = font.tables.cvt;
        if (oCvt) {
            var cvt = prepState.cvt = new Array(oCvt.length);
            var scale = ppem / font.unitsPerEm;
            for (var c = 0; c < oCvt.length; c++) {
                cvt[c] = oCvt[c] * scale;
            }
        } else {
            prepState.cvt = [];
        }

        if (exports.DEBUG) {
            console.log('---EXEC PREP---');
            prepState.step = -1;
        }

        try {
            exec(prepState);
        } catch (e) {
            if (this._errorState < 2) {
                console.log('Hinting error in PREP:' + e);
            }
            this._errorState = 2;
        }
    }

    if (this._errorState > 1) { return; }

    try {
        return execGlyph(glyph, prepState);
    } catch (e) {
        if (this._errorState < 1) {
            console.log('Hinting error:' + e);
            console.log('Note: further hinting errors are silenced');
        }
        this._errorState = 1;
        return undefined;
    }
};

/*
* Executes the hinting program for a glyph.
*/
execGlyph = function(glyph, prepState) {
    // original point positions
    var xScale = prepState.ppem / prepState.font.unitsPerEm;
    var yScale = xScale;
    var components = glyph.components;
    var contours;
    var gZone;
    var state;

    State.prototype = prepState;
    if (!components) {
        state = new State('glyf', glyph.instructions);
        if (exports.DEBUG) {
            console.log('---EXEC GLYPH---');
            state.step = -1;
        }
        execComponent(glyph, state, xScale, yScale);
        gZone = state.gZone;
    } else {
        var font = prepState.font;
        gZone = [];
        contours = [];
        for (var i = 0; i < components.length; i++) {
            var c = components[i];
            var cg = font.glyphs.get(c.glyphIndex);

            state = new State('glyf', cg.instructions);

            if (exports.DEBUG) {
                console.log('---EXEC COMP ' + i + '---');
                state.step = -1;
            }

            execComponent(cg, state, xScale, yScale);
            // appends the computed points to the result array
            // post processes the component points
            var dx = Math.round(c.dx * xScale);
            var dy = Math.round(c.dy * yScale);
            var gz = state.gZone;
            var cc = state.contours;
            for (var pi = 0; pi < gz.length; pi++) {
                var p = gz[pi];
                p.xTouched = p.yTouched = false;
                p.xo = p.x = p.x + dx;
                p.yo = p.y = p.y + dy;
            }

            var gLen = gZone.length;
            gZone.push.apply(gZone, gz);
            for (var j = 0; j < cc.length; j++) {
                contours.push(cc[j] + gLen);
            }
        }

        if (glyph.instructions && !state.inhibitGridFit) {
            // the composite has instructions on its own
            state = new State('glyf', glyph.instructions);

            state.gZone = state.z0 = state.z1 = state.z2 = gZone;

            state.contours = contours;

            // note: HPZero cannot be used here, since
            //       the point might be modified
            gZone.push(
                new HPoint(0, 0),
                new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
            );

            if (exports.DEBUG) {
                console.log('---EXEC COMPOSITE---');
                state.step = -1;
            }

            exec(state);

            gZone.length -= 2;
        }
    }

    return gZone;
};

/*
* Executes the hinting program for a component of a multi-component glyph
* or of the glyph itself for a non-component glyph.
*/
execComponent = function(glyph, state, xScale, yScale)
{
    var points = glyph.points || [];
    var pLen = points.length;
    var gZone = state.gZone = state.z0 = state.z1 = state.z2 = [];
    var contours = state.contours = [];

    // Scales the original points and
    // makes copies for the hinted points.
    var cp; // current point
    for (var i = 0; i < pLen; i++) {
        cp = points[i];

        gZone[i] = new HPoint(
            cp.x * xScale,
            cp.y * yScale,
            cp.lastPointOfContour,
            cp.onCurve
        );
    }

    // Chain links the contours.
    var sp; // start point
    var np; // next point

    for (var i$1 = 0; i$1 < pLen; i$1++) {
        cp = gZone[i$1];

        if (!sp) {
            sp = cp;
            contours.push(i$1);
        }

        if (cp.lastPointOfContour) {
            cp.nextPointOnContour = sp;
            sp.prevPointOnContour = cp;
            sp = undefined;
        } else {
            np = gZone[i$1 + 1];
            cp.nextPointOnContour = np;
            np.prevPointOnContour = cp;
        }
    }

    if (state.inhibitGridFit) { return; }

    if (exports.DEBUG) {
        console.log('PROCESSING GLYPH', state.stack);
        for (var i$2 = 0; i$2 < pLen; i$2++) {
            console.log(i$2, gZone[i$2].x, gZone[i$2].y);
        }
    }

    gZone.push(
        new HPoint(0, 0),
        new HPoint(Math.round(glyph.advanceWidth * xScale), 0)
    );

    exec(state);

    // Removes the extra points.
    gZone.length -= 2;

    if (exports.DEBUG) {
        console.log('FINISHED GLYPH', state.stack);
        for (var i$3 = 0; i$3 < pLen; i$3++) {
            console.log(i$3, gZone[i$3].x, gZone[i$3].y);
        }
    }
};

/*
* Executes the program loaded in state.
*/
exec = function(state) {
    var prog = state.prog;

    if (!prog) { return; }

    var pLen = prog.length;
    var ins;

    for (state.ip = 0; state.ip < pLen; state.ip++) {
        if (exports.DEBUG) { state.step++; }
        ins = instructionTable[prog[state.ip]];

        if (!ins) {
            throw new Error(
                'unknown instruction: 0x' +
                Number(prog[state.ip]).toString(16)
            );
        }

        ins(state);

        // very extensive debugging for each step
        /*
        if (exports.DEBUG) {
            var da;
            if (state.gZone) {
                da = [];
                for (let i = 0; i < state.gZone.length; i++)
                {
                    da.push(i + ' ' +
                        state.gZone[i].x * 64 + ' ' +
                        state.gZone[i].y * 64 + ' ' +
                        (state.gZone[i].xTouched ? 'x' : '') +
                        (state.gZone[i].yTouched ? 'y' : '')
                    );
                }
                console.log('GZ', da);
            }

            if (state.tZone) {
                da = [];
                for (let i = 0; i < state.tZone.length; i++) {
                    da.push(i + ' ' +
                        state.tZone[i].x * 64 + ' ' +
                        state.tZone[i].y * 64 + ' ' +
                        (state.tZone[i].xTouched ? 'x' : '') +
                        (state.tZone[i].yTouched ? 'y' : '')
                    );
                }
                console.log('TZ', da);
            }

            if (state.stack.length > 10) {
                console.log(
                    state.stack.length,
                    '...', state.stack.slice(state.stack.length - 10)
                );
            } else {
                console.log(state.stack.length, state.stack);
            }
        }
        */
    }
};

/*
* Initializes the twilight zone.
*
* This is only done if a SZPx instruction
* refers to the twilight zone.
*/
function initTZone(state)
{
    var tZone = state.tZone = new Array(state.gZone.length);

    // no idea if this is actually correct...
    for (var i = 0; i < tZone.length; i++)
    {
        tZone[i] = new HPoint(0, 0);
    }
}

/*
* Skips the instruction pointer ahead over an IF/ELSE block.
* handleElse .. if true breaks on matching ELSE
*/
function skip(state, handleElse)
{
    var prog = state.prog;
    var ip = state.ip;
    var nesting = 1;
    var ins;

    do {
        ins = prog[++ip];
        if (ins === 0x58) // IF
            { nesting++; }
        else if (ins === 0x59) // EIF
            { nesting--; }
        else if (ins === 0x40) // NPUSHB
            { ip += prog[ip + 1] + 1; }
        else if (ins === 0x41) // NPUSHW
            { ip += 2 * prog[ip + 1] + 1; }
        else if (ins >= 0xB0 && ins <= 0xB7) // PUSHB
            { ip += ins - 0xB0 + 1; }
        else if (ins >= 0xB8 && ins <= 0xBF) // PUSHW
            { ip += (ins - 0xB8 + 1) * 2; }
        else if (handleElse && nesting === 1 && ins === 0x1B) // ELSE
            { break; }
    } while (nesting > 0);

    state.ip = ip;
}

/*----------------------------------------------------------*
*          And then a lot of instructions...                *
*----------------------------------------------------------*/

// SVTCA[a] Set freedom and projection Vectors To Coordinate Axis
// 0x00-0x01
function SVTCA(v, state) {
    if (exports.DEBUG) { console.log(state.step, 'SVTCA[' + v.axis + ']'); }

    state.fv = state.pv = state.dpv = v;
}

// SPVTCA[a] Set Projection Vector to Coordinate Axis
// 0x02-0x03
function SPVTCA(v, state) {
    if (exports.DEBUG) { console.log(state.step, 'SPVTCA[' + v.axis + ']'); }

    state.pv = state.dpv = v;
}

// SFVTCA[a] Set Freedom Vector to Coordinate Axis
// 0x04-0x05
function SFVTCA(v, state) {
    if (exports.DEBUG) { console.log(state.step, 'SFVTCA[' + v.axis + ']'); }

    state.fv = v;
}

// SPVTL[a] Set Projection Vector To Line
// 0x06-0x07
function SPVTL(a, state) {
    var stack = state.stack;
    var p2i = stack.pop();
    var p1i = stack.pop();
    var p2 = state.z2[p2i];
    var p1 = state.z1[p1i];

    if (exports.DEBUG) { console.log('SPVTL[' + a + ']', p2i, p1i); }

    var dx;
    var dy;

    if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
    } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
    }

    state.pv = state.dpv = getUnitVector(dx, dy);
}

// SFVTL[a] Set Freedom Vector To Line
// 0x08-0x09
function SFVTL(a, state) {
    var stack = state.stack;
    var p2i = stack.pop();
    var p1i = stack.pop();
    var p2 = state.z2[p2i];
    var p1 = state.z1[p1i];

    if (exports.DEBUG) { console.log('SFVTL[' + a + ']', p2i, p1i); }

    var dx;
    var dy;

    if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
    } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
    }

    state.fv = getUnitVector(dx, dy);
}

// SPVFS[] Set Projection Vector From Stack
// 0x0A
function SPVFS(state) {
    var stack = state.stack;
    var y = stack.pop();
    var x = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }

    state.pv = state.dpv = getUnitVector(x, y);
}

// SFVFS[] Set Freedom Vector From Stack
// 0x0B
function SFVFS(state) {
    var stack = state.stack;
    var y = stack.pop();
    var x = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SPVFS[]', y, x); }

    state.fv = getUnitVector(x, y);
}

// GPV[] Get Projection Vector
// 0x0C
function GPV(state) {
    var stack = state.stack;
    var pv = state.pv;

    if (exports.DEBUG) { console.log(state.step, 'GPV[]'); }

    stack.push(pv.x * 0x4000);
    stack.push(pv.y * 0x4000);
}

// GFV[] Get Freedom Vector
// 0x0C
function GFV(state) {
    var stack = state.stack;
    var fv = state.fv;

    if (exports.DEBUG) { console.log(state.step, 'GFV[]'); }

    stack.push(fv.x * 0x4000);
    stack.push(fv.y * 0x4000);
}

// SFVTPV[] Set Freedom Vector To Projection Vector
// 0x0E
function SFVTPV(state) {
    state.fv = state.pv;

    if (exports.DEBUG) { console.log(state.step, 'SFVTPV[]'); }
}

// ISECT[] moves point p to the InterSECTion of two lines
// 0x0F
function ISECT(state)
{
    var stack = state.stack;
    var pa0i = stack.pop();
    var pa1i = stack.pop();
    var pb0i = stack.pop();
    var pb1i = stack.pop();
    var pi = stack.pop();
    var z0 = state.z0;
    var z1 = state.z1;
    var pa0 = z0[pa0i];
    var pa1 = z0[pa1i];
    var pb0 = z1[pb0i];
    var pb1 = z1[pb1i];
    var p = state.z2[pi];

    if (exports.DEBUG) { console.log('ISECT[], ', pa0i, pa1i, pb0i, pb1i, pi); }

    // math from
    // en.wikipedia.org/wiki/Line%E2%80%93line_intersection#Given_two_points_on_each_line

    var x1 = pa0.x;
    var y1 = pa0.y;
    var x2 = pa1.x;
    var y2 = pa1.y;
    var x3 = pb0.x;
    var y3 = pb0.y;
    var x4 = pb1.x;
    var y4 = pb1.y;

    var div = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    var f1 = x1 * y2 - y1 * x2;
    var f2 = x3 * y4 - y3 * x4;

    p.x = (f1 * (x3 - x4) - f2 * (x1 - x2)) / div;
    p.y = (f1 * (y3 - y4) - f2 * (y1 - y2)) / div;
}

// SRP0[] Set Reference Point 0
// 0x10
function SRP0(state) {
    state.rp0 = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SRP0[]', state.rp0); }
}

// SRP1[] Set Reference Point 1
// 0x11
function SRP1(state) {
    state.rp1 = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SRP1[]', state.rp1); }
}

// SRP1[] Set Reference Point 2
// 0x12
function SRP2(state) {
    state.rp2 = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SRP2[]', state.rp2); }
}

// SZP0[] Set Zone Pointer 0
// 0x13
function SZP0(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SZP0[]', n); }

    state.zp0 = n;

    switch (n) {
        case 0:
            if (!state.tZone) { initTZone(state); }
            state.z0 = state.tZone;
            break;
        case 1 :
            state.z0 = state.gZone;
            break;
        default :
            throw new Error('Invalid zone pointer');
    }
}

// SZP1[] Set Zone Pointer 1
// 0x14
function SZP1(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SZP1[]', n); }

    state.zp1 = n;

    switch (n) {
        case 0:
            if (!state.tZone) { initTZone(state); }
            state.z1 = state.tZone;
            break;
        case 1 :
            state.z1 = state.gZone;
            break;
        default :
            throw new Error('Invalid zone pointer');
    }
}

// SZP2[] Set Zone Pointer 2
// 0x15
function SZP2(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SZP2[]', n); }

    state.zp2 = n;

    switch (n) {
        case 0:
            if (!state.tZone) { initTZone(state); }
            state.z2 = state.tZone;
            break;
        case 1 :
            state.z2 = state.gZone;
            break;
        default :
            throw new Error('Invalid zone pointer');
    }
}

// SZPS[] Set Zone PointerS
// 0x16
function SZPS(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SZPS[]', n); }

    state.zp0 = state.zp1 = state.zp2 = n;

    switch (n) {
        case 0:
            if (!state.tZone) { initTZone(state); }
            state.z0 = state.z1 = state.z2 = state.tZone;
            break;
        case 1 :
            state.z0 = state.z1 = state.z2 = state.gZone;
            break;
        default :
            throw new Error('Invalid zone pointer');
    }
}

// SLOOP[] Set LOOP variable
// 0x17
function SLOOP(state) {
    state.loop = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SLOOP[]', state.loop); }
}

// RTG[] Round To Grid
// 0x18
function RTG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RTG[]'); }

    state.round = roundToGrid;
}

// RTHG[] Round To Half Grid
// 0x19
function RTHG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RTHG[]'); }

    state.round = roundToHalfGrid;
}

// SMD[] Set Minimum Distance
// 0x1A
function SMD(state) {
    var d = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SMD[]', d); }

    state.minDis = d / 0x40;
}

// ELSE[] ELSE clause
// 0x1B
function ELSE(state) {
    // This instruction has been reached by executing a then branch
    // so it just skips ahead until matching EIF.
    //
    // In case the IF was negative the IF[] instruction already
    // skipped forward over the ELSE[]

    if (exports.DEBUG) { console.log(state.step, 'ELSE[]'); }

    skip(state, false);
}

// JMPR[] JuMP Relative
// 0x1C
function JMPR(state) {
    var o = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'JMPR[]', o); }

    // A jump by 1 would do nothing.
    state.ip += o - 1;
}

// SCVTCI[] Set Control Value Table Cut-In
// 0x1D
function SCVTCI(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SCVTCI[]', n); }

    state.cvCutIn = n / 0x40;
}

// DUP[] DUPlicate top stack element
// 0x20
function DUP(state) {
    var stack = state.stack;

    if (exports.DEBUG) { console.log(state.step, 'DUP[]'); }

    stack.push(stack[stack.length - 1]);
}

// POP[] POP top stack element
// 0x21
function POP(state) {
    if (exports.DEBUG) { console.log(state.step, 'POP[]'); }

    state.stack.pop();
}

// CLEAR[] CLEAR the stack
// 0x22
function CLEAR(state) {
    if (exports.DEBUG) { console.log(state.step, 'CLEAR[]'); }

    state.stack.length = 0;
}

// SWAP[] SWAP the top two elements on the stack
// 0x23
function SWAP(state) {
    var stack = state.stack;

    var a = stack.pop();
    var b = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SWAP[]'); }

    stack.push(a);
    stack.push(b);
}

// DEPTH[] DEPTH of the stack
// 0x24
function DEPTH(state) {
    var stack = state.stack;

    if (exports.DEBUG) { console.log(state.step, 'DEPTH[]'); }

    stack.push(stack.length);
}

// LOOPCALL[] LOOPCALL function
// 0x2A
function LOOPCALL(state) {
    var stack = state.stack;
    var fn = stack.pop();
    var c = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'LOOPCALL[]', fn, c); }

    // saves callers program
    var cip = state.ip;
    var cprog = state.prog;

    state.prog = state.funcs[fn];

    // executes the function
    for (var i = 0; i < c; i++) {
        exec(state);

        if (exports.DEBUG) { console.log(
            ++state.step,
            i + 1 < c ? 'next loopcall' : 'done loopcall',
            i
        ); }
    }

    // restores the callers program
    state.ip = cip;
    state.prog = cprog;
}

// CALL[] CALL function
// 0x2B
function CALL(state) {
    var fn = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'CALL[]', fn); }

    // saves callers program
    var cip = state.ip;
    var cprog = state.prog;

    state.prog = state.funcs[fn];

    // executes the function
    exec(state);

    // restores the callers program
    state.ip = cip;
    state.prog = cprog;

    if (exports.DEBUG) { console.log(++state.step, 'returning from', fn); }
}

// CINDEX[] Copy the INDEXed element to the top of the stack
// 0x25
function CINDEX(state) {
    var stack = state.stack;
    var k = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'CINDEX[]', k); }

    // In case of k == 1, it copies the last element after popping
    // thus stack.length - k.
    stack.push(stack[stack.length - k]);
}

// MINDEX[] Move the INDEXed element to the top of the stack
// 0x26
function MINDEX(state) {
    var stack = state.stack;
    var k = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'MINDEX[]', k); }

    stack.push(stack.splice(stack.length - k, 1)[0]);
}

// FDEF[] Function DEFinition
// 0x2C
function FDEF(state) {
    if (state.env !== 'fpgm') { throw new Error('FDEF not allowed here'); }
    var stack = state.stack;
    var prog = state.prog;
    var ip = state.ip;

    var fn = stack.pop();
    var ipBegin = ip;

    if (exports.DEBUG) { console.log(state.step, 'FDEF[]', fn); }

    while (prog[++ip] !== 0x2D){  }

    state.ip = ip;
    state.funcs[fn] = prog.slice(ipBegin + 1, ip);
}

// MDAP[a] Move Direct Absolute Point
// 0x2E-0x2F
function MDAP(round, state) {
    var pi = state.stack.pop();
    var p = state.z0[pi];
    var fv = state.fv;
    var pv = state.pv;

    if (exports.DEBUG) { console.log(state.step, 'MDAP[' + round + ']', pi); }

    var d = pv.distance(p, HPZero);

    if (round) { d = state.round(d); }

    fv.setRelative(p, HPZero, d, pv);
    fv.touch(p);

    state.rp0 = state.rp1 = pi;
}

// IUP[a] Interpolate Untouched Points through the outline
// 0x30
function IUP(v, state) {
    var z2 = state.z2;
    var pLen = z2.length - 2;
    var cp;
    var pp;
    var np;

    if (exports.DEBUG) { console.log(state.step, 'IUP[' + v.axis + ']'); }

    for (var i = 0; i < pLen; i++) {
        cp = z2[i]; // current point

        // if this point has been touched go on
        if (v.touched(cp)) { continue; }

        pp = cp.prevTouched(v);

        // no point on the contour has been touched?
        if (pp === cp) { continue; }

        np = cp.nextTouched(v);

        if (pp === np) {
            // only one point on the contour has been touched
            // so simply moves the point like that

            v.setRelative(cp, cp, v.distance(pp, pp, false, true), v, true);
        }

        v.interpolate(cp, pp, np, v);
    }
}

// SHP[] SHift Point using reference point
// 0x32-0x33
function SHP(a, state) {
    var stack = state.stack;
    var rpi = a ? state.rp1 : state.rp2;
    var rp = (a ? state.z0 : state.z1)[rpi];
    var fv = state.fv;
    var pv = state.pv;
    var loop = state.loop;
    var z2 = state.z2;

    while (loop--)
    {
        var pi = stack.pop();
        var p = z2[pi];

        var d = pv.distance(rp, rp, false, true);
        fv.setRelative(p, p, d, pv);
        fv.touch(p);

        if (exports.DEBUG) {
            console.log(
                state.step,
                (state.loop > 1 ?
                   'loop ' + (state.loop - loop) + ': ' :
                   ''
                ) +
                'SHP[' + (a ? 'rp1' : 'rp2') + ']', pi
            );
        }
    }

    state.loop = 1;
}

// SHC[] SHift Contour using reference point
// 0x36-0x37
function SHC(a, state) {
    var stack = state.stack;
    var rpi = a ? state.rp1 : state.rp2;
    var rp = (a ? state.z0 : state.z1)[rpi];
    var fv = state.fv;
    var pv = state.pv;
    var ci = stack.pop();
    var sp = state.z2[state.contours[ci]];
    var p = sp;

    if (exports.DEBUG) { console.log(state.step, 'SHC[' + a + ']', ci); }

    var d = pv.distance(rp, rp, false, true);

    do {
        if (p !== rp) { fv.setRelative(p, p, d, pv); }
        p = p.nextPointOnContour;
    } while (p !== sp);
}

// SHZ[] SHift Zone using reference point
// 0x36-0x37
function SHZ(a, state) {
    var stack = state.stack;
    var rpi = a ? state.rp1 : state.rp2;
    var rp = (a ? state.z0 : state.z1)[rpi];
    var fv = state.fv;
    var pv = state.pv;

    var e = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SHZ[' + a + ']', e); }

    var z;
    switch (e) {
        case 0 : z = state.tZone; break;
        case 1 : z = state.gZone; break;
        default : throw new Error('Invalid zone');
    }

    var p;
    var d = pv.distance(rp, rp, false, true);
    var pLen = z.length - 2;
    for (var i = 0; i < pLen; i++)
    {
        p = z[i];
        fv.setRelative(p, p, d, pv);
        //if (p !== rp) fv.setRelative(p, p, d, pv);
    }
}

// SHPIX[] SHift point by a PIXel amount
// 0x38
function SHPIX(state) {
    var stack = state.stack;
    var loop = state.loop;
    var fv = state.fv;
    var d = stack.pop() / 0x40;
    var z2 = state.z2;

    while (loop--) {
        var pi = stack.pop();
        var p = z2[pi];

        if (exports.DEBUG) {
            console.log(
                state.step,
                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
                'SHPIX[]', pi, d
            );
        }

        fv.setRelative(p, p, d);
        fv.touch(p);
    }

    state.loop = 1;
}

// IP[] Interpolate Point
// 0x39
function IP(state) {
    var stack = state.stack;
    var rp1i = state.rp1;
    var rp2i = state.rp2;
    var loop = state.loop;
    var rp1 = state.z0[rp1i];
    var rp2 = state.z1[rp2i];
    var fv = state.fv;
    var pv = state.dpv;
    var z2 = state.z2;

    while (loop--) {
        var pi = stack.pop();
        var p = z2[pi];

        if (exports.DEBUG) {
            console.log(
                state.step,
                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
                'IP[]', pi, rp1i, '<->', rp2i
            );
        }

        fv.interpolate(p, rp1, rp2, pv);

        fv.touch(p);
    }

    state.loop = 1;
}

// MSIRP[a] Move Stack Indirect Relative Point
// 0x3A-0x3B
function MSIRP(a, state) {
    var stack = state.stack;
    var d = stack.pop() / 64;
    var pi = stack.pop();
    var p = state.z1[pi];
    var rp0 = state.z0[state.rp0];
    var fv = state.fv;
    var pv = state.pv;

    fv.setRelative(p, rp0, d, pv);
    fv.touch(p);

    if (exports.DEBUG) { console.log(state.step, 'MSIRP[' + a + ']', d, pi); }

    state.rp1 = state.rp0;
    state.rp2 = pi;
    if (a) { state.rp0 = pi; }
}

// ALIGNRP[] Align to reference point.
// 0x3C
function ALIGNRP(state) {
    var stack = state.stack;
    var rp0i = state.rp0;
    var rp0 = state.z0[rp0i];
    var loop = state.loop;
    var fv = state.fv;
    var pv = state.pv;
    var z1 = state.z1;

    while (loop--) {
        var pi = stack.pop();
        var p = z1[pi];

        if (exports.DEBUG) {
            console.log(
                state.step,
                (state.loop > 1 ? 'loop ' + (state.loop - loop) + ': ' : '') +
                'ALIGNRP[]', pi
            );
        }

        fv.setRelative(p, rp0, 0, pv);
        fv.touch(p);
    }

    state.loop = 1;
}

// RTG[] Round To Double Grid
// 0x3D
function RTDG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RTDG[]'); }

    state.round = roundToDoubleGrid;
}

// MIAP[a] Move Indirect Absolute Point
// 0x3E-0x3F
function MIAP(round, state) {
    var stack = state.stack;
    var n = stack.pop();
    var pi = stack.pop();
    var p = state.z0[pi];
    var fv = state.fv;
    var pv = state.pv;
    var cv = state.cvt[n];

    if (exports.DEBUG) {
        console.log(
            state.step,
            'MIAP[' + round + ']',
            n, '(', cv, ')', pi
        );
    }

    var d = pv.distance(p, HPZero);

    if (round) {
        if (Math.abs(d - cv) < state.cvCutIn) { d = cv; }

        d = state.round(d);
    }

    fv.setRelative(p, HPZero, d, pv);

    if (state.zp0 === 0) {
        p.xo = p.x;
        p.yo = p.y;
    }

    fv.touch(p);

    state.rp0 = state.rp1 = pi;
}

// NPUSB[] PUSH N Bytes
// 0x40
function NPUSHB(state) {
    var prog = state.prog;
    var ip = state.ip;
    var stack = state.stack;

    var n = prog[++ip];

    if (exports.DEBUG) { console.log(state.step, 'NPUSHB[]', n); }

    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }

    state.ip = ip;
}

// NPUSHW[] PUSH N Words
// 0x41
function NPUSHW(state) {
    var ip = state.ip;
    var prog = state.prog;
    var stack = state.stack;
    var n = prog[++ip];

    if (exports.DEBUG) { console.log(state.step, 'NPUSHW[]', n); }

    for (var i = 0; i < n; i++) {
        var w = (prog[++ip] << 8) | prog[++ip];
        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
        stack.push(w);
    }

    state.ip = ip;
}

// WS[] Write Store
// 0x42
function WS(state) {
    var stack = state.stack;
    var store = state.store;

    if (!store) { store = state.store = []; }

    var v = stack.pop();
    var l = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'WS', v, l); }

    store[l] = v;
}

// RS[] Read Store
// 0x43
function RS(state) {
    var stack = state.stack;
    var store = state.store;

    var l = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'RS', l); }

    var v = (store && store[l]) || 0;

    stack.push(v);
}

// WCVTP[] Write Control Value Table in Pixel units
// 0x44
function WCVTP(state) {
    var stack = state.stack;

    var v = stack.pop();
    var l = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'WCVTP', v, l); }

    state.cvt[l] = v / 0x40;
}

// RCVT[] Read Control Value Table entry
// 0x45
function RCVT(state) {
    var stack = state.stack;
    var cvte = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'RCVT', cvte); }

    stack.push(state.cvt[cvte] * 0x40);
}

// GC[] Get Coordinate projected onto the projection vector
// 0x46-0x47
function GC(a, state) {
    var stack = state.stack;
    var pi = stack.pop();
    var p = state.z2[pi];

    if (exports.DEBUG) { console.log(state.step, 'GC[' + a + ']', pi); }

    stack.push(state.dpv.distance(p, HPZero, a, false) * 0x40);
}

// MD[a] Measure Distance
// 0x49-0x4A
function MD(a, state) {
    var stack = state.stack;
    var pi2 = stack.pop();
    var pi1 = stack.pop();
    var p2 = state.z1[pi2];
    var p1 = state.z0[pi1];
    var d = state.dpv.distance(p1, p2, a, a);

    if (exports.DEBUG) { console.log(state.step, 'MD[' + a + ']', pi2, pi1, '->', d); }

    state.stack.push(Math.round(d * 64));
}

// MPPEM[] Measure Pixels Per EM
// 0x4B
function MPPEM(state) {
    if (exports.DEBUG) { console.log(state.step, 'MPPEM[]'); }
    state.stack.push(state.ppem);
}

// FLIPON[] set the auto FLIP Boolean to ON
// 0x4D
function FLIPON(state) {
    if (exports.DEBUG) { console.log(state.step, 'FLIPON[]'); }
    state.autoFlip = true;
}

// LT[] Less Than
// 0x50
function LT(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'LT[]', e2, e1); }

    stack.push(e1 < e2 ? 1 : 0);
}

// LTEQ[] Less Than or EQual
// 0x53
function LTEQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'LTEQ[]', e2, e1); }

    stack.push(e1 <= e2 ? 1 : 0);
}

// GTEQ[] Greater Than
// 0x52
function GT(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'GT[]', e2, e1); }

    stack.push(e1 > e2 ? 1 : 0);
}

// GTEQ[] Greater Than or EQual
// 0x53
function GTEQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'GTEQ[]', e2, e1); }

    stack.push(e1 >= e2 ? 1 : 0);
}

// EQ[] EQual
// 0x54
function EQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'EQ[]', e2, e1); }

    stack.push(e2 === e1 ? 1 : 0);
}

// NEQ[] Not EQual
// 0x55
function NEQ(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'NEQ[]', e2, e1); }

    stack.push(e2 !== e1 ? 1 : 0);
}

// ODD[] ODD
// 0x56
function ODD(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'ODD[]', n); }

    stack.push(Math.trunc(n) % 2 ? 1 : 0);
}

// EVEN[] EVEN
// 0x57
function EVEN(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'EVEN[]', n); }

    stack.push(Math.trunc(n) % 2 ? 0 : 1);
}

// IF[] IF test
// 0x58
function IF(state) {
    var test = state.stack.pop();
    var ins;

    if (exports.DEBUG) { console.log(state.step, 'IF[]', test); }

    // if test is true it just continues
    // if not the ip is skipped until matching ELSE or EIF
    if (!test) {
        skip(state, true);

        if (exports.DEBUG) { console.log(state.step, ins === 0x1B ? 'ELSE[]' : 'EIF[]'); }
    }
}

// EIF[] End IF
// 0x59
function EIF(state) {
    // this can be reached normally when
    // executing an else branch.
    // -> just ignore it

    if (exports.DEBUG) { console.log(state.step, 'EIF[]'); }
}

// AND[] logical AND
// 0x5A
function AND(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'AND[]', e2, e1); }

    stack.push(e2 && e1 ? 1 : 0);
}

// OR[] logical OR
// 0x5B
function OR(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'OR[]', e2, e1); }

    stack.push(e2 || e1 ? 1 : 0);
}

// NOT[] logical NOT
// 0x5C
function NOT(state) {
    var stack = state.stack;
    var e = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'NOT[]', e); }

    stack.push(e ? 0 : 1);
}

// DELTAP1[] DELTA exception P1
// DELTAP2[] DELTA exception P2
// DELTAP3[] DELTA exception P3
// 0x5D, 0x71, 0x72
function DELTAP123(b, state) {
    var stack = state.stack;
    var n = stack.pop();
    var fv = state.fv;
    var pv = state.pv;
    var ppem = state.ppem;
    var base = state.deltaBase + (b - 1) * 16;
    var ds = state.deltaShift;
    var z0 = state.z0;

    if (exports.DEBUG) { console.log(state.step, 'DELTAP[' + b + ']', n, stack); }

    for (var i = 0; i < n; i++) {
        var pi = stack.pop();
        var arg = stack.pop();
        var appem = base + ((arg & 0xF0) >> 4);
        if (appem !== ppem) { continue; }

        var mag = (arg & 0x0F) - 8;
        if (mag >= 0) { mag++; }
        if (exports.DEBUG) { console.log(state.step, 'DELTAPFIX', pi, 'by', mag * ds); }

        var p = z0[pi];
        fv.setRelative(p, p, mag * ds, pv);
    }
}

// SDB[] Set Delta Base in the graphics state
// 0x5E
function SDB(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SDB[]', n); }

    state.deltaBase = n;
}

// SDS[] Set Delta Shift in the graphics state
// 0x5F
function SDS(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SDS[]', n); }

    state.deltaShift = Math.pow(0.5, n);
}

// ADD[] ADD
// 0x60
function ADD(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'ADD[]', n2, n1); }

    stack.push(n1 + n2);
}

// SUB[] SUB
// 0x61
function SUB(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SUB[]', n2, n1); }

    stack.push(n1 - n2);
}

// DIV[] DIV
// 0x62
function DIV(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'DIV[]', n2, n1); }

    stack.push(n1 * 64 / n2);
}

// MUL[] MUL
// 0x63
function MUL(state) {
    var stack = state.stack;
    var n2 = stack.pop();
    var n1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'MUL[]', n2, n1); }

    stack.push(n1 * n2 / 64);
}

// ABS[] ABSolute value
// 0x64
function ABS(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'ABS[]', n); }

    stack.push(Math.abs(n));
}

// NEG[] NEGate
// 0x65
function NEG(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'NEG[]', n); }

    stack.push(-n);
}

// FLOOR[] FLOOR
// 0x66
function FLOOR(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'FLOOR[]', n); }

    stack.push(Math.floor(n / 0x40) * 0x40);
}

// CEILING[] CEILING
// 0x67
function CEILING(state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'CEILING[]', n); }

    stack.push(Math.ceil(n / 0x40) * 0x40);
}

// ROUND[ab] ROUND value
// 0x68-0x6B
function ROUND(dt, state) {
    var stack = state.stack;
    var n = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'ROUND[]'); }

    stack.push(state.round(n / 0x40) * 0x40);
}

// WCVTF[] Write Control Value Table in Funits
// 0x70
function WCVTF(state) {
    var stack = state.stack;
    var v = stack.pop();
    var l = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'WCVTF[]', v, l); }

    state.cvt[l] = v * state.ppem / state.font.unitsPerEm;
}

// DELTAC1[] DELTA exception C1
// DELTAC2[] DELTA exception C2
// DELTAC3[] DELTA exception C3
// 0x73, 0x74, 0x75
function DELTAC123(b, state) {
    var stack = state.stack;
    var n = stack.pop();
    var ppem = state.ppem;
    var base = state.deltaBase + (b - 1) * 16;
    var ds = state.deltaShift;

    if (exports.DEBUG) { console.log(state.step, 'DELTAC[' + b + ']', n, stack); }

    for (var i = 0; i < n; i++) {
        var c = stack.pop();
        var arg = stack.pop();
        var appem = base + ((arg & 0xF0) >> 4);
        if (appem !== ppem) { continue; }

        var mag = (arg & 0x0F) - 8;
        if (mag >= 0) { mag++; }

        var delta = mag * ds;

        if (exports.DEBUG) { console.log(state.step, 'DELTACFIX', c, 'by', delta); }

        state.cvt[c] += delta;
    }
}

// SROUND[] Super ROUND
// 0x76
function SROUND(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'SROUND[]', n); }

    state.round = roundSuper;

    var period;

    switch (n & 0xC0) {
        case 0x00:
            period = 0.5;
            break;
        case 0x40:
            period = 1;
            break;
        case 0x80:
            period = 2;
            break;
        default:
            throw new Error('invalid SROUND value');
    }

    state.srPeriod = period;

    switch (n & 0x30) {
        case 0x00:
            state.srPhase = 0;
            break;
        case 0x10:
            state.srPhase = 0.25 * period;
            break;
        case 0x20:
            state.srPhase = 0.5  * period;
            break;
        case 0x30:
            state.srPhase = 0.75 * period;
            break;
        default: throw new Error('invalid SROUND value');
    }

    n &= 0x0F;

    if (n === 0) { state.srThreshold = 0; }
    else { state.srThreshold = (n / 8 - 0.5) * period; }
}

// S45ROUND[] Super ROUND 45 degrees
// 0x77
function S45ROUND(state) {
    var n = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'S45ROUND[]', n); }

    state.round = roundSuper;

    var period;

    switch (n & 0xC0) {
        case 0x00:
            period = Math.sqrt(2) / 2;
            break;
        case 0x40:
            period = Math.sqrt(2);
            break;
        case 0x80:
            period = 2 * Math.sqrt(2);
            break;
        default:
            throw new Error('invalid S45ROUND value');
    }

    state.srPeriod = period;

    switch (n & 0x30) {
        case 0x00:
            state.srPhase = 0;
            break;
        case 0x10:
            state.srPhase = 0.25 * period;
            break;
        case 0x20:
            state.srPhase = 0.5  * period;
            break;
        case 0x30:
            state.srPhase = 0.75 * period;
            break;
        default:
            throw new Error('invalid S45ROUND value');
    }

    n &= 0x0F;

    if (n === 0) { state.srThreshold = 0; }
    else { state.srThreshold = (n / 8 - 0.5) * period; }
}

// ROFF[] Round Off
// 0x7A
function ROFF(state) {
    if (exports.DEBUG) { console.log(state.step, 'ROFF[]'); }

    state.round = roundOff;
}

// RUTG[] Round Up To Grid
// 0x7C
function RUTG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RUTG[]'); }

    state.round = roundUpToGrid;
}

// RDTG[] Round Down To Grid
// 0x7D
function RDTG(state) {
    if (exports.DEBUG) { console.log(state.step, 'RDTG[]'); }

    state.round = roundDownToGrid;
}

// SCANCTRL[] SCAN conversion ConTRoL
// 0x85
function SCANCTRL(state) {
    var n = state.stack.pop();

    // ignored by opentype.js

    if (exports.DEBUG) { console.log(state.step, 'SCANCTRL[]', n); }
}

// SDPVTL[a] Set Dual Projection Vector To Line
// 0x86-0x87
function SDPVTL(a, state) {
    var stack = state.stack;
    var p2i = stack.pop();
    var p1i = stack.pop();
    var p2 = state.z2[p2i];
    var p1 = state.z1[p1i];

    if (exports.DEBUG) { console.log(state.step, 'SDPVTL[' + a + ']', p2i, p1i); }

    var dx;
    var dy;

    if (!a) {
        dx = p1.x - p2.x;
        dy = p1.y - p2.y;
    } else {
        dx = p2.y - p1.y;
        dy = p1.x - p2.x;
    }

    state.dpv = getUnitVector(dx, dy);
}

// GETINFO[] GET INFOrmation
// 0x88
function GETINFO(state) {
    var stack = state.stack;
    var sel = stack.pop();
    var r = 0;

    if (exports.DEBUG) { console.log(state.step, 'GETINFO[]', sel); }

    // v35 as in no subpixel hinting
    if (sel & 0x01) { r = 35; }

    // TODO rotation and stretch currently not supported
    // and thus those GETINFO are always 0.

    // opentype.js is always gray scaling
    if (sel & 0x20) { r |= 0x1000; }

    stack.push(r);
}

// ROLL[] ROLL the top three stack elements
// 0x8A
function ROLL(state) {
    var stack = state.stack;
    var a = stack.pop();
    var b = stack.pop();
    var c = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'ROLL[]'); }

    stack.push(b);
    stack.push(a);
    stack.push(c);
}

// MAX[] MAXimum of top two stack elements
// 0x8B
function MAX(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'MAX[]', e2, e1); }

    stack.push(Math.max(e1, e2));
}

// MIN[] MINimum of top two stack elements
// 0x8C
function MIN(state) {
    var stack = state.stack;
    var e2 = stack.pop();
    var e1 = stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'MIN[]', e2, e1); }

    stack.push(Math.min(e1, e2));
}

// SCANTYPE[] SCANTYPE
// 0x8D
function SCANTYPE(state) {
    var n = state.stack.pop();
    // ignored by opentype.js
    if (exports.DEBUG) { console.log(state.step, 'SCANTYPE[]', n); }
}

// INSTCTRL[] INSTCTRL
// 0x8D
function INSTCTRL(state) {
    var s = state.stack.pop();
    var v = state.stack.pop();

    if (exports.DEBUG) { console.log(state.step, 'INSTCTRL[]', s, v); }

    switch (s) {
        case 1 : state.inhibitGridFit = !!v; return;
        case 2 : state.ignoreCvt = !!v; return;
        default: throw new Error('invalid INSTCTRL[] selector');
    }
}

// PUSHB[abc] PUSH Bytes
// 0xB0-0xB7
function PUSHB(n, state) {
    var stack = state.stack;
    var prog = state.prog;
    var ip = state.ip;

    if (exports.DEBUG) { console.log(state.step, 'PUSHB[' + n + ']'); }

    for (var i = 0; i < n; i++) { stack.push(prog[++ip]); }

    state.ip = ip;
}

// PUSHW[abc] PUSH Words
// 0xB8-0xBF
function PUSHW(n, state) {
    var ip = state.ip;
    var prog = state.prog;
    var stack = state.stack;

    if (exports.DEBUG) { console.log(state.ip, 'PUSHW[' + n + ']'); }

    for (var i = 0; i < n; i++) {
        var w = (prog[++ip] << 8) | prog[++ip];
        if (w & 0x8000) { w = -((w ^ 0xffff) + 1); }
        stack.push(w);
    }

    state.ip = ip;
}

// MDRP[abcde] Move Direct Relative Point
// 0xD0-0xEF
// (if indirect is 0)
//
// and
//
// MIRP[abcde] Move Indirect Relative Point
// 0xE0-0xFF
// (if indirect is 1)

function MDRP_MIRP(indirect, setRp0, keepD, ro, dt, state) {
    var stack = state.stack;
    var cvte = indirect && stack.pop();
    var pi = stack.pop();
    var rp0i = state.rp0;
    var rp = state.z0[rp0i];
    var p = state.z1[pi];

    var md = state.minDis;
    var fv = state.fv;
    var pv = state.dpv;
    var od; // original distance
    var d; // moving distance
    var sign; // sign of distance
    var cv;

    d = od = pv.distance(p, rp, true, true);
    sign = d >= 0 ? 1 : -1; // Math.sign would be 0 in case of 0

    // TODO consider autoFlip
    d = Math.abs(d);

    if (indirect) {
        cv = state.cvt[cvte];

        if (ro && Math.abs(d - cv) < state.cvCutIn) { d = cv; }
    }

    if (keepD && d < md) { d = md; }

    if (ro) { d = state.round(d); }

    fv.setRelative(p, rp, sign * d, pv);
    fv.touch(p);

    if (exports.DEBUG) {
        console.log(
            state.step,
            (indirect ? 'MIRP[' : 'MDRP[') +
            (setRp0 ? 'M' : 'm') +
            (keepD ? '>' : '_') +
            (ro ? 'R' : '_') +
            (dt === 0 ? 'Gr' : (dt === 1 ? 'Bl' : (dt === 2 ? 'Wh' : ''))) +
            ']',
            indirect ?
                cvte + '(' + state.cvt[cvte] + ',' +  cv + ')' :
                '',
            pi,
            '(d =', od, '->', sign * d, ')'
        );
    }

    state.rp1 = state.rp0;
    state.rp2 = pi;
    if (setRp0) { state.rp0 = pi; }
}

/*
* The instruction table.
*/
instructionTable = [
    /* 0x00 */ SVTCA.bind(undefined, yUnitVector),
    /* 0x01 */ SVTCA.bind(undefined, xUnitVector),
    /* 0x02 */ SPVTCA.bind(undefined, yUnitVector),
    /* 0x03 */ SPVTCA.bind(undefined, xUnitVector),
    /* 0x04 */ SFVTCA.bind(undefined, yUnitVector),
    /* 0x05 */ SFVTCA.bind(undefined, xUnitVector),
    /* 0x06 */ SPVTL.bind(undefined, 0),
    /* 0x07 */ SPVTL.bind(undefined, 1),
    /* 0x08 */ SFVTL.bind(undefined, 0),
    /* 0x09 */ SFVTL.bind(undefined, 1),
    /* 0x0A */ SPVFS,
    /* 0x0B */ SFVFS,
    /* 0x0C */ GPV,
    /* 0x0D */ GFV,
    /* 0x0E */ SFVTPV,
    /* 0x0F */ ISECT,
    /* 0x10 */ SRP0,
    /* 0x11 */ SRP1,
    /* 0x12 */ SRP2,
    /* 0x13 */ SZP0,
    /* 0x14 */ SZP1,
    /* 0x15 */ SZP2,
    /* 0x16 */ SZPS,
    /* 0x17 */ SLOOP,
    /* 0x18 */ RTG,
    /* 0x19 */ RTHG,
    /* 0x1A */ SMD,
    /* 0x1B */ ELSE,
    /* 0x1C */ JMPR,
    /* 0x1D */ SCVTCI,
    /* 0x1E */ undefined,   // TODO SSWCI
    /* 0x1F */ undefined,   // TODO SSW
    /* 0x20 */ DUP,
    /* 0x21 */ POP,
    /* 0x22 */ CLEAR,
    /* 0x23 */ SWAP,
    /* 0x24 */ DEPTH,
    /* 0x25 */ CINDEX,
    /* 0x26 */ MINDEX,
    /* 0x27 */ undefined,   // TODO ALIGNPTS
    /* 0x28 */ undefined,
    /* 0x29 */ undefined,   // TODO UTP
    /* 0x2A */ LOOPCALL,
    /* 0x2B */ CALL,
    /* 0x2C */ FDEF,
    /* 0x2D */ undefined,   // ENDF (eaten by FDEF)
    /* 0x2E */ MDAP.bind(undefined, 0),
    /* 0x2F */ MDAP.bind(undefined, 1),
    /* 0x30 */ IUP.bind(undefined, yUnitVector),
    /* 0x31 */ IUP.bind(undefined, xUnitVector),
    /* 0x32 */ SHP.bind(undefined, 0),
    /* 0x33 */ SHP.bind(undefined, 1),
    /* 0x34 */ SHC.bind(undefined, 0),
    /* 0x35 */ SHC.bind(undefined, 1),
    /* 0x36 */ SHZ.bind(undefined, 0),
    /* 0x37 */ SHZ.bind(undefined, 1),
    /* 0x38 */ SHPIX,
    /* 0x39 */ IP,
    /* 0x3A */ MSIRP.bind(undefined, 0),
    /* 0x3B */ MSIRP.bind(undefined, 1),
    /* 0x3C */ ALIGNRP,
    /* 0x3D */ RTDG,
    /* 0x3E */ MIAP.bind(undefined, 0),
    /* 0x3F */ MIAP.bind(undefined, 1),
    /* 0x40 */ NPUSHB,
    /* 0x41 */ NPUSHW,
    /* 0x42 */ WS,
    /* 0x43 */ RS,
    /* 0x44 */ WCVTP,
    /* 0x45 */ RCVT,
    /* 0x46 */ GC.bind(undefined, 0),
    /* 0x47 */ GC.bind(undefined, 1),
    /* 0x48 */ undefined,   // TODO SCFS
    /* 0x49 */ MD.bind(undefined, 0),
    /* 0x4A */ MD.bind(undefined, 1),
    /* 0x4B */ MPPEM,
    /* 0x4C */ undefined,   // TODO MPS
    /* 0x4D */ FLIPON,
    /* 0x4E */ undefined,   // TODO FLIPOFF
    /* 0x4F */ undefined,   // TODO DEBUG
    /* 0x50 */ LT,
    /* 0x51 */ LTEQ,
    /* 0x52 */ GT,
    /* 0x53 */ GTEQ,
    /* 0x54 */ EQ,
    /* 0x55 */ NEQ,
    /* 0x56 */ ODD,
    /* 0x57 */ EVEN,
    /* 0x58 */ IF,
    /* 0x59 */ EIF,
    /* 0x5A */ AND,
    /* 0x5B */ OR,
    /* 0x5C */ NOT,
    /* 0x5D */ DELTAP123.bind(undefined, 1),
    /* 0x5E */ SDB,
    /* 0x5F */ SDS,
    /* 0x60 */ ADD,
    /* 0x61 */ SUB,
    /* 0x62 */ DIV,
    /* 0x63 */ MUL,
    /* 0x64 */ ABS,
    /* 0x65 */ NEG,
    /* 0x66 */ FLOOR,
    /* 0x67 */ CEILING,
    /* 0x68 */ ROUND.bind(undefined, 0),
    /* 0x69 */ ROUND.bind(undefined, 1),
    /* 0x6A */ ROUND.bind(undefined, 2),
    /* 0x6B */ ROUND.bind(undefined, 3),
    /* 0x6C */ undefined,   // TODO NROUND[ab]
    /* 0x6D */ undefined,   // TODO NROUND[ab]
    /* 0x6E */ undefined,   // TODO NROUND[ab]
    /* 0x6F */ undefined,   // TODO NROUND[ab]
    /* 0x70 */ WCVTF,
    /* 0x71 */ DELTAP123.bind(undefined, 2),
    /* 0x72 */ DELTAP123.bind(undefined, 3),
    /* 0x73 */ DELTAC123.bind(undefined, 1),
    /* 0x74 */ DELTAC123.bind(undefined, 2),
    /* 0x75 */ DELTAC123.bind(undefined, 3),
    /* 0x76 */ SROUND,
    /* 0x77 */ S45ROUND,
    /* 0x78 */ undefined,   // TODO JROT[]
    /* 0x79 */ undefined,   // TODO JROF[]
    /* 0x7A */ ROFF,
    /* 0x7B */ undefined,
    /* 0x7C */ RUTG,
    /* 0x7D */ RDTG,
    /* 0x7E */ POP, // actually SANGW, supposed to do only a pop though
    /* 0x7F */ POP, // actually AA, supposed to do only a pop though
    /* 0x80 */ undefined,   // TODO FLIPPT
    /* 0x81 */ undefined,   // TODO FLIPRGON
    /* 0x82 */ undefined,   // TODO FLIPRGOFF
    /* 0x83 */ undefined,
    /* 0x84 */ undefined,
    /* 0x85 */ SCANCTRL,
    /* 0x86 */ SDPVTL.bind(undefined, 0),
    /* 0x87 */ SDPVTL.bind(undefined, 1),
    /* 0x88 */ GETINFO,
    /* 0x89 */ undefined,   // TODO IDEF
    /* 0x8A */ ROLL,
    /* 0x8B */ MAX,
    /* 0x8C */ MIN,
    /* 0x8D */ SCANTYPE,
    /* 0x8E */ INSTCTRL,
    /* 0x8F */ undefined,
    /* 0x90 */ undefined,
    /* 0x91 */ undefined,
    /* 0x92 */ undefined,
    /* 0x93 */ undefined,
    /* 0x94 */ undefined,
    /* 0x95 */ undefined,
    /* 0x96 */ undefined,
    /* 0x97 */ undefined,
    /* 0x98 */ undefined,
    /* 0x99 */ undefined,
    /* 0x9A */ undefined,
    /* 0x9B */ undefined,
    /* 0x9C */ undefined,
    /* 0x9D */ undefined,
    /* 0x9E */ undefined,
    /* 0x9F */ undefined,
    /* 0xA0 */ undefined,
    /* 0xA1 */ undefined,
    /* 0xA2 */ undefined,
    /* 0xA3 */ undefined,
    /* 0xA4 */ undefined,
    /* 0xA5 */ undefined,
    /* 0xA6 */ undefined,
    /* 0xA7 */ undefined,
    /* 0xA8 */ undefined,
    /* 0xA9 */ undefined,
    /* 0xAA */ undefined,
    /* 0xAB */ undefined,
    /* 0xAC */ undefined,
    /* 0xAD */ undefined,
    /* 0xAE */ undefined,
    /* 0xAF */ undefined,
    /* 0xB0 */ PUSHB.bind(undefined, 1),
    /* 0xB1 */ PUSHB.bind(undefined, 2),
    /* 0xB2 */ PUSHB.bind(undefined, 3),
    /* 0xB3 */ PUSHB.bind(undefined, 4),
    /* 0xB4 */ PUSHB.bind(undefined, 5),
    /* 0xB5 */ PUSHB.bind(undefined, 6),
    /* 0xB6 */ PUSHB.bind(undefined, 7),
    /* 0xB7 */ PUSHB.bind(undefined, 8),
    /* 0xB8 */ PUSHW.bind(undefined, 1),
    /* 0xB9 */ PUSHW.bind(undefined, 2),
    /* 0xBA */ PUSHW.bind(undefined, 3),
    /* 0xBB */ PUSHW.bind(undefined, 4),
    /* 0xBC */ PUSHW.bind(undefined, 5),
    /* 0xBD */ PUSHW.bind(undefined, 6),
    /* 0xBE */ PUSHW.bind(undefined, 7),
    /* 0xBF */ PUSHW.bind(undefined, 8),
    /* 0xC0 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 0),
    /* 0xC1 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 1),
    /* 0xC2 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 2),
    /* 0xC3 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 0, 3),
    /* 0xC4 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 0),
    /* 0xC5 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 1),
    /* 0xC6 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 2),
    /* 0xC7 */ MDRP_MIRP.bind(undefined, 0, 0, 0, 1, 3),
    /* 0xC8 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 0),
    /* 0xC9 */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 1),
    /* 0xCA */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 2),
    /* 0xCB */ MDRP_MIRP.bind(undefined, 0, 0, 1, 0, 3),
    /* 0xCC */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 0),
    /* 0xCD */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 1),
    /* 0xCE */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 2),
    /* 0xCF */ MDRP_MIRP.bind(undefined, 0, 0, 1, 1, 3),
    /* 0xD0 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 0),
    /* 0xD1 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 1),
    /* 0xD2 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 2),
    /* 0xD3 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 0, 3),
    /* 0xD4 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 0),
    /* 0xD5 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 1),
    /* 0xD6 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 2),
    /* 0xD7 */ MDRP_MIRP.bind(undefined, 0, 1, 0, 1, 3),
    /* 0xD8 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 0),
    /* 0xD9 */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 1),
    /* 0xDA */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 2),
    /* 0xDB */ MDRP_MIRP.bind(undefined, 0, 1, 1, 0, 3),
    /* 0xDC */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 0),
    /* 0xDD */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 1),
    /* 0xDE */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 2),
    /* 0xDF */ MDRP_MIRP.bind(undefined, 0, 1, 1, 1, 3),
    /* 0xE0 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 0),
    /* 0xE1 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 1),
    /* 0xE2 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 2),
    /* 0xE3 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 0, 3),
    /* 0xE4 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 0),
    /* 0xE5 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 1),
    /* 0xE6 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 2),
    /* 0xE7 */ MDRP_MIRP.bind(undefined, 1, 0, 0, 1, 3),
    /* 0xE8 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 0),
    /* 0xE9 */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 1),
    /* 0xEA */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 2),
    /* 0xEB */ MDRP_MIRP.bind(undefined, 1, 0, 1, 0, 3),
    /* 0xEC */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 0),
    /* 0xED */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 1),
    /* 0xEE */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 2),
    /* 0xEF */ MDRP_MIRP.bind(undefined, 1, 0, 1, 1, 3),
    /* 0xF0 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 0),
    /* 0xF1 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 1),
    /* 0xF2 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 2),
    /* 0xF3 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 0, 3),
    /* 0xF4 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 0),
    /* 0xF5 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 1),
    /* 0xF6 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 2),
    /* 0xF7 */ MDRP_MIRP.bind(undefined, 1, 1, 0, 1, 3),
    /* 0xF8 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 0),
    /* 0xF9 */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 1),
    /* 0xFA */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 2),
    /* 0xFB */ MDRP_MIRP.bind(undefined, 1, 1, 1, 0, 3),
    /* 0xFC */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 0),
    /* 0xFD */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 1),
    /* 0xFE */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 2),
    /* 0xFF */ MDRP_MIRP.bind(undefined, 1, 1, 1, 1, 3)
];



/*****************************
  Mathematical Considerations
******************************

fv ... refers to freedom vector
pv ... refers to projection vector
rp ... refers to reference point
p  ... refers to to point being operated on
d  ... refers to distance

SETRELATIVE:
============

case freedom vector == x-axis:
------------------------------

                        (pv)
                     .-'
              rpd .-'
               .-*
          d .-'90°'
         .-'       '
      .-'           '
   *-'               ' b
  rp                  '
                       '
                        '
            p *----------*-------------- (fv)
                          pm

  rpdx = rpx + d * pv.x
  rpdy = rpy + d * pv.y

  equation of line b

   y - rpdy = pvns * (x- rpdx)

   y = p.y

   x = rpdx + ( p.y - rpdy ) / pvns


case freedom vector == y-axis:
------------------------------

    * pm
    |\
    | \
    |  \
    |   \
    |    \
    |     \
    |      \
    |       \
    |        \
    |         \ b
    |          \
    |           \
    |            \    .-' (pv)
    |         90° \.-'
    |           .-'* rpd
    |        .-'
    *     *-'  d
    p     rp

  rpdx = rpx + d * pv.x
  rpdy = rpy + d * pv.y

  equation of line b:
           pvns ... normal slope to pv

   y - rpdy = pvns * (x - rpdx)

   x = p.x

   y = rpdy +  pvns * (p.x - rpdx)



generic case:
-------------


                              .'(fv)
                            .'
                          .* pm
                        .' !
                      .'    .
                    .'      !
                  .'         . b
                .'           !
               *              .
              p               !
                         90°   .    ... (pv)
                           ...-*-'''
                  ...---'''    rpd
         ...---'''   d
   *--'''
  rp

    rpdx = rpx + d * pv.x
    rpdy = rpy + d * pv.y

 equation of line b:
    pvns... normal slope to pv

    y - rpdy = pvns * (x - rpdx)

 equation of freedom vector line:
    fvs ... slope of freedom vector (=fy/fx)

    y - py = fvs * (x - px)


  on pm both equations are true for same x/y

    y - rpdy = pvns * (x - rpdx)

    y - py = fvs * (x - px)

  form to y and set equal:

    pvns * (x - rpdx) + rpdy = fvs * (x - px) + py

  expand:

    pvns * x - pvns * rpdx + rpdy = fvs * x - fvs * px + py

  switch:

    fvs * x - fvs * px + py = pvns * x - pvns * rpdx + rpdy

  solve for x:

    fvs * x - pvns * x = fvs * px - pvns * rpdx - py + rpdy



          fvs * px - pvns * rpdx + rpdy - py
    x =  -----------------------------------
                 fvs - pvns

  and:

    y = fvs * (x - px) + py



INTERPOLATE:
============

Examples of point interpolation.

The weight of the movement of the reference point gets bigger
the further the other reference point is away, thus the safest
option (that is avoiding 0/0 divisions) is to weight the
original distance of the other point by the sum of both distances.

If the sum of both distances is 0, then move the point by the
arithmetic average of the movement of both reference points.




           (+6)
    rp1o *---->*rp1
         .     .                          (+12)
         .     .                  rp2o *---------->* rp2
         .     .                       .           .
         .     .                       .           .
         .    10          20           .           .
         |.........|...................|           .
               .   .                               .
               .   . (+8)                          .
                po *------>*p                      .
               .           .                       .
               .    12     .          24           .
               |...........|.......................|
                                  36


-------



           (+10)
    rp1o *-------->*rp1
         .         .                      (-10)
         .         .              rp2 *<---------* rpo2
         .         .                   .         .
         .         .                   .         .
         .    10   .          30       .         .
         |.........|.............................|
                   .                   .
                   . (+5)              .
                po *--->* p            .
                   .    .              .
                   .    .   20         .
                   |....|..............|
                     5        15


-------


           (+10)
    rp1o *-------->*rp1
         .         .
         .         .
    rp2o *-------->*rp2


                               (+10)
                          po *-------->* p

-------


           (+10)
    rp1o *-------->*rp1
         .         .
         .         .(+30)
    rp2o *---------------------------->*rp2


                                        (+25)
                          po *----------------------->* p



vim: set ts=4 sw=4 expandtab:
*****/

// The Font object

/**
 * @typedef FontOptions
 * @type Object
 * @property {Boolean} empty - whether to create a new empty font
 * @property {string} familyName
 * @property {string} styleName
 * @property {string=} fullName
 * @property {string=} postScriptName
 * @property {string=} designer
 * @property {string=} designerURL
 * @property {string=} manufacturer
 * @property {string=} manufacturerURL
 * @property {string=} license
 * @property {string=} licenseURL
 * @property {string=} version
 * @property {string=} description
 * @property {string=} copyright
 * @property {string=} trademark
 * @property {Number} unitsPerEm
 * @property {Number} ascender
 * @property {Number} descender
 * @property {Number} createdTimestamp
 * @property {string=} weightClass
 * @property {string=} widthClass
 * @property {string=} fsSelection
 */

/**
 * A Font represents a loaded OpenType font file.
 * It contains a set of glyphs and methods to draw text on a drawing context,
 * or to get a path representing the text.
 * @exports opentype.Font
 * @class
 * @param {FontOptions}
 * @constructor
 */
function Font(options) {
    options = options || {};

    if (!options.empty) {
        // Check that we've provided the minimum set of names.
        checkArgument(options.familyName, 'When creating a new Font object, familyName is required.');
        checkArgument(options.styleName, 'When creating a new Font object, styleName is required.');
        checkArgument(options.unitsPerEm, 'When creating a new Font object, unitsPerEm is required.');
        checkArgument(options.ascender, 'When creating a new Font object, ascender is required.');
        checkArgument(options.descender, 'When creating a new Font object, descender is required.');
        checkArgument(options.descender < 0, 'Descender should be negative (e.g. -512).');

        // OS X will complain if the names are empty, so we put a single space everywhere by default.
        this.names = {
            fontFamily: {en: options.familyName || ' '},
            fontSubfamily: {en: options.styleName || ' '},
            fullName: {en: options.fullName || options.familyName + ' ' + options.styleName},
            postScriptName: {en: options.postScriptName || options.familyName + options.styleName},
            designer: {en: options.designer || ' '},
            designerURL: {en: options.designerURL || ' '},
            manufacturer: {en: options.manufacturer || ' '},
            manufacturerURL: {en: options.manufacturerURL || ' '},
            license: {en: options.license || ' '},
            licenseURL: {en: options.licenseURL || ' '},
            version: {en: options.version || 'Version 0.1'},
            description: {en: options.description || ' '},
            copyright: {en: options.copyright || ' '},
            trademark: {en: options.trademark || ' '}
        };
        this.unitsPerEm = options.unitsPerEm || 1000;
        this.ascender = options.ascender;
        this.descender = options.descender;
        this.createdTimestamp = options.createdTimestamp;
        this.tables = { os2: {
            usWeightClass: options.weightClass || this.usWeightClasses.MEDIUM,
            usWidthClass: options.widthClass || this.usWidthClasses.MEDIUM,
            fsSelection: options.fsSelection || this.fsSelectionValues.REGULAR
        } };
    }

    this.supported = true; // Deprecated: parseBuffer will throw an error if font is not supported.
    this.glyphs = new glyphset.GlyphSet(this, options.glyphs || []);
    this.encoding = new DefaultEncoding(this);
    this.position = new Position(this);
    this.substitution = new Substitution(this);
    this.tables = this.tables || {};

    Object.defineProperty(this, 'hinting', {
        get: function() {
            if (this._hinting) { return this._hinting; }
            if (this.outlinesFormat === 'truetype') {
                return (this._hinting = new Hinting(this));
            }
        }
    });
}

/**
 * Check if the font has a glyph for the given character.
 * @param  {string}
 * @return {Boolean}
 */
Font.prototype.hasChar = function(c) {
    return this.encoding.charToGlyphIndex(c) !== null;
};

/**
 * Convert the given character to a single glyph index.
 * Note that this function assumes that there is a one-to-one mapping between
 * the given character and a glyph; for complex scripts this might not be the case.
 * @param  {string}
 * @return {Number}
 */
Font.prototype.charToGlyphIndex = function(s) {
    return this.encoding.charToGlyphIndex(s);
};

/**
 * Convert the given character to a single Glyph object.
 * Note that this function assumes that there is a one-to-one mapping between
 * the given character and a glyph; for complex scripts this might not be the case.
 * @param  {string}
 * @return {opentype.Glyph}
 */
Font.prototype.charToGlyph = function(c) {
    var glyphIndex = this.charToGlyphIndex(c);
    var glyph = this.glyphs.get(glyphIndex);
    if (!glyph) {
        // .notdef
        glyph = this.glyphs.get(0);
    }

    return glyph;
};

/**
 * Convert the given text to a list of Glyph objects.
 * Note that there is no strict one-to-one mapping between characters and
 * glyphs, so the list of returned glyphs can be larger or smaller than the
 * length of the given string.
 * @param  {string}
 * @param  {GlyphRenderOptions} [options]
 * @return {opentype.Glyph[]}
 */
Font.prototype.stringToGlyphs = function(s, options) {
    var this$1 = this;

    options = options || this.defaultRenderOptions;
    // Get glyph indexes
    var indexes = [];
    for (var i = 0; i < s.length; i += 1) {
        var c = s[i];
        indexes.push(this$1.charToGlyphIndex(c));
    }
    var length = indexes.length;

    // Apply substitutions on glyph indexes
    if (options.features) {
        var script = options.script || this.substitution.getDefaultScriptName();
        var manyToOne = [];
        if (options.features.liga) { manyToOne = manyToOne.concat(this.substitution.getFeature('liga', script, options.language)); }
        if (options.features.rlig) { manyToOne = manyToOne.concat(this.substitution.getFeature('rlig', script, options.language)); }
        for (var i$1 = 0; i$1 < length; i$1 += 1) {
            for (var j = 0; j < manyToOne.length; j++) {
                var ligature = manyToOne[j];
                var components = ligature.sub;
                var compCount = components.length;
                var k = 0;
                while (k < compCount && components[k] === indexes[i$1 + k]) { k++; }
                if (k === compCount) {
                    indexes.splice(i$1, compCount, ligature.by);
                    length = length - compCount + 1;
                }
            }
        }
    }

    // convert glyph indexes to glyph objects
    var glyphs = new Array(length);
    var notdef = this.glyphs.get(0);
    for (var i$2 = 0; i$2 < length; i$2 += 1) {
        glyphs[i$2] = this$1.glyphs.get(indexes[i$2]) || notdef;
    }
    return glyphs;
};

/**
 * @param  {string}
 * @return {Number}
 */
Font.prototype.nameToGlyphIndex = function(name) {
    return this.glyphNames.nameToGlyphIndex(name);
};

/**
 * @param  {string}
 * @return {opentype.Glyph}
 */
Font.prototype.nameToGlyph = function(name) {
    var glyphIndex = this.nameToGlyphIndex(name);
    var glyph = this.glyphs.get(glyphIndex);
    if (!glyph) {
        // .notdef
        glyph = this.glyphs.get(0);
    }

    return glyph;
};

/**
 * @param  {Number}
 * @return {String}
 */
Font.prototype.glyphIndexToName = function(gid) {
    if (!this.glyphNames.glyphIndexToName) {
        return '';
    }

    return this.glyphNames.glyphIndexToName(gid);
};

/**
 * Retrieve the value of the kerning pair between the left glyph (or its index)
 * and the right glyph (or its index). If no kerning pair is found, return 0.
 * The kerning value gets added to the advance width when calculating the spacing
 * between glyphs.
 * @param  {opentype.Glyph} leftGlyph
 * @param  {opentype.Glyph} rightGlyph
 * @return {Number}
 */
Font.prototype.getKerningValue = function(leftGlyph, rightGlyph) {
    leftGlyph = leftGlyph.index || leftGlyph;
    rightGlyph = rightGlyph.index || rightGlyph;
    return this.kerningPairs[leftGlyph + ',' + rightGlyph] || 0;
};

/**
 * @typedef GlyphRenderOptions
 * @type Object
 * @property {string} [script] - script used to determine which features to apply. By default, 'DFLT' or 'latn' is used.
 *                               See https://www.microsoft.com/typography/otspec/scripttags.htm
 * @property {string} [language='dflt'] - language system used to determine which features to apply.
 *                                        See https://www.microsoft.com/typography/developers/opentype/languagetags.aspx
 * @property {boolean} [kerning=true] - whether to include kerning values
 * @property {object} [features] - OpenType Layout feature tags. Used to enable or disable the features of the given script/language system.
 *                                 See https://www.microsoft.com/typography/otspec/featuretags.htm
 */
Font.prototype.defaultRenderOptions = {
    kerning: true,
    features: {
        liga: true,
        rlig: true
    }
};

/**
 * Helper function that invokes the given callback for each glyph in the given text.
 * The callback gets `(glyph, x, y, fontSize, options)`.* @param  {string} text
 * @param {string} text - The text to apply.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @param  {Function} callback
 */
Font.prototype.forEachGlyph = function(text, x, y, fontSize, options, callback) {
    var this$1 = this;

    x = x !== undefined ? x : 0;
    y = y !== undefined ? y : 0;
    fontSize = fontSize !== undefined ? fontSize : 72;
    options = options || this.defaultRenderOptions;
    var fontScale = 1 / this.unitsPerEm * fontSize;
    var glyphs = this.stringToGlyphs(text, options);
    var kerningLookups;
    if (options.kerning) {
        var script = options.script || this.position.getDefaultScriptName();
        kerningLookups = this.position.getKerningTables(script, options.language);
    }
    for (var i = 0; i < glyphs.length; i += 1) {
        var glyph = glyphs[i];
        callback.call(this$1, glyph, x, y, fontSize, options);
        if (glyph.advanceWidth) {
            x += glyph.advanceWidth * fontScale;
        }

        if (options.kerning && i < glyphs.length - 1) {
            // We should apply position adjustment lookups in a more generic way.
            // Here we only use the xAdvance value.
            var kerningValue = kerningLookups ?
                  this$1.position.getKerningValue(kerningLookups, glyph.index, glyphs[i + 1].index) :
                  this$1.getKerningValue(glyph, glyphs[i + 1]);
            x += kerningValue * fontScale;
        }

        if (options.letterSpacing) {
            x += options.letterSpacing * fontSize;
        } else if (options.tracking) {
            x += (options.tracking / 1000) * fontSize;
        }
    }
    return x;
};

/**
 * Create a Path object that represents the given text.
 * @param  {string} text - The text to create.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @return {opentype.Path}
 */
Font.prototype.getPath = function(text, x, y, fontSize, options) {
    var fullPath = new Path();
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
        fullPath.extend(glyphPath);
    });
    return fullPath;
};

/**
 * Create an array of Path objects that represent the glyphs of a given text.
 * @param  {string} text - The text to create.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @return {opentype.Path[]}
 */
Font.prototype.getPaths = function(text, x, y, fontSize, options) {
    var glyphPaths = [];
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        var glyphPath = glyph.getPath(gX, gY, gFontSize, options, this);
        glyphPaths.push(glyphPath);
    });

    return glyphPaths;
};

/**
 * Returns the advance width of a text.
 *
 * This is something different than Path.getBoundingBox() as for example a
 * suffixed whitespace increases the advanceWidth but not the bounding box
 * or an overhanging letter like a calligraphic 'f' might have a quite larger
 * bounding box than its advance width.
 *
 * This corresponds to canvas2dContext.measureText(text).width
 *
 * @param  {string} text - The text to create.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 * @return advance width
 */
Font.prototype.getAdvanceWidth = function(text, fontSize, options) {
    return this.forEachGlyph(text, 0, 0, fontSize, options, function() {});
};

/**
 * Draw the text on the given drawing context.
 * @param  {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param  {string} text - The text to create.
 * @param  {number} [x=0] - Horizontal position of the beginning of the text.
 * @param  {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param  {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param  {GlyphRenderOptions=} options
 */
Font.prototype.draw = function(ctx, text, x, y, fontSize, options) {
    this.getPath(text, x, y, fontSize, options).draw(ctx);
};

/**
 * Draw the points of all glyphs in the text.
 * On-curve points will be drawn in blue, off-curve points will be drawn in red.
 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param {string} text - The text to create.
 * @param {number} [x=0] - Horizontal position of the beginning of the text.
 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param {GlyphRenderOptions=} options
 */
Font.prototype.drawPoints = function(ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        glyph.drawPoints(ctx, gX, gY, gFontSize);
    });
};

/**
 * Draw lines indicating important font measurements for all glyphs in the text.
 * Black lines indicate the origin of the coordinate system (point 0,0).
 * Blue lines indicate the glyph bounding box.
 * Green line indicates the advance width of the glyph.
 * @param {CanvasRenderingContext2D} ctx - A 2D drawing context, like Canvas.
 * @param {string} text - The text to create.
 * @param {number} [x=0] - Horizontal position of the beginning of the text.
 * @param {number} [y=0] - Vertical position of the *baseline* of the text.
 * @param {number} [fontSize=72] - Font size in pixels. We scale the glyph units by `1 / unitsPerEm * fontSize`.
 * @param {GlyphRenderOptions=} options
 */
Font.prototype.drawMetrics = function(ctx, text, x, y, fontSize, options) {
    this.forEachGlyph(text, x, y, fontSize, options, function(glyph, gX, gY, gFontSize) {
        glyph.drawMetrics(ctx, gX, gY, gFontSize);
    });
};

/**
 * @param  {string}
 * @return {string}
 */
Font.prototype.getEnglishName = function(name) {
    var translations = this.names[name];
    if (translations) {
        return translations.en;
    }
};

/**
 * Validate
 */
Font.prototype.validate = function() {
    var warnings = [];
    var _this = this;

    function assert(predicate, message) {
        if (!predicate) {
            warnings.push(message);
        }
    }

    function assertNamePresent(name) {
        var englishName = _this.getEnglishName(name);
        assert(englishName && englishName.trim().length > 0,
               'No English ' + name + ' specified.');
    }

    // Identification information
    assertNamePresent('fontFamily');
    assertNamePresent('weightName');
    assertNamePresent('manufacturer');
    assertNamePresent('copyright');
    assertNamePresent('version');

    // Dimension information
    assert(this.unitsPerEm > 0, 'No unitsPerEm specified.');
};

/**
 * Convert the font object to a SFNT data structure.
 * This structure contains all the necessary tables and metadata to create a binary OTF file.
 * @return {opentype.Table}
 */
Font.prototype.toTables = function() {
    return sfnt.fontToTable(this);
};
/**
 * @deprecated Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.
 */
Font.prototype.toBuffer = function() {
    console.warn('Font.toBuffer is deprecated. Use Font.toArrayBuffer instead.');
    return this.toArrayBuffer();
};
/**
 * Converts a `opentype.Font` into an `ArrayBuffer`
 * @return {ArrayBuffer}
 */
Font.prototype.toArrayBuffer = function() {
    var sfntTable = this.toTables();
    var bytes = sfntTable.encode();
    var buffer = new ArrayBuffer(bytes.length);
    var intArray = new Uint8Array(buffer);
    for (var i = 0; i < bytes.length; i++) {
        intArray[i] = bytes[i];
    }

    return buffer;
};

/**
 * Initiate a download of the OpenType font.
 */
Font.prototype.download = function(fileName) {
    var familyName = this.getEnglishName('fontFamily');
    var styleName = this.getEnglishName('fontSubfamily');
    fileName = fileName || familyName.replace(/\s/g, '') + '-' + styleName + '.otf';
    var arrayBuffer = this.toArrayBuffer();

    if (isBrowser()) {
        window.requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
        window.requestFileSystem(window.TEMPORARY, arrayBuffer.byteLength, function(fs) {
            fs.root.getFile(fileName, {create: true}, function(fileEntry) {
                fileEntry.createWriter(function(writer) {
                    var dataView = new DataView(arrayBuffer);
                    var blob = new Blob([dataView], {type: 'font/opentype'});
                    writer.write(blob);

                    writer.addEventListener('writeend', function() {
                        // Navigating to the file will download it.
                        location.href = fileEntry.toURL();
                    }, false);
                });
            });
        },
        function(err) {
            throw new Error(err.name + ': ' + err.message);
        });
    } else {
        var fs = require('fs');
        var buffer = arrayBufferToNodeBuffer(arrayBuffer);
        fs.writeFileSync(fileName, buffer);
    }
};
/**
 * @private
 */
Font.prototype.fsSelectionValues = {
    ITALIC:              0x001, //1
    UNDERSCORE:          0x002, //2
    NEGATIVE:            0x004, //4
    OUTLINED:            0x008, //8
    STRIKEOUT:           0x010, //16
    BOLD:                0x020, //32
    REGULAR:             0x040, //64
    USER_TYPO_METRICS:   0x080, //128
    WWS:                 0x100, //256
    OBLIQUE:             0x200  //512
};

/**
 * @private
 */
Font.prototype.usWidthClasses = {
    ULTRA_CONDENSED: 1,
    EXTRA_CONDENSED: 2,
    CONDENSED: 3,
    SEMI_CONDENSED: 4,
    MEDIUM: 5,
    SEMI_EXPANDED: 6,
    EXPANDED: 7,
    EXTRA_EXPANDED: 8,
    ULTRA_EXPANDED: 9
};

/**
 * @private
 */
Font.prototype.usWeightClasses = {
    THIN: 100,
    EXTRA_LIGHT: 200,
    LIGHT: 300,
    NORMAL: 400,
    MEDIUM: 500,
    SEMI_BOLD: 600,
    BOLD: 700,
    EXTRA_BOLD: 800,
    BLACK:    900
};

// The `fvar` table stores font variation axes and instances.
// https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6fvar.html

function addName(name, names) {
    var nameString = JSON.stringify(name);
    var nameID = 256;
    for (var nameKey in names) {
        var n = parseInt(nameKey);
        if (!n || n < 256) {
            continue;
        }

        if (JSON.stringify(names[nameKey]) === nameString) {
            return n;
        }

        if (nameID <= n) {
            nameID = n + 1;
        }
    }

    names[nameID] = name;
    return nameID;
}

function makeFvarAxis(n, axis, names) {
    var nameID = addName(axis.name, names);
    return [
        {name: 'tag_' + n, type: 'TAG', value: axis.tag},
        {name: 'minValue_' + n, type: 'FIXED', value: axis.minValue << 16},
        {name: 'defaultValue_' + n, type: 'FIXED', value: axis.defaultValue << 16},
        {name: 'maxValue_' + n, type: 'FIXED', value: axis.maxValue << 16},
        {name: 'flags_' + n, type: 'USHORT', value: 0},
        {name: 'nameID_' + n, type: 'USHORT', value: nameID}
    ];
}

function parseFvarAxis(data, start, names) {
    var axis = {};
    var p = new parse.Parser(data, start);
    axis.tag = p.parseTag();
    axis.minValue = p.parseFixed();
    axis.defaultValue = p.parseFixed();
    axis.maxValue = p.parseFixed();
    p.skip('uShort', 1);  // reserved for flags; no values defined
    axis.name = names[p.parseUShort()] || {};
    return axis;
}

function makeFvarInstance(n, inst, axes, names) {
    var nameID = addName(inst.name, names);
    var fields = [
        {name: 'nameID_' + n, type: 'USHORT', value: nameID},
        {name: 'flags_' + n, type: 'USHORT', value: 0}
    ];

    for (var i = 0; i < axes.length; ++i) {
        var axisTag = axes[i].tag;
        fields.push({
            name: 'axis_' + n + ' ' + axisTag,
            type: 'FIXED',
            value: inst.coordinates[axisTag] << 16
        });
    }

    return fields;
}

function parseFvarInstance(data, start, axes, names) {
    var inst = {};
    var p = new parse.Parser(data, start);
    inst.name = names[p.parseUShort()] || {};
    p.skip('uShort', 1);  // reserved for flags; no values defined

    inst.coordinates = {};
    for (var i = 0; i < axes.length; ++i) {
        inst.coordinates[axes[i].tag] = p.parseFixed();
    }

    return inst;
}

function makeFvarTable(fvar, names) {
    var result = new table.Table('fvar', [
        {name: 'version', type: 'ULONG', value: 0x10000},
        {name: 'offsetToData', type: 'USHORT', value: 0},
        {name: 'countSizePairs', type: 'USHORT', value: 2},
        {name: 'axisCount', type: 'USHORT', value: fvar.axes.length},
        {name: 'axisSize', type: 'USHORT', value: 20},
        {name: 'instanceCount', type: 'USHORT', value: fvar.instances.length},
        {name: 'instanceSize', type: 'USHORT', value: 4 + fvar.axes.length * 4}
    ]);
    result.offsetToData = result.sizeOf();

    for (var i = 0; i < fvar.axes.length; i++) {
        result.fields = result.fields.concat(makeFvarAxis(i, fvar.axes[i], names));
    }

    for (var j = 0; j < fvar.instances.length; j++) {
        result.fields = result.fields.concat(makeFvarInstance(j, fvar.instances[j], fvar.axes, names));
    }

    return result;
}

function parseFvarTable(data, start, names) {
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseULong();
    check.argument(tableVersion === 0x00010000, 'Unsupported fvar table version.');
    var offsetToData = p.parseOffset16();
    // Skip countSizePairs.
    p.skip('uShort', 1);
    var axisCount = p.parseUShort();
    var axisSize = p.parseUShort();
    var instanceCount = p.parseUShort();
    var instanceSize = p.parseUShort();

    var axes = [];
    for (var i = 0; i < axisCount; i++) {
        axes.push(parseFvarAxis(data, start + offsetToData + i * axisSize, names));
    }

    var instances = [];
    var instanceStart = start + offsetToData + axisCount * axisSize;
    for (var j = 0; j < instanceCount; j++) {
        instances.push(parseFvarInstance(data, instanceStart + j * instanceSize, axes, names));
    }

    return {axes: axes, instances: instances};
}

var fvar = { make: makeFvarTable, parse: parseFvarTable };

// The `GPOS` table contains kerning pairs, among other things.
// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos

var subtableParsers$1 = new Array(10);         // subtableParsers[0] is unused

// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-1-single-adjustment-positioning-subtable
// this = Parser instance
subtableParsers$1[1] = function parseLookup1() {
    var start = this.offset + this.relativeOffset;
    var posformat = this.parseUShort();
    if (posformat === 1) {
        return {
            posFormat: 1,
            coverage: this.parsePointer(Parser.coverage),
            value: this.parseValueRecord()
        };
    } else if (posformat === 2) {
        return {
            posFormat: 2,
            coverage: this.parsePointer(Parser.coverage),
            values: this.parseValueRecordList()
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 1 format must be 1 or 2.');
};

// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos#lookup-type-2-pair-adjustment-positioning-subtable
subtableParsers$1[2] = function parseLookup2() {
    var start = this.offset + this.relativeOffset;
    var posFormat = this.parseUShort();
    var coverage = this.parsePointer(Parser.coverage);
    var valueFormat1 = this.parseUShort();
    var valueFormat2 = this.parseUShort();
    if (posFormat === 1) {
        // Adjustments for Glyph Pairs
        return {
            posFormat: posFormat,
            coverage: coverage,
            valueFormat1: valueFormat1,
            valueFormat2: valueFormat2,
            pairSets: this.parseList(Parser.pointer(Parser.list(function() {
                return {        // pairValueRecord
                    secondGlyph: this.parseUShort(),
                    value1: this.parseValueRecord(valueFormat1),
                    value2: this.parseValueRecord(valueFormat2)
                };
            })))
        };
    } else if (posFormat === 2) {
        var classDef1 = this.parsePointer(Parser.classDef);
        var classDef2 = this.parsePointer(Parser.classDef);
        var class1Count = this.parseUShort();
        var class2Count = this.parseUShort();
        return {
            // Class Pair Adjustment
            posFormat: posFormat,
            coverage: coverage,
            valueFormat1: valueFormat1,
            valueFormat2: valueFormat2,
            classDef1: classDef1,
            classDef2: classDef2,
            class1Count: class1Count,
            class2Count: class2Count,
            classRecords: this.parseList(class1Count, Parser.list(class2Count, function() {
                return {
                    value1: this.parseValueRecord(valueFormat1),
                    value2: this.parseValueRecord(valueFormat2)
                };
            }))
        };
    }
    check.assert(false, '0x' + start.toString(16) + ': GPOS lookup type 2 format must be 1 or 2.');
};

subtableParsers$1[3] = function parseLookup3() { return { error: 'GPOS Lookup 3 not supported' }; };
subtableParsers$1[4] = function parseLookup4() { return { error: 'GPOS Lookup 4 not supported' }; };
subtableParsers$1[5] = function parseLookup5() { return { error: 'GPOS Lookup 5 not supported' }; };
subtableParsers$1[6] = function parseLookup6() { return { error: 'GPOS Lookup 6 not supported' }; };
subtableParsers$1[7] = function parseLookup7() { return { error: 'GPOS Lookup 7 not supported' }; };
subtableParsers$1[8] = function parseLookup8() { return { error: 'GPOS Lookup 8 not supported' }; };
subtableParsers$1[9] = function parseLookup9() { return { error: 'GPOS Lookup 9 not supported' }; };

// https://docs.microsoft.com/en-us/typography/opentype/spec/gpos
function parseGposTable(data, start) {
    start = start || 0;
    var p = new Parser(data, start);
    var tableVersion = p.parseVersion(1);
    check.argument(tableVersion === 1 || tableVersion === 1.1, 'Unsupported GPOS table version ' + tableVersion);

    if (tableVersion === 1) {
        return {
            version: tableVersion,
            scripts: p.parseScriptList(),
            features: p.parseFeatureList(),
            lookups: p.parseLookupList(subtableParsers$1)
        };
    } else {
        return {
            version: tableVersion,
            scripts: p.parseScriptList(),
            features: p.parseFeatureList(),
            lookups: p.parseLookupList(subtableParsers$1),
            variations: p.parseFeatureVariationsList()
        };
    }

}

// GPOS Writing //////////////////////////////////////////////
// NOT SUPPORTED
var subtableMakers$1 = new Array(10);

function makeGposTable(gpos) {
    return new table.Table('GPOS', [
        {name: 'version', type: 'ULONG', value: 0x10000},
        {name: 'scripts', type: 'TABLE', value: new table.ScriptList(gpos.scripts)},
        {name: 'features', type: 'TABLE', value: new table.FeatureList(gpos.features)},
        {name: 'lookups', type: 'TABLE', value: new table.LookupList(gpos.lookups, subtableMakers$1)}
    ]);
}

var gpos = { parse: parseGposTable, make: makeGposTable };

// The `kern` table contains kerning pairs.
// Note that some fonts use the GPOS OpenType layout table to specify kerning.
// https://www.microsoft.com/typography/OTSPEC/kern.htm

function parseWindowsKernTable(p) {
    var pairs = {};
    // Skip nTables.
    p.skip('uShort');
    var subtableVersion = p.parseUShort();
    check.argument(subtableVersion === 0, 'Unsupported kern sub-table version.');
    // Skip subtableLength, subtableCoverage
    p.skip('uShort', 2);
    var nPairs = p.parseUShort();
    // Skip searchRange, entrySelector, rangeShift.
    p.skip('uShort', 3);
    for (var i = 0; i < nPairs; i += 1) {
        var leftIndex = p.parseUShort();
        var rightIndex = p.parseUShort();
        var value = p.parseShort();
        pairs[leftIndex + ',' + rightIndex] = value;
    }
    return pairs;
}

function parseMacKernTable(p) {
    var pairs = {};
    // The Mac kern table stores the version as a fixed (32 bits) but we only loaded the first 16 bits.
    // Skip the rest.
    p.skip('uShort');
    var nTables = p.parseULong();
    //check.argument(nTables === 1, 'Only 1 subtable is supported (got ' + nTables + ').');
    if (nTables > 1) {
        console.warn('Only the first kern subtable is supported.');
    }
    p.skip('uLong');
    var coverage = p.parseUShort();
    var subtableVersion = coverage & 0xFF;
    p.skip('uShort');
    if (subtableVersion === 0) {
        var nPairs = p.parseUShort();
        // Skip searchRange, entrySelector, rangeShift.
        p.skip('uShort', 3);
        for (var i = 0; i < nPairs; i += 1) {
            var leftIndex = p.parseUShort();
            var rightIndex = p.parseUShort();
            var value = p.parseShort();
            pairs[leftIndex + ',' + rightIndex] = value;
        }
    }
    return pairs;
}

// Parse the `kern` table which contains kerning pairs.
function parseKernTable(data, start) {
    var p = new parse.Parser(data, start);
    var tableVersion = p.parseUShort();
    if (tableVersion === 0) {
        return parseWindowsKernTable(p);
    } else if (tableVersion === 1) {
        return parseMacKernTable(p);
    } else {
        throw new Error('Unsupported kern table version (' + tableVersion + ').');
    }
}

var kern = { parse: parseKernTable };

// The `loca` table stores the offsets to the locations of the glyphs in the font.
// https://www.microsoft.com/typography/OTSPEC/loca.htm

// Parse the `loca` table. This table stores the offsets to the locations of the glyphs in the font,
// relative to the beginning of the glyphData table.
// The number of glyphs stored in the `loca` table is specified in the `maxp` table (under numGlyphs)
// The loca table has two versions: a short version where offsets are stored as uShorts, and a long
// version where offsets are stored as uLongs. The `head` table specifies which version to use
// (under indexToLocFormat).
function parseLocaTable(data, start, numGlyphs, shortVersion) {
    var p = new parse.Parser(data, start);
    var parseFn = shortVersion ? p.parseUShort : p.parseULong;
    // There is an extra entry after the last index element to compute the length of the last glyph.
    // That's why we use numGlyphs + 1.
    var glyphOffsets = [];
    for (var i = 0; i < numGlyphs + 1; i += 1) {
        var glyphOffset = parseFn.call(p);
        if (shortVersion) {
            // The short table version stores the actual offset divided by 2.
            glyphOffset *= 2;
        }

        glyphOffsets.push(glyphOffset);
    }

    return glyphOffsets;
}

var loca = { parse: parseLocaTable };

// opentype.js
// https://github.com/nodebox/opentype.js
// (c) 2015 Frederik De Bleser
// opentype.js may be freely distributed under the MIT license.

/* global DataView, Uint8Array, XMLHttpRequest  */

/**
 * The opentype library.
 * @namespace opentype
 */

// File loaders /////////////////////////////////////////////////////////
/**
 * Loads a font from a file. The callback throws an error message as the first parameter if it fails
 * and the font as an ArrayBuffer in the second parameter if it succeeds.
 * @param  {string} path - The path of the file
 * @param  {Function} callback - The function to call when the font load completes
 */
function loadFromFile(path, callback) {
    var fs = require('fs');
    fs.readFile(path, function(err, buffer) {
        if (err) {
            return callback(err.message);
        }

        callback(null, nodeBufferToArrayBuffer(buffer));
    });
}
/**
 * Loads a font from a URL. The callback throws an error message as the first parameter if it fails
 * and the font as an ArrayBuffer in the second parameter if it succeeds.
 * @param  {string} url - The URL of the font file.
 * @param  {Function} callback - The function to call when the font load completes
 */
function loadFromUrl(url, callback) {
    var request = new XMLHttpRequest();
    request.open('get', url, true);
    request.responseType = 'arraybuffer';
    request.onload = function() {
        if (request.response) {
            return callback(null, request.response);
        } else {
            return callback('Font could not be loaded: ' + request.statusText);
        }
    };

    request.onerror = function () {
        callback('Font could not be loaded');
    };

    request.send();
}

// Table Directory Entries //////////////////////////////////////////////
/**
 * Parses OpenType table entries.
 * @param  {DataView}
 * @param  {Number}
 * @return {Object[]}
 */
function parseOpenTypeTableEntries(data, numTables) {
    var tableEntries = [];
    var p = 12;
    for (var i = 0; i < numTables; i += 1) {
        var tag = parse.getTag(data, p);
        var checksum = parse.getULong(data, p + 4);
        var offset = parse.getULong(data, p + 8);
        var length = parse.getULong(data, p + 12);
        tableEntries.push({tag: tag, checksum: checksum, offset: offset, length: length, compression: false});
        p += 16;
    }

    return tableEntries;
}

/**
 * Parses WOFF table entries.
 * @param  {DataView}
 * @param  {Number}
 * @return {Object[]}
 */
function parseWOFFTableEntries(data, numTables) {
    var tableEntries = [];
    var p = 44; // offset to the first table directory entry.
    for (var i = 0; i < numTables; i += 1) {
        var tag = parse.getTag(data, p);
        var offset = parse.getULong(data, p + 4);
        var compLength = parse.getULong(data, p + 8);
        var origLength = parse.getULong(data, p + 12);
        var compression = (void 0);
        if (compLength < origLength) {
            compression = 'WOFF';
        } else {
            compression = false;
        }

        tableEntries.push({tag: tag, offset: offset, compression: compression,
            compressedLength: compLength, length: origLength});
        p += 20;
    }

    return tableEntries;
}

/**
 * @typedef TableData
 * @type Object
 * @property {DataView} data - The DataView
 * @property {number} offset - The data offset.
 */

/**
 * @param  {DataView}
 * @param  {Object}
 * @return {TableData}
 */
function uncompressTable(data, tableEntry) {
    if (tableEntry.compression === 'WOFF') {
        var inBuffer = new Uint8Array(data.buffer, tableEntry.offset + 2, tableEntry.compressedLength - 2);
        var outBuffer = new Uint8Array(tableEntry.length);
        tinyInflate(inBuffer, outBuffer);
        if (outBuffer.byteLength !== tableEntry.length) {
            throw new Error('Decompression error: ' + tableEntry.tag + ' decompressed length doesn\'t match recorded length');
        }

        var view = new DataView(outBuffer.buffer, 0);
        return {data: view, offset: 0};
    } else {
        return {data: data, offset: tableEntry.offset};
    }
}

// Public API ///////////////////////////////////////////////////////////

/**
 * Parse the OpenType file data (as an ArrayBuffer) and return a Font object.
 * Throws an error if the font could not be parsed.
 * @param  {ArrayBuffer}
 * @return {opentype.Font}
 */
function parseBuffer(buffer) {
    var indexToLocFormat;
    var ltagTable;

    // Since the constructor can also be called to create new fonts from scratch, we indicate this
    // should be an empty font that we'll fill with our own data.
    var font = new Font({empty: true});

    // OpenType fonts use big endian byte ordering.
    // We can't rely on typed array view types, because they operate with the endianness of the host computer.
    // Instead we use DataViews where we can specify endianness.
    var data = new DataView(buffer, 0);
    var numTables;
    var tableEntries = [];
    var signature = parse.getTag(data, 0);
    if (signature === String.fromCharCode(0, 1, 0, 0) || signature === 'true' || signature === 'typ1') {
        font.outlinesFormat = 'truetype';
        numTables = parse.getUShort(data, 4);
        tableEntries = parseOpenTypeTableEntries(data, numTables);
    } else if (signature === 'OTTO') {
        font.outlinesFormat = 'cff';
        numTables = parse.getUShort(data, 4);
        tableEntries = parseOpenTypeTableEntries(data, numTables);
    } else if (signature === 'wOFF') {
        var flavor = parse.getTag(data, 4);
        if (flavor === String.fromCharCode(0, 1, 0, 0)) {
            font.outlinesFormat = 'truetype';
        } else if (flavor === 'OTTO') {
            font.outlinesFormat = 'cff';
        } else {
            throw new Error('Unsupported OpenType flavor ' + signature);
        }

        numTables = parse.getUShort(data, 12);
        tableEntries = parseWOFFTableEntries(data, numTables);
    } else {
        throw new Error('Unsupported OpenType signature ' + signature);
    }

    var cffTableEntry;
    var fvarTableEntry;
    var glyfTableEntry;
    var gposTableEntry;
    var gsubTableEntry;
    var hmtxTableEntry;
    var kernTableEntry;
    var locaTableEntry;
    var nameTableEntry;
    var metaTableEntry;
    var p;

    for (var i = 0; i < numTables; i += 1) {
        var tableEntry = tableEntries[i];
        var table = (void 0);
        switch (tableEntry.tag) {
            case 'cmap':
                table = uncompressTable(data, tableEntry);
                font.tables.cmap = cmap.parse(table.data, table.offset);
                font.encoding = new CmapEncoding(font.tables.cmap);
                break;
            case 'cvt ' :
                table = uncompressTable(data, tableEntry);
                p = new parse.Parser(table.data, table.offset);
                font.tables.cvt = p.parseShortList(tableEntry.length / 2);
                break;
            case 'fvar':
                fvarTableEntry = tableEntry;
                break;
            case 'fpgm' :
                table = uncompressTable(data, tableEntry);
                p = new parse.Parser(table.data, table.offset);
                font.tables.fpgm = p.parseByteList(tableEntry.length);
                break;
            case 'head':
                table = uncompressTable(data, tableEntry);
                font.tables.head = head.parse(table.data, table.offset);
                font.unitsPerEm = font.tables.head.unitsPerEm;
                indexToLocFormat = font.tables.head.indexToLocFormat;
                break;
            case 'hhea':
                table = uncompressTable(data, tableEntry);
                font.tables.hhea = hhea.parse(table.data, table.offset);
                font.ascender = font.tables.hhea.ascender;
                font.descender = font.tables.hhea.descender;
                font.numberOfHMetrics = font.tables.hhea.numberOfHMetrics;
                break;
            case 'hmtx':
                hmtxTableEntry = tableEntry;
                break;
            case 'ltag':
                table = uncompressTable(data, tableEntry);
                ltagTable = ltag.parse(table.data, table.offset);
                break;
            case 'maxp':
                table = uncompressTable(data, tableEntry);
                font.tables.maxp = maxp.parse(table.data, table.offset);
                font.numGlyphs = font.tables.maxp.numGlyphs;
                break;
            case 'name':
                nameTableEntry = tableEntry;
                break;
            case 'OS/2':
                table = uncompressTable(data, tableEntry);
                font.tables.os2 = os2.parse(table.data, table.offset);
                break;
            case 'post':
                table = uncompressTable(data, tableEntry);
                font.tables.post = post.parse(table.data, table.offset);
                font.glyphNames = new GlyphNames(font.tables.post);
                break;
            case 'prep' :
                table = uncompressTable(data, tableEntry);
                p = new parse.Parser(table.data, table.offset);
                font.tables.prep = p.parseByteList(tableEntry.length);
                break;
            case 'glyf':
                glyfTableEntry = tableEntry;
                break;
            case 'loca':
                locaTableEntry = tableEntry;
                break;
            case 'CFF ':
                cffTableEntry = tableEntry;
                break;
            case 'kern':
                kernTableEntry = tableEntry;
                break;
            case 'GPOS':
                gposTableEntry = tableEntry;
                break;
            case 'GSUB':
                gsubTableEntry = tableEntry;
                break;
            case 'meta':
                metaTableEntry = tableEntry;
                break;
        }
    }

    var nameTable = uncompressTable(data, nameTableEntry);
    font.tables.name = _name.parse(nameTable.data, nameTable.offset, ltagTable);
    font.names = font.tables.name;

    if (glyfTableEntry && locaTableEntry) {
        var shortVersion = indexToLocFormat === 0;
        var locaTable = uncompressTable(data, locaTableEntry);
        var locaOffsets = loca.parse(locaTable.data, locaTable.offset, font.numGlyphs, shortVersion);
        var glyfTable = uncompressTable(data, glyfTableEntry);
        font.glyphs = glyf.parse(glyfTable.data, glyfTable.offset, locaOffsets, font);
    } else if (cffTableEntry) {
        var cffTable = uncompressTable(data, cffTableEntry);
        cff.parse(cffTable.data, cffTable.offset, font);
    } else {
        throw new Error('Font doesn\'t contain TrueType or CFF outlines.');
    }

    var hmtxTable = uncompressTable(data, hmtxTableEntry);
    hmtx.parse(hmtxTable.data, hmtxTable.offset, font.numberOfHMetrics, font.numGlyphs, font.glyphs);
    addGlyphNames(font);

    if (kernTableEntry) {
        var kernTable = uncompressTable(data, kernTableEntry);
        font.kerningPairs = kern.parse(kernTable.data, kernTable.offset);
    } else {
        font.kerningPairs = {};
    }

    if (gposTableEntry) {
        var gposTable = uncompressTable(data, gposTableEntry);
        font.tables.gpos = gpos.parse(gposTable.data, gposTable.offset);
    }

    if (gsubTableEntry) {
        var gsubTable = uncompressTable(data, gsubTableEntry);
        font.tables.gsub = gsub.parse(gsubTable.data, gsubTable.offset);
    }

    if (fvarTableEntry) {
        var fvarTable = uncompressTable(data, fvarTableEntry);
        font.tables.fvar = fvar.parse(fvarTable.data, fvarTable.offset, font.names);
    }

    if (metaTableEntry) {
        var metaTable = uncompressTable(data, metaTableEntry);
        font.tables.meta = meta.parse(metaTable.data, metaTable.offset);
        font.metas = font.tables.meta;
    }

    return font;
}

/**
 * Asynchronously load the font from a URL or a filesystem. When done, call the callback
 * with two arguments `(err, font)`. The `err` will be null on success,
 * the `font` is a Font object.
 * We use the node.js callback convention so that
 * opentype.js can integrate with frameworks like async.js.
 * @alias opentype.load
 * @param  {string} url - The URL of the font to load.
 * @param  {Function} callback - The callback.
 */
function load(url, callback) {
    var isNode$$1 = typeof window === 'undefined';
    var loadFn = isNode$$1 ? loadFromFile : loadFromUrl;
    loadFn(url, function(err, arrayBuffer) {
        if (err) {
            return callback(err);
        }
        var font;
        try {
            font = parseBuffer(arrayBuffer);
        } catch (e) {
            return callback(e, null);
        }
        return callback(null, font);
    });
}

/**
 * Synchronously load the font from a URL or file.
 * When done, returns the font object or throws an error.
 * @alias opentype.loadSync
 * @param  {string} url - The URL of the font to load.
 * @return {opentype.Font}
 */
function loadSync(url) {
    var fs = require('fs');
    var buffer = fs.readFileSync(url);
    return parseBuffer(nodeBufferToArrayBuffer(buffer));
}

exports.Font = Font;
exports.Glyph = Glyph;
exports.Path = Path;
exports.BoundingBox = BoundingBox;
exports._parse = parse;
exports.parse = parseBuffer;
exports.load = load;
exports.loadSync = loadSync;

Object.defineProperty(exports, '__esModule', { value: true });

})));


}).call(this,require("buffer").Buffer)

},{"buffer":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/node_modules/buffer/index.js","fs":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/node_modules/browser-resolve/empty.js"}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/glcat-path-gui.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _glcatPath = require('./glcat-path');

var _glcatPath2 = _interopRequireDefault(_glcatPath);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var requiredFields = function requiredFields(object, nanithefuck, fields) {
  fields.map(function (field) {
    if (typeof object[field] === "undefined") {
      throw "GLCat-Path: " + field + " is required for " + nanithefuck;
    }
  });
};

var PathGUI = function (_Path) {
  _inherits(PathGUI, _Path);

  function PathGUI(glCat, params) {
    _classCallCheck(this, PathGUI);

    var _this = _possibleConstructorReturn(this, (PathGUI.__proto__ || Object.getPrototypeOf(PathGUI)).call(this, glCat, params));

    var it = _this;

    requiredFields(params, "params", ["canvas", "el"]);

    it.gui = { parent: it.params.el };

    it.gui.info = document.createElement("span");
    it.gui.parent.appendChild(it.gui.info);

    it.gui.range = document.createElement("input");
    it.gui.range.type = "range";
    it.gui.range.min = 0;
    it.gui.range.max = 0;
    it.gui.range.step = 1;
    it.gui.parent.appendChild(it.gui.range);

    it.dateList = new Array(30).fill(0);
    it.dateListIndex = 0;
    it.totalFrames = 0;
    it.fps = 0;
    it.currentIndex = 0;
    it.viewName = "";
    it.viewIndex = 0;

    var gl = glCat.gl;
    var vboQuad = glCat.createVertexbuffer([-1, -1, 1, -1, -1, 1, 1, 1]);
    it.add({
      __PathGuiReturn: {
        width: it.params.canvas.width,
        height: it.params.canvas.height,
        vert: "attribute vec2 p;void main(){gl_Position=vec4(p,0,1);}",
        frag: "precision highp float;uniform vec2 r;uniform sampler2D s;void main(){gl_FragColor=texture2D(s,gl_FragCoord.xy/r);}",
        blend: [gl.ONE, gl.ONE],
        clear: [0.0, 0.0, 0.0, 1.0],
        func: function func(_p, params) {
          gl.viewport(0, 0, it.params.canvas.width, it.params.canvas.height);
          glCat.uniform2fv('r', [it.params.canvas.width, it.params.canvas.height]);

          glCat.attribute('p', vboQuad, 2);
          glCat.uniformTexture('s', params.input, 0);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
      }
    });
    return _this;
  }

  _createClass(PathGUI, [{
    key: 'begin',
    value: function begin() {
      var it = this;

      it.currentIndex = 0;
    }
  }, {
    key: 'end',
    value: function end() {
      var it = this;

      it.gui.range.max = Math.max(it.gui.range.max, it.currentIndex);
      it.currentIndex = 0;

      var now = +new Date() * 1E-3;
      it.dateList[it.dateListIndex] = now;
      it.dateListIndex = (it.dateListIndex + 1) % it.dateList.length;
      it.fps = ((it.dateList.length - 1) / (now - it.dateList[it.dateListIndex])).toFixed(1);

      it.totalFrames++;

      it.gui.info.innerText = "Path: " + it.viewName + " (" + it.viewIndex + ")\n" + it.fps + " FPS\n" + it.totalFrames + " frames\n";
    }
  }, {
    key: 'render',
    value: function render(name, params) {
      var it = this;

      it.currentIndex++;
      var view = parseInt(it.gui.range.value);

      if (it.currentIndex <= view || view === 0) {
        it.viewName = view === 0 ? "*Full*" : name;
        it.viewIndex = it.currentIndex;

        _get(PathGUI.prototype.__proto__ || Object.getPrototypeOf(PathGUI.prototype), 'render', this).call(this, name, params);

        if (it.currentIndex === view) {
          var t = params && params.target ? params.target : it.paths[name].framebuffer;

          if (t && t.framebuffer) {
            var i = t.textures ? t.textures[0] : t.texture;
            if (it.params.stretch) {
              _get(PathGUI.prototype.__proto__ || Object.getPrototypeOf(PathGUI.prototype), 'render', this).call(this, "__PathGuiReturn", {
                target: PathGUI.nullFb,
                input: i,
                width: it.params.canvas.width,
                height: it.params.canvas.height
              });
            } else {
              it.params.canvas.width = (params ? params.width : 0) || it.paths[name].width || it.params.width;
              it.params.canvas.height = (params ? params.height : 0) || it.paths[name].height || it.params.height;
              _get(PathGUI.prototype.__proto__ || Object.getPrototypeOf(PathGUI.prototype), 'render', this).call(this, "__PathGuiReturn", {
                target: PathGUI.nullFb,
                input: i
              });
            }
          }
        }
      }
    }
  }]);

  return PathGUI;
}(_glcatPath2.default);

exports.default = PathGUI;

},{"./glcat-path":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/glcat-path.js"}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/glcat-path.js":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }



var requiredFields = function requiredFields(object, nanithefuck, fields) {
  fields.map(function (field) {
    if (typeof object[field] === "undefined") {
      throw "GLCat-Path: " + field + " is required for " + nanithefuck;
    }
  });
};

var Path = function () {
  function Path(glCat, params) {
    _classCallCheck(this, Path);

    var it = this;

    it.glCat = glCat;
    it.gl = glCat.gl;

    it.paths = {};
    it.globalFunc = function () {};
    it.params = params || {};
  }

  _createClass(Path, [{
    key: "add",
    value: function add(paths) {
      var it = this;

      for (var name in paths) {
        var path = paths[name];
        requiredFields(path, "path object", ["vert", "frag"]);
        it.paths[name] = path;

        if (typeof path.depthTest === "undefined") {
          path.depthTest = true;
        }
        if (typeof path.depthWrite === "undefined") {
          path.depthWrite = true;
        }
        if (typeof path.blend === "undefined") {
          path.blend = [it.gl.SRC_ALPHA, it.gl.ONE_MINUS_SRC_ALPHA];
        }
        if (typeof path.cull === "undefined") {
          path.cull = true;
        }

        if (path.framebuffer) {
          if (path.drawbuffers) {
            path.framebuffer = it.glCat.createDrawBuffers(path.width, path.height, path.drawbuffers);
          } else if (path.float) {
            path.framebuffer = it.glCat.createFloatFramebuffer(path.width, path.height);
          } else {
            path.framebuffer = it.glCat.createFramebuffer(path.width, path.height);
          }
        }

        path.program = it.glCat.createProgram(path.vert, path.frag);
      }
    }
  }, {
    key: "render",
    value: function render(name, params) {
      var _it$gl;

      var it = this;

      var path = it.paths[name];
      if (!path) {
        throw "GLCat-Path: The path called " + name + " is not defined!";
      }

      if (!params) {
        params = {};
      }
      params.framebuffer = typeof params.target !== "undefined" ? params.target.framebuffer : path.framebuffer ? path.framebuffer.framebuffer : null;

      var width = params.width || path.width;
      var height = params.height || path.height;

      if (!width || !height) {
        throw 'GLCat-Path: width or height is invalid';
      }

      it.gl.viewport(0, 0, width, height);
      it.glCat.useProgram(path.program);
      path.cull ? it.gl.enable(it.gl.CULL_FACE) : it.gl.disable(it.gl.CULL_FACE);
      it.gl.bindFramebuffer(it.gl.FRAMEBUFFER, params.framebuffer);
      if (it.params.drawbuffers) {
        it.glCat.drawBuffers(path.drawbuffers ? path.drawbuffers : params.framebuffer === null ? [it.gl.BACK] : [it.gl.COLOR_ATTACHMENT0]);
      }
      (_it$gl = it.gl).blendFunc.apply(_it$gl, _toConsumableArray(path.blend));
      if (path.clear) {
        var _it$glCat;

        (_it$glCat = it.glCat).clear.apply(_it$glCat, _toConsumableArray(path.clear));
      }
      path.depthTest ? it.gl.enable(it.gl.DEPTH_TEST) : it.gl.disable(it.gl.DEPTH_TEST);
      path.depthWrite ? it.gl.depthMask(true) : it.gl.depthMask(false);

      it.glCat.uniform2fv('resolution', [width, height]);
      it.globalFunc(path, params);

      if (path.func) {
        path.func(path, params);
      }
    }
  }, {
    key: "resize",
    value: function resize(name, width, height) {
      var it = this;

      var path = it.paths[name];

      path.width = width;
      path.height = height;

      if (path.framebuffer) {
        if (it.params.drawbuffers && path.drawbuffers) {
          path.framebuffer = it.glCat.createDrawBuffers(path.width, path.height, path.drawbuffers);
        } else if (path.float) {
          it.glCat.resizeFloatFramebuffer(path.framebuffer, path.width, path.height);
        } else {
          it.glCat.resizeFramebuffer(path.framebuffer, path.width, path.height);
        }
      }

      if (typeof path.onresize === "function") {
        path.onresize(path, width, height);
      }
    }
  }, {
    key: "setGlobalFunc",
    value: function setGlobalFunc(func) {
      this.globalFunc = func;
    }
  }, {
    key: "fb",
    value: function fb(name) {
      if (!this.paths[name]) {
        throw "glcat-path.fb: path called " + name + " is not defined";
      }
      if (!this.paths[name].framebuffer) {
        throw "glcat-path.fb: there is no framebuffer for the path " + name;
      }

      return this.paths[name].framebuffer;
    }
  }]);

  return Path;
}();

Path.nullFb = { framebuffer: null };

exports.default = Path;

},{}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/glcat.js":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var GLCat = function () {
	function GLCat(_gl) {
		_classCallCheck(this, GLCat);

		var it = this;

		it.gl = _gl;
		var gl = it.gl;

		gl.enable(gl.DEPTH_TEST);
		gl.depthFunc(gl.LEQUAL);
		gl.enable(gl.BLEND);
		gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

		it.extensions = {};

		it.currentProgram = null;
	}

	_createClass(GLCat, [{
		key: "getExtension",
		value: function getExtension(_name, _throw) {
			var it = this;
			var gl = it.gl;

			if ((typeof _name === "undefined" ? "undefined" : _typeof(_name)) === "object" && _name.isArray()) {
				return _name.every(function (name) {
					return it.getExtension(name, _throw);
				});
			} else if (typeof _name === "string") {
				if (it.extensions[_name]) {
					return it.extensions[_name];
				} else {
					it.extensions[_name] = gl.getExtension(_name);
					if (it.extensions[_name]) {
						return it.extensions[_name];
					} else {
						if (_throw) {
							throw console.error("The extension \"" + _name + "\" is not supported");
						}
						return false;
					}
				}
				return !!it.extensions[_name];
			} else {
				throw "GLCat.getExtension: _name must be string or array";
			}
		}
	}, {
		key: "createProgram",
		value: function createProgram(_vert, _frag, _onError) {
			var it = this;
			var gl = it.gl;

			var error = void 0;
			if (typeof _onError === 'function') {
				error = _onError;
			} else {
				error = function error(_str) {
					console.error(_str);
				};
			}

			var vert = gl.createShader(gl.VERTEX_SHADER);
			gl.shaderSource(vert, _vert);
			gl.compileShader(vert);
			if (!gl.getShaderParameter(vert, gl.COMPILE_STATUS)) {
				error(gl.getShaderInfoLog(vert));
				return null;
			}

			var frag = gl.createShader(gl.FRAGMENT_SHADER);
			gl.shaderSource(frag, _frag);
			gl.compileShader(frag);
			if (!gl.getShaderParameter(frag, gl.COMPILE_STATUS)) {
				error(gl.getShaderInfoLog(frag));
				return null;
			}

			var program = gl.createProgram();
			gl.attachShader(program, vert);
			gl.attachShader(program, frag);
			gl.linkProgram(program);
			if (gl.getProgramParameter(program, gl.LINK_STATUS)) {
				program.locations = {};
				return program;
			} else {
				error(gl.getProgramInfoLog(program));
				return null;
			}
		}
	}, {
		key: "useProgram",
		value: function useProgram(_program) {
			var it = this;
			var gl = it.gl;

			gl.useProgram(_program);
			it.currentProgram = _program;
		}
	}, {
		key: "createVertexbuffer",
		value: function createVertexbuffer(_array) {
			var it = this;
			var gl = it.gl;

			var buffer = gl.createBuffer();

			if (_array) {
				it.setVertexbuffer(buffer, _array);
			}

			return buffer;
		}
	}, {
		key: "setVertexbuffer",
		value: function setVertexbuffer(_buffer, _array, _mode) {
			var it = this;
			var gl = it.gl;

			var mode = _mode || gl.STATIC_DRAW;

			gl.bindBuffer(gl.ARRAY_BUFFER, _buffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(_array), mode);
			gl.bindBuffer(gl.ARRAY_BUFFER, null);

			_buffer.length = _array.length;
		}
	}, {
		key: "createIndexbuffer",
		value: function createIndexbuffer(_array) {
			var it = this;
			var gl = it.gl;

			var buffer = gl.createBuffer();

			if (_array) {
				it.setIndexbuffer(buffer, _array);
			}

			return buffer;
		}
	}, {
		key: "setIndexbuffer",
		value: function setIndexbuffer(_buffer, _array, _mode) {
			var it = this;
			var gl = it.gl;

			var mode = _mode || gl.STATIC_DRAW;

			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _buffer);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Int16Array(_array), mode);
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

			_buffer.length = _array.length;
		}
	}, {
		key: "getAttribLocation",
		value: function getAttribLocation(_name) {
			var it = this;
			var gl = it.gl;

			var location = void 0;
			if (it.currentProgram.locations[_name]) {
				location = it.currentProgram.locations[_name];
			} else {
				location = gl.getAttribLocation(it.currentProgram, _name);
				it.currentProgram.locations[_name] = location;
			}

			return location;
		}
	}, {
		key: "attribute",
		value: function attribute(_name, _buffer, _stride, _div) {
			var it = this;
			var gl = it.gl;

			if (_div) {
				it.getExtension("ANGLE_instanced_arrays", true);
			}

			var location = it.getAttribLocation(_name);

			gl.bindBuffer(gl.ARRAY_BUFFER, _buffer);
			gl.enableVertexAttribArray(location);
			gl.vertexAttribPointer(location, _stride, gl.FLOAT, false, 0, 0);

			var ext = it.getExtension("ANGLE_instanced_arrays");
			if (ext) {
				var div = _div || 0;
				ext.vertexAttribDivisorANGLE(location, div);
			}

			gl.bindBuffer(gl.ARRAY_BUFFER, null);
		}
	}, {
		key: "getUniformLocation",
		value: function getUniformLocation(_name) {
			var it = this;
			var gl = it.gl;

			var location = void 0;

			if (typeof it.currentProgram.locations[_name] !== "undefined") {
				location = it.currentProgram.locations[_name];
			} else {
				location = gl.getUniformLocation(it.currentProgram, _name);
				it.currentProgram.locations[_name] = location;
			}

			return location;
		}
	}, {
		key: "uniform1i",
		value: function uniform1i(_name, _value) {
			var it = this;
			var gl = it.gl;

			var location = it.getUniformLocation(_name);
			gl.uniform1i(location, _value);
		}
	}, {
		key: "uniform1f",
		value: function uniform1f(_name, _value) {
			var it = this;
			var gl = it.gl;

			var location = it.getUniformLocation(_name);
			gl.uniform1f(location, _value);
		}
	}, {
		key: "uniform2fv",
		value: function uniform2fv(_name, _value) {
			var it = this;
			var gl = it.gl;

			var location = it.getUniformLocation(_name);
			gl.uniform2fv(location, _value);
		}
	}, {
		key: "uniform3fv",
		value: function uniform3fv(_name, _value) {
			var it = this;
			var gl = it.gl;

			var location = it.getUniformLocation(_name);
			gl.uniform3fv(location, _value);
		}
	}, {
		key: "uniform4fv",
		value: function uniform4fv(_name, _value) {
			var it = this;
			var gl = it.gl;

			var location = it.getUniformLocation(_name);
			gl.uniform4fv(location, _value);
		}
	}, {
		key: "uniformMatrix4fv",
		value: function uniformMatrix4fv(_name, _value, _transpose) {
			var it = this;
			var gl = it.gl;

			var location = it.getUniformLocation(_name);
			gl.uniformMatrix4fv(location, _transpose || false, _value);
		}
	}, {
		key: "uniformCubemap",
		value: function uniformCubemap(_name, _texture, _number) {
			var it = this;
			var gl = it.gl;

			var location = it.getUniformLocation(_name);
			gl.activeTexture(gl.TEXTURE0 + _number);
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, _texture);
			gl.uniform1i(location, _number);
		}
	}, {
		key: "uniformTexture",
		value: function uniformTexture(_name, _texture, _number) {
			var it = this;
			var gl = it.gl;

			var location = it.getUniformLocation(_name);
			gl.activeTexture(gl.TEXTURE0 + _number);
			gl.bindTexture(gl.TEXTURE_2D, _texture);
			gl.uniform1i(location, _number);
		}
	}, {
		key: "createTexture",
		value: function createTexture() {
			var it = this;
			var gl = it.gl;

			var texture = gl.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.bindTexture(gl.TEXTURE_2D, null);

			return texture;
		}
	}, {
		key: "textureFilter",
		value: function textureFilter(_texture, _filter) {
			var it = this;
			var gl = it.gl;

			gl.bindTexture(gl.TEXTURE_2D, _texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, _filter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, _filter);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: "textureWrap",
		value: function textureWrap(_texture, _wrap) {
			var it = this;
			var gl = it.gl;

			gl.bindTexture(gl.TEXTURE_2D, _texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, _wrap);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, _wrap);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: "setTexture",
		value: function setTexture(_texture, _image) {
			var it = this;
			var gl = it.gl;

			gl.bindTexture(gl.TEXTURE_2D, _texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, _image);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: "setTextureFromArray",
		value: function setTextureFromArray(_texture, _width, _height, _array) {
			var it = this;
			var gl = it.gl;

			gl.bindTexture(gl.TEXTURE_2D, _texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(_array));
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: "setTextureFromFloatArray",
		value: function setTextureFromFloatArray(_texture, _width, _height, _array) {
			var it = this;
			var gl = it.gl;

			it.getExtension("OES_texture_float", true);

			gl.bindTexture(gl.TEXTURE_2D, _texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, new Float32Array(_array));
			if (!it.getExtension("OES_texture_float_linear")) {
				it.textureFilter(_texture, gl.NEAREST);
			}
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: "copyTexture",
		value: function copyTexture(_texture, _width, _height) {
			var it = this;
			var gl = it.gl;

			gl.bindTexture(gl.TEXTURE_2D, _texture);
			gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, _width, _height, 0);
			gl.bindTexture(gl.TEXTURE_2D, null);
		}
	}, {
		key: "createCubemap",
		value: function createCubemap(_arrayOfImage) {
			var it = this;
			var gl = it.gl;

			// order : X+, X-, Y+, Y-, Z+, Z-
			var texture = gl.createTexture();

			gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
			for (var i = 0; i < 6; i++) {
				gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, _arrayOfImage[i]);
			}
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);

			return texture;
		}
	}, {
		key: "createFramebuffer",
		value: function createFramebuffer(_width, _height) {
			var it = this;
			var gl = it.gl;

			var framebuffer = {};
			framebuffer.framebuffer = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer.framebuffer);

			framebuffer.depth = gl.createRenderbuffer();
			gl.bindRenderbuffer(gl.RENDERBUFFER, framebuffer.depth);
			gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, framebuffer.depth);

			framebuffer.texture = it.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, framebuffer.texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
			gl.bindTexture(gl.TEXTURE_2D, null);

			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, framebuffer.texture, 0);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			return framebuffer;
		}
	}, {
		key: "resizeFramebuffer",
		value: function resizeFramebuffer(_framebuffer, _width, _height) {
			var it = this;
			var gl = it.gl;

			gl.bindFramebuffer(gl.FRAMEBUFFER, _framebuffer.framebuffer);

			gl.bindRenderbuffer(gl.RENDERBUFFER, _framebuffer.depth);
			gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
			gl.bindRenderbuffer(gl.RENDERBUFFER, null);

			gl.bindTexture(gl.TEXTURE_2D, _framebuffer.texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
			gl.bindTexture(gl.TEXTURE_2D, null);

			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
	}, {
		key: "createFloatFramebuffer",
		value: function createFloatFramebuffer(_width, _height) {
			var it = this;
			var gl = it.gl;

			it.getExtension("OES_texture_float", true);

			var framebuffer = {};
			framebuffer.framebuffer = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer.framebuffer);

			framebuffer.depth = gl.createRenderbuffer();
			gl.bindRenderbuffer(gl.RENDERBUFFER, framebuffer.depth);
			gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, framebuffer.depth);

			framebuffer.texture = it.createTexture();
			gl.bindTexture(gl.TEXTURE_2D, framebuffer.texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, null);
			if (!it.getExtension("OES_texture_float_linear")) {
				it.textureFilter(framebuffer.texture, gl.NEAREST);
			}
			gl.bindTexture(gl.TEXTURE_2D, null);

			gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, framebuffer.texture, 0);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			return framebuffer;
		}
	}, {
		key: "resizeFloatFramebuffer",
		value: function resizeFloatFramebuffer(_framebuffer, _width, _height) {
			var it = this;
			var gl = it.gl;

			gl.bindFramebuffer(gl.FRAMEBUFFER, _framebuffer.framebuffer);

			gl.bindRenderbuffer(gl.RENDERBUFFER, _framebuffer.depth);
			gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
			gl.bindRenderbuffer(gl.RENDERBUFFER, null);

			gl.bindTexture(gl.TEXTURE_2D, _framebuffer.texture);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, null);
			gl.bindTexture(gl.TEXTURE_2D, null);

			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
	}, {
		key: "createDrawBuffers",
		value: function createDrawBuffers(_width, _height, _numDrawBuffers) {
			var it = this;
			var gl = it.gl;

			it.getExtension('OES_texture_float', true);
			var ext = it.getExtension('WEBGL_draw_buffers', true);

			if (ext.MAX_DRAW_BUFFERS_WEBGL < _numDrawBuffers) {
				throw "createDrawBuffers: MAX_DRAW_BUFFERS_WEBGL is " + ext.MAX_DRAW_BUFFERS_WEBGL;
			}

			var framebuffer = {};
			framebuffer.framebuffer = gl.createFramebuffer();
			gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer.framebuffer);

			framebuffer.depth = gl.createRenderbuffer();
			gl.bindRenderbuffer(gl.RENDERBUFFER, framebuffer.depth);
			gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
			gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, framebuffer.depth);

			framebuffer.textures = [];
			for (var i = 0; i < _numDrawBuffers; i++) {
				framebuffer.textures[i] = it.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, framebuffer.textures[i]);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, null);
				if (!it.getExtension("OES_texture_float_linear")) {
					it.textureFilter(framebuffer.textures[i], gl.NEAREST);
				}
				gl.bindTexture(gl.TEXTURE_2D, null);

				gl.framebufferTexture2D(gl.FRAMEBUFFER, ext.COLOR_ATTACHMENT0_WEBGL + i, gl.TEXTURE_2D, framebuffer.textures[i], 0);
			}

			var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
			if (status !== gl.FRAMEBUFFER_COMPLETE) {
				throw "createDrawBuffers: gl.checkFramebufferStatus( gl.FRAMEBUFFER ) returns " + status;
			}
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);

			return framebuffer;
		}
	}, {
		key: "resizeDrawBuffers",
		value: function resizeDrawBuffers(_framebuffer, _width, height) {
			var it = this;
			var gl = it.gl;

			gl.bindFramebuffer(gl.FRAMEBUFFER, _framebuffer.framebuffer);

			gl.bindRenderbuffer(gl.RENDERBUFFER, _framebuffer.depth);
			gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, _width, _height);
			gl.bindRenderbuffer(gl.RENDERBUFFER, null);

			for (var i = 0; i < _framebuffer.textures.length; i++) {
				gl.bindTexture(gl.TEXTURE_2D, _framebuffer.textures[i]);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _width, _height, 0, gl.RGBA, gl.FLOAT, null);
				gl.bindTexture(gl.TEXTURE_2D, null);
			}

			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
		}
	}, {
		key: "drawBuffers",
		value: function drawBuffers(_numDrawBuffers) {
			var it = this;
			var gl = it.gl;

			var ext = it.getExtension("WEBGL_draw_buffers", true);

			var array = [];
			if (typeof _numDrawBuffers === "number") {
				for (var i = 0; i < _numDrawBuffers; i++) {
					array.push(ext.COLOR_ATTACHMENT0_WEBGL + i);
				}
			} else {
				array = array.concat(_numDrawBuffers);
			}
			ext.drawBuffersWEBGL(array);
		}
	}, {
		key: "clear",
		value: function clear(_r, _g, _b, _a, _d) {
			var it = this;
			var gl = it.gl;

			var r = _r || 0.0;
			var g = _g || 0.0;
			var b = _b || 0.0;
			var a = typeof _a === 'number' ? _a : 1.0;
			var d = typeof _d === 'number' ? _d : 1.0;

			gl.clearColor(r, g, b, a);
			gl.clearDepth(d);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
		}
	}]);

	return GLCat;
}();

exports.default = GLCat;

},{}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/mathcat.js":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// にゃーん

var MathCat = {};

/**
 * adds a two vec
 * @param {array} a - vec
 * @param {array} b - vec
 */
MathCat.vecAdd = function (a, b) {
  return a.map(function (e, i) {
    return e + b[i];
  });
};

/**
 * substracts a vec from an another vec
 * @param {array} a - vec
 * @param {array} b - vec
 */
MathCat.vecSub = function (a, b) {
  return a.map(function (e, i) {
    return e - b[i];
  });
};

/**
 * returns a cross of two vec3s
 * @param {array} a - vec3
 * @param {array} b - vec3
 */
MathCat.vec3Cross = function (a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
};

/**
 * scales a vec by scalar
 * @param {number} s - scalar
 * @param {array} v - vec
 */
MathCat.vecScale = function (s, v) {
  return v.map(function (e) {
    return e * s;
  });
};

/**
 * returns length of a vec
 * @param {array} v - vec
 */
MathCat.vecLength = function (v) {
  return Math.sqrt(v.reduce(function (p, c) {
    return p + c * c;
  }, 0.0));
};

/**
 * normalizes a vec
 * @param {array} v - vec
 */
MathCat.vecNormalize = function (v) {
  return MathCat.vecScale(1.0 / MathCat.vecLength(v), v);
};

/**
 * applies two mat4s
 * @param {array} a - mat4
 * @param {array} b - mat4
 */
MathCat.mat4Apply = function (a, b) {
  return [a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3], a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3], a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3], a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3], a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7], a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7], a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7], a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7], a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11], a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11], a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11], a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11], a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15], a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15], a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15], a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]];
};

/**
 * transpose a mat4
 * @param {array} m - mat4
 */
MathCat.mat4Transpose = function (m) {
  return [m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]];
};

/**
 * returns an indentity mat4
 */
MathCat.mat4Identity = function () {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
};

MathCat.mat4Translate = function (v) {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, v[0], v[1], v[2], 1];
};

MathCat.mat4Scale = function (v) {
  return [v[0], 0, 0, 0, 0, v[1], 0, 0, 0, 0, v[2], 0, 0, 0, 0, 1];
};

MathCat.mat4ScaleXYZ = function (s) {
  return [s, 0, 0, 0, 0, s, 0, 0, 0, 0, s, 0, 0, 0, 0, 1];
};

MathCat.mat4RotateX = function (t) {
  return [1, 0, 0, 0, 0, Math.cos(t), -Math.sin(t), 0, 0, Math.sin(t), Math.cos(t), 0, 0, 0, 0, 1];
};

MathCat.mat4RotateY = function (t) {
  return [Math.cos(t), 0, Math.sin(t), 0, 0, 1, 0, 0, -Math.sin(t), 0, Math.cos(t), 0, 0, 0, 0, 1];
};

MathCat.mat4RotateZ = function (t) {
  return [Math.cos(t), -Math.sin(t), 0, 0, Math.sin(t), Math.cos(t), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
};

MathCat.mat4LookAt = function (pos, tar, air, rot) {
  var dir = MathCat.vecNormalize(MathCat.vecSub(tar, pos));
  var sid = MathCat.vecNormalize(MathCat.vec3Cross(dir, air));
  var top = MathCat.vec3Cross(sid, dir);
  sid = MathCat.vecAdd(MathCat.vecScale(Math.cos(rot), sid), MathCat.vecScale(Math.sin(rot), top));
  top = MathCat.vec3Cross(sid, dir);

  return [sid[0], top[0], dir[0], 0.0, sid[1], top[1], dir[1], 0.0, sid[2], top[2], dir[2], 0.0, -sid[0] * pos[0] - sid[1] * pos[1] - sid[2] * pos[2], -top[0] * pos[0] - top[1] * pos[1] - top[2] * pos[2], -dir[0] * pos[0] - dir[1] * pos[1] - dir[2] * pos[2], 1.0];
};

MathCat.mat4Perspective = function (fov, near, far) {
  var p = 1.0 / Math.tan(fov * Math.PI / 360.0);
  var d = far - near;
  return [p, 0.0, 0.0, 0.0, 0.0, p, 0.0, 0.0, 0.0, 0.0, (far + near) / d, 1.0, 0.0, 0.0, -2 * far * near / d, 0.0];
};

exports.default = MathCat;

},{}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/step.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var step = function step(_obj) {
  var obj = _obj;
  var count = -1;

  var func = function func() {
    count++;
    if (typeof obj[count] === 'function') {
      obj[count](func);
    }
  };
  func();
};

exports.default = step;

},{}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/tweak.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Tweak = function () {
  function Tweak(_el) {
    _classCallCheck(this, Tweak);

    var it = this;

    it.parent = _el;
    it.values = {};
    it.elements = {};
  }

  _createClass(Tweak, [{
    key: 'button',
    value: function button(_name, _props) {
      var it = this;

      var props = _props || {};

      if (typeof it.values[_name] === 'undefined') {
        var div = document.createElement('div');
        it.parent.appendChild(div);

        var input = document.createElement('input');
        div.appendChild(input);
        input.type = 'button';
        input.value = _name;

        input.addEventListener('click', function () {
          it.values[_name] = true;
        });

        it.elements[_name] = {
          div: div,
          input: input
        };
      }

      var tempvalue = it.values[_name];
      it.values[_name] = false;
      if (typeof props.set === 'boolean') {
        it.values[_name] = props.set;
      }

      return tempvalue;
    }
  }, {
    key: 'checkbox',
    value: function checkbox(_name, _props) {
      var it = this;

      var props = _props || {};

      var value = void 0;

      if (typeof it.values[_name] === 'undefined') {
        value = props.value || false;

        var div = document.createElement('div');
        it.parent.appendChild(div);

        var name = document.createElement('span');
        div.appendChild(name);
        name.innerText = _name;

        var input = document.createElement('input');
        div.appendChild(input);
        input.type = 'checkbox';
        input.checked = value;

        it.elements[_name] = {
          div: div,
          name: name,
          input: input
        };
      } else {
        value = it.elements[_name].input.checked;
      }

      if (typeof props.set === 'boolean') {
        value = props.set;
      }

      it.elements[_name].input.checked = value;
      it.values[_name] = value;

      return it.values[_name];
    }
  }, {
    key: 'range',
    value: function range(_name, _props) {
      var it = this;

      var props = _props || {};

      var value = void 0;

      if (typeof it.values[_name] === 'undefined') {
        var min = props.min || 0.0;
        var max = props.max || 1.0;
        var step = props.step || 0.001;
        value = props.value || min;

        var div = document.createElement('div');
        it.parent.appendChild(div);

        var name = document.createElement('span');
        div.appendChild(name);
        name.innerText = _name;

        var input = document.createElement('input');
        div.appendChild(input);
        input.type = 'range';
        input.value = value;
        input.min = min;
        input.max = max;
        input.step = step;

        var val = document.createElement('span');
        val.innerText = value.toFixed(3);
        div.appendChild(val);
        input.addEventListener('input', function (_event) {
          var value = parseFloat(input.value);
          val.innerText = value.toFixed(3);
        });

        it.elements[_name] = {
          div: div,
          name: name,
          input: input,
          val: val
        };
      } else {
        value = parseFloat(it.elements[_name].input.value);
      }

      if (typeof props.set === 'number') {
        value = props.set;
      }

      it.values[_name] = value;
      it.elements[_name].input.value = value;

      return it.values[_name];
    }
  }]);

  return Tweak;
}();

exports.default = Tweak;

},{}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/xorshift.js":[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var seed = void 0;
var xorshift = function xorshift(_seed) {
  seed = _seed || seed || 1;
  seed = seed ^ seed << 13;
  seed = seed ^ seed >>> 17;
  seed = seed ^ seed << 5;
  return seed / Math.pow(2, 32) + 0.5;
};

exports.default = xorshift;

},{}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/main.js":[function(require,module,exports){
'use strict';

var _xorshift = require('./libs/xorshift');

var _xorshift2 = _interopRequireDefault(_xorshift);

var _tweak = require('./libs/tweak');

var _tweak2 = _interopRequireDefault(_tweak);

var _glcat = require('./libs/glcat');

var _glcat2 = _interopRequireDefault(_glcat);

var _glcatPathGui = require('./libs/glcat-path-gui');

var _glcatPathGui2 = _interopRequireDefault(_glcatPathGui);

var _mathcat = require('./libs/mathcat');

var _mathcat2 = _interopRequireDefault(_mathcat);

var _step = require('./libs/step');

var _step2 = _interopRequireDefault(_step);

var _pathLofipath = require('./path-lofipath');

var _pathLofipath2 = _interopRequireDefault(_pathLofipath);

var _pathPieces = require('./path-pieces');

var _pathPieces2 = _interopRequireDefault(_pathPieces);

var _pathPostfx = require('./path-postfx');

var _pathPostfx2 = _interopRequireDefault(_pathPostfx);

var _pathConsole = require('./path-console');

var _pathConsole2 = _interopRequireDefault(_pathConsole);

var _pathGrid = require('./path-grid');

var _pathGrid2 = _interopRequireDefault(_pathGrid);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }



// ------

(0, _xorshift2.default)(326789157890);

// ------

var width = canvas.width = 480;
var height = canvas.height = 480;

var renderA = document.createElement('a');

var saveFrame = function saveFrame() {
  renderA.href = canvas.toDataURL();
  renderA.download = ('0000' + totalFrame).slice(-5) + '.png';
  renderA.click();
};

// ------

var gl = canvas.getContext('webgl');
gl.lineWidth(1);

var glCat = new _glcat2.default(gl);

glCat.getExtension('OES_texture_float', true);
glCat.getExtension('OES_texture_float_linear', true);
glCat.getExtension('EXT_frag_depth', true);
glCat.getExtension('ANGLE_instanced_arrays', true);

var glCatPath = new _glcatPathGui2.default(glCat, {
  el: divPath,
  canvas: canvas,
  stretch: true
});

// ------

var tweak = new _tweak2.default(divTweak);

// ------

var totalFrame = 0;
var init = false;

var automaton = new Automaton({
  gui: divAutomaton,
  fps: 60,
  data: '\n  {"v":"1.1.1","length":3,"resolution":1000,"params":{"cameraPosX":[{"time":0,"value":0,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":0.5,"value":0,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]},{"time":1,"value":0.3685084541062791,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]},{"time":1.625,"value":-0.32850241545893955,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]},{"time":2,"value":0.3318236714975846,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]},{"time":3,"value":0,"mode":4,"params":{"rate":2000,"damp":1},"mods":[false,false,false,false]}],"pathBegin":[{"time":0,"value":0.2,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":3,"value":0,"mode":1,"params":{},"mods":[false,false,false,false]}],"pathSegs":[{"time":0,"value":30.000000000000007,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":1.25,"value":4,"mode":4,"params":{"rate":30,"damp":1},"mods":[false,false,false,false]},{"time":3,"value":30,"mode":4,"params":{"rate":30,"damp":1},"mods":[false,false,false,false]}],"deformAmp":[{"time":0,"value":5,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":1.25,"value":5.744800003243596,"mode":4,"params":{"rate":50,"damp":1},"mods":[false,false,false,false]},{"time":2.4314868804664727,"value":0,"mode":4,"params":{"rate":91,"damp":1},"mods":[false,false,false,false]},{"time":2.685131195335277,"value":1.7939176042416891,"mode":4,"params":{"rate":500,"damp":1},"mods":[false,false,false,false]},{"time":3,"value":5,"mode":4,"params":{"rate":500,"damp":1},"mods":[false,false,false,false]}],"deformFreq":[{"time":0,"value":1,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":1.25,"value":0.15161574064757133,"mode":4,"params":{"rate":50,"damp":1},"mods":[false,false,false,false]},{"time":3,"value":1,"mode":4,"params":{"rate":500,"damp":1},"mods":[false,false,false,false]}],"deformOffset":[{"time":0,"value":0,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":3,"value":1.0014573039186314,"mode":1,"params":{},"mods":[false,false,false,false]}],"cameraPosY":[{"time":0,"value":0,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":0.75,"value":0,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]},{"time":1.25,"value":0.40126811594202927,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]},{"time":1.875,"value":-0.735960144927537,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]},{"time":2,"value":0.4012681159420284,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]},{"time":3,"value":0,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]}],"cameraPosZ":[{"time":0,"value":10,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":1.25,"value":18.080519192055664,"mode":4,"params":{"rate":250,"damp":1},"mods":[false,false,false,false]},{"time":2,"value":9.572463768115943,"mode":4,"params":{"rate":250,"damp":1},"mods":[false,false,false,false]},{"time":3,"value":10,"mode":4,"params":{"rate":5000,"damp":1},"mods":[false,false,false,false]}],"glitch":[{"time":0,"value":0.3650542009991148,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":2.5,"value":0,"mode":4,"params":{"rate":190,"damp":1},"mods":[false,false,{"freq":1,"amp":0.024,"reso":8,"recursion":4,"seed":20.07},{"freq":19}]},{"time":3,"value":0.31146654065536417,"mode":2,"params":{},"mods":[{"velocity":0},false,false,false]}],"glitchSeed":[{"time":0,"value":0,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":0.04054054054054054,"value":0.053140096618357446,"mode":0,"params":{},"mods":[false,false,false,false]},{"time":0.4723032069970846,"value":0.18357487922705318,"mode":0,"params":{},"mods":[false,false,false,false]},{"time":2.5509810101646835,"value":0.7248830012077294,"mode":1,"params":{},"mods":[false,false,false,{"freq":31}]},{"time":2.921,"value":0.8840579710144932,"mode":0,"params":{},"mods":[false,false,false,false]},{"time":3,"value":1,"mode":1,"params":{},"mods":[false,false,false,false]}],"measurePhase1":[{"time":0,"value":1,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":1.25,"value":5.551115123125783e-17,"mode":4,"params":{"rate":500,"damp":1},"mods":[false,false,false,false]},{"time":3,"value":1,"mode":4,"params":{"rate":500,"damp":1},"mods":[false,false,false,false]}],"measurePhase2":[{"time":0,"value":1,"mode":1,"params":{},"mods":[false,false,false,false]},{"time":1.5801158301158305,"value":0.004830917874396101,"mode":4,"params":{"rate":500,"damp":1},"mods":[false,false,false,false]},{"time":3,"value":1,"mode":4,"params":{"rate":500,"damp":1},"mods":[false,false,false,false]}]},"gui":{"snap":{"enable":true,"bpm":"60","offset":"0"}}}\n'
});
var auto = automaton.auto;

// ------

var cameraPos = [0.0, 0.0, 10.0];
var cameraTar = [0.0, 0.0, 0.0];
var cameraRoll = 0.0;
var cameraFov = 70.0;

var cameraNear = 0.1;
var cameraFar = 100.0;

var lightPos = [10.0, 8.0, 10.0];

var matP = void 0;
var matV = void 0;
var matPL = void 0;
var matVL = void 0;

var updateMatrices = function updateMatrices() {
  cameraPos[0] = auto('cameraPosX');
  cameraPos[1] = auto('cameraPosY');
  cameraPos[2] = auto('cameraPosZ');

  matP = _mathcat2.default.mat4Perspective(cameraFov, cameraNear, cameraFar);
  matV = _mathcat2.default.mat4LookAt(cameraPos, cameraTar, [0.0, 1.0, 0.0], cameraRoll);

  matPL = _mathcat2.default.mat4Perspective(cameraFov, cameraNear, cameraFar);
  matVL = _mathcat2.default.mat4LookAt(lightPos, cameraTar, [0.0, 1.0, 0.0], 0.0);
};
updateMatrices();

// ------

var mouseX = 0.0;
var mouseY = 0.0;

canvas.addEventListener('mousemove', function (event) {
  mouseX = event.offsetX;
  mouseY = event.offsetY;
});

// ------

var vboQuad = glCat.createVertexbuffer([-1, -1, 1, -1, -1, 1, 1, 1]);

// ------

var bgColor = [0.01, 0.01, 0.01, 1.0];

// ------

glCatPath.setGlobalFunc(function () {
  glCat.uniform1i('init', init);
  glCat.uniform1f('time', automaton.time);
  glCat.uniform1f('deltaTime', automaton.deltaTime);

  glCat.uniform1f('totalFrame', totalFrame);
  glCat.uniform2fv('mouse', [mouseX, mouseY]);

  glCat.uniform3fv('cameraPos', cameraPos);
  glCat.uniform3fv('cameraTar', cameraTar);
  glCat.uniform1f('cameraRoll', cameraRoll);
  glCat.uniform1f('cameraFov', cameraFov);
  glCat.uniform1f('cameraNear', cameraNear);
  glCat.uniform1f('cameraFar', cameraFar);
  glCat.uniform3fv('lightPos', lightPos);

  glCat.uniformMatrix4fv('matP', matP);
  glCat.uniformMatrix4fv('matV', matV);
  glCat.uniformMatrix4fv('matPL', matPL);
  glCat.uniformMatrix4fv('matVL', matVL);
  glCat.uniform4fv('bgColor', bgColor);
});

glCatPath.add({
  return: {
    width: width,
    height: height,
    vert: "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}\n",
    frag: "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform sampler2D sampler0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  gl_FragColor = texture2D( sampler0, uv );\n}\n",
    blend: [gl.ONE, gl.ZERO],
    clear: [0.0, 0.0, 0.0, 1.0],
    func: function func(path, params) {
      glCat.attribute('p', vboQuad, 2);
      glCat.uniformTexture('sampler0', params.input, 0);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
  },

  inspector: {
    width: width,
    height: height,
    vert: "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}\n",
    frag: "#define RADIUS 40.0\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform vec2 mouse;\nuniform vec3 circleColor;\nuniform sampler2D sampler0;\n\nbool print( in vec2 _coord, float _in ) {\n  vec2 coord = _coord;\n\n  // vertical restriction\n  if ( coord.y <= 0.0 || 5.0 <= coord.y ) { return false; }\n  \n  // dot\n  if ( 0.0 < coord.x && coord.x < 2.0 ) {\n    return coord.x < 1.0 && coord.y < 1.0;\n  }\n\n  // padded by dot\n  if ( 2.0 < coord.x ) { coord.x -= 2.0; }\n  \n  // determine digit\n  float ci = floor( coord.x / 5.0 ) + 1.0;\n\n  // too low / too high\n  if ( 4.0 < ci ) { return false; }\n  if ( ci < -4.0 ) { return false; }\n\n  // x of char\n  float cfx = floor( mod( coord.x, 5.0 ) );\n\n  // width is 4\n  if ( 4.0 == cfx ) { return false; }\n\n  // y of char\n  float cfy = floor( coord.y );\n\n  // bit of char\n  float cf = cfx + 4.0 * cfy;\n\n  // determine char  \n  float num = 0.0;\n  if ( 0.0 < ci ) {\n    float n = abs( _in );\n    for ( int i = 0; i < 6; i ++ ) {\n      if ( ci < float( i ) ) { break; }\n      \n      num = mod( floor( n ), 10.0 );\n      n -= num;\n      n *= 10.0;\n    }\n  } else {\n    float n = abs( _in );\n    for ( int i = 0; i < 6; i ++ ) {\n      if ( -ci < float( i ) ) { break; }\n      \n      if ( ci != 0.0 && n < 1.0 ) {\n        // minus\n        return float( i ) == -ci && _in < 0.0 && cfy == 2.0 && 0.0 < cfx;\n      }\n      num = mod( floor( n ), 10.0 );\n      n -= num;\n      n /= 10.0;\n    }\n  }\n\n  bool a;\n  a = 1.0 == mod( floor( (\n    num == 0.0 ? 432534.0 :\n    num == 1.0 ? 410692.0 :\n    num == 2.0 ? 493087.0 :\n    num == 3.0 ? 493191.0 :\n    num == 4.0 ? 630408.0 :\n    num == 5.0 ? 989063.0 :\n    num == 6.0 ? 399254.0 :\n    num == 7.0 ? 1016898.0 :\n    num == 8.0 ? 431766.0 :\n    433798.0\n  ) / pow( 2.0, cf ) ), 2.0 );\n  \n  return a ? true : false;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n\n  vec2 m = floor( vec2( 0.0, resolution.y ) + vec2( 1.0, -1.0 ) * mouse );\n  vec2 center = floor( m + vec2( 1.0, 0.7 ) * RADIUS );\n  float circle = length( gl_FragCoord.xy - center ) - RADIUS;\n\n  vec4 col = texture2D( sampler0, uv );\n  vec4 mcol = texture2D( sampler0, ( m + 0.5 ) / resolution );\n  vec4 bcol = vec4( circleColor, 1.0 );\n\n  col = mix(\n    col,\n    mix(\n      bcol,\n      mcol,\n      smoothstep( 1.0, 0.0, circle + 5.0 )\n    ),\n    smoothstep( 1.0, 0.0, circle )\n  );\n\n  if ( circle < 0.0 ) {\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, 8.0 ), mcol.x ) ? bcol : col;\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, 0.0 ), mcol.y ) ? bcol : col;\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, -8.0 ), mcol.z ) ? bcol : col;\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, -16.0 ), mcol.w ) ? bcol : col;\n  }\n\n  gl_FragColor = col;\n}",
    blend: [gl.ONE, gl.ZERO],
    clear: [0.0, 0.0, 0.0, 1.0],
    func: function func(path, params) {
      glCat.attribute('p', vboQuad, 2);
      glCat.uniform3fv('circleColor', [1.0, 1.0, 1.0]);
      glCat.uniformTexture('sampler0', params.input, 0);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
  },

  'target': {
    width: width,
    height: height,
    vert: "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}\n",
    frag: "precision highp float;\n#define GLSLIFY 1\n\nuniform vec4 bgColor;\n\n// ------\n\nvoid main() {\n  gl_FragColor = bgColor;\n}",
    blend: [gl.ONE, gl.ZERO],
    clear: [0.0, 0.0, 0.0, 1.0],
    framebuffer: true,
    float: true,
    depthWrite: false,
    func: function func() {
      glCat.attribute('p', vboQuad, 2);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }
  }
});

// ------

var updateUI = function updateUI() {
  var now = new Date();
  var deadline = new Date(2018, 2, 16, 0, 0);

  divCountdown.innerText = 'Deadline: ' + Math.floor((deadline - now) / 1000);
};

// ------

var update = function update() {
  if (!tweak.checkbox('play', { value: true })) {
    setTimeout(update, 100);
    return;
  }

  automaton.update();

  updateUI();
  updateMatrices();

  // ------

  glCatPath.begin();

  glCatPath.render('target');

  glCatPath.render('piecesComputeReturn');
  glCatPath.render('piecesCompute');

  glCatPath.render('lofipath', {
    target: glCatPath.fb('target'),
    width: width,
    height: height,
    begin: auto('pathBegin'),
    segs: auto('pathSegs')
  });

  glCatPath.render('piecesRender', {
    target: glCatPath.fb('target'),
    width: width,
    height: height
  });

  glCatPath.render('console', {
    target: glCatPath.fb('target'),
    width: width,
    height: height,
    time: automaton.time,
    frame: automaton.frame,
    cameraX: cameraPos[0],
    cameraY: cameraPos[1],
    cameraZ: cameraPos[2]
  });

  glCatPath.render('measure', {
    target: glCatPath.fb('target'),
    width: width,
    height: height,
    phase1: auto('measurePhase1'),
    phase2: auto('measurePhase2')
  });

  glCatPath.render('grid', {
    target: glCatPath.fb('target'),
    width: width,
    height: height
  });

  glCatPath.render('glitch', {
    input: glCatPath.fb('target').texture,
    width: width,
    height: height,
    amp: auto('glitch'),
    seed: auto('glitchSeed')
  });

  glCatPath.render('post', {
    target: _glcatPathGui2.default.nullFb,
    input: glCatPath.fb('glitch').texture,
    width: width,
    height: height
  });

  glCatPath.end();

  init = false;
  totalFrame++;

  // ------

  if (tweak.checkbox('save', { value: false })) {
    saveFrame();
  }

  requestAnimationFrame(update);
};

(0, _step2.default)({
  0: function _(step) {
    (0, _pathLofipath2.default)(glCatPath, auto, step);
    (0, _pathPostfx2.default)(glCatPath, width, height);
    (0, _pathConsole2.default)(glCatPath, width, height);
    (0, _pathPieces2.default)(glCatPath, automaton);
    (0, _pathGrid2.default)(glCatPath);
  },

  1: function _(step) {
    update();
  }
});

// ------

window.addEventListener('keydown', function (_e) {
  if (_e.which === 27) {
    tweak.checkbox('play', { set: false });
  }
});

},{"./libs/glcat":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/glcat.js","./libs/glcat-path-gui":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/glcat-path-gui.js","./libs/mathcat":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/mathcat.js","./libs/step":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/step.js","./libs/tweak":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/tweak.js","./libs/xorshift":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/xorshift.js","./path-console":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/path-console.js","./path-grid":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/path-grid.js","./path-lofipath":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/path-lofipath.js","./path-pieces":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/path-pieces.js","./path-postfx":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/path-postfx.js"}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/path-console.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});


// ------

var canvas = document.createElement('canvas');
var context = canvas.getContext('2d');

// ------

var textWithBg = function textWithBg(text, x, y) {
  context.font = '500 20px Wt-Position';
  context.textAlign = 'left';
  context.textBaseline = 'hanging';

  var mt = context.measureText(text);

  context.fillStyle = '#fff';
  context.fillRect(x - 4, y - 4, mt.width + 8, 20);

  context.fillStyle = '#000';
  context.fillText(text, x, y);
};

var textBottom = function textBottom(text, size, x, y) {
  context.font = '900 ' + size + 'px Helvetica Neue';
  context.textAlign = 'right';
  context.textBaseline = 'alphabetic';

  context.fillStyle = '#fff';
  context.fillText(text, x, y);
};

// ------

var pathConsole = function pathConsole(glCatPath, width, height) {
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;

  // ------

  var w = canvas.width = width;
  var h = canvas.height = height;

  var vboQuad = glCat.createVertexbuffer([-1, -1, 1, -1, -1, 1, 1, 1]);
  var texture = glCat.createTexture();

  // ------

  glCatPath.add({
    console: {
      vert: "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}\n",
      frag: "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform sampler2D sampler0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  uv.y = 1.0 - uv.y;\n  gl_FragColor = texture2D( sampler0, uv );\n}\n",
      float: true,
      blend: [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA],
      depthWrite: false,
      depthTest: false,
      func: function func(path, params) {
        context.clearRect(0, 0, w, h);

        textWithBg('RANDOM F*%#ING NUMBER: ' + (256.0 * Math.random()).toFixed(3), 10, 10);
        textWithBg('CAMERA X: ' + params.cameraX.toFixed(3), 10, 40);
        textWithBg('CAMERA Y: ' + params.cameraY.toFixed(3), 10, 70);
        textWithBg('CAMERA Z: ' + params.cameraZ.toFixed(3), 10, 100);

        textBottom(params.time.toFixed(3), 30, width - 10, height - 80);
        textBottom('undefined', 30, width - 10, height - 50);
        textBottom('[Placeholder]', 40, width - 10, height - 10);

        glCat.setTexture(texture, canvas);

        glCat.attribute('p', vboQuad, 2);
        glCat.uniformTexture('sampler0', texture, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    }
  });
};

exports.default = pathConsole;

},{}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/path-grid.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mathcat = require('./libs/mathcat');

var _mathcat2 = _interopRequireDefault(_mathcat);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }



// ------

var pathGrid = function pathGrid(glCatPath) {
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;

  // ------

  var vboQuad = glCat.createVertexbuffer([-1, -1, 1, -1, -1, 1, 1, 1]);

  var layer = [];
  for (var i = -3; i < 0; i++) {
    layer.push((i + 0.5) * 0.05);
  }
  var vboLayer = glCat.createVertexbuffer(layer);

  // ------

  glCatPath.add({
    grid: {
      vert: "#define GLSLIFY 1\n#define HUGE 9E16\n#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n\n// ------\n\nattribute vec2 p;\nattribute float z;\n\nvarying vec3 vPos;\n\nuniform vec2 resolution;\n\nuniform mat4 matP;\nuniform mat4 matV;\nuniform mat4 matM;\n\n// ------\n\nvoid main() {\n  vec4 p = matM * vec4( p, z, 1.0 );\n  vPos = p.xyz;\n\n  vec4 outPos;\n  outPos = matP * matV * p;\n  outPos.x /= resolution.x / resolution.y;\n  \n  gl_Position = outPos;\n  gl_PointSize = resolution.y / 100.0;\n}",
      frag: "#define saturate(i) clamp(i,0.,1.)\n\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPos;\n\nuniform vec3 color;\n\n// ------\n\nvoid main() {\n  float intrv = 5.0;\n  vec2 p = mod( vPos.xy, intrv ) - intrv / 2.0;\n\n  float a = 1.0;\n  a *= smoothstep( 0.05, 0.00, min( abs( p.x ), abs( p.y ) ) );\n  a *= smoothstep( 0.40, 0.39, max( abs( p.x ), abs( p.y ) ) );\n\n  if ( a == 0.0 ) { discard; }\n  gl_FragColor = vec4( color, 0.1 * saturate( a ) );\n}",
      func: function func(path, params) {
        glCat.attribute('z', vboLayer, 1, 1);
        glCat.attribute('p', vboQuad, 2);

        var matM = _mathcat2.default.mat4Identity();
        matM = _mathcat2.default.mat4Apply(_mathcat2.default.mat4ScaleXYZ(100.0), matM);
        glCat.uniformMatrix4fv('matM', matM);

        glCat.uniform3fv('color', [1.0, 1.0, 1.0]);

        var ext = glCat.getExtension("ANGLE_instanced_arrays");
        ext.drawArraysInstancedANGLE(gl.TRIANGLE_STRIP, 0, 4, vboLayer.length);
      }
    },

    measure: {
      vert: "#define GLSLIFY 1\n#define HUGE 9E16\n#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n\n// ------\n\nattribute vec2 p;\n\nvarying vec3 vPos;\n\nuniform vec2 resolution;\n\nuniform mat4 matP;\nuniform mat4 matV;\nuniform mat4 matM;\n\n// ------\n\nvoid main() {\n  vec4 p = matM * vec4( p, 0.0, 1.0 );\n  vPos = p.xyz;\n\n  vec4 outPos;\n  outPos = matP * matV * p;\n  outPos.x /= resolution.x / resolution.y;\n  \n  gl_Position = outPos;\n  gl_PointSize = resolution.y / 100.0;\n}",
      frag: "#define saturate(i) clamp(i,0.,1.)\n\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vPos;\n\nuniform float time;\nuniform vec3 color;\nuniform float phase1;\nuniform float phase2;\n\n// ------\n\nvoid main() {\n  float a = 0.0;\n\n  // line\n  a += (\n    smoothstep( 0.05, 0.04, abs( abs( vPos.y ) - 3.0 ) )\n  );\n\n  float scroll = vPos.y < 0.0 ? time : -time;\n\n  // dot1\n  {\n    float d = mod( vPos.x - 0.1 + scroll, 0.2 ) - 0.1;\n    a += (\n      smoothstep( 0.03, 0.02, abs( d ) )\n      * smoothstep( 2.9, 2.89, abs( vPos.y ) )\n      * smoothstep( 2.9, 2.91, abs( vPos.y ) + 0.1 * phase2 )\n    );\n  }\n\n  // dot2\n  {\n    float d = mod( vPos.x - 0.5 + scroll, 1.0 ) - 0.5;\n    a += (\n      smoothstep( 0.03, 0.02, abs( d ) )\n      * smoothstep( 2.9, 2.89, abs( vPos.y ) )\n      * smoothstep( 2.9, 2.91, abs( vPos.y ) + 0.2 * phase2 )\n    );\n  }\n\n  a *= smoothstep( 0.0, -0.01, abs( vPos.x ) - 6.02 * phase1 );\n\n  if ( a == 0.0 ) { discard; }\n  gl_FragColor = vec4( color, 0.3 * saturate( a ) );\n}",
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);

        var matM = _mathcat2.default.mat4Identity();
        matM = _mathcat2.default.mat4Apply(_mathcat2.default.mat4ScaleXYZ(100.0), matM);
        glCat.uniformMatrix4fv('matM', matM);

        glCat.uniform1f('phase1', params.phase1);
        glCat.uniform1f('phase2', params.phase2);
        glCat.uniform3fv('color', [1.0, 1.0, 1.0]);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    }
  });
};

exports.default = pathGrid;

},{"./libs/mathcat":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/mathcat.js"}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/path-lofipath.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _svgPath = require('./svg-path');

var _svgPath2 = _interopRequireDefault(_svgPath);

var _mathcat = require('./libs/mathcat');

var _mathcat2 = _interopRequireDefault(_mathcat);

var _vertphaser = require('./vertphaser');

var _vertphaser2 = _interopRequireDefault(_vertphaser);

var _opentype = require('opentype.js');

var opentype = _interopRequireWildcard(_opentype);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }



// ------

var pathLofiPath = function pathLofiPath(glCatPath, auto, callback) {
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;

  // ------

  var phasers = void 0;

  opentype.load('fonts/Orbitron-Black.ttf', function (error, font) {
    if (error) {
      throw error;
    }

    var fontSize = 12.0;
    var text = 'Vec';
    var wid = font.getAdvanceWidth(text, fontSize);
    var path = font.getPath(text, 0, 0, fontSize).toPathData();
    var vs = (0, _svgPath2.default)(path, { curveSegs: 8 });
    phasers = vs.map(function (v) {
      for (var i = 0; i < v.length / 2; i++) {
        v[i * 2 + 0] = v[i * 2 + 0] - wid / 2;
        v[i * 2 + 1] = -(v[i * 2 + 1] + fontSize * 0.35);
      }
      return new _vertphaser2.default(v);
    });

    callback();
  });

  var vboPos = glCat.createVertexbuffer(false);

  // ------

  glCatPath.add({
    lofipath: {
      vert: "#define GLSLIFY 1\n#define HUGE 9E16\n#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n\n// ------\n\nattribute vec2 p;\n\nvarying vec3 vPos;\n\nuniform vec2 resolution;\nuniform float deformAmp;\nuniform float deformFreq;\nuniform float deformOffset;\n\nuniform mat4 matP;\nuniform mat4 matV;\nuniform mat4 matM;\n\n// ------\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\n// ------\n\nvoid main() {\n  vec4 p = matM * vec4( p, 0.0, 1.0 );\n  p.xyz += deformAmp * vec3(\n    snoise( vec4( p.xyz * deformFreq,   1.0 + deformOffset ) ),\n    snoise( vec4( p.xyz * deformFreq,  44.7 + deformOffset ) ),\n    snoise( vec4( p.xyz * deformFreq, 111.3 + deformOffset ) )\n  );\n  vPos = p.xyz;\n\n  vec4 outPos;\n  outPos = matP * matV * p;\n  outPos.x /= resolution.x / resolution.y;\n  \n  gl_Position = outPos;\n  gl_PointSize = resolution.y / 100.0;\n}",
      frag: "precision highp float;\n#define GLSLIFY 1\n\nuniform vec3 color;\nuniform bool isPoint;\n\n// ------\n\nvoid main() {\n  if ( isPoint && 0.5 < length( gl_PointCoord - 0.5 ) ) { discard; }\n  gl_FragColor = vec4( color, 1.0 );\n}",
      float: true,
      depthWrite: false,
      depthTest: false,
      func: function func(path, params) {
        var matM = _mathcat2.default.mat4Identity();
        matM = _mathcat2.default.mat4Apply(_mathcat2.default.mat4ScaleXYZ(0.4), matM);
        glCat.uniformMatrix4fv('matM', matM);

        glCat.uniform3fv('color', [1.0, 1.0, 1.0]);

        // ------

        phasers.map(function (phaser) {
          var begin = params.begin || 0.0;
          var segs = Math.max(3, params.segs || 3);
          var arr = phaser.lofi(begin, segs);

          glCat.setVertexbuffer(vboPos, arr, gl.DYNAMIC_DRAW);

          glCat.attribute('p', vboPos, 2);

          glCat.uniform1f('deformAmp', auto('deformAmp'));
          glCat.uniform1f('deformFreq', auto('deformFreq'));
          glCat.uniform1f('deformOffset', auto('deformOffset'));

          glCat.uniform1i('isPoint', false);
          gl.drawArrays(gl.LINE_STRIP, 0, arr.length / 2);

          glCat.uniform1i('isPoint', true);
          gl.drawArrays(gl.POINTS, 0, arr.length / 2);
        });
      }
    }
  });
};

exports.default = pathLofiPath;

},{"./libs/mathcat":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/mathcat.js","./svg-path":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/svg-path.js","./vertphaser":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/vertphaser.js","opentype.js":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/node_modules/opentype.js/dist/opentype.js"}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/path-pieces.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mathcat = require('./libs/mathcat');

var _mathcat2 = _interopRequireDefault(_mathcat);

var _xorshift = require('./libs/xorshift');

var _xorshift2 = _interopRequireDefault(_xorshift);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }



(0, _xorshift2.default)(487723);

// ------

var particlePixels = 2;
var particlesSqrt = 8;
var particles = particlesSqrt * particlesSqrt;
// let vertsPerParticle = lunaLen / 3;

// ------

var pathPieces = function pathPieces(glCatPath, automaton) {
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;

  // ------

  var vboQuad = glCat.createVertexbuffer([-1, -1, 1, -1, -1, 1, 1, 1]);

  var vboParticleUV = glCat.createVertexbuffer(function () {
    var ret = [];
    for (var i = 0; i < particles; i++) {
      var ix = i % particlesSqrt;
      var iy = Math.floor(i / particlesSqrt);

      ret.push(ix * particlePixels);
      ret.push(iy);
    }
    return ret;
  }());

  // ------

  var textureRandomSize = 32;
  var textureRandomUpdate = function textureRandomUpdate(_tex) {
    glCat.setTextureFromArray(_tex, textureRandomSize, textureRandomSize, function () {
      var len = textureRandomSize * textureRandomSize * 4;
      var ret = new Uint8Array(len);
      for (var i = 0; i < len; i++) {
        ret[i] = Math.floor((0, _xorshift2.default)() * 256.0);
      }
      return ret;
    }());
  };

  var textureRandomStatic = glCat.createTexture();
  glCat.textureWrap(textureRandomStatic, gl.REPEAT);
  textureRandomUpdate(textureRandomStatic);

  var textureRandom = glCat.createTexture();
  glCat.textureWrap(textureRandom, gl.REPEAT);

  // ------

  glCatPath.add({
    piecesComputeReturn: {
      width: particlesSqrt * particlePixels,
      height: particlesSqrt,
      vert: "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}\n",
      frag: "precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform sampler2D sampler0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  gl_FragColor = texture2D( sampler0, uv );\n}\n",
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniformTexture('sampler0', glCatPath.fb("piecesCompute").texture, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },

    piecesCompute: {
      width: particlesSqrt * particlePixels,
      height: particlesSqrt,
      vert: "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}\n",
      frag: "#define PARTICLE_LIFE_LENGTH 0.5\n\n#define HUGE 9E16\n#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n#define lofir(i,m) (floor((i)/(m)+.5)*(m))\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float particlesSqrt;\nuniform float particlePixels;\nuniform float totalFrame;\nuniform float charShuffle;\nuniform bool init;\nuniform float deltaTime;\nuniform vec2 resolution;\nuniform vec3 cameraPos;\n\nuniform sampler2D samplerPcompute;\nuniform sampler2D samplerRandom;\n\n// ------\n\nvec2 vInvert( vec2 _uv ) {\n  return vec2( 0.0, 1.0 ) + vec2( 1.0, -1.0 ) * _uv;\n}\n\n// ------\n\nmat2 rotate2D( float _t ) {\n  return mat2( cos( _t ), sin( _t ), -sin( _t ), cos( _t ) );\n}\n\nvec4 random( vec2 _uv ) {\n  return texture2D( samplerRandom, _uv );\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\nfloat GPURnd(inout vec4 n)\n{\n\t// Based on the post http://gpgpu.org/forums/viewtopic.php?t=2591&sid=17051481b9f78fb49fba5b98a5e0f1f3\n\t// (The page no longer exists as of March 17th, 2015. Please let me know if you see why this code works.)\n\tconst vec4 q = vec4(   1225.0,    1585.0,    2457.0,    2098.0);\n\tconst vec4 r = vec4(   1112.0,     367.0,      92.0,     265.0);\n\tconst vec4 a = vec4(   3423.0,    2646.0,    1707.0,    1999.0);\n\tconst vec4 m = vec4(4194287.0, 4194277.0, 4194191.0, 4194167.0);\n\n\tvec4 beta = floor(n / q);\n\tvec4 p = a * (n - beta * q) - beta * r;\n\tbeta = (sign(-p) + vec4(1.0)) * vec4(0.5) * m;\n\tn = (p + beta);\n\n\treturn fract(dot(n / m, vec4(1.0, -1.0, 1.0, -1.0)));\n}\n\nvec3 randomSphere( inout vec4 seed ) {\n  vec3 v;\n  for ( int i = 0; i < 10; i ++ ) {\n    v = vec3(\n      GPURnd( seed ),\n      GPURnd( seed ),\n      GPURnd( seed )\n    ) * 2.0 - 1.0;\n    if ( length( v ) < 1.0 ) { break; }\n  }\n  return v;\n}\n\nvec2 randomCircle( inout vec4 seed ) {\n  vec2 v;\n  for ( int i = 0; i < 10; i ++ ) {\n    v = vec2(\n      GPURnd( seed ),\n      GPURnd( seed )\n    ) * 2.0 - 1.0;\n    if ( length( v ) < 1.0 ) { break; }\n  }\n  return v;\n}\n\nvec3 randomBox( inout vec4 seed ) {\n  vec3 v;\n  v = vec3(\n    GPURnd( seed ),\n    GPURnd( seed ),\n    GPURnd( seed )\n  ) * 2.0 - 1.0;\n  return v;\n}\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 puv = vec2( ( floor( gl_FragCoord.x / particlePixels ) * particlePixels + 0.5 ) / resolution.x, uv.y );\n  float number = ( ( gl_FragCoord.x - 0.5 ) / particlePixels ) + ( ( gl_FragCoord.y - 0.5 ) * particlesSqrt );\n  float mode = mod( gl_FragCoord.x, particlePixels );\n  vec2 dpix = vec2( 1.0 ) / resolution;\n\n  vec4 seed = texture2D( samplerRandom, puv );\n  GPURnd( seed );\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n  vec4 vel = texture2D( samplerPcompute, puv + dpix * vec2( 1.0, 0.0 ) );\n\n  float dt = deltaTime;\n\n  float timing = mix( 0.0, PARTICLE_LIFE_LENGTH, number / particlesSqrt / particlesSqrt );\n  timing += lofi( time, PARTICLE_LIFE_LENGTH );\n\n  if ( time - deltaTime < timing && timing < time ) {\n    pos.xyz = 20.0 * randomSphere( seed );\n    pos.xyz = lofir( pos.xyz, 1.0 );\n    pos.w = 1.0; // life\n\n    vel.xyz = vec3( 0.0 );\n    vel.w = GPURnd( seed ); // size\n\n    dt = time - timing;\n  }\n\n  // vel.xyz += 10.0 * dt * vec3(\n  //   noise( vec4( pos.xyz * 0.37 + 61.51 + 0.1 * sin( 2.0 * PI * time ), 20.04 ) ),\n  //   noise( vec4( pos.xyz * 0.37 + 15.31 + 0.1 * sin( 2.0 * PI * time ), 41.21 ) ),\n  //   noise( vec4( pos.xyz * 0.37 + 28.79 + 0.1 * sin( 2.0 * PI * time ), 32.95 ) )\n  // );\n\n  pos.xyz += vel.xyz * dt;\n  pos.w -= dt / PARTICLE_LIFE_LENGTH;\n\n  gl_FragColor = (\n    mode < 1.0 ? pos :\n    vel\n  );\n}",
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        if (automaton.frame === 1) {
          (0, _xorshift2.default)(487723);
        }
        textureRandomUpdate(textureRandom);

        glCat.attribute('p', vboQuad, 2);

        glCat.uniform1f('particlesSqrt', particlesSqrt);
        glCat.uniform1f('particlePixels', particlePixels);

        glCat.uniformTexture('samplerPcompute', glCatPath.fb("piecesComputeReturn").texture, 0);
        glCat.uniformTexture('samplerRandom', textureRandom, 1);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },

    piecesRender: {
      vert: "#define GLSLIFY 1\n#define HUGE 9E16\n#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n\n// ------\n\nattribute vec2 computeUV;\nattribute vec2 rect;\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSize;\n\nuniform vec2 resolutionPcompute;\nuniform mat4 matP;\nuniform mat4 matV;\n\nuniform sampler2D samplerPcompute;\n\n// ------\n\nmat2 rotate2D( float _t ) {\n  return mat2( cos( _t ), sin( _t ), -sin( _t ), cos( _t ) );\n}\n\nvoid main() {\n  vec2 puv = ( computeUV.xy + 0.5 ) / resolutionPcompute;\n  vec2 dppix = vec2( 1.0 ) / resolutionPcompute;\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n  vec4 vel = texture2D( samplerPcompute, puv + dppix * vec2( 1.0, 0.0 ) );\n\n  pos.xy += vel.w * rect;\n\n  vLife = pos.w;\n  vSize = vel.w;\n\n  vUv = 0.5 + 0.5 * rect;\n\n  vec4 outPos = matP * matV * vec4( pos.xyz, 1.0 );\n  gl_Position = outPos;\n}",
      frag: "#define HUGE 9E16\n#define PI 3.14159265\n#define TAU 6.28318531\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n#define lofir(i,m) (floor((i)/(m)+.5)*(m))\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec2 vUv;\nvarying float vLife;\nvarying float vSize;\n\nuniform vec3 color;\nuniform vec3 cameraPos;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform vec3 lightPos;\nuniform float totalFrame;\nuniform float time;\n\n// ------\n\nmat2 rotate2D( float _t ) {\n  return mat2( cos( _t ), sin( _t ), -sin( _t ), cos( _t ) );\n}\n\n// ------\n\nvoid main() {\n  if ( vLife <= 0.0 ) { discard; }\n\n  vec2 p = vUv * 2.0 - 1.0;\n\n  float mode = floor( mod( vSize * 8573.51, 4.0 ) );\n  \n  if ( mode == 1.0 ) { // 田\n    if ( any( lessThan( abs( p ), vec2( 0.2 ) ) ) ) { discard; }\n\n    float ptn = floor( mod( vSize * 6499.85 + totalFrame / 4.0, 4.0 ) );\n    float pos = floor( p.x + 1.0 ) + 2.0 * floor( p.y + 1.0 );\n    if ( ptn != pos ) { discard; }\n\n  } else if ( mode == 2.0 ) { // c\n    if ( 0.2 < abs( length( p ) - 0.8 ) ) { discard; }\n\n    float ptn = floor( mod( vSize * 6499.85 - totalFrame / 4.0, 12.0 ) );\n    vec2 pp = rotate2D(ptn * TAU / 12.0 ) * p;\n    float th = atan( pp.y, pp.x );\n    if ( th < 0.0 ) { discard; }\n\n  } else if ( mode == 3.0 ) { // |\n    float ptn = floor( mod( vSize * 6499.85 + totalFrame / 3.0, 4.0 ) );\n    vec2 pp = rotate2D( ptn * TAU / 8.0 ) * p;\n    \n    if ( 0.2 < abs( pp.x ) || 0.9 < abs( pp.y ) ) { discard; }\n  } else { // ∴\n    vec2 pp = p;\n    float ptn = floor( mod( vSize * 6499.85 + totalFrame / 3.0, 3.0 ) );\n    pp = rotate2D( -PI / 2.0 + ptn * TAU / 3.0 ) * pp;\n\n    float d = lofir( atan( pp.y, pp.x ), TAU / 3.0 );\n    pp = rotate2D( -d ) * pp;\n    pp -= vec2( 0.5, 0.0 );\n\n    if ( 0.5 < length( pp ) ) { discard; }\n    if ( d != 0.0 && length( pp ) < 0.3 ) { discard; }\n\n  }\n\n  gl_FragColor = vec4( vec3( 1.0 ), 0.3 );\n}",
      blend: [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA],
      func: function func(path, params) {
        glCat.attribute('computeUV', vboParticleUV, 2, 1);
        glCat.attribute('rect', vboQuad, 2);

        glCat.uniform1f('particlesSqrt', particlesSqrt);
        glCat.uniform1f('particlePixels', particlePixels);

        glCat.uniform2fv('resolutionPcompute', [particlesSqrt * particlePixels, particlesSqrt]);
        glCat.uniformTexture('samplerPcompute', glCatPath.fb("piecesCompute").texture, 1);

        var ext = glCat.getExtension("ANGLE_instanced_arrays");
        ext.drawArraysInstancedANGLE(gl.TRIANGLE_STRIP, 0, 4, particles);
      }
    }
  });
};

exports.default = pathPieces;

},{"./libs/mathcat":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/mathcat.js","./libs/xorshift":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/xorshift.js"}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/path-postfx.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mathcat = require('./libs/mathcat');

var _mathcat2 = _interopRequireDefault(_mathcat);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }



// ------

var pathPostfx = function pathPostfx(glCatPath, width, height) {
  var glCat = glCatPath.glCat;
  var gl = glCat.gl;

  // ------

  var vboQuad = glCat.createVertexbuffer([-1, -1, 1, -1, -1, 1, 1, 1]);

  // ------

  glCatPath.add({
    fxaa: {
      width: width,
      height: height,
      vert: "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}\n",
      frag: "#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n\n#define FXAA_REDUCE_MIN (1.0 / 128.0)\n#define FXAA_REDUCE_MUL (1.0 / 8.0)\n#define FXAA_SPAN_MAX 16.0\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\n\nuniform sampler2D texture;\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n\n  #define T(v) texture2D( texture, (v) / resolution ).xyz\n  vec3 rgb11 = T( gl_FragCoord.xy );\n  vec3 rgb00 = T( gl_FragCoord.xy + V.zz );\n  vec3 rgb02 = T( gl_FragCoord.xy + V.zy );\n  vec3 rgb20 = T( gl_FragCoord.xy + V.yz );\n  vec3 rgb22 = T( gl_FragCoord.xy + V.yy );\n  #undef T\n\n  vec3 luma = vec3( 0.299, 0.587, 0.114 );\n  #define L(c) dot( c, luma )\n  float luma11 = L( rgb11 );\n  float luma00 = L( rgb00 );\n  float luma02 = L( rgb02 );\n  float luma20 = L( rgb20 );\n  float luma22 = L( rgb22 );\n  #undef L\n\n  float lumaMin = min( luma00, min( min( luma00, luma02 ), min( luma20, luma22 ) ) );\n  float lumaMax = max( luma00, max( max( luma00, luma02 ), max( luma20, luma22 ) ) );\n\n  vec2 dir = vec2(\n    -( ( luma00 + luma20 ) - ( luma02 + luma22 ) ),\n    ( ( luma00 + luma02 ) - ( luma20 + luma22 ) )\n  );\n\n  float dirReduce = max(\n    ( luma00 + luma02 + luma20 + luma22 ) * 0.25 * FXAA_REDUCE_MUL,\n    FXAA_REDUCE_MIN\n  );\n  float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );\n  dir = min(\n    vec2( FXAA_SPAN_MAX ),\n    max(\n      vec2( -FXAA_SPAN_MAX ),\n      dir * rcpDirMin\n    )\n  ) / resolution;\n\n  vec3 rgbA = 0.5 * (\n    texture2D( texture, uv + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz +\n    texture2D( texture, uv + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz\n  );\n  vec3 rgbB = rgbA * 0.5 + 0.25 * (\n    texture2D( texture, uv - dir * 0.5 ).xyz +\n    texture2D( texture, uv + dir * 0.5 ).xyz\n  );\n\n  float lumaB = dot( rgbB, luma );\n  gl_FragColor = (\n    ( ( lumaB < lumaMin ) || ( lumaMax < lumaB ) ) ?\n    vec4( rgbA, 1.0 ) :\n    vec4( rgbB, 1.0 )\n  );\n}",
      clear: [0.0, 0.0, 0.0, 1.0],
      framebuffer: true,
      float: true,
      blend: [gl.ONE, gl.ZERO],
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniformTexture('sampler0', params.input, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },

    post: {
      width: width,
      height: height,
      vert: "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}\n",
      frag: "#define BARREL_ITER 20\n#define BARREL_AMP 0.07\n#define BARREL_OFFSET 0.05\n\n#define HUGE 9E16\n#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform vec2 resolution;\n\nuniform sampler2D sampler0;\n\n// ------\n\nvec3 barrel( float amp, vec2 uv ) {\n\tfloat corn = length( vec2( 0.5 ) );\n\tfloat a = min( 3.0 * sqrt( amp ), corn * PI );\n\tfloat zoom = corn / ( tan( corn * a ) + corn );\n\tvec2 p = saturate(\n    ( uv + normalize( uv - 0.5 ) * tan( length( uv - 0.5 ) * a ) ) * zoom +\n    0.5 * ( 1.0 - zoom )\n  );\n\treturn texture2D( sampler0, vec2( p.x, p.y ) ).xyz;\n}\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 p = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution.y;\n  float vig = 1.14 - length( p ) * 0.6;\n\n  vec3 tex = vec3( 0.0 );\n\n  for ( int i = 0; i < BARREL_ITER; i ++ ) {\n    float fi = ( float( i ) + 0.5 ) / float( BARREL_ITER );\n    vec3 a = saturate( vec3(\n      1.0 - 3.0 * abs( 1.0 / 6.0 - fi ),\n      1.0 - 3.0 * abs( 1.0 / 2.0 - fi ),\n      1.0 - 3.0 * abs( 5.0 / 6.0 - fi )\n    ) ) / float( BARREL_ITER ) * 4.0;\n    tex += a * barrel( BARREL_OFFSET + BARREL_AMP * fi, uv );\n  }\n\n  tex = mix(\n    vec3( 0.0 ),\n    tex,\n    vig\n  );\n\n  vec3 col = pow( saturate( tex.xyz ), vec3( 1.0 / 2.2 ) );\n  col = vec3(\n    smoothstep( -0.1, 1.1, col.x ),\n    smoothstep( 0.0, 1.0, col.y ),\n    smoothstep( -0.3, 1.3, col.z )\n  );\n\n  gl_FragColor = vec4( col, 1.0 );\n}",
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniformTexture('sampler0', params.input, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    },

    glitch: {
      width: width,
      height: height,
      vert: "#define GLSLIFY 1\nattribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}\n",
      frag: "#define BARREL_ITER 20\n#define BARREL_AMP 0.1\n#define BARREL_OFFSET 0.05\n\n#define HUGE 9E16\n#define PI 3.14159265\n#define V vec3(0.,1.,-1.)\n#define saturate(i) clamp(i,0.,1.)\n#define lofi(i,m) (floor((i)/(m))*(m))\n\n// ------\n\nprecision highp float;\n#define GLSLIFY 1\n\nuniform float time;\nuniform float totalFrame;\nuniform vec2 resolution;\nuniform vec2 mouse;\n\nuniform float amp;\nuniform float seed;\nuniform sampler2D sampler0;\n\n// ------\n\nfloat seg( vec2 uv, vec2 s ) {\n  return floor( s.x * uv.x ) + s.x * floor( s.y * uv.y );\n}\n\nfloat random( float v ) {\n  return fract( sin( 691.43 * v + seed ) * 571.54 );\n}\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n\n  vec2 displace = vec2( 0.0 );\n  for ( int i = 0; i < 4; i ++ ) {\n    float m = pow( 2.0, float( i ) );\n    bool b = random( 0.2 + seg( uv + 0.7 * float( i ), vec2( 3.0, 8.0 ) * m ) ) < amp;\n    displace += b ? vec2(\n      random( 0.5 + seg( uv + 0.7 * float( i ), vec2( 3.0, 8.0 ) * m ) ) * 2.0 - 1.0,\n      random( 0.8 + seg( uv + 0.7 * float( i ), vec2( 3.0, 8.0 ) * m ) ) * 2.0 - 1.0\n    ) / 2.0 / m : vec2( 0.0 );\n  }\n  displace = 0.4 * displace;\n\n  vec3 col = vec3(\n    texture2D( sampler0, uv + 1.00 * displace ).x,\n    texture2D( sampler0, uv + 1.05 * displace ).y,\n    texture2D( sampler0, uv + 1.10 * displace ).z\n  );\n  gl_FragColor = vec4( col, 1.0 );\n}",
      blend: [gl.ONE, gl.ZERO],
      clear: [0.0, 0.0, 0.0, 0.0],
      framebuffer: true,
      float: true,
      func: function func(path, params) {
        glCat.attribute('p', vboQuad, 2);
        glCat.uniform1f('amp', params.amp);
        glCat.uniform1f('seed', params.seed);
        glCat.uniformTexture('sampler0', params.input, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }
    }
  });
};

exports.default = pathPostfx;

},{"./libs/mathcat":"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/libs/mathcat.js"}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/svg-path.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var reMode = /([MmLlHhVvZzCcSsQqTtAa])/;
var reCommand = /([MmLlHhVvZzCcSsQqTtAa]|-?[\d]+(\.\d+)?)/g;

var svgPath = function svgPath(_str, _params) {
  var str = _str;
  var params = {
    curveSegs: 4
  };
  for (var key in _params) {
    params[key] = _params[key];
  }

  var arr = str.match(reCommand);

  var paths = [];

  var head = 0;
  var x = 0;
  var y = 0;
  var curPath = null;

  var refx = 0;
  var refy = 0;
  var prevMode = '';
  var prevModeU = '';

  while (head < arr.length) {
    var mode = arr[head];
    if (mode.match(reMode)) {
      head++;
    } else {
      // streak!
      mode = prevMode;
    }
    var modeU = mode.toUpperCase();
    var abs = mode === modeU;

    var ax = abs ? 0 : x;
    var ay = abs ? 0 : y;

    if (modeU === 'M') {
      // move
      x = parseFloat(arr[head + 0]) + ax;
      y = parseFloat(arr[head + 1]) + ay;

      curPath = [x, y];
      paths.push(curPath);

      head += 2;
    } else if (modeU === 'L') {
      // line
      x = parseFloat(arr[head + 0]) + ax;
      y = parseFloat(arr[head + 1]) + ay;

      curPath.push(x, y);

      head += 2;
    } else if (modeU === 'H') {
      // horizontal
      x = parseFloat(arr[head + 0]) + ax;

      curPath.push(x, y);

      head += 1;
    } else if (modeU === 'V') {
      // vertical
      y = parseFloat(arr[head + 0]) + ay;

      curPath.push(x, y);

      head += 1;
    } else if (modeU === 'Z') {
      // close path
      curPath.push(curPath[0], curPath[1]);
    } else if (modeU === 'C') {
      // cubic bezier
      var x0 = x;
      var y0 = y;
      var x1 = parseFloat(arr[head + 0]) + ax;
      var y1 = parseFloat(arr[head + 1]) + ay;
      var x2 = parseFloat(arr[head + 2]) + ax;
      var y2 = parseFloat(arr[head + 3]) + ay;
      x = parseFloat(arr[head + 4]) + ax;
      y = parseFloat(arr[head + 5]) + ay;

      for (var i = 0; i < params.curveSegs; i++) {
        var t = (i + 1) / params.curveSegs;
        var u = 1.0 - t;
        curPath.push(u * u * u * x0 + 3 * t * u * u * x1 + 3 * t * t * u * x2 + t * t * t * x, u * u * u * y0 + 3 * t * u * u * y1 + 3 * t * t * u * y2 + t * t * t * y);
      }

      refx = 2 * x - x2;
      refy = 2 * y - y2;

      head += 6;
    } else if (modeU === 'S') {
      // cubic bezier, with reflection
      var prevValid = prevModeU === 'C' || prevModeU === 'S';
      if (!prevValid) {
        console.warn('svgPath: Invalid S/s command use detected');
      }

      var _x = x;
      var _y = y;
      var _x2 = prevValid ? refx : x;
      var _y2 = prevValid ? refy : y;
      var _x3 = parseFloat(arr[head + 0]) + ax;
      var _y3 = parseFloat(arr[head + 1]) + ay;
      x = parseFloat(arr[head + 2]) + ax;
      y = parseFloat(arr[head + 3]) + ay;

      for (var _i = 0; _i < params.curveSegs; _i++) {
        var _t = (_i + 1) / params.curveSegs;
        var _u = 1.0 - _t;
        curPath.push(_u * _u * _u * _x + 3 * _t * _u * _u * _x2 + 3 * _t * _t * _u * _x3 + _t * _t * _t * x, _u * _u * _u * _y + 3 * _t * _u * _u * _y2 + 3 * _t * _t * _u * _y3 + _t * _t * _t * y);
      }

      refx = 2 * x - _x3;
      refy = 2 * y - _y3;

      head += 4;
    } else if (modeU === 'Q') {
      // quad bezier
      var _x4 = x;
      var _y4 = y;
      var _x5 = parseFloat(arr[head + 0]) + ax;
      var _y5 = parseFloat(arr[head + 1]) + ay;
      x = parseFloat(arr[head + 2]) + ax;
      y = parseFloat(arr[head + 3]) + ay;

      for (var _i2 = 0; _i2 < params.curveSegs; _i2++) {
        var _t2 = (_i2 + 1) / params.curveSegs;
        var _u2 = 1.0 - _t2;
        curPath.push(_u2 * _u2 * _x4 + 2 * _t2 * _u2 * _x5 + _t2 * _t2 * x, _u2 * _u2 * _y4 + 2 * _t2 * _u2 * _y5 + _t2 * _t2 * y);
      }

      refx = 2 * x - _x5;
      refy = 2 * y - _y5;

      head += 4;
    } else if (modeU === 'T') {
      // quad bezier, with reflection
      var _prevValid = prevModeU === 'Q' || prevModeU === 'T';
      if (!_prevValid) {
        console.warn('svgPath: Invalid T/t command use detected');
      }

      var _x6 = x;
      var _y6 = y;
      var _x7 = _prevValid ? refx : x;
      var _y7 = _prevValid ? refy : y;
      x = parseFloat(arr[head + 0]) + ax;
      y = parseFloat(arr[head + 1]) + ay;

      for (var _i3 = 0; _i3 < params.curveSegs; _i3++) {
        var _t3 = (_i3 + 1) / params.curveSegs;
        var _u3 = 1.0 - _t3;
        curPath.push(_u3 * _u3 * _x6 + 2 * _t3 * _u3 * _x7 + _t3 * _t3 * x, _u3 * _u3 * _y6 + 2 * _t3 * _u3 * _y7 + _t3 * _t3 * y);
      }

      refx = 2 * x - _x7;
      refy = 2 * y - _y7;

      head += 2;
    } else if (modeU === 'A') {
      // arc
      // THIS. IS. HELL.
      // ref: https://triple-underscore.github.io/SVG11/implnote.html#PathElementImplementationNotes

      var _x8 = x;
      var _y8 = y;
      var rx = Math.abs(parseFloat(arr[head + 0]));
      var ry = Math.abs(parseFloat(arr[head + 1]));
      var rot = parseFloat(arr[head + 2]);
      var large = arr[head + 3] !== "0";
      var sweep = arr[head + 4] !== "0";
      x = parseFloat(arr[head + 5]) + ax;
      y = parseFloat(arr[head + 6]) + ay;

      if (_x8 === x && _y8 === y) {// endpoints are same, will be omitted
        // do nothing
      } else if (rx === 0 || ry === 0) {
        // radius is 0, will be line
        curPath.push(x, y);
      } else {
        // hell
        var cosr = Math.cos(rot / 180 * Math.PI);
        var sinr = Math.sin(rot / 180 * Math.PI);

        var x0p = cosr * (_x8 - x) / 2 + sinr * (_y8 - y) / 2;
        var y0p = -sinr * (_x8 - x) / 2 + cosr * (_y8 - y) / 2;
        console.log(x0p, y0p);

        var lambda = x0p * x0p / (rx * rx) + y0p * y0p / (ry * ry);
        if (1.0 < lambda) {
          var k = Math.sqrt(lambda);
          rx *= rx;
          ry *= ry;
        }

        var t1 = rx * rx * y0p * y0p;
        var t2 = ry * ry * x0p * x0p;
        var ctp = Math.sqrt((rx * rx * ry * ry - t1 - t2) / (t1 + t2)) * (large === sweep ? -1 : 1);
        var cxp = ctp * rx * y0p / ry;
        var cyp = -ctp * ry * x0p / rx;
        console.log(cxp, cyp);

        var cx = cosr * cxp - sinr * cyp + (_x8 + x) / 2;
        var cy = sinr * cxp + cosr * cyp + (_y8 + y) / 2;
        console.log(cx, cy);

        var theta0 = Math.atan2((y0p - cyp) / ry, (x0p - cxp) / rx);
        var theta1 = Math.atan2((-y0p - cyp) / ry, (-x0p - cxp) / rx);
        if (theta1 < theta0 && sweep) {
          theta1 += Math.PI * 2.0;
        } else if (theta0 < theta1 && !sweep) {
          theta1 -= Math.PI * 2.0;
        }
        var dtheta = theta1 - theta0;
        console.log(theta0, theta1);

        for (var _i4 = 0; _i4 < params.curveSegs; _i4++) {
          var _t4 = (_i4 + 1) / params.curveSegs;
          var theta = theta0 + dtheta * _t4;

          var xf = rx * Math.cos(theta);
          var yf = ry * Math.sin(theta);

          curPath.push(cx + cosr * xf - sinr * yf, cy + sinr * xf + cosr * yf);
        }
      }

      head += 7;
    } else {
      // invalid
      console.warn('svgPath: Invalid command: ' + mode);
    }

    prevMode = mode;
    prevModeU = modeU;
  }

  return paths;
};

exports.default = svgPath;

},{}],"/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/vertphaser.js":[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var lerp = function lerp(a, b, x) {
  return a + (b - a) * x;
};
var dist = function dist(ax, ay, bx, by) {
  return Math.sqrt((bx - ax) * (bx - ax) + (by - ay) * (by - ay));
};

var VertPhaser = function () {
  function VertPhaser(_vert) {
    _classCallCheck(this, VertPhaser);

    var it = this;

    it.vert = _vert.concat();
    it.totalLength = 0.0;
    it.lengthMap = [];

    it.calcLength();
  }

  _createClass(VertPhaser, [{
    key: 'calcLength',
    value: function calcLength() {
      var it = this;

      it.totalLength = 0.0;
      it.lengthMap = [];

      for (var i = 0; i < it.vert.length / 2 - 1; i++) {
        var _l = dist(it.vert[i * 2 + 0], it.vert[i * 2 + 1], it.vert[i * 2 + 2], it.vert[i * 2 + 3]);
        it.totalLength += _l;
        it.lengthMap.push(_l);
      }

      var l = dist(it.vert[it.vert.length - 2], it.vert[it.vert.length - 1], it.vert[0], it.vert[1]);
      it.totalLength += l;
      it.lengthMap.push(l);
    }
  }, {
    key: 'getPhaseInfo',
    value: function getPhaseInfo(_phase) {
      var it = this;

      var phase = _phase % 1.0;
      var len = phase * it.totalLength;

      var i = 0;
      var psum = 0.0;
      var sum = 0.0;
      while (sum <= len) {
        psum = sum;
        sum += it.lengthMap[i];
        i++;
      }

      var p = (len - psum) / (sum - psum);
      var x = lerp(it.vert[i * 2 - 2], it.vert[(i * 2 + 0) % it.vert.length], p);
      var y = lerp(it.vert[i * 2 - 1], it.vert[(i * 2 + 1) % it.vert.length], p);

      return {
        phase: phase,
        length: len,
        i: i,
        x: x,
        y: y,
        p: p
      };
    }
  }, {
    key: 'do',
    value: function _do(_begin, _phase) {
      var it = this;

      var begin = it.getPhaseInfo(_begin);
      var end = it.getPhaseInfo(_begin + _phase);

      var ret = [begin.x, begin.y];
      if (begin.phase <= end.phase) {
        ret = ret.concat(it.vert.slice(begin.i * 2, end.i * 2));
      } else {
        ret = ret.concat(it.vert.slice(begin.i * 2));
        ret = ret.concat(it.vert.slice(0, end.i * 2));
      }
      ret.push(end.x, end.y);

      return ret;
    }
  }, {
    key: 'lofi',
    value: function lofi(_begin, _segs) {
      var it = this;

      var segs = _segs;
      if (segs < 1) {
        throw 'VertPhaser.lofi: segs < 1, it\'s invalid';
      }

      var begin = it.getPhaseInfo(_begin);

      var ret = [begin.x, begin.y];
      for (var i = 1; i < Math.floor(segs + 1); i++) {
        var p = _begin + i / segs;
        var seg = it.getPhaseInfo(p);
        ret.push(seg.x, seg.y);
      }
      ret.push(begin.x, begin.y);

      return ret;
    }
  }]);

  return VertPhaser;
}();

exports.default = VertPhaser;

},{}]},{},["/Users/Yutaka/Dropbox/pro/_Projects/_eom/20180330/src/script/main.js"])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb3BlbnR5cGUuanMvZGlzdC9vcGVudHlwZS5qcyIsInNyYy9zY3JpcHQvbGlicy9nbGNhdC1wYXRoLWd1aS5qcyIsInNyYy9zY3JpcHQvbGlicy9nbGNhdC1wYXRoLmpzIiwic3JjL3NjcmlwdC9saWJzL2dsY2F0LmpzIiwic3JjL3NjcmlwdC9saWJzL21hdGhjYXQuanMiLCJzcmMvc2NyaXB0L2xpYnMvc3RlcC5qcyIsInNyYy9zY3JpcHQvbGlicy90d2Vhay5qcyIsInNyYy9zY3JpcHQvbGlicy94b3JzaGlmdC5qcyIsInNyYy9zY3JpcHQvbWFpbi5qcyIsInNyYy9zY3JpcHQvcGF0aC1jb25zb2xlLmpzIiwic3JjL3NjcmlwdC9wYXRoLWdyaWQuanMiLCJzcmMvc2NyaXB0L3BhdGgtbG9maXBhdGguanMiLCJzcmMvc2NyaXB0L3BhdGgtcGllY2VzLmpzIiwic3JjL3NjcmlwdC9wYXRoLXBvc3RmeC5qcyIsInNyYy9zY3JpcHQvc3ZnLXBhdGguanMiLCJzcmMvc2NyaXB0L3ZlcnRwaGFzZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3dkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0Q7QUFDRCxVQUFJLElBQUosQ0FBVSxNQUFNLENBQWhCLEVBQW1CLE1BQU0sQ0FBekI7O0FBRUEsYUFBTyxHQUFQO0FBQ0Q7QUE5R0M7O0FBQUE7QUFBQSxHQUFKOztrQkFpSGUsVSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiAoYjY0Lmxlbmd0aCAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NClcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgaSwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG5cbiAgYXJyID0gbmV3IEFycigobGVuICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gNCkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIi8qKlxuICogaHR0cHM6Ly9vcGVudHlwZS5qcy5vcmcgdjAuOC4wIHwgKGMpIEZyZWRlcmlrIERlIEJsZXNlciBhbmQgb3RoZXIgY29udHJpYnV0b3JzIHwgTUlUIExpY2Vuc2UgfCBVc2VzIHRpbnktaW5mbGF0ZSBieSBEZXZvbiBHb3ZldHRcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChmYWN0b3J5KChnbG9iYWwub3BlbnR5cGUgPSBnbG9iYWwub3BlbnR5cGUgfHwge30pKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XG5cbnZhciBUSU5GX09LID0gMDtcbnZhciBUSU5GX0RBVEFfRVJST1IgPSAtMztcblxuZnVuY3Rpb24gVHJlZSgpIHtcbiAgdGhpcy50YWJsZSA9IG5ldyBVaW50MTZBcnJheSgxNik7ICAgLyogdGFibGUgb2YgY29kZSBsZW5ndGggY291bnRzICovXG4gIHRoaXMudHJhbnMgPSBuZXcgVWludDE2QXJyYXkoMjg4KTsgIC8qIGNvZGUgLT4gc3ltYm9sIHRyYW5zbGF0aW9uIHRhYmxlICovXG59XG5cbmZ1bmN0aW9uIERhdGEoc291cmNlLCBkZXN0KSB7XG4gIHRoaXMuc291cmNlID0gc291cmNlO1xuICB0aGlzLnNvdXJjZUluZGV4ID0gMDtcbiAgdGhpcy50YWcgPSAwO1xuICB0aGlzLmJpdGNvdW50ID0gMDtcbiAgXG4gIHRoaXMuZGVzdCA9IGRlc3Q7XG4gIHRoaXMuZGVzdExlbiA9IDA7XG4gIFxuICB0aGlzLmx0cmVlID0gbmV3IFRyZWUoKTsgIC8qIGR5bmFtaWMgbGVuZ3RoL3N5bWJvbCB0cmVlICovXG4gIHRoaXMuZHRyZWUgPSBuZXcgVHJlZSgpOyAgLyogZHluYW1pYyBkaXN0YW5jZSB0cmVlICovXG59XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG4gKiAtLSB1bmluaXRpYWxpemVkIGdsb2JhbCBkYXRhIChzdGF0aWMgc3RydWN0dXJlcykgLS0gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbnZhciBzbHRyZWUgPSBuZXcgVHJlZSgpO1xudmFyIHNkdHJlZSA9IG5ldyBUcmVlKCk7XG5cbi8qIGV4dHJhIGJpdHMgYW5kIGJhc2UgdGFibGVzIGZvciBsZW5ndGggY29kZXMgKi9cbnZhciBsZW5ndGhfYml0cyA9IG5ldyBVaW50OEFycmF5KDMwKTtcbnZhciBsZW5ndGhfYmFzZSA9IG5ldyBVaW50MTZBcnJheSgzMCk7XG5cbi8qIGV4dHJhIGJpdHMgYW5kIGJhc2UgdGFibGVzIGZvciBkaXN0YW5jZSBjb2RlcyAqL1xudmFyIGRpc3RfYml0cyA9IG5ldyBVaW50OEFycmF5KDMwKTtcbnZhciBkaXN0X2Jhc2UgPSBuZXcgVWludDE2QXJyYXkoMzApO1xuXG4vKiBzcGVjaWFsIG9yZGVyaW5nIG9mIGNvZGUgbGVuZ3RoIGNvZGVzICovXG52YXIgY2xjaWR4ID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAxNiwgMTcsIDE4LCAwLCA4LCA3LCA5LCA2LFxuICAxMCwgNSwgMTEsIDQsIDEyLCAzLCAxMywgMixcbiAgMTQsIDEsIDE1XG5dKTtcblxuLyogdXNlZCBieSB0aW5mX2RlY29kZV90cmVlcywgYXZvaWRzIGFsbG9jYXRpb25zIGV2ZXJ5IGNhbGwgKi9cbnZhciBjb2RlX3RyZWUgPSBuZXcgVHJlZSgpO1xudmFyIGxlbmd0aHMgPSBuZXcgVWludDhBcnJheSgyODggKyAzMik7XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICpcbiAqIC0tIHV0aWxpdHkgZnVuY3Rpb25zIC0tICpcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qIGJ1aWxkIGV4dHJhIGJpdHMgYW5kIGJhc2UgdGFibGVzICovXG5mdW5jdGlvbiB0aW5mX2J1aWxkX2JpdHNfYmFzZShiaXRzLCBiYXNlLCBkZWx0YSwgZmlyc3QpIHtcbiAgdmFyIGksIHN1bTtcblxuICAvKiBidWlsZCBiaXRzIHRhYmxlICovXG4gIGZvciAoaSA9IDA7IGkgPCBkZWx0YTsgKytpKSB7IGJpdHNbaV0gPSAwOyB9XG4gIGZvciAoaSA9IDA7IGkgPCAzMCAtIGRlbHRhOyArK2kpIHsgYml0c1tpICsgZGVsdGFdID0gaSAvIGRlbHRhIHwgMDsgfVxuXG4gIC8qIGJ1aWxkIGJhc2UgdGFibGUgKi9cbiAgZm9yIChzdW0gPSBmaXJzdCwgaSA9IDA7IGkgPCAzMDsgKytpKSB7XG4gICAgYmFzZVtpXSA9IHN1bTtcbiAgICBzdW0gKz0gMSA8PCBiaXRzW2ldO1xuICB9XG59XG5cbi8qIGJ1aWxkIHRoZSBmaXhlZCBodWZmbWFuIHRyZWVzICovXG5mdW5jdGlvbiB0aW5mX2J1aWxkX2ZpeGVkX3RyZWVzKGx0LCBkdCkge1xuICB2YXIgaTtcblxuICAvKiBidWlsZCBmaXhlZCBsZW5ndGggdHJlZSAqL1xuICBmb3IgKGkgPSAwOyBpIDwgNzsgKytpKSB7IGx0LnRhYmxlW2ldID0gMDsgfVxuXG4gIGx0LnRhYmxlWzddID0gMjQ7XG4gIGx0LnRhYmxlWzhdID0gMTUyO1xuICBsdC50YWJsZVs5XSA9IDExMjtcblxuICBmb3IgKGkgPSAwOyBpIDwgMjQ7ICsraSkgeyBsdC50cmFuc1tpXSA9IDI1NiArIGk7IH1cbiAgZm9yIChpID0gMDsgaSA8IDE0NDsgKytpKSB7IGx0LnRyYW5zWzI0ICsgaV0gPSBpOyB9XG4gIGZvciAoaSA9IDA7IGkgPCA4OyArK2kpIHsgbHQudHJhbnNbMjQgKyAxNDQgKyBpXSA9IDI4MCArIGk7IH1cbiAgZm9yIChpID0gMDsgaSA8IDExMjsgKytpKSB7IGx0LnRyYW5zWzI0ICsgMTQ0ICsgOCArIGldID0gMTQ0ICsgaTsgfVxuXG4gIC8qIGJ1aWxkIGZpeGVkIGRpc3RhbmNlIHRyZWUgKi9cbiAgZm9yIChpID0gMDsgaSA8IDU7ICsraSkgeyBkdC50YWJsZVtpXSA9IDA7IH1cblxuICBkdC50YWJsZVs1XSA9IDMyO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgKytpKSB7IGR0LnRyYW5zW2ldID0gaTsgfVxufVxuXG4vKiBnaXZlbiBhbiBhcnJheSBvZiBjb2RlIGxlbmd0aHMsIGJ1aWxkIGEgdHJlZSAqL1xudmFyIG9mZnMgPSBuZXcgVWludDE2QXJyYXkoMTYpO1xuXG5mdW5jdGlvbiB0aW5mX2J1aWxkX3RyZWUodCwgbGVuZ3Rocywgb2ZmLCBudW0pIHtcbiAgdmFyIGksIHN1bTtcblxuICAvKiBjbGVhciBjb2RlIGxlbmd0aCBjb3VudCB0YWJsZSAqL1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7ICsraSkgeyB0LnRhYmxlW2ldID0gMDsgfVxuXG4gIC8qIHNjYW4gc3ltYm9sIGxlbmd0aHMsIGFuZCBzdW0gY29kZSBsZW5ndGggY291bnRzICovXG4gIGZvciAoaSA9IDA7IGkgPCBudW07ICsraSkgeyB0LnRhYmxlW2xlbmd0aHNbb2ZmICsgaV1dKys7IH1cblxuICB0LnRhYmxlWzBdID0gMDtcblxuICAvKiBjb21wdXRlIG9mZnNldCB0YWJsZSBmb3IgZGlzdHJpYnV0aW9uIHNvcnQgKi9cbiAgZm9yIChzdW0gPSAwLCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICBvZmZzW2ldID0gc3VtO1xuICAgIHN1bSArPSB0LnRhYmxlW2ldO1xuICB9XG5cbiAgLyogY3JlYXRlIGNvZGUtPnN5bWJvbCB0cmFuc2xhdGlvbiB0YWJsZSAoc3ltYm9scyBzb3J0ZWQgYnkgY29kZSkgKi9cbiAgZm9yIChpID0gMDsgaSA8IG51bTsgKytpKSB7XG4gICAgaWYgKGxlbmd0aHNbb2ZmICsgaV0pIHsgdC50cmFuc1tvZmZzW2xlbmd0aHNbb2ZmICsgaV1dKytdID0gaTsgfVxuICB9XG59XG5cbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuICogLS0gZGVjb2RlIGZ1bmN0aW9ucyAtLSAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbi8qIGdldCBvbmUgYml0IGZyb20gc291cmNlIHN0cmVhbSAqL1xuZnVuY3Rpb24gdGluZl9nZXRiaXQoZCkge1xuICAvKiBjaGVjayBpZiB0YWcgaXMgZW1wdHkgKi9cbiAgaWYgKCFkLmJpdGNvdW50LS0pIHtcbiAgICAvKiBsb2FkIG5leHQgdGFnICovXG4gICAgZC50YWcgPSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4KytdO1xuICAgIGQuYml0Y291bnQgPSA3O1xuICB9XG5cbiAgLyogc2hpZnQgYml0IG91dCBvZiB0YWcgKi9cbiAgdmFyIGJpdCA9IGQudGFnICYgMTtcbiAgZC50YWcgPj4+PSAxO1xuXG4gIHJldHVybiBiaXQ7XG59XG5cbi8qIHJlYWQgYSBudW0gYml0IHZhbHVlIGZyb20gYSBzdHJlYW0gYW5kIGFkZCBiYXNlICovXG5mdW5jdGlvbiB0aW5mX3JlYWRfYml0cyhkLCBudW0sIGJhc2UpIHtcbiAgaWYgKCFudW0pXG4gICAgeyByZXR1cm4gYmFzZTsgfVxuXG4gIHdoaWxlIChkLmJpdGNvdW50IDwgMjQpIHtcbiAgICBkLnRhZyB8PSBkLnNvdXJjZVtkLnNvdXJjZUluZGV4KytdIDw8IGQuYml0Y291bnQ7XG4gICAgZC5iaXRjb3VudCArPSA4O1xuICB9XG5cbiAgdmFyIHZhbCA9IGQudGFnICYgKDB4ZmZmZiA+Pj4gKDE2IC0gbnVtKSk7XG4gIGQudGFnID4+Pj0gbnVtO1xuICBkLmJpdGNvdW50IC09IG51bTtcbiAgcmV0dXJuIHZhbCArIGJhc2U7XG59XG5cbi8qIGdpdmVuIGEgZGF0YSBzdHJlYW0gYW5kIGEgdHJlZSwgZGVjb2RlIGEgc3ltYm9sICovXG5mdW5jdGlvbiB0aW5mX2RlY29kZV9zeW1ib2woZCwgdCkge1xuICB3aGlsZSAoZC5iaXRjb3VudCA8IDI0KSB7XG4gICAgZC50YWcgfD0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCsrXSA8PCBkLmJpdGNvdW50O1xuICAgIGQuYml0Y291bnQgKz0gODtcbiAgfVxuICBcbiAgdmFyIHN1bSA9IDAsIGN1ciA9IDAsIGxlbiA9IDA7XG4gIHZhciB0YWcgPSBkLnRhZztcblxuICAvKiBnZXQgbW9yZSBiaXRzIHdoaWxlIGNvZGUgdmFsdWUgaXMgYWJvdmUgc3VtICovXG4gIGRvIHtcbiAgICBjdXIgPSAyICogY3VyICsgKHRhZyAmIDEpO1xuICAgIHRhZyA+Pj49IDE7XG4gICAgKytsZW47XG5cbiAgICBzdW0gKz0gdC50YWJsZVtsZW5dO1xuICAgIGN1ciAtPSB0LnRhYmxlW2xlbl07XG4gIH0gd2hpbGUgKGN1ciA+PSAwKTtcbiAgXG4gIGQudGFnID0gdGFnO1xuICBkLmJpdGNvdW50IC09IGxlbjtcblxuICByZXR1cm4gdC50cmFuc1tzdW0gKyBjdXJdO1xufVxuXG4vKiBnaXZlbiBhIGRhdGEgc3RyZWFtLCBkZWNvZGUgZHluYW1pYyB0cmVlcyBmcm9tIGl0ICovXG5mdW5jdGlvbiB0aW5mX2RlY29kZV90cmVlcyhkLCBsdCwgZHQpIHtcbiAgdmFyIGhsaXQsIGhkaXN0LCBoY2xlbjtcbiAgdmFyIGksIG51bSwgbGVuZ3RoO1xuXG4gIC8qIGdldCA1IGJpdHMgSExJVCAoMjU3LTI4NikgKi9cbiAgaGxpdCA9IHRpbmZfcmVhZF9iaXRzKGQsIDUsIDI1Nyk7XG5cbiAgLyogZ2V0IDUgYml0cyBIRElTVCAoMS0zMikgKi9cbiAgaGRpc3QgPSB0aW5mX3JlYWRfYml0cyhkLCA1LCAxKTtcblxuICAvKiBnZXQgNCBiaXRzIEhDTEVOICg0LTE5KSAqL1xuICBoY2xlbiA9IHRpbmZfcmVhZF9iaXRzKGQsIDQsIDQpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAxOTsgKytpKSB7IGxlbmd0aHNbaV0gPSAwOyB9XG5cbiAgLyogcmVhZCBjb2RlIGxlbmd0aHMgZm9yIGNvZGUgbGVuZ3RoIGFscGhhYmV0ICovXG4gIGZvciAoaSA9IDA7IGkgPCBoY2xlbjsgKytpKSB7XG4gICAgLyogZ2V0IDMgYml0cyBjb2RlIGxlbmd0aCAoMC03KSAqL1xuICAgIHZhciBjbGVuID0gdGluZl9yZWFkX2JpdHMoZCwgMywgMCk7XG4gICAgbGVuZ3Roc1tjbGNpZHhbaV1dID0gY2xlbjtcbiAgfVxuXG4gIC8qIGJ1aWxkIGNvZGUgbGVuZ3RoIHRyZWUgKi9cbiAgdGluZl9idWlsZF90cmVlKGNvZGVfdHJlZSwgbGVuZ3RocywgMCwgMTkpO1xuXG4gIC8qIGRlY29kZSBjb2RlIGxlbmd0aHMgZm9yIHRoZSBkeW5hbWljIHRyZWVzICovXG4gIGZvciAobnVtID0gMDsgbnVtIDwgaGxpdCArIGhkaXN0Oykge1xuICAgIHZhciBzeW0gPSB0aW5mX2RlY29kZV9zeW1ib2woZCwgY29kZV90cmVlKTtcblxuICAgIHN3aXRjaCAoc3ltKSB7XG4gICAgICBjYXNlIDE2OlxuICAgICAgICAvKiBjb3B5IHByZXZpb3VzIGNvZGUgbGVuZ3RoIDMtNiB0aW1lcyAocmVhZCAyIGJpdHMpICovXG4gICAgICAgIHZhciBwcmV2ID0gbGVuZ3Roc1tudW0gLSAxXTtcbiAgICAgICAgZm9yIChsZW5ndGggPSB0aW5mX3JlYWRfYml0cyhkLCAyLCAzKTsgbGVuZ3RoOyAtLWxlbmd0aCkge1xuICAgICAgICAgIGxlbmd0aHNbbnVtKytdID0gcHJldjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTc6XG4gICAgICAgIC8qIHJlcGVhdCBjb2RlIGxlbmd0aCAwIGZvciAzLTEwIHRpbWVzIChyZWFkIDMgYml0cykgKi9cbiAgICAgICAgZm9yIChsZW5ndGggPSB0aW5mX3JlYWRfYml0cyhkLCAzLCAzKTsgbGVuZ3RoOyAtLWxlbmd0aCkge1xuICAgICAgICAgIGxlbmd0aHNbbnVtKytdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTg6XG4gICAgICAgIC8qIHJlcGVhdCBjb2RlIGxlbmd0aCAwIGZvciAxMS0xMzggdGltZXMgKHJlYWQgNyBiaXRzKSAqL1xuICAgICAgICBmb3IgKGxlbmd0aCA9IHRpbmZfcmVhZF9iaXRzKGQsIDcsIDExKTsgbGVuZ3RoOyAtLWxlbmd0aCkge1xuICAgICAgICAgIGxlbmd0aHNbbnVtKytdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8qIHZhbHVlcyAwLTE1IHJlcHJlc2VudCB0aGUgYWN0dWFsIGNvZGUgbGVuZ3RocyAqL1xuICAgICAgICBsZW5ndGhzW251bSsrXSA9IHN5bTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyogYnVpbGQgZHluYW1pYyB0cmVlcyAqL1xuICB0aW5mX2J1aWxkX3RyZWUobHQsIGxlbmd0aHMsIDAsIGhsaXQpO1xuICB0aW5mX2J1aWxkX3RyZWUoZHQsIGxlbmd0aHMsIGhsaXQsIGhkaXN0KTtcbn1cblxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKlxuICogLS0gYmxvY2sgaW5mbGF0ZSBmdW5jdGlvbnMgLS0gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuLyogZ2l2ZW4gYSBzdHJlYW0gYW5kIHR3byB0cmVlcywgaW5mbGF0ZSBhIGJsb2NrIG9mIGRhdGEgKi9cbmZ1bmN0aW9uIHRpbmZfaW5mbGF0ZV9ibG9ja19kYXRhKGQsIGx0LCBkdCkge1xuICB3aGlsZSAoMSkge1xuICAgIHZhciBzeW0gPSB0aW5mX2RlY29kZV9zeW1ib2woZCwgbHQpO1xuXG4gICAgLyogY2hlY2sgZm9yIGVuZCBvZiBibG9jayAqL1xuICAgIGlmIChzeW0gPT09IDI1Nikge1xuICAgICAgcmV0dXJuIFRJTkZfT0s7XG4gICAgfVxuXG4gICAgaWYgKHN5bSA8IDI1Nikge1xuICAgICAgZC5kZXN0W2QuZGVzdExlbisrXSA9IHN5bTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlbmd0aCwgZGlzdCwgb2ZmcztcbiAgICAgIHZhciBpO1xuXG4gICAgICBzeW0gLT0gMjU3O1xuXG4gICAgICAvKiBwb3NzaWJseSBnZXQgbW9yZSBiaXRzIGZyb20gbGVuZ3RoIGNvZGUgKi9cbiAgICAgIGxlbmd0aCA9IHRpbmZfcmVhZF9iaXRzKGQsIGxlbmd0aF9iaXRzW3N5bV0sIGxlbmd0aF9iYXNlW3N5bV0pO1xuXG4gICAgICBkaXN0ID0gdGluZl9kZWNvZGVfc3ltYm9sKGQsIGR0KTtcblxuICAgICAgLyogcG9zc2libHkgZ2V0IG1vcmUgYml0cyBmcm9tIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgIG9mZnMgPSBkLmRlc3RMZW4gLSB0aW5mX3JlYWRfYml0cyhkLCBkaXN0X2JpdHNbZGlzdF0sIGRpc3RfYmFzZVtkaXN0XSk7XG5cbiAgICAgIC8qIGNvcHkgbWF0Y2ggKi9cbiAgICAgIGZvciAoaSA9IG9mZnM7IGkgPCBvZmZzICsgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZC5kZXN0W2QuZGVzdExlbisrXSA9IGQuZGVzdFtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogaW5mbGF0ZSBhbiB1bmNvbXByZXNzZWQgYmxvY2sgb2YgZGF0YSAqL1xuZnVuY3Rpb24gdGluZl9pbmZsYXRlX3VuY29tcHJlc3NlZF9ibG9jayhkKSB7XG4gIHZhciBsZW5ndGgsIGludmxlbmd0aDtcbiAgdmFyIGk7XG4gIFxuICAvKiB1bnJlYWQgZnJvbSBiaXRidWZmZXIgKi9cbiAgd2hpbGUgKGQuYml0Y291bnQgPiA4KSB7XG4gICAgZC5zb3VyY2VJbmRleC0tO1xuICAgIGQuYml0Y291bnQgLT0gODtcbiAgfVxuXG4gIC8qIGdldCBsZW5ndGggKi9cbiAgbGVuZ3RoID0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCArIDFdO1xuICBsZW5ndGggPSAyNTYgKiBsZW5ndGggKyBkLnNvdXJjZVtkLnNvdXJjZUluZGV4XTtcblxuICAvKiBnZXQgb25lJ3MgY29tcGxlbWVudCBvZiBsZW5ndGggKi9cbiAgaW52bGVuZ3RoID0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCArIDNdO1xuICBpbnZsZW5ndGggPSAyNTYgKiBpbnZsZW5ndGggKyBkLnNvdXJjZVtkLnNvdXJjZUluZGV4ICsgMl07XG5cbiAgLyogY2hlY2sgbGVuZ3RoICovXG4gIGlmIChsZW5ndGggIT09ICh+aW52bGVuZ3RoICYgMHgwMDAwZmZmZikpXG4gICAgeyByZXR1cm4gVElORl9EQVRBX0VSUk9SOyB9XG5cbiAgZC5zb3VyY2VJbmRleCArPSA0O1xuXG4gIC8qIGNvcHkgYmxvY2sgKi9cbiAgZm9yIChpID0gbGVuZ3RoOyBpOyAtLWkpXG4gICAgeyBkLmRlc3RbZC5kZXN0TGVuKytdID0gZC5zb3VyY2VbZC5zb3VyY2VJbmRleCsrXTsgfVxuXG4gIC8qIG1ha2Ugc3VyZSB3ZSBzdGFydCBuZXh0IGJsb2NrIG9uIGEgYnl0ZSBib3VuZGFyeSAqL1xuICBkLmJpdGNvdW50ID0gMDtcblxuICByZXR1cm4gVElORl9PSztcbn1cblxuLyogaW5mbGF0ZSBzdHJlYW0gZnJvbSBzb3VyY2UgdG8gZGVzdCAqL1xuZnVuY3Rpb24gdGluZl91bmNvbXByZXNzKHNvdXJjZSwgZGVzdCkge1xuICB2YXIgZCA9IG5ldyBEYXRhKHNvdXJjZSwgZGVzdCk7XG4gIHZhciBiZmluYWwsIGJ0eXBlLCByZXM7XG5cbiAgZG8ge1xuICAgIC8qIHJlYWQgZmluYWwgYmxvY2sgZmxhZyAqL1xuICAgIGJmaW5hbCA9IHRpbmZfZ2V0Yml0KGQpO1xuXG4gICAgLyogcmVhZCBibG9jayB0eXBlICgyIGJpdHMpICovXG4gICAgYnR5cGUgPSB0aW5mX3JlYWRfYml0cyhkLCAyLCAwKTtcblxuICAgIC8qIGRlY29tcHJlc3MgYmxvY2sgKi9cbiAgICBzd2l0Y2ggKGJ0eXBlKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIC8qIGRlY29tcHJlc3MgdW5jb21wcmVzc2VkIGJsb2NrICovXG4gICAgICAgIHJlcyA9IHRpbmZfaW5mbGF0ZV91bmNvbXByZXNzZWRfYmxvY2soZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICAvKiBkZWNvbXByZXNzIGJsb2NrIHdpdGggZml4ZWQgaHVmZm1hbiB0cmVlcyAqL1xuICAgICAgICByZXMgPSB0aW5mX2luZmxhdGVfYmxvY2tfZGF0YShkLCBzbHRyZWUsIHNkdHJlZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICAvKiBkZWNvbXByZXNzIGJsb2NrIHdpdGggZHluYW1pYyBodWZmbWFuIHRyZWVzICovXG4gICAgICAgIHRpbmZfZGVjb2RlX3RyZWVzKGQsIGQubHRyZWUsIGQuZHRyZWUpO1xuICAgICAgICByZXMgPSB0aW5mX2luZmxhdGVfYmxvY2tfZGF0YShkLCBkLmx0cmVlLCBkLmR0cmVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXMgPSBUSU5GX0RBVEFfRVJST1I7XG4gICAgfVxuXG4gICAgaWYgKHJlcyAhPT0gVElORl9PSylcbiAgICAgIHsgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGVycm9yJyk7IH1cblxuICB9IHdoaWxlICghYmZpbmFsKTtcblxuICBpZiAoZC5kZXN0TGVuIDwgZC5kZXN0Lmxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgZC5kZXN0LnNsaWNlID09PSAnZnVuY3Rpb24nKVxuICAgICAgeyByZXR1cm4gZC5kZXN0LnNsaWNlKDAsIGQuZGVzdExlbik7IH1cbiAgICBlbHNlXG4gICAgICB7IHJldHVybiBkLmRlc3Quc3ViYXJyYXkoMCwgZC5kZXN0TGVuKTsgfVxuICB9XG4gIFxuICByZXR1cm4gZC5kZXN0O1xufVxuXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLSAqXG4gKiAtLSBpbml0aWFsaXphdGlvbiAtLSAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG4vKiBidWlsZCBmaXhlZCBodWZmbWFuIHRyZWVzICovXG50aW5mX2J1aWxkX2ZpeGVkX3RyZWVzKHNsdHJlZSwgc2R0cmVlKTtcblxuLyogYnVpbGQgZXh0cmEgYml0cyBhbmQgYmFzZSB0YWJsZXMgKi9cbnRpbmZfYnVpbGRfYml0c19iYXNlKGxlbmd0aF9iaXRzLCBsZW5ndGhfYmFzZSwgNCwgMyk7XG50aW5mX2J1aWxkX2JpdHNfYmFzZShkaXN0X2JpdHMsIGRpc3RfYmFzZSwgMiwgMSk7XG5cbi8qIGZpeCBhIHNwZWNpYWwgY2FzZSAqL1xubGVuZ3RoX2JpdHNbMjhdID0gMDtcbmxlbmd0aF9iYXNlWzI4XSA9IDI1ODtcblxudmFyIHRpbnlJbmZsYXRlID0gdGluZl91bmNvbXByZXNzO1xuXG4vLyBUaGUgQm91bmRpbmcgQm94IG9iamVjdFxuXG5mdW5jdGlvbiBkZXJpdmUodjAsIHYxLCB2MiwgdjMsIHQpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMSAtIHQsIDMpICogdjAgK1xuICAgICAgICAzICogTWF0aC5wb3coMSAtIHQsIDIpICogdCAqIHYxICtcbiAgICAgICAgMyAqICgxIC0gdCkgKiBNYXRoLnBvdyh0LCAyKSAqIHYyICtcbiAgICAgICAgTWF0aC5wb3codCwgMykgKiB2Mztcbn1cbi8qKlxuICogQSBib3VuZGluZyBib3ggaXMgYW4gZW5jbG9zaW5nIGJveCB0aGF0IGRlc2NyaWJlcyB0aGUgc21hbGxlc3QgbWVhc3VyZSB3aXRoaW4gd2hpY2ggYWxsIHRoZSBwb2ludHMgbGllLlxuICogSXQgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlIGJvdW5kaW5nIGJveCBvZiBhIGdseXBoIG9yIHRleHQgcGF0aC5cbiAqXG4gKiBPbiBpbml0aWFsaXphdGlvbiwgeDEveTEveDIveTIgd2lsbCBiZSBOYU4uIENoZWNrIGlmIHRoZSBib3VuZGluZyBib3ggaXMgZW1wdHkgdXNpbmcgYGlzRW1wdHkoKWAuXG4gKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuQm91bmRpbmdCb3hcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJvdW5kaW5nQm94KCkge1xuICAgIHRoaXMueDEgPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMueTEgPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMueDIgPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMueTIgPSBOdW1iZXIuTmFOO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYm91bmRpbmcgYm94IGlzIGVtcHR5LCB0aGF0IGlzLCBubyBwb2ludHMgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBib3ggeWV0LlxuICovXG5Cb3VuZGluZ0JveC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpc05hTih0aGlzLngxKSB8fCBpc05hTih0aGlzLnkxKSB8fCBpc05hTih0aGlzLngyKSB8fCBpc05hTih0aGlzLnkyKTtcbn07XG5cbi8qKlxuICogQWRkIHRoZSBwb2ludCB0byB0aGUgYm91bmRpbmcgYm94LlxuICogVGhlIHgxL3kxL3gyL3kyIGNvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGluZyBib3ggd2lsbCBub3cgZW5jb21wYXNzIHRoZSBnaXZlbiBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50LlxuICovXG5Cb3VuZGluZ0JveC5wcm90b3R5cGUuYWRkUG9pbnQgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoaXNOYU4odGhpcy54MSkgfHwgaXNOYU4odGhpcy54MikpIHtcbiAgICAgICAgICAgIHRoaXMueDEgPSB4O1xuICAgICAgICAgICAgdGhpcy54MiA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPCB0aGlzLngxKSB7XG4gICAgICAgICAgICB0aGlzLngxID0geDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA+IHRoaXMueDIpIHtcbiAgICAgICAgICAgIHRoaXMueDIgPSB4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGlzTmFOKHRoaXMueTEpIHx8IGlzTmFOKHRoaXMueTIpKSB7XG4gICAgICAgICAgICB0aGlzLnkxID0geTtcbiAgICAgICAgICAgIHRoaXMueTIgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh5IDwgdGhpcy55MSkge1xuICAgICAgICAgICAgdGhpcy55MSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPiB0aGlzLnkyKSB7XG4gICAgICAgICAgICB0aGlzLnkyID0geTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIGEgWCBjb29yZGluYXRlIHRvIHRoZSBib3VuZGluZyBib3guXG4gKiBUaGlzIGV4dGVuZHMgdGhlIGJvdW5kaW5nIGJveCB0byBpbmNsdWRlIHRoZSBYIGNvb3JkaW5hdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW50ZXJuYWxseSBpbnNpZGUgb2YgYWRkQmV6aWVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludC5cbiAqL1xuQm91bmRpbmdCb3gucHJvdG90eXBlLmFkZFggPSBmdW5jdGlvbih4KSB7XG4gICAgdGhpcy5hZGRQb2ludCh4LCBudWxsKTtcbn07XG5cbi8qKlxuICogQWRkIGEgWSBjb29yZGluYXRlIHRvIHRoZSBib3VuZGluZyBib3guXG4gKiBUaGlzIGV4dGVuZHMgdGhlIGJvdW5kaW5nIGJveCB0byBpbmNsdWRlIHRoZSBZIGNvb3JkaW5hdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgaW50ZXJuYWxseSBpbnNpZGUgb2YgYWRkQmV6aWVyLlxuICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludC5cbiAqL1xuQm91bmRpbmdCb3gucHJvdG90eXBlLmFkZFkgPSBmdW5jdGlvbih5KSB7XG4gICAgdGhpcy5hZGRQb2ludChudWxsLCB5KTtcbn07XG5cbi8qKlxuICogQWRkIGEgQsOpemllciBjdXJ2ZSB0byB0aGUgYm91bmRpbmcgYm94LlxuICogVGhpcyBleHRlbmRzIHRoZSBib3VuZGluZyBib3ggdG8gaW5jbHVkZSB0aGUgZW50aXJlIELDqXppZXIuXG4gKiBAcGFyYW0ge251bWJlcn0geDAgLSBUaGUgc3RhcnRpbmcgWCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkwIC0gVGhlIHN0YXJ0aW5nIFkgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MSAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geTEgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBmaXJzdCBjb250cm9sIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHgyIC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geTIgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBzZWNvbmQgY29udHJvbCBwb2ludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGVuZGluZyBYIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBlbmRpbmcgWSBjb29yZGluYXRlLlxuICovXG5Cb3VuZGluZ0JveC5wcm90b3R5cGUuYWRkQmV6aWVyID0gZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeCwgeSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgLy8gVGhpcyBjb2RlIGlzIGJhc2VkIG9uIGh0dHA6Ly9uaXNoaW9oaXJva2F6dS5ibG9nc3BvdC5jb20vMjAwOS8wNi9ob3ctdG8tY2FsY3VsYXRlLWJlemllci1jdXJ2ZXMtYm91bmRpbmcuaHRtbFxuICAgIC8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vaWNvbnM4L3N2Zy1wYXRoLWJvdW5kaW5nLWJveFxuXG4gICAgdmFyIHAwID0gW3gwLCB5MF07XG4gICAgdmFyIHAxID0gW3gxLCB5MV07XG4gICAgdmFyIHAyID0gW3gyLCB5Ml07XG4gICAgdmFyIHAzID0gW3gsIHldO1xuXG4gICAgdGhpcy5hZGRQb2ludCh4MCwgeTApO1xuICAgIHRoaXMuYWRkUG9pbnQoeCwgeSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAxOyBpKyspIHtcbiAgICAgICAgdmFyIGIgPSA2ICogcDBbaV0gLSAxMiAqIHAxW2ldICsgNiAqIHAyW2ldO1xuICAgICAgICB2YXIgYSA9IC0zICogcDBbaV0gKyA5ICogcDFbaV0gLSA5ICogcDJbaV0gKyAzICogcDNbaV07XG4gICAgICAgIHZhciBjID0gMyAqIHAxW2ldIC0gMyAqIHAwW2ldO1xuXG4gICAgICAgIGlmIChhID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoYiA9PT0gMCkgeyBjb250aW51ZTsgfVxuICAgICAgICAgICAgdmFyIHQgPSAtYyAvIGI7XG4gICAgICAgICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkgeyB0aGlzJDEuYWRkWChkZXJpdmUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQpKTsgfVxuICAgICAgICAgICAgICAgIGlmIChpID09PSAxKSB7IHRoaXMkMS5hZGRZKGRlcml2ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdCkpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBiMmFjID0gTWF0aC5wb3coYiwgMikgLSA0ICogYyAqIGE7XG4gICAgICAgIGlmIChiMmFjIDwgMCkgeyBjb250aW51ZTsgfVxuICAgICAgICB2YXIgdDEgPSAoLWIgKyBNYXRoLnNxcnQoYjJhYykpIC8gKDIgKiBhKTtcbiAgICAgICAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7IHRoaXMkMS5hZGRYKGRlcml2ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdDEpKTsgfVxuICAgICAgICAgICAgaWYgKGkgPT09IDEpIHsgdGhpcyQxLmFkZFkoZGVyaXZlKHAwW2ldLCBwMVtpXSwgcDJbaV0sIHAzW2ldLCB0MSkpOyB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQyID0gKC1iIC0gTWF0aC5zcXJ0KGIyYWMpKSAvICgyICogYSk7XG4gICAgICAgIGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgeyB0aGlzJDEuYWRkWChkZXJpdmUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQyKSk7IH1cbiAgICAgICAgICAgIGlmIChpID09PSAxKSB7IHRoaXMkMS5hZGRZKGRlcml2ZShwMFtpXSwgcDFbaV0sIHAyW2ldLCBwM1tpXSwgdDIpKTsgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBBZGQgYSBxdWFkcmF0aWMgY3VydmUgdG8gdGhlIGJvdW5kaW5nIGJveC5cbiAqIFRoaXMgZXh0ZW5kcyB0aGUgYm91bmRpbmcgYm94IHRvIGluY2x1ZGUgdGhlIGVudGlyZSBxdWFkcmF0aWMgY3VydmUuXG4gKiBAcGFyYW0ge251bWJlcn0geDAgLSBUaGUgc3RhcnRpbmcgWCBjb29yZGluYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IHkwIC0gVGhlIHN0YXJ0aW5nIFkgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4MSAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNvbnRyb2wgcG9pbnQuXG4gKiBAcGFyYW0ge251bWJlcn0geTEgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjb250cm9sIHBvaW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgZW5kaW5nIFggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIGVuZGluZyBZIGNvb3JkaW5hdGUuXG4gKi9cbkJvdW5kaW5nQm94LnByb3RvdHlwZS5hZGRRdWFkID0gZnVuY3Rpb24oeDAsIHkwLCB4MSwgeTEsIHgsIHkpIHtcbiAgICB2YXIgY3AxeCA9IHgwICsgMiAvIDMgKiAoeDEgLSB4MCk7XG4gICAgdmFyIGNwMXkgPSB5MCArIDIgLyAzICogKHkxIC0geTApO1xuICAgIHZhciBjcDJ4ID0gY3AxeCArIDEgLyAzICogKHggLSB4MCk7XG4gICAgdmFyIGNwMnkgPSBjcDF5ICsgMSAvIDMgKiAoeSAtIHkwKTtcbiAgICB0aGlzLmFkZEJlemllcih4MCwgeTAsIGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpO1xufTtcblxuLy8gR2VvbWV0cmljIG9iamVjdHNcblxuLyoqXG4gKiBBIGLDqXppZXIgcGF0aCBjb250YWluaW5nIGEgc2V0IG9mIHBhdGggY29tbWFuZHMgc2ltaWxhciB0byBhIFNWRyBwYXRoLlxuICogUGF0aHMgY2FuIGJlIGRyYXduIG9uIGEgY29udGV4dCB1c2luZyBgZHJhd2AuXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5QYXRoXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQYXRoKCkge1xuICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICB0aGlzLmZpbGwgPSAnYmxhY2snO1xuICAgIHRoaXMuc3Ryb2tlID0gbnVsbDtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSAge251bWJlcn0geVxuICovXG5QYXRoLnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ00nLFxuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0geFxuICogQHBhcmFtICB7bnVtYmVyfSB5XG4gKi9cblBhdGgucHJvdG90eXBlLmxpbmVUbyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLmNvbW1hbmRzLnB1c2goe1xuICAgICAgICB0eXBlOiAnTCcsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRHJhd3MgY3ViaWMgY3VydmVcbiAqIEBmdW5jdGlvblxuICogY3VydmVUb1xuICogQG1lbWJlcm9mIG9wZW50eXBlLlBhdGgucHJvdG90eXBlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgxIC0geCBvZiBjb250cm9sIDFcbiAqIEBwYXJhbSAge251bWJlcn0geTEgLSB5IG9mIGNvbnRyb2wgMVxuICogQHBhcmFtICB7bnVtYmVyfSB4MiAtIHggb2YgY29udHJvbCAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkyIC0geSBvZiBjb250cm9sIDJcbiAqIEBwYXJhbSAge251bWJlcn0geCAtIHggb2YgcGF0aCBwb2ludFxuICogQHBhcmFtICB7bnVtYmVyfSB5IC0geSBvZiBwYXRoIHBvaW50XG4gKi9cblxuLyoqXG4gKiBEcmF3cyBjdWJpYyBjdXJ2ZVxuICogQGZ1bmN0aW9uXG4gKiBiZXppZXJDdXJ2ZVRvXG4gKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcbiAqIEBwYXJhbSAge251bWJlcn0geDEgLSB4IG9mIGNvbnRyb2wgMVxuICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbCAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHgyIC0geCBvZiBjb250cm9sIDJcbiAqIEBwYXJhbSAge251bWJlcn0geTIgLSB5IG9mIGNvbnRyb2wgMlxuICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcbiAqIEBzZWUgY3VydmVUb1xuICovXG5QYXRoLnByb3RvdHlwZS5jdXJ2ZVRvID0gUGF0aC5wcm90b3R5cGUuYmV6aWVyQ3VydmVUbyA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ0MnLFxuICAgICAgICB4MTogeDEsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeDI6IHgyLFxuICAgICAgICB5MjogeTIsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRHJhd3MgcXVhZHJhdGljIGN1cnZlXG4gKiBAZnVuY3Rpb25cbiAqIHF1YWRyYXRpY0N1cnZlVG9cbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbFxuICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbFxuICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcbiAqL1xuXG4vKipcbiAqIERyYXdzIHF1YWRyYXRpYyBjdXJ2ZVxuICogQGZ1bmN0aW9uXG4gKiBxdWFkVG9cbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICogQHBhcmFtICB7bnVtYmVyfSB4MSAtIHggb2YgY29udHJvbFxuICogQHBhcmFtICB7bnVtYmVyfSB5MSAtIHkgb2YgY29udHJvbFxuICogQHBhcmFtICB7bnVtYmVyfSB4IC0geCBvZiBwYXRoIHBvaW50XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHkgLSB5IG9mIHBhdGggcG9pbnRcbiAqL1xuUGF0aC5wcm90b3R5cGUucXVhZFRvID0gUGF0aC5wcm90b3R5cGUucXVhZHJhdGljQ3VydmVUbyA9IGZ1bmN0aW9uKHgxLCB5MSwgeCwgeSkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdRJyxcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB5MTogeTEsXG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHlcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBwYXRoXG4gKiBAZnVuY3Rpb24gY2xvc2VQYXRoXG4gKiBAbWVtYmVyb2Ygb3BlbnR5cGUuUGF0aC5wcm90b3R5cGVcbiAqL1xuXG4vKipcbiAqIENsb3NlIHRoZSBwYXRoXG4gKiBAZnVuY3Rpb24gY2xvc2VcbiAqIEBtZW1iZXJvZiBvcGVudHlwZS5QYXRoLnByb3RvdHlwZVxuICovXG5QYXRoLnByb3RvdHlwZS5jbG9zZSA9IFBhdGgucHJvdG90eXBlLmNsb3NlUGF0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdaJ1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHBhdGggb3IgbGlzdCBvZiBjb21tYW5kcyB0byB0aGUgY29tbWFuZHMgb2YgdGhpcyBwYXRoLlxuICogQHBhcmFtICB7QXJyYXl9IHBhdGhPckNvbW1hbmRzIC0gYW5vdGhlciBvcGVudHlwZS5QYXRoLCBhbiBvcGVudHlwZS5Cb3VuZGluZ0JveCwgb3IgYW4gYXJyYXkgb2YgY29tbWFuZHMuXG4gKi9cblBhdGgucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKHBhdGhPckNvbW1hbmRzKSB7XG4gICAgaWYgKHBhdGhPckNvbW1hbmRzLmNvbW1hbmRzKSB7XG4gICAgICAgIHBhdGhPckNvbW1hbmRzID0gcGF0aE9yQ29tbWFuZHMuY29tbWFuZHM7XG4gICAgfSBlbHNlIGlmIChwYXRoT3JDb21tYW5kcyBpbnN0YW5jZW9mIEJvdW5kaW5nQm94KSB7XG4gICAgICAgIHZhciBib3ggPSBwYXRoT3JDb21tYW5kcztcbiAgICAgICAgdGhpcy5tb3ZlVG8oYm94LngxLCBib3gueTEpO1xuICAgICAgICB0aGlzLmxpbmVUbyhib3gueDIsIGJveC55MSk7XG4gICAgICAgIHRoaXMubGluZVRvKGJveC54MiwgYm94LnkyKTtcbiAgICAgICAgdGhpcy5saW5lVG8oYm94LngxLCBib3gueTIpO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLmNvbW1hbmRzLCBwYXRoT3JDb21tYW5kcyk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBwYXRoLlxuICogQHJldHVybnMge29wZW50eXBlLkJvdW5kaW5nQm94fVxuICovXG5QYXRoLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGJveCA9IG5ldyBCb3VuZGluZ0JveCgpO1xuXG4gICAgdmFyIHN0YXJ0WCA9IDA7XG4gICAgdmFyIHN0YXJ0WSA9IDA7XG4gICAgdmFyIHByZXZYID0gMDtcbiAgICB2YXIgcHJldlkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb21tYW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY21kID0gdGhpcyQxLmNvbW1hbmRzW2ldO1xuICAgICAgICBzd2l0Y2ggKGNtZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICBib3guYWRkUG9pbnQoY21kLngsIGNtZC55KTtcbiAgICAgICAgICAgICAgICBzdGFydFggPSBwcmV2WCA9IGNtZC54O1xuICAgICAgICAgICAgICAgIHN0YXJ0WSA9IHByZXZZID0gY21kLnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICAgICAgICBib3guYWRkUG9pbnQoY21kLngsIGNtZC55KTtcbiAgICAgICAgICAgICAgICBwcmV2WCA9IGNtZC54O1xuICAgICAgICAgICAgICAgIHByZXZZID0gY21kLnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICAgICAgICBib3guYWRkUXVhZChwcmV2WCwgcHJldlksIGNtZC54MSwgY21kLnkxLCBjbWQueCwgY21kLnkpO1xuICAgICAgICAgICAgICAgIHByZXZYID0gY21kLng7XG4gICAgICAgICAgICAgICAgcHJldlkgPSBjbWQueTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgICAgIGJveC5hZGRCZXppZXIocHJldlgsIHByZXZZLCBjbWQueDEsIGNtZC55MSwgY21kLngyLCBjbWQueTIsIGNtZC54LCBjbWQueSk7XG4gICAgICAgICAgICAgICAgcHJldlggPSBjbWQueDtcbiAgICAgICAgICAgICAgICBwcmV2WSA9IGNtZC55O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICAgICAgcHJldlggPSBzdGFydFg7XG4gICAgICAgICAgICAgICAgcHJldlkgPSBzdGFydFk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBwYXRoIGNvbW1hbmQgJyArIGNtZC50eXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYm94LmlzRW1wdHkoKSkge1xuICAgICAgICBib3guYWRkUG9pbnQoMCwgMCk7XG4gICAgfVxuICAgIHJldHVybiBib3g7XG59O1xuXG4vKipcbiAqIERyYXcgdGhlIHBhdGggdG8gYSAyRCBjb250ZXh0LlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LlxuICovXG5QYXRoLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjbWQgPSB0aGlzJDEuY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKGNtZC54LCBjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnQycpIHtcbiAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNtZC54MSwgY21kLnkxLCBjbWQueDIsIGNtZC55MiwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1EnKSB7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjbWQueDEsIGNtZC55MSwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5maWxsKSB7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmZpbGw7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3Ryb2tlKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5zdHJva2VXaWR0aDtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgUGF0aCB0byBhIHN0cmluZyBvZiBwYXRoIGRhdGEgaW5zdHJ1Y3Rpb25zXG4gKiBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHL3BhdGhzLmh0bWwjUGF0aERhdGFcbiAqIEBwYXJhbSAge251bWJlcn0gW2RlY2ltYWxQbGFjZXM9Ml0gLSBUaGUgYW1vdW50IG9mIGRlY2ltYWwgcGxhY2VzIGZvciBmbG9hdGluZy1wb2ludCB2YWx1ZXNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuUGF0aC5wcm90b3R5cGUudG9QYXRoRGF0YSA9IGZ1bmN0aW9uKGRlY2ltYWxQbGFjZXMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGRlY2ltYWxQbGFjZXMgPSBkZWNpbWFsUGxhY2VzICE9PSB1bmRlZmluZWQgPyBkZWNpbWFsUGxhY2VzIDogMjtcblxuICAgIGZ1bmN0aW9uIGZsb2F0VG9TdHJpbmcodikge1xuICAgICAgICBpZiAoTWF0aC5yb3VuZCh2KSA9PT0gdikge1xuICAgICAgICAgICAgcmV0dXJuICcnICsgTWF0aC5yb3VuZCh2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2LnRvRml4ZWQoZGVjaW1hbFBsYWNlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYWNrVmFsdWVzKCkge1xuICAgICAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgdmFyIHMgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciB2ID0gYXJndW1lbnRzJDFbaV07XG4gICAgICAgICAgICBpZiAodiA+PSAwICYmIGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcyArPSAnICc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHMgKz0gZmxvYXRUb1N0cmluZyh2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIHZhciBkID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjbWQgPSB0aGlzJDEuY29tbWFuZHNbaV07XG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ00nKSB7XG4gICAgICAgICAgICBkICs9ICdNJyArIHBhY2tWYWx1ZXMoY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0wnKSB7XG4gICAgICAgICAgICBkICs9ICdMJyArIHBhY2tWYWx1ZXMoY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICBkICs9ICdDJyArIHBhY2tWYWx1ZXMoY21kLngxLCBjbWQueTEsIGNtZC54MiwgY21kLnkyLCBjbWQueCwgY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgIGQgKz0gJ1EnICsgcGFja1ZhbHVlcyhjbWQueDEsIGNtZC55MSwgY21kLngsIGNtZC55KTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICBkICs9ICdaJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBwYXRoIHRvIGFuIFNWRyA8cGF0aD4gZWxlbWVudCwgYXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtkZWNpbWFsUGxhY2VzPTJdIC0gVGhlIGFtb3VudCBvZiBkZWNpbWFsIHBsYWNlcyBmb3IgZmxvYXRpbmctcG9pbnQgdmFsdWVzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblBhdGgucHJvdG90eXBlLnRvU1ZHID0gZnVuY3Rpb24oZGVjaW1hbFBsYWNlcykge1xuICAgIHZhciBzdmcgPSAnPHBhdGggZD1cIic7XG4gICAgc3ZnICs9IHRoaXMudG9QYXRoRGF0YShkZWNpbWFsUGxhY2VzKTtcbiAgICBzdmcgKz0gJ1wiJztcbiAgICBpZiAodGhpcy5maWxsICYmIHRoaXMuZmlsbCAhPT0gJ2JsYWNrJykge1xuICAgICAgICBpZiAodGhpcy5maWxsID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdmcgKz0gJyBmaWxsPVwibm9uZVwiJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN2ZyArPSAnIGZpbGw9XCInICsgdGhpcy5maWxsICsgJ1wiJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnN0cm9rZSkge1xuICAgICAgICBzdmcgKz0gJyBzdHJva2U9XCInICsgdGhpcy5zdHJva2UgKyAnXCIgc3Ryb2tlLXdpZHRoPVwiJyArIHRoaXMuc3Ryb2tlV2lkdGggKyAnXCInO1xuICAgIH1cblxuICAgIHN2ZyArPSAnLz4nO1xuICAgIHJldHVybiBzdmc7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIHBhdGggdG8gYSBET00gZWxlbWVudC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2RlY2ltYWxQbGFjZXM9Ml0gLSBUaGUgYW1vdW50IG9mIGRlY2ltYWwgcGxhY2VzIGZvciBmbG9hdGluZy1wb2ludCB2YWx1ZXNcbiAqIEByZXR1cm4ge1NWR1BhdGhFbGVtZW50fVxuICovXG5QYXRoLnByb3RvdHlwZS50b0RPTUVsZW1lbnQgPSBmdW5jdGlvbihkZWNpbWFsUGxhY2VzKSB7XG4gICAgdmFyIHRlbXBvcmFyeVBhdGggPSB0aGlzLnRvUGF0aERhdGEoZGVjaW1hbFBsYWNlcyk7XG4gICAgdmFyIG5ld1BhdGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3BhdGgnKTtcblxuICAgIG5ld1BhdGguc2V0QXR0cmlidXRlKCdkJywgdGVtcG9yYXJ5UGF0aCk7XG5cbiAgICByZXR1cm4gbmV3UGF0aDtcbn07XG5cbi8vIFJ1bi10aW1lIGNoZWNraW5nIG9mIHByZWNvbmRpdGlvbnMuXG5cbmZ1bmN0aW9uIGZhaWwobWVzc2FnZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuLy8gUHJlY29uZGl0aW9uIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGlmIHRoZSBnaXZlbiBwcmVkaWNhdGUgaXMgdHJ1ZS5cbi8vIElmIG5vdCwgaXQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbmZ1bmN0aW9uIGFyZ3VtZW50KHByZWRpY2F0ZSwgbWVzc2FnZSkge1xuICAgIGlmICghcHJlZGljYXRlKSB7XG4gICAgICAgIGZhaWwobWVzc2FnZSk7XG4gICAgfVxufVxuXG52YXIgY2hlY2sgPSB7IGZhaWw6IGZhaWwsIGFyZ3VtZW50OiBhcmd1bWVudCwgYXNzZXJ0OiBhcmd1bWVudCB9O1xuXG4vLyBEYXRhIHR5cGVzIHVzZWQgaW4gdGhlIE9wZW5UeXBlIGZvbnQgZmlsZS5cbi8vIEFsbCBPcGVuVHlwZSBmb250cyB1c2UgTW90b3JvbGEtc3R5bGUgYnl0ZSBvcmRlcmluZyAoQmlnIEVuZGlhbilcblxudmFyIExJTUlUMTYgPSAzMjc2ODsgLy8gVGhlIGxpbWl0IGF0IHdoaWNoIGEgMTYtYml0IG51bWJlciBzd2l0Y2hlcyBzaWducyA9PSAyXjE1XG52YXIgTElNSVQzMiA9IDIxNDc0ODM2NDg7IC8vIFRoZSBsaW1pdCBhdCB3aGljaCBhIDMyLWJpdCBudW1iZXIgc3dpdGNoZXMgc2lnbnMgPT0gMiBeIDMxXG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuZGVjb2RlXG4gKiBAY2xhc3NcbiAqL1xudmFyIGRlY29kZSA9IHt9O1xuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5lbmNvZGVcbiAqIEBjbGFzc1xuICovXG52YXIgZW5jb2RlID0ge307XG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLnNpemVPZlxuICogQGNsYXNzXG4gKi9cbnZhciBzaXplT2YgPSB7fTtcblxuLy8gUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSB2YWx1ZS5cbmZ1bmN0aW9uIGNvbnN0YW50KHYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH07XG59XG5cbi8vIE9wZW5UeXBlIGRhdGEgdHlwZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ29udmVydCBhbiA4LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiAxIGJ5dGUuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLkJZVEUgPSBmdW5jdGlvbih2KSB7XG4gICAgY2hlY2suYXJndW1lbnQodiA+PSAwICYmIHYgPD0gMjU1LCAnQnl0ZSB2YWx1ZSBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAyNTUuJyk7XG4gICAgcmV0dXJuIFt2XTtcbn07XG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLkJZVEUgPSBjb25zdGFudCgxKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgOC1iaXQgc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDEgYnl0ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuQ0hBUiA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gW3YuY2hhckNvZGVBdCgwKV07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLkNIQVIgPSBjb25zdGFudCgxKTtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFTQ0lJIHN0cmluZyB0byBhIGxpc3Qgb2YgYnl0ZXMuXG4gKiBAcGFyYW0ge3N0cmluZ31cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLkNIQVJBUlJBWSA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgYiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBiW2ldID0gdi5jaGFyQ29kZUF0KGkpO1xuICAgIH1cblxuICAgIHJldHVybiBiO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLkNIQVJBUlJBWSA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdi5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSAxNi1iaXQgdW5zaWduZWQgaW50ZWdlciB0byBhIGxpc3Qgb2YgMiBieXRlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuVVNIT1JUID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBbKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLlVTSE9SVCA9IGNvbnN0YW50KDIpO1xuXG4vKipcbiAqIENvbnZlcnQgYSAxNi1iaXQgc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDIgYnl0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLlNIT1JUID0gZnVuY3Rpb24odikge1xuICAgIC8vIFR3bydzIGNvbXBsZW1lbnRcbiAgICBpZiAodiA+PSBMSU1JVDE2KSB7XG4gICAgICAgIHYgPSAtKDIgKiBMSU1JVDE2IC0gdik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFsodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5zaXplT2YuU0hPUlQgPSBjb25zdGFudCgyKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgMjQtYml0IHVuc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDMgYnl0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLlVJTlQyNCA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gWyh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5VSU5UMjQgPSBjb25zdGFudCgzKTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgMzItYml0IHVuc2lnbmVkIGludGVnZXIgdG8gYSBsaXN0IG9mIDQgYnl0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLlVMT05HID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBbKHYgPj4gMjQpICYgMHhGRiwgKHYgPj4gMTYpICYgMHhGRiwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLlVMT05HID0gY29uc3RhbnQoNCk7XG5cbi8qKlxuICogQ29udmVydCBhIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIGEgbGlzdCBvZiA0IGJ5dGVzLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5MT05HID0gZnVuY3Rpb24odikge1xuICAgIC8vIFR3bydzIGNvbXBsZW1lbnRcbiAgICBpZiAodiA+PSBMSU1JVDMyKSB7XG4gICAgICAgIHYgPSAtKDIgKiBMSU1JVDMyIC0gdik7XG4gICAgfVxuXG4gICAgcmV0dXJuIFsodiA+PiAyNCkgJiAweEZGLCAodiA+PiAxNikgJiAweEZGLCAodiA+PiA4KSAmIDB4RkYsIHYgJiAweEZGXTtcbn07XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5zaXplT2YuTE9ORyA9IGNvbnN0YW50KDQpO1xuXG5lbmNvZGUuRklYRUQgPSBlbmNvZGUuVUxPTkc7XG5zaXplT2YuRklYRUQgPSBzaXplT2YuVUxPTkc7XG5cbmVuY29kZS5GV09SRCA9IGVuY29kZS5TSE9SVDtcbnNpemVPZi5GV09SRCA9IHNpemVPZi5TSE9SVDtcblxuZW5jb2RlLlVGV09SRCA9IGVuY29kZS5VU0hPUlQ7XG5zaXplT2YuVUZXT1JEID0gc2l6ZU9mLlVTSE9SVDtcblxuLyoqXG4gKiBDb252ZXJ0IGEgMzItYml0IEFwcGxlIE1hYyB0aW1lc3RhbXAgaW50ZWdlciB0byBhIGxpc3Qgb2YgOCBieXRlcywgNjQtYml0IHRpbWVzdGFtcC5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuTE9OR0RBVEVUSU1FID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBbMCwgMCwgMCwgMCwgKHYgPj4gMjQpICYgMHhGRiwgKHYgPj4gMTYpICYgMHhGRiwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLkxPTkdEQVRFVElNRSA9IGNvbnN0YW50KDgpO1xuXG4vKipcbiAqIENvbnZlcnQgYSA0LWNoYXIgdGFnIHRvIGEgbGlzdCBvZiA0IGJ5dGVzLlxuICogQHBhcmFtIHtzdHJpbmd9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5UQUcgPSBmdW5jdGlvbih2KSB7XG4gICAgY2hlY2suYXJndW1lbnQodi5sZW5ndGggPT09IDQsICdUYWcgc2hvdWxkIGJlIGV4YWN0bHkgNCBBU0NJSSBjaGFyYWN0ZXJzLicpO1xuICAgIHJldHVybiBbdi5jaGFyQ29kZUF0KDApLFxuICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDEpLFxuICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDIpLFxuICAgICAgICAgICAgdi5jaGFyQ29kZUF0KDMpXTtcbn07XG5cbi8qKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5zaXplT2YuVEFHID0gY29uc3RhbnQoNCk7XG5cbi8vIENGRiBkYXRhIHR5cGVzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmVuY29kZS5DYXJkOCA9IGVuY29kZS5CWVRFO1xuc2l6ZU9mLkNhcmQ4ID0gc2l6ZU9mLkJZVEU7XG5cbmVuY29kZS5DYXJkMTYgPSBlbmNvZGUuVVNIT1JUO1xuc2l6ZU9mLkNhcmQxNiA9IHNpemVPZi5VU0hPUlQ7XG5cbmVuY29kZS5PZmZTaXplID0gZW5jb2RlLkJZVEU7XG5zaXplT2YuT2ZmU2l6ZSA9IHNpemVPZi5CWVRFO1xuXG5lbmNvZGUuU0lEID0gZW5jb2RlLlVTSE9SVDtcbnNpemVPZi5TSUQgPSBzaXplT2YuVVNIT1JUO1xuXG4vLyBDb252ZXJ0IGEgbnVtZXJpYyBvcGVyYW5kIG9yIGNoYXJzdHJpbmcgbnVtYmVyIHRvIGEgdmFyaWFibGUtc2l6ZSBsaXN0IG9mIGJ5dGVzLlxuLyoqXG4gKiBDb252ZXJ0IGEgbnVtZXJpYyBvcGVyYW5kIG9yIGNoYXJzdHJpbmcgbnVtYmVyIHRvIGEgdmFyaWFibGUtc2l6ZSBsaXN0IG9mIGJ5dGVzLlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5OVU1CRVIgPSBmdW5jdGlvbih2KSB7XG4gICAgaWYgKHYgPj0gLTEwNyAmJiB2IDw9IDEwNykge1xuICAgICAgICByZXR1cm4gW3YgKyAxMzldO1xuICAgIH0gZWxzZSBpZiAodiA+PSAxMDggJiYgdiA8PSAxMTMxKSB7XG4gICAgICAgIHYgPSB2IC0gMTA4O1xuICAgICAgICByZXR1cm4gWyh2ID4+IDgpICsgMjQ3LCB2ICYgMHhGRl07XG4gICAgfSBlbHNlIGlmICh2ID49IC0xMTMxICYmIHYgPD0gLTEwOCkge1xuICAgICAgICB2ID0gLXYgLSAxMDg7XG4gICAgICAgIHJldHVybiBbKHYgPj4gOCkgKyAyNTEsIHYgJiAweEZGXTtcbiAgICB9IGVsc2UgaWYgKHYgPj0gLTMyNzY4ICYmIHYgPD0gMzI3NjcpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZS5OVU1CRVIxNih2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZW5jb2RlLk5VTUJFUjMyKHYpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuTlVNQkVSID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBlbmNvZGUuTlVNQkVSKHYpLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHNpZ25lZCBudW1iZXIgYmV0d2VlbiAtMzI3NjggYW5kICszMjc2NyB0byBhIHRocmVlLWJ5dGUgdmFsdWUuXG4gKiBUaGlzIGVuc3VyZXMgd2UgYWx3YXlzIHVzZSB0aHJlZSBieXRlcywgYnV0IGlzIG5vdCB0aGUgbW9zdCBjb21wYWN0IGZvcm1hdC5cbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuTlVNQkVSMTYgPSBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIFsyOCwgKHYgPj4gOCkgJiAweEZGLCB2ICYgMHhGRl07XG59O1xuXG4vKipcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqL1xuc2l6ZU9mLk5VTUJFUjE2ID0gY29uc3RhbnQoMyk7XG5cbi8qKlxuICogQ29udmVydCBhIHNpZ25lZCBudW1iZXIgYmV0d2VlbiAtKDJeMzEpIGFuZCArKDJeMzEtMSkgdG8gYSBmaXZlLWJ5dGUgdmFsdWUuXG4gKiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byBiZSBzdXJlIHlvdSBhbHdheXMgdXNlIGZvdXIgYnl0ZXMsXG4gKiBhdCB0aGUgZXhwZW5zZSBvZiB3YXN0aW5nIGEgZmV3IGJ5dGVzIGZvciBzbWFsbGVyIG51bWJlcnMuXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLk5VTUJFUjMyID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBbMjksICh2ID4+IDI0KSAmIDB4RkYsICh2ID4+IDE2KSAmIDB4RkYsICh2ID4+IDgpICYgMHhGRiwgdiAmIDB4RkZdO1xufTtcblxuLyoqXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5OVU1CRVIzMiA9IGNvbnN0YW50KDUpO1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuUkVBTCA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgdmFsdWUgPSB2LnRvU3RyaW5nKCk7XG5cbiAgICAvLyBTb21lIG51bWJlcnMgdXNlIGFuIGVwc2lsb24gdG8gZW5jb2RlIHRoZSB2YWx1ZS4gKGUuZy4gSmF2YVNjcmlwdCB3aWxsIHN0b3JlIDAuMDAwMDAwMSBhcyAxZS03KVxuICAgIC8vIFRoaXMgY29kZSBjb252ZXJ0cyBpdCBiYWNrIHRvIGEgbnVtYmVyIHdpdGhvdXQgdGhlIGVwc2lsb24uXG4gICAgdmFyIG0gPSAvXFwuKFxcZCo/KSg/Ojl7NSwyMH18MHs1LDIwfSlcXGR7MCwyfSg/OmUoLispfCQpLy5leGVjKHZhbHVlKTtcbiAgICBpZiAobSkge1xuICAgICAgICB2YXIgZXBzaWxvbiA9IHBhcnNlRmxvYXQoJzFlJyArICgobVsyXSA/ICttWzJdIDogMCkgKyBtWzFdLmxlbmd0aCkpO1xuICAgICAgICB2YWx1ZSA9IChNYXRoLnJvdW5kKHYgKiBlcHNpbG9uKSAvIGVwc2lsb24pLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgdmFyIG5pYmJsZXMgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpaTsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjID0gdmFsdWVbaV07XG4gICAgICAgIGlmIChjID09PSAnZScpIHtcbiAgICAgICAgICAgIG5pYmJsZXMgKz0gdmFsdWVbKytpXSA9PT0gJy0nID8gJ2MnIDogJ2InO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPT09ICcuJykge1xuICAgICAgICAgICAgbmliYmxlcyArPSAnYSc7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJy0nKSB7XG4gICAgICAgICAgICBuaWJibGVzICs9ICdlJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5pYmJsZXMgKz0gYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5pYmJsZXMgKz0gKG5pYmJsZXMubGVuZ3RoICYgMSkgPyAnZicgOiAnZmYnO1xuICAgIHZhciBvdXQgPSBbMzBdO1xuICAgIGZvciAodmFyIGkkMSA9IDAsIGlpJDEgPSBuaWJibGVzLmxlbmd0aDsgaSQxIDwgaWkkMTsgaSQxICs9IDIpIHtcbiAgICAgICAgb3V0LnB1c2gocGFyc2VJbnQobmliYmxlcy5zdWJzdHIoaSQxLCAyKSwgMTYpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbnNpemVPZi5SRUFMID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBlbmNvZGUuUkVBTCh2KS5sZW5ndGg7XG59O1xuXG5lbmNvZGUuTkFNRSA9IGVuY29kZS5DSEFSQVJSQVk7XG5zaXplT2YuTkFNRSA9IHNpemVPZi5DSEFSQVJSQVk7XG5cbmVuY29kZS5TVFJJTkcgPSBlbmNvZGUuQ0hBUkFSUkFZO1xuc2l6ZU9mLlNUUklORyA9IHNpemVPZi5DSEFSQVJSQVk7XG5cbi8qKlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IG51bUJ5dGVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5kZWNvZGUuVVRGOCA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgbnVtQnl0ZXMpIHtcbiAgICB2YXIgY29kZVBvaW50cyA9IFtdO1xuICAgIHZhciBudW1DaGFycyA9IG51bUJ5dGVzO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtQ2hhcnM7IGorKywgb2Zmc2V0ICs9IDEpIHtcbiAgICAgICAgY29kZVBvaW50c1tqXSA9IGRhdGEuZ2V0VWludDgob2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlUG9pbnRzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHBhcmFtIHtudW1iZXJ9IG51bUJ5dGVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5kZWNvZGUuVVRGMTYgPSBmdW5jdGlvbihkYXRhLCBvZmZzZXQsIG51bUJ5dGVzKSB7XG4gICAgdmFyIGNvZGVQb2ludHMgPSBbXTtcbiAgICB2YXIgbnVtQ2hhcnMgPSBudW1CeXRlcyAvIDI7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1DaGFyczsgaisrLCBvZmZzZXQgKz0gMikge1xuICAgICAgICBjb2RlUG9pbnRzW2pdID0gZGF0YS5nZXRVaW50MTYob2Zmc2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBjb2RlUG9pbnRzKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIEphdmFTY3JpcHQgc3RyaW5nIHRvIFVURjE2LUJFLlxuICogQHBhcmFtIHtzdHJpbmd9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5VVEYxNiA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgYiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY29kZXBvaW50ID0gdi5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBiW2IubGVuZ3RoXSA9IChjb2RlcG9pbnQgPj4gOCkgJiAweEZGO1xuICAgICAgICBiW2IubGVuZ3RoXSA9IGNvZGVwb2ludCAmIDB4RkY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGI7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLlVURjE2ID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiB2Lmxlbmd0aCAqIDI7XG59O1xuXG4vLyBEYXRhIGZvciBjb252ZXJ0aW5nIG9sZCBlaWdodC1iaXQgTWFjaW50b3NoIGVuY29kaW5ncyB0byBVbmljb2RlLlxuLy8gVGhpcyByZXByZXNlbnRhdGlvbiBpcyBvcHRpbWl6ZWQgZm9yIGRlY29kaW5nOyBlbmNvZGluZyBpcyBzbG93ZXJcbi8vIGFuZCBuZWVkcyBtb3JlIG1lbW9yeS4gVGhlIGFzc3VtcHRpb24gaXMgdGhhdCBhbGwgb3BlbnR5cGUuanMgdXNlcnNcbi8vIHdhbnQgdG8gb3BlbiBmb250cywgYnV0IHNhdmluZyBhIGZvbnQgd2lsbCBiZSBjb21wYXJhdGl2ZWx5IHJhcmVcbi8vIHNvIGl0IGNhbiBiZSBtb3JlIGV4cGVuc2l2ZS4gS2V5ZWQgYnkgSUFOQSBjaGFyYWN0ZXIgc2V0IG5hbWUuXG4vL1xuLy8gUHl0aG9uIHNjcmlwdCBmb3IgZ2VuZXJhdGluZyB0aGVzZSBzdHJpbmdzOlxuLy9cbi8vICAgICBzID0gdScnLmpvaW4oW2NocihjKS5kZWNvZGUoJ21hY19ncmVlaycpIGZvciBjIGluIHJhbmdlKDEyOCwgMjU2KV0pXG4vLyAgICAgcHJpbnQocy5lbmNvZGUoJ3V0Zi04JykpXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBlaWdodEJpdE1hY0VuY29kaW5ncyA9IHtcbiAgICAneC1tYWMtY3JvYXRpYW4nOiAgLy8gUHl0aG9uOiAnbWFjX2Nyb2F0aWFuJ1xuICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O84oCgwrDCosKjwqfigKLCtsOfwq7FoOKEosK0wqjiiaDFvcOY4oiewrHiiaTiiaXiiIbCteKIguKIkeKIj8Wh4oirwqrCus6pxb7DuCcgK1xuICAgICfCv8KhwqziiJrGkuKJiMSGwqvEjOKApsKgw4DDg8OVxZLFk8SQ4oCU4oCc4oCd4oCY4oCZw7fil4rvo7/CqeKBhOKCrOKAueKAusOGwrvigJPCt+KAmuKAnuKAsMOCxIfDgcSNw4jDjcOOw4/DjMOTw5TEkcOSw5rDm8OZxLHLhsucwq/PgMOLy5rCuMOKw6bLhycsXG4gICAgJ3gtbWFjLWN5cmlsbGljJzogIC8vIFB5dGhvbjogJ21hY19jeXJpbGxpYydcbiAgICAn0JDQkdCS0JPQlNCV0JbQl9CY0JnQmtCb0JzQndCe0J/QoNCh0KLQo9Ck0KXQptCn0KjQqdCq0KvQrNCt0K7Qr+KAoMKw0pDCo8Kn4oCiwrbQhsKuwqnihKLQgtGS4omg0IPRk+KInsKx4omk4oml0ZbCtdKR0IjQhNGU0IfRl9CJ0ZnQitGaJyArXG4gICAgJ9GY0IXCrOKImsaS4omI4oiGwqvCu+KApsKg0IvRm9CM0ZzRleKAk+KAlOKAnOKAneKAmOKAmcO34oCe0I7RntCP0Z/ihJbQgdGR0Y/QsNCx0LLQs9C00LXQttC30LjQudC60LvQvNC90L7Qv9GA0YHRgtGD0YTRhdGG0YfRiNGJ0YrRi9GM0Y3RjicsXG4gICAgJ3gtbWFjLWdhZWxpYyc6IC8vIGh0dHA6Ly91bmljb2RlLm9yZy9QdWJsaWMvTUFQUElOR1MvVkVORE9SUy9BUFBMRS9HQUVMSUMuVFhUXG4gICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMOGw5jhuILCseKJpOKJpeG4g8SKxIvhuIrhuIvhuJ7huJ/EoMSh4bmAw6bDuCcgK1xuICAgICfhuYHhuZbhuZfJvMaSxb/huaDCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZ4bmh4bqbw7/FuOG5quKCrOKAueKAusW2xbfhuavCt+G7suG7s+KBisOCw4rDgcOLw4jDjcOOw4/DjMOTw5TimaPDksOaw5vDmcSxw53DvcW0xbXhuoThuoXhuoDhuoHhuoLhuoMnLFxuICAgICd4LW1hYy1ncmVlayc6ICAvLyBQeXRob246ICdtYWNfZ3JlZWsnXG4gICAgJ8OEwrnCssOJwrPDlsOczoXDoMOiw6TOhMKow6fDqcOow6rDq8Kj4oSiw67Dr+KAosK94oCww7TDtsKm4oKsw7nDu8O84oCgzpPOlM6YzpvOns6gw5/CrsKpzqPOqsKn4omgwrDCt86RwrHiiaTiiaXCpc6SzpXOls6XzpnOms6czqbOq86ozqknICtcbiAgICAnzqzOncKszp/OoeKJiM6kwqvCu+KApsKgzqXOp86GzojFk+KAk+KAleKAnOKAneKAmOKAmcO3zonOis6Mzo7Orc6uzq/PjM6Pz43Osc6yz4jOtM61z4bOs863zrnOvs66zrvOvM69zr/PgM+Oz4HPg8+EzrjPic+Cz4fPhc62z4rPi86QzrBcXHUwMEFEJyxcbiAgICAneC1tYWMtaWNlbGFuZGljJzogIC8vIFB5dGhvbjogJ21hY19pY2VsYW5kJ1xuICAgICfDhMOFw4fDicORw5bDnMOhw6DDosOkw6PDpcOnw6nDqMOqw6vDrcOsw67Dr8Oxw7PDssO0w7bDtcO6w7nDu8O8w53CsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMOGw5jiiJ7CseKJpOKJpcKlwrXiiILiiJHiiI/PgOKIq8KqwrrOqcOmw7gnICtcbiAgICAnwr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W44oGE4oKsw5DDsMOew77DvcK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+jv8OSw5rDm8OZxLHLhsucwq/LmMuZy5rCuMudy5vLhycsXG4gICAgJ3gtbWFjLWludWl0JzogLy8gaHR0cDovL3VuaWNvZGUub3JnL1B1YmxpYy9NQVBQSU5HUy9WRU5ET1JTL0FQUExFL0lOVUlULlRYVFxuICAgICfhkIPhkIThkIXhkIbhkIrhkIvhkLHhkLLhkLPhkLThkLjhkLnhkYnhkY7hkY/hkZDhkZHhkZXhkZbhkabhka3hka7hka/hkbDhkbLhkbPhkoPhkovhkozhko3hko7hkpDhkpHCsOGSoeGSpeGSpuKAosK24ZKnwq7CqeKEouGSqOGSquGSq+GSu+GTguGTg+GThOGTheGTh+GTiOGTkOGTr+GTsOGTseGTsuGTtOGTteGUheGTleGTluGTlycgK1xuICAgICfhk5jhk5rhk5vhk6rhlKjhlKnhlKrhlKvhlK3igKbCoOGUruGUvuGVleGVluGVl+KAk+KAlOKAnOKAneKAmOKAmeGVmOGVmeGVmuGVneGVhuGVh+GViOGVieGVi+GVjOGVkOGVv+GWgOGWgeGWguGWg+GWhOGWheGWj+GWkOGWkeGWkuGWk+GWlOGWleGZseGZsuGZs+GZtOGZteGZtuGWluGWoOGWoeGWouGWo+GWpOGWpeGWpuGVvMWBxYInLFxuICAgICd4LW1hYy1jZSc6ICAvLyBQeXRob246ICdtYWNfbGF0aW4yJ1xuICAgICfDhMSAxIHDicSEw5bDnMOhxIXEjMOkxI3EhsSHw6nFucW6xI7DrcSPxJLEk8SWw7PEl8O0w7bDtcO6xJrEm8O84oCgwrDEmMKjwqfigKLCtsOfwq7CqeKEosSZwqjiiaDEo8SuxK/EquKJpOKJpcSrxLbiiILiiJHFgsS7xLzEvcS+xLnEusWFJyArXG4gICAgJ8WGxYPCrOKImsWExYfiiIbCq8K74oCmwqDFiMWQw5XFkcWM4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rFjcWUxZXFmOKAueKAusWZxZbFl8Wg4oCa4oCexaHFmsWbw4HFpMWlw43FvcW+xarDk8OUxavFrsOaxa/FsMWxxbLFs8Odw73Et8W7xYHFvMSiy4cnLFxuICAgIG1hY2ludG9zaDogIC8vIFB5dGhvbjogJ21hY19yb21hbidcbiAgICAnw4TDhcOHw4nDkcOWw5zDocOgw6LDpMOjw6XDp8Opw6jDqsOrw63DrMOuw6/DscOzw7LDtMO2w7XDusO5w7vDvOKAoMKwwqLCo8Kn4oCiwrbDn8KuwqnihKLCtMKo4omgw4bDmOKInsKx4omk4omlwqXCteKIguKIkeKIj8+A4oirwqrCus6pw6bDuCcgK1xuICAgICfCv8KhwqziiJrGkuKJiOKIhsKrwrvigKbCoMOAw4PDlcWSxZPigJPigJTigJzigJ3igJjigJnDt+KXisO/xbjigYTigqzigLnigLrvrIHvrILigKHCt+KAmuKAnuKAsMOCw4rDgcOLw4jDjcOOw4/DjMOTw5Tvo7/DksOaw5vDmcSxy4bLnMKvy5jLmcuawrjLncuby4cnLFxuICAgICd4LW1hYy1yb21hbmlhbic6ICAvLyBQeXRob246ICdtYWNfcm9tYW5pYW4nXG4gICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMSCyJjiiJ7CseKJpOKJpcKlwrXiiILiiJHiiI/PgOKIq8KqwrrOqcSDyJknICtcbiAgICAnwr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W44oGE4oKs4oC54oC6yJrIm+KAocK34oCa4oCe4oCww4LDisOBw4vDiMONw47Dj8OMw5PDlO+jv8OSw5rDm8OZxLHLhsucwq/LmMuZy5rCuMudy5vLhycsXG4gICAgJ3gtbWFjLXR1cmtpc2gnOiAgLy8gUHl0aG9uOiAnbWFjX3R1cmtpc2gnXG4gICAgJ8OEw4XDh8OJw5HDlsOcw6HDoMOiw6TDo8Olw6fDqcOow6rDq8Otw6zDrsOvw7HDs8Oyw7TDtsO1w7rDucO7w7zigKDCsMKiwqPCp+KAosK2w5/CrsKp4oSiwrTCqOKJoMOGw5jiiJ7CseKJpOKJpcKlwrXiiILiiJHiiI/PgOKIq8KqwrrOqcOmw7gnICtcbiAgICAnwr/CocKs4oiaxpLiiYjiiIbCq8K74oCmwqDDgMODw5XFksWT4oCT4oCU4oCc4oCd4oCY4oCZw7fil4rDv8W4xJ7En8SwxLHFnsWf4oChwrfigJrigJ7igLDDgsOKw4HDi8OIw43DjsOPw4zDk8OU76O/w5LDmsObw5nvoqDLhsucwq/LmMuZy5rCuMudy5vLhydcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhbiBvbGQtc3R5bGUgTWFjaW50b3NoIHN0cmluZy4gUmV0dXJucyBlaXRoZXIgYSBVbmljb2RlIEphdmFTY3JpcHRcbiAqIHN0cmluZywgb3IgJ3VuZGVmaW5lZCcgaWYgdGhlIGVuY29kaW5nIGlzIHVuc3VwcG9ydGVkLiBGb3IgZXhhbXBsZSwgd2UgZG9cbiAqIG5vdCBzdXBwb3J0IENoaW5lc2UsIEphcGFuZXNlIG9yIEtvcmVhbiBiZWNhdXNlIHRoZXNlIHdvdWxkIG5lZWQgbGFyZ2VcbiAqIG1hcHBpbmcgdGFibGVzLlxuICogQHBhcmFtIHtEYXRhVmlld30gZGF0YVZpZXdcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBkYXRhTGVuZ3RoXG4gKiBAcGFyYW0ge3N0cmluZ30gZW5jb2RpbmdcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmRlY29kZS5NQUNTVFJJTkcgPSBmdW5jdGlvbihkYXRhVmlldywgb2Zmc2V0LCBkYXRhTGVuZ3RoLCBlbmNvZGluZykge1xuICAgIHZhciB0YWJsZSA9IGVpZ2h0Qml0TWFjRW5jb2RpbmdzW2VuY29kaW5nXTtcbiAgICBpZiAodGFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IGRhdGFWaWV3LmdldFVpbnQ4KG9mZnNldCArIGkpO1xuICAgICAgICAvLyBJbiBhbGwgZWlnaHQtYml0IE1hYyBlbmNvZGluZ3MsIHRoZSBjaGFyYWN0ZXJzIDB4MDAuLjB4N0YgYXJlXG4gICAgICAgIC8vIG1hcHBlZCB0byBVKzAwMDAuLlUrMDA3Rjsgd2Ugb25seSBuZWVkIHRvIGxvb2sgdXAgdGhlIG90aGVycy5cbiAgICAgICAgaWYgKGMgPD0gMHg3Rikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGFibGVbYyAmIDB4N0ZdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIEhlbHBlciBmdW5jdGlvbiBmb3IgZW5jb2RlLk1BQ1NUUklORy4gUmV0dXJucyBhIGRpY3Rpb25hcnkgZm9yIG1hcHBpbmdcbi8vIFVuaWNvZGUgY2hhcmFjdGVyIGNvZGVzIHRvIHRoZWlyIDgtYml0IE1hY09TIGVxdWl2YWxlbnQuIFRoaXMgdGFibGVcbi8vIGlzIG5vdCBleGFjdGx5IGEgc3VwZXIgY2hlYXAgZGF0YSBzdHJ1Y3R1cmUsIGJ1dCB3ZSBkbyBub3QgY2FyZSBiZWNhdXNlXG4vLyBlbmNvZGluZyBNYWNpbnRvc2ggc3RyaW5ncyBpcyBvbmx5IHJhcmVseSBuZWVkZWQgaW4gdHlwaWNhbCBhcHBsaWNhdGlvbnMuXG52YXIgbWFjRW5jb2RpbmdUYWJsZUNhY2hlID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgJiYgbmV3IFdlYWtNYXAoKTtcbnZhciBtYWNFbmNvZGluZ0NhY2hlS2V5cztcbnZhciBnZXRNYWNFbmNvZGluZ1RhYmxlID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gICAgLy8gU2luY2Ugd2UgdXNlIGVuY29kaW5nIGFzIGEgY2FjaGUga2V5IGZvciBXZWFrTWFwLCBpdCBoYXMgdG8gYmVcbiAgICAvLyBhIFN0cmluZyBvYmplY3QgYW5kIG5vdCBhIGxpdGVyYWwuIEFuZCBhdCBsZWFzdCBvbiBOb2RlSlMgMi4xMC4xLFxuICAgIC8vIFdlYWtNYXAgcmVxdWlyZXMgdGhhdCB0aGUgc2FtZSBTdHJpbmcgaW5zdGFuY2UgaXMgcGFzc2VkIGZvciBjYWNoZSBoaXRzLlxuICAgIGlmICghbWFjRW5jb2RpbmdDYWNoZUtleXMpIHtcbiAgICAgICAgbWFjRW5jb2RpbmdDYWNoZUtleXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgZSBpbiBlaWdodEJpdE1hY0VuY29kaW5ncykge1xuICAgICAgICAgICAgLypqc2hpbnQgLVcwNTMgKi8gIC8vIFN1cHByZXNzIFwiRG8gbm90IHVzZSBTdHJpbmcgYXMgYSBjb25zdHJ1Y3Rvci5cIlxuICAgICAgICAgICAgbWFjRW5jb2RpbmdDYWNoZUtleXNbZV0gPSBuZXcgU3RyaW5nKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNhY2hlS2V5ID0gbWFjRW5jb2RpbmdDYWNoZUtleXNbZW5jb2RpbmddO1xuICAgIGlmIChjYWNoZUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuJ3QgZG8gXCJpZiAoY2FjaGUuaGFzKGtleSkpIHtyZXR1cm4gY2FjaGUuZ2V0KGtleSl9XCIgaGVyZTpcbiAgICAvLyBzaW5jZSBnYXJiYWdlIGNvbGxlY3Rpb24gbWF5IHJ1biBhdCBhbnkgdGltZSwgaXQgY291bGQgYWxzbyBraWNrIGluXG4gICAgLy8gYmV0d2VlbiB0aGUgY2FsbHMgdG8gY2FjaGUuaGFzKCkgYW5kIGNhY2hlLmdldCgpLiBJbiB0aGF0IGNhc2UsXG4gICAgLy8gd2Ugd291bGQgcmV0dXJuICd1bmRlZmluZWQnIGV2ZW4gdGhvdWdoIHdlIGRvIHN1cHBvcnQgdGhlIGVuY29kaW5nLlxuICAgIGlmIChtYWNFbmNvZGluZ1RhYmxlQ2FjaGUpIHtcbiAgICAgICAgdmFyIGNhY2hlZFRhYmxlID0gbWFjRW5jb2RpbmdUYWJsZUNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgICAgIGlmIChjYWNoZWRUYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkVGFibGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVjb2RpbmdUYWJsZSA9IGVpZ2h0Qml0TWFjRW5jb2RpbmdzW2VuY29kaW5nXTtcbiAgICBpZiAoZGVjb2RpbmdUYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIGVuY29kaW5nVGFibGUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlY29kaW5nVGFibGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZW5jb2RpbmdUYWJsZVtkZWNvZGluZ1RhYmxlLmNoYXJDb2RlQXQoaSldID0gaSArIDB4ODA7XG4gICAgfVxuXG4gICAgaWYgKG1hY0VuY29kaW5nVGFibGVDYWNoZSkge1xuICAgICAgICBtYWNFbmNvZGluZ1RhYmxlQ2FjaGUuc2V0KGNhY2hlS2V5LCBlbmNvZGluZ1RhYmxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZW5jb2RpbmdUYWJsZTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhbiBvbGQtc3R5bGUgTWFjaW50b3NoIHN0cmluZy4gUmV0dXJucyBhIGJ5dGUgYXJyYXkgdXBvbiBzdWNjZXNzLlxuICogSWYgdGhlIHJlcXVlc3RlZCBlbmNvZGluZyBpcyB1bnN1cHBvcnRlZCwgb3IgaWYgdGhlIGlucHV0IHN0cmluZyBjb250YWluc1xuICogYSBjaGFyYWN0ZXIgdGhhdCBjYW5ub3QgYmUgZXhwcmVzc2VkIGluIHRoZSBlbmNvZGluZywgdGhlIGZ1bmN0aW9uIHJldHVybnNcbiAqICd1bmRlZmluZWQnLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5NQUNTVFJJTkcgPSBmdW5jdGlvbihzdHIsIGVuY29kaW5nKSB7XG4gICAgdmFyIHRhYmxlID0gZ2V0TWFjRW5jb2RpbmdUYWJsZShlbmNvZGluZyk7XG4gICAgaWYgKHRhYmxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcblxuICAgICAgICAvLyBJbiBhbGwgZWlnaHQtYml0IE1hYyBlbmNvZGluZ3MsIHRoZSBjaGFyYWN0ZXJzIDB4MDAuLjB4N0YgYXJlXG4gICAgICAgIC8vIG1hcHBlZCB0byBVKzAwMDAuLlUrMDA3Rjsgd2Ugb25seSBuZWVkIHRvIGxvb2sgdXAgdGhlIG90aGVycy5cbiAgICAgICAgaWYgKGMgPj0gMHg4MCkge1xuICAgICAgICAgICAgYyA9IHRhYmxlW2NdO1xuICAgICAgICAgICAgaWYgKGMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIHN0ciBjb250YWlucyBhIFVuaWNvZGUgY2hhcmFjdGVyIHRoYXQgY2Fubm90IGJlIGVuY29kZWRcbiAgICAgICAgICAgICAgICAvLyBpbiB0aGUgcmVxdWVzdGVkIGVuY29kaW5nLlxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2ldID0gYztcbiAgICAgICAgLy8gcmVzdWx0LnB1c2goYyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtzdHJpbmd9IGVuY29kaW5nXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuTUFDU1RSSU5HID0gZnVuY3Rpb24oc3RyLCBlbmNvZGluZykge1xuICAgIHZhciBiID0gZW5jb2RlLk1BQ1NUUklORyhzdHIsIGVuY29kaW5nKTtcbiAgICBpZiAoYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBiLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG4vLyBIZWxwZXIgZm9yIGVuY29kZS5WQVJERUxUQVNcbmZ1bmN0aW9uIGlzQnl0ZUVuY29kYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA+PSAtMTI4ICYmIHZhbHVlIDw9IDEyNztcbn1cblxuLy8gSGVscGVyIGZvciBlbmNvZGUuVkFSREVMVEFTXG5mdW5jdGlvbiBlbmNvZGVWYXJEZWx0YVJ1bkFzWmVyb2VzKGRlbHRhcywgcG9zLCByZXN1bHQpIHtcbiAgICB2YXIgcnVuTGVuZ3RoID0gMDtcbiAgICB2YXIgbnVtRGVsdGFzID0gZGVsdGFzLmxlbmd0aDtcbiAgICB3aGlsZSAocG9zIDwgbnVtRGVsdGFzICYmIHJ1bkxlbmd0aCA8IDY0ICYmIGRlbHRhc1twb3NdID09PSAwKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgICArK3J1bkxlbmd0aDtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goMHg4MCB8IChydW5MZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIHBvcztcbn1cblxuLy8gSGVscGVyIGZvciBlbmNvZGUuVkFSREVMVEFTXG5mdW5jdGlvbiBlbmNvZGVWYXJEZWx0YVJ1bkFzQnl0ZXMoZGVsdGFzLCBvZmZzZXQsIHJlc3VsdCkge1xuICAgIHZhciBydW5MZW5ndGggPSAwO1xuICAgIHZhciBudW1EZWx0YXMgPSBkZWx0YXMubGVuZ3RoO1xuICAgIHZhciBwb3MgPSBvZmZzZXQ7XG4gICAgd2hpbGUgKHBvcyA8IG51bURlbHRhcyAmJiBydW5MZW5ndGggPCA2NCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBkZWx0YXNbcG9zXTtcbiAgICAgICAgaWYgKCFpc0J5dGVFbmNvZGFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdpdGhpbiBhIGJ5dGUtZW5jb2RlZCBydW4gb2YgZGVsdGFzLCBhIHNpbmdsZSB6ZXJvIGlzIGJlc3RcbiAgICAgICAgLy8gc3RvcmVkIGxpdGVyYWxseSBhcyAweDAwIHZhbHVlLiBIb3dldmVyLCBpZiB3ZSBoYXZlIHR3byBvclxuICAgICAgICAvLyBtb3JlIHplcm9lcyBpbiBhIHNlcXVlbmNlLCBpdCBpcyBiZXR0ZXIgdG8gc3RhcnQgYSBuZXcgcnVuLlxuICAgICAgICAvLyBGb3JlIGV4YW1wbGUsIHRoZSBzZXF1ZW5jZSBvZiBkZWx0YXMgWzE1LCAxNSwgMCwgMTUsIDE1XVxuICAgICAgICAvLyBiZWNvbWVzIDYgYnl0ZXMgKDA0IDBGIDBGIDAwIDBGIDBGKSB3aGVuIHN0b3JpbmcgdGhlIHplcm9cbiAgICAgICAgLy8gd2l0aGluIHRoZSBjdXJyZW50IHJ1biwgYnV0IDcgYnl0ZXMgKDAxIDBGIDBGIDgwIDAxIDBGIDBGKVxuICAgICAgICAvLyB3aGVuIHN0YXJ0aW5nIGEgbmV3IHJ1bi5cbiAgICAgICAgaWYgKHZhbHVlID09PSAwICYmIHBvcyArIDEgPCBudW1EZWx0YXMgJiYgZGVsdGFzW3BvcyArIDFdID09PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICsrcG9zO1xuICAgICAgICArK3J1bkxlbmd0aDtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gocnVuTGVuZ3RoIC0gMSk7XG4gICAgZm9yICh2YXIgaSA9IG9mZnNldDsgaSA8IHBvczsgKytpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKChkZWx0YXNbaV0gKyAyNTYpICYgMHhmZik7XG4gICAgfVxuICAgIHJldHVybiBwb3M7XG59XG5cbi8vIEhlbHBlciBmb3IgZW5jb2RlLlZBUkRFTFRBU1xuZnVuY3Rpb24gZW5jb2RlVmFyRGVsdGFSdW5Bc1dvcmRzKGRlbHRhcywgb2Zmc2V0LCByZXN1bHQpIHtcbiAgICB2YXIgcnVuTGVuZ3RoID0gMDtcbiAgICB2YXIgbnVtRGVsdGFzID0gZGVsdGFzLmxlbmd0aDtcbiAgICB2YXIgcG9zID0gb2Zmc2V0O1xuICAgIHdoaWxlIChwb3MgPCBudW1EZWx0YXMgJiYgcnVuTGVuZ3RoIDwgNjQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZGVsdGFzW3Bvc107XG5cbiAgICAgICAgLy8gV2l0aGluIGEgd29yZC1lbmNvZGVkIHJ1biBvZiBkZWx0YXMsIGl0IGlzIGVhc2llc3QgdG8gc3RhcnRcbiAgICAgICAgLy8gYSBuZXcgcnVuICh3aXRoIGEgZGlmZmVyZW50IGVuY29kaW5nKSB3aGVuZXZlciB3ZSBlbmNvdW50ZXJcbiAgICAgICAgLy8gYSB6ZXJvIHZhbHVlLiBGb3IgZXhhbXBsZSwgdGhlIHNlcXVlbmNlIFsweDY2NjYsIDAsIDB4Nzc3N11cbiAgICAgICAgLy8gbmVlZHMgNyBieXRlcyB3aGVuIHN0b3JpbmcgdGhlIHplcm8gaW5zaWRlIHRoZSBjdXJyZW50IHJ1blxuICAgICAgICAvLyAoNDIgNjYgNjYgMDAgMDAgNzcgNzcpLCBhbmQgZXF1YWxseSA3IGJ5dGVzIHdoZW4gc3RhcnRpbmcgYVxuICAgICAgICAvLyBuZXcgcnVuICg0MCA2NiA2NiA4MCA0MCA3NyA3NykuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXaXRoaW4gYSB3b3JkLWVuY29kZWQgcnVuIG9mIGRlbHRhcywgYSBzaW5nbGUgdmFsdWUgaW4gdGhlXG4gICAgICAgIC8vIHJhbmdlICgtMTI4Li4xMjcpIHNob3VsZCBiZSBlbmNvZGVkIHdpdGhpbiB0aGUgY3VycmVudCBydW5cbiAgICAgICAgLy8gYmVjYXVzZSBpdCBpcyBtb3JlIGNvbXBhY3QuIEZvciBleGFtcGxlLCB0aGUgc2VxdWVuY2VcbiAgICAgICAgLy8gWzB4NjY2NiwgMiwgMHg3Nzc3XSBiZWNvbWVzIDcgYnl0ZXMgd2hlbiBzdG9yaW5nIHRoZSB2YWx1ZVxuICAgICAgICAvLyBsaXRlcmFsbHkgKDQyIDY2IDY2IDAwIDAyIDc3IDc3KSwgYnV0IDggYnl0ZXMgd2hlbiBzdGFydGluZ1xuICAgICAgICAvLyBhIG5ldyBydW4gKDQwIDY2IDY2IDAwIDAyIDQwIDc3IDc3KS5cbiAgICAgICAgaWYgKGlzQnl0ZUVuY29kYWJsZSh2YWx1ZSkgJiYgcG9zICsgMSA8IG51bURlbHRhcyAmJiBpc0J5dGVFbmNvZGFibGUoZGVsdGFzW3BvcyArIDFdKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK3BvcztcbiAgICAgICAgKytydW5MZW5ndGg7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKDB4NDAgfCAocnVuTGVuZ3RoIC0gMSkpO1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBwb3M7ICsraSkge1xuICAgICAgICB2YXIgdmFsID0gZGVsdGFzW2ldO1xuICAgICAgICByZXN1bHQucHVzaCgoKHZhbCArIDB4MTAwMDApID4+IDgpICYgMHhmZiwgKHZhbCArIDB4MTAwKSAmIDB4ZmYpO1xuICAgIH1cbiAgICByZXR1cm4gcG9zO1xufVxuXG4vKipcbiAqIEVuY29kZSBhIGxpc3Qgb2YgdmFyaWF0aW9uIGFkanVzdG1lbnQgZGVsdGFzLlxuICpcbiAqIFZhcmlhdGlvbiBhZGp1c3RtZW50IGRlbHRhcyBhcmUgdXNlZCBpbiDigJhndmFy4oCZIGFuZCDigJhjdmFy4oCZIHRhYmxlcy5cbiAqIFRoZXkgaW5kaWNhdGUgaG93IHBvaW50cyAoaW4g4oCYZ3ZhcuKAmSkgb3IgdmFsdWVzIChpbiDigJhjdmFy4oCZKSBnZXQgYWRqdXN0ZWRcbiAqIHdoZW4gZ2VuZXJhdGluZyBpbnN0YW5jZXMgb2YgdmFyaWF0aW9uIGZvbnRzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L290c3BlYy9ndmFyLmh0bVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9udHMvVHJ1ZVR5cGUtUmVmZXJlbmNlLU1hbnVhbC9STTA2L0NoYXA2Z3Zhci5odG1sXG4gKiBAcGFyYW0ge0FycmF5fVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmVuY29kZS5WQVJERUxUQVMgPSBmdW5jdGlvbihkZWx0YXMpIHtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKHBvcyA8IGRlbHRhcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZGVsdGFzW3Bvc107XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgcG9zID0gZW5jb2RlVmFyRGVsdGFSdW5Bc1plcm9lcyhkZWx0YXMsIHBvcywgcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA+PSAtMTI4ICYmIHZhbHVlIDw9IDEyNykge1xuICAgICAgICAgICAgcG9zID0gZW5jb2RlVmFyRGVsdGFSdW5Bc0J5dGVzKGRlbHRhcywgcG9zLCByZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zID0gZW5jb2RlVmFyRGVsdGFSdW5Bc1dvcmRzKGRlbHRhcywgcG9zLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBDb252ZXJ0IGEgbGlzdCBvZiB2YWx1ZXMgdG8gYSBDRkYgSU5ERVggc3RydWN0dXJlLlxuLy8gVGhlIHZhbHVlcyBzaG91bGQgYmUgb2JqZWN0cyBjb250YWluaW5nIG5hbWUgLyB0eXBlIC8gdmFsdWUuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IGxcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLklOREVYID0gZnVuY3Rpb24obCkge1xuICAgIC8vdmFyIG9mZnNldCwgb2Zmc2V0cywgb2Zmc2V0RW5jb2RlciwgZW5jb2RlZE9mZnNldHMsIGVuY29kZWRPZmZzZXQsIGRhdGEsXG4gICAgLy8gICAgaSwgdjtcbiAgICAvLyBCZWNhdXNlIHdlIGhhdmUgdG8ga25vdyB3aGljaCBkYXRhIHR5cGUgdG8gdXNlIHRvIGVuY29kZSB0aGUgb2Zmc2V0cyxcbiAgICAvLyB3ZSBoYXZlIHRvIGdvIHRocm91Z2ggdGhlIHZhbHVlcyB0d2ljZTogb25jZSB0byBlbmNvZGUgdGhlIGRhdGEgYW5kXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBvZmZzZXRzLCB0aGVuIGFnYWluIHRvIGVuY29kZSB0aGUgb2Zmc2V0cyB1c2luZyB0aGUgZml0dGluZyBkYXRhIHR5cGUuXG4gICAgdmFyIG9mZnNldCA9IDE7IC8vIEZpcnN0IG9mZnNldCBpcyBhbHdheXMgMS5cbiAgICB2YXIgb2Zmc2V0cyA9IFtvZmZzZXRdO1xuICAgIHZhciBkYXRhID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciB2ID0gZW5jb2RlLk9CSkVDVChsW2ldKTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZGF0YSwgdik7XG4gICAgICAgIG9mZnNldCArPSB2Lmxlbmd0aDtcbiAgICAgICAgb2Zmc2V0cy5wdXNoKG9mZnNldCk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbMCwgMF07XG4gICAgfVxuXG4gICAgdmFyIGVuY29kZWRPZmZzZXRzID0gW107XG4gICAgdmFyIG9mZlNpemUgPSAoMSArIE1hdGguZmxvb3IoTWF0aC5sb2cob2Zmc2V0KSAvIE1hdGgubG9nKDIpKSAvIDgpIHwgMDtcbiAgICB2YXIgb2Zmc2V0RW5jb2RlciA9IFt1bmRlZmluZWQsIGVuY29kZS5CWVRFLCBlbmNvZGUuVVNIT1JULCBlbmNvZGUuVUlOVDI0LCBlbmNvZGUuVUxPTkddW29mZlNpemVdO1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG9mZnNldHMubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgZW5jb2RlZE9mZnNldCA9IG9mZnNldEVuY29kZXIob2Zmc2V0c1tpJDFdKTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZW5jb2RlZE9mZnNldHMsIGVuY29kZWRPZmZzZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0KGVuY29kZS5DYXJkMTYobC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlLk9mZlNpemUob2ZmU2l6ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVkT2Zmc2V0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuc2l6ZU9mLklOREVYID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBlbmNvZGUuSU5ERVgodikubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGFuIG9iamVjdCB0byBhIENGRiBESUNUIHN0cnVjdHVyZS5cbiAqIFRoZSBrZXlzIHNob3VsZCBiZSBudW1lcmljLlxuICogVGhlIHZhbHVlcyBzaG91bGQgYmUgb2JqZWN0cyBjb250YWluaW5nIG5hbWUgLyB0eXBlIC8gdmFsdWUuXG4gKiBAcGFyYW0ge09iamVjdH0gbVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuRElDVCA9IGZ1bmN0aW9uKG0pIHtcbiAgICB2YXIgZCA9IFtdO1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobSk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAvLyBPYmplY3Qua2V5cygpIHJldHVybiBzdHJpbmcga2V5cywgYnV0IG91ciBrZXlzIGFyZSBhbHdheXMgbnVtZXJpYy5cbiAgICAgICAgdmFyIGsgPSBwYXJzZUludChrZXlzW2ldLCAwKTtcbiAgICAgICAgdmFyIHYgPSBtW2tdO1xuICAgICAgICAvLyBWYWx1ZSBjb21lcyBiZWZvcmUgdGhlIGtleS5cbiAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5PUEVSQU5EKHYudmFsdWUsIHYudHlwZSkpO1xuICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk9QRVJBVE9SKGspKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuRElDVCA9IGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gZW5jb2RlLkRJQ1QobSkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZW5jb2RlLk9QRVJBVE9SID0gZnVuY3Rpb24odikge1xuICAgIGlmICh2IDwgMTIwMCkge1xuICAgICAgICByZXR1cm4gW3ZdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMTIsIHYgLSAxMjAwXTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IHZcbiAqIEBwYXJhbSB7c3RyaW5nfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuT1BFUkFORCA9IGZ1bmN0aW9uKHYsIHR5cGUpIHtcbiAgICB2YXIgZCA9IFtdO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY2hlY2suYXJndW1lbnQodi5sZW5ndGggPT09IHR5cGUubGVuZ3RoLCAnTm90IGVub3VnaCBhcmd1bWVudHMgZ2l2ZW4gZm9yIHR5cGUnICsgdHlwZSk7XG4gICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk9QRVJBTkQodltpXSwgdHlwZVtpXSkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdTSUQnKSB7XG4gICAgICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlLk5VTUJFUih2KSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29mZnNldCcpIHtcbiAgICAgICAgICAgIC8vIFdlIG1ha2UgaXQgZWFzeSBmb3Igb3Vyc2VsdmVzIGFuZCBhbHdheXMgZW5jb2RlIG9mZnNldHMgYXNcbiAgICAgICAgICAgIC8vIDQgYnl0ZXMuIFRoaXMgbWFrZXMgb2Zmc2V0IGNhbGN1bGF0aW9uIGZvciB0aGUgdG9wIGRpY3QgZWFzaWVyLlxuICAgICAgICAgICAgZCA9IGQuY29uY2F0KGVuY29kZS5OVU1CRVIzMih2KSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuTlVNQkVSKHYpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAncmVhbCcpIHtcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChlbmNvZGUuUkVBTCh2KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gb3BlcmFuZCB0eXBlICcgKyB0eXBlKTtcbiAgICAgICAgICAgIC8vIEZJWE1FIEFkZCBzdXBwb3J0IGZvciBib29sZWFuc1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG59O1xuXG5lbmNvZGUuT1AgPSBlbmNvZGUuQllURTtcbnNpemVPZi5PUCA9IHNpemVPZi5CWVRFO1xuXG4vLyBtZW1vaXplIGNoYXJzdHJpbmcgZW5jb2RpbmcgdXNpbmcgV2Vha01hcCBpZiBhdmFpbGFibGVcbnZhciB3bW0gPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIENvbnZlcnQgYSBsaXN0IG9mIENoYXJTdHJpbmcgb3BlcmF0aW9ucyB0byBieXRlcy5cbiAqIEBwYXJhbSB7QXJyYXl9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5DSEFSU1RSSU5HID0gZnVuY3Rpb24ob3BzKSB7XG4gICAgLy8gU2VlIGVuY29kZS5NQUNTVFJJTkcgZm9yIHdoeSB3ZSBkb24ndCBkbyBcImlmICh3bW0gJiYgd21tLmhhcyhvcHMpKVwiLlxuICAgIGlmICh3bW0pIHtcbiAgICAgICAgdmFyIGNhY2hlZFZhbHVlID0gd21tLmdldChvcHMpO1xuICAgICAgICBpZiAoY2FjaGVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGQgPSBbXTtcbiAgICB2YXIgbGVuZ3RoID0gb3BzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG9wID0gb3BzW2ldO1xuICAgICAgICBkID0gZC5jb25jYXQoZW5jb2RlW29wLnR5cGVdKG9wLnZhbHVlKSk7XG4gICAgfVxuXG4gICAgaWYgKHdtbSkge1xuICAgICAgICB3bW0uc2V0KG9wcywgZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuQ0hBUlNUUklORyA9IGZ1bmN0aW9uKG9wcykge1xuICAgIHJldHVybiBlbmNvZGUuQ0hBUlNUUklORyhvcHMpLmxlbmd0aDtcbn07XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb25zIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ29udmVydCBhbiBvYmplY3QgY29udGFpbmluZyBuYW1lIC8gdHlwZSAvIHZhbHVlIHRvIGJ5dGVzLlxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmVuY29kZS5PQkpFQ1QgPSBmdW5jdGlvbih2KSB7XG4gICAgdmFyIGVuY29kaW5nRnVuY3Rpb24gPSBlbmNvZGVbdi50eXBlXTtcbiAgICBjaGVjay5hcmd1bWVudChlbmNvZGluZ0Z1bmN0aW9uICE9PSB1bmRlZmluZWQsICdObyBlbmNvZGluZyBmdW5jdGlvbiBmb3IgdHlwZSAnICsgdi50eXBlKTtcbiAgICByZXR1cm4gZW5jb2RpbmdGdW5jdGlvbih2LnZhbHVlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuT0JKRUNUID0gZnVuY3Rpb24odikge1xuICAgIHZhciBzaXplT2ZGdW5jdGlvbiA9IHNpemVPZlt2LnR5cGVdO1xuICAgIGNoZWNrLmFyZ3VtZW50KHNpemVPZkZ1bmN0aW9uICE9PSB1bmRlZmluZWQsICdObyBzaXplT2YgZnVuY3Rpb24gZm9yIHR5cGUgJyArIHYudHlwZSk7XG4gICAgcmV0dXJuIHNpemVPZkZ1bmN0aW9uKHYudmFsdWUpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdGFibGUgb2JqZWN0IHRvIGJ5dGVzLlxuICogQSB0YWJsZSBjb250YWlucyBhIGxpc3Qgb2YgZmllbGRzIGNvbnRhaW5pbmcgdGhlIG1ldGFkYXRhIChuYW1lLCB0eXBlIGFuZCBkZWZhdWx0IHZhbHVlKS5cbiAqIFRoZSB0YWJsZSBpdHNlbGYgaGFzIHRoZSBmaWVsZCB2YWx1ZXMgc2V0IGFzIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge29wZW50eXBlLlRhYmxlfVxuICogQHJldHVybnMge0FycmF5fVxuICovXG5lbmNvZGUuVEFCTEUgPSBmdW5jdGlvbih0YWJsZSkge1xuICAgIHZhciBkID0gW107XG4gICAgdmFyIGxlbmd0aCA9IHRhYmxlLmZpZWxkcy5sZW5ndGg7XG4gICAgdmFyIHN1YnRhYmxlcyA9IFtdO1xuICAgIHZhciBzdWJ0YWJsZU9mZnNldHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gdGFibGUuZmllbGRzW2ldO1xuICAgICAgICB2YXIgZW5jb2RpbmdGdW5jdGlvbiA9IGVuY29kZVtmaWVsZC50eXBlXTtcbiAgICAgICAgY2hlY2suYXJndW1lbnQoZW5jb2RpbmdGdW5jdGlvbiAhPT0gdW5kZWZpbmVkLCAnTm8gZW5jb2RpbmcgZnVuY3Rpb24gZm9yIGZpZWxkIHR5cGUgJyArIGZpZWxkLnR5cGUgKyAnICgnICsgZmllbGQubmFtZSArICcpJyk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRhYmxlW2ZpZWxkLm5hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBmaWVsZC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBieXRlcyA9IGVuY29kaW5nRnVuY3Rpb24odmFsdWUpO1xuXG4gICAgICAgIGlmIChmaWVsZC50eXBlID09PSAnVEFCTEUnKSB7XG4gICAgICAgICAgICBzdWJ0YWJsZU9mZnNldHMucHVzaChkLmxlbmd0aCk7XG4gICAgICAgICAgICBkID0gZC5jb25jYXQoWzAsIDBdKTtcbiAgICAgICAgICAgIHN1YnRhYmxlcy5wdXNoKGJ5dGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGQgPSBkLmNvbmNhdChieXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBzdWJ0YWJsZXMubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgbyA9IHN1YnRhYmxlT2Zmc2V0c1tpJDFdO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gZC5sZW5ndGg7XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KG9mZnNldCA8IDY1NTM2LCAnVGFibGUgJyArIHRhYmxlLnRhYmxlTmFtZSArICcgdG9vIGJpZy4nKTtcbiAgICAgICAgZFtvXSA9IG9mZnNldCA+PiA4O1xuICAgICAgICBkW28gKyAxXSA9IG9mZnNldCAmIDB4ZmY7XG4gICAgICAgIGQgPSBkLmNvbmNhdChzdWJ0YWJsZXNbaSQxXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b3BlbnR5cGUuVGFibGV9XG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5zaXplT2YuVEFCTEUgPSBmdW5jdGlvbih0YWJsZSkge1xuICAgIHZhciBudW1CeXRlcyA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IHRhYmxlLmZpZWxkcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IHRhYmxlLmZpZWxkc1tpXTtcbiAgICAgICAgdmFyIHNpemVPZkZ1bmN0aW9uID0gc2l6ZU9mW2ZpZWxkLnR5cGVdO1xuICAgICAgICBjaGVjay5hcmd1bWVudChzaXplT2ZGdW5jdGlvbiAhPT0gdW5kZWZpbmVkLCAnTm8gc2l6ZU9mIGZ1bmN0aW9uIGZvciBmaWVsZCB0eXBlICcgKyBmaWVsZC50eXBlICsgJyAoJyArIGZpZWxkLm5hbWUgKyAnKScpO1xuICAgICAgICB2YXIgdmFsdWUgPSB0YWJsZVtmaWVsZC5uYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmllbGQudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBudW1CeXRlcyArPSBzaXplT2ZGdW5jdGlvbih2YWx1ZSk7XG5cbiAgICAgICAgLy8gU3VidGFibGVzIHRha2UgMiBtb3JlIGJ5dGVzIGZvciBvZmZzZXRzLlxuICAgICAgICBpZiAoZmllbGQudHlwZSA9PT0gJ1RBQkxFJykge1xuICAgICAgICAgICAgbnVtQnl0ZXMgKz0gMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudW1CeXRlcztcbn07XG5cbmVuY29kZS5SRUNPUkQgPSBlbmNvZGUuVEFCTEU7XG5zaXplT2YuUkVDT1JEID0gc2l6ZU9mLlRBQkxFO1xuXG4vLyBNZXJnZSBpbiBhIGxpc3Qgb2YgYnl0ZXMuXG5lbmNvZGUuTElURVJBTCA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdjtcbn07XG5cbnNpemVPZi5MSVRFUkFMID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiB2Lmxlbmd0aDtcbn07XG5cbi8vIFRhYmxlIG1ldGFkYXRhXG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuVGFibGVcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmd9IHRhYmxlTmFtZVxuICogQHBhcmFtIHtBcnJheX0gZmllbGRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRhYmxlKHRhYmxlTmFtZSwgZmllbGRzLCBvcHRpb25zKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgIHRoaXMkMVtmaWVsZC5uYW1lXSA9IGZpZWxkLnZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMudGFibGVOYW1lID0gdGFibGVOYW1lO1xuICAgIHRoaXMuZmllbGRzID0gZmllbGRzO1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRpb25LZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG9wdGlvbktleXMubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGsgPSBvcHRpb25LZXlzW2kkMV07XG4gICAgICAgICAgICB2YXIgdiA9IG9wdGlvbnNba107XG4gICAgICAgICAgICBpZiAodGhpcyQxW2tdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzJDFba10gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEVuY29kZXMgdGhlIHRhYmxlIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGJ5dGVzXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuVGFibGUucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBlbmNvZGUuVEFCTEUodGhpcyk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc2l6ZSBvZiB0aGUgdGFibGUuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblRhYmxlLnByb3RvdHlwZS5zaXplT2YgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2l6ZU9mLlRBQkxFKHRoaXMpO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1c2hvcnRMaXN0KGl0ZW1OYW1lLCBsaXN0LCBjb3VudCkge1xuICAgIGlmIChjb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvdW50ID0gbGlzdC5sZW5ndGg7XG4gICAgfVxuICAgIHZhciBmaWVsZHMgPSBuZXcgQXJyYXkobGlzdC5sZW5ndGggKyAxKTtcbiAgICBmaWVsZHNbMF0gPSB7bmFtZTogaXRlbU5hbWUgKyAnQ291bnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGNvdW50fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZmllbGRzW2kgKyAxXSA9IHtuYW1lOiBpdGVtTmFtZSArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbGlzdFtpXX07XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHM7XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdGFibGVMaXN0KGl0ZW1OYW1lLCByZWNvcmRzLCBpdGVtQ2FsbGJhY2spIHtcbiAgICB2YXIgY291bnQgPSByZWNvcmRzLmxlbmd0aDtcbiAgICB2YXIgZmllbGRzID0gbmV3IEFycmF5KGNvdW50ICsgMSk7XG4gICAgZmllbGRzWzBdID0ge25hbWU6IGl0ZW1OYW1lICsgJ0NvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBjb3VudH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGZpZWxkc1tpICsgMV0gPSB7bmFtZTogaXRlbU5hbWUgKyBpLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogaXRlbUNhbGxiYWNrKHJlY29yZHNbaV0sIGkpfTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNvcmRMaXN0KGl0ZW1OYW1lLCByZWNvcmRzLCBpdGVtQ2FsbGJhY2spIHtcbiAgICB2YXIgY291bnQgPSByZWNvcmRzLmxlbmd0aDtcbiAgICB2YXIgZmllbGRzID0gW107XG4gICAgZmllbGRzWzBdID0ge25hbWU6IGl0ZW1OYW1lICsgJ0NvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBjb3VudH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGZpZWxkcyA9IGZpZWxkcy5jb25jYXQoaXRlbUNhbGxiYWNrKHJlY29yZHNbaV0sIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbn1cblxuLy8gQ29tbW9uIExheW91dCBUYWJsZXNcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5Db3ZlcmFnZVxuICogQGNsYXNzXG4gKiBAcGFyYW0ge29wZW50eXBlLlRhYmxlfVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBvcGVudHlwZS5UYWJsZVxuICovXG5mdW5jdGlvbiBDb3ZlcmFnZShjb3ZlcmFnZVRhYmxlKSB7XG4gICAgaWYgKGNvdmVyYWdlVGFibGUuZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIFRhYmxlLmNhbGwodGhpcywgJ2NvdmVyYWdlVGFibGUnLFxuICAgICAgICAgICAgW3tuYW1lOiAnY292ZXJhZ2VGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9XVxuICAgICAgICAgICAgLmNvbmNhdCh1c2hvcnRMaXN0KCdnbHlwaCcsIGNvdmVyYWdlVGFibGUuZ2x5cGhzKSlcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjay5hc3NlcnQoZmFsc2UsICdDYW5cXCd0IGNyZWF0ZSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgMiB5ZXQuJyk7XG4gICAgfVxufVxuQ292ZXJhZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUYWJsZS5wcm90b3R5cGUpO1xuQ292ZXJhZ2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ292ZXJhZ2U7XG5cbmZ1bmN0aW9uIFNjcmlwdExpc3Qoc2NyaXB0TGlzdFRhYmxlKSB7XG4gICAgVGFibGUuY2FsbCh0aGlzLCAnc2NyaXB0TGlzdFRhYmxlJyxcbiAgICAgICAgcmVjb3JkTGlzdCgnc2NyaXB0UmVjb3JkJywgc2NyaXB0TGlzdFRhYmxlLCBmdW5jdGlvbihzY3JpcHRSZWNvcmQsIGkpIHtcbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBzY3JpcHRSZWNvcmQuc2NyaXB0O1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRMYW5nU3lzID0gc2NyaXB0LmRlZmF1bHRMYW5nU3lzO1xuICAgICAgICAgICAgY2hlY2suYXNzZXJ0KCEhZGVmYXVsdExhbmdTeXMsICdVbmFibGUgdG8gd3JpdGUgR1NVQjogc2NyaXB0ICcgKyBzY3JpcHRSZWNvcmQudGFnICsgJyBoYXMgbm8gZGVmYXVsdCBsYW5ndWFnZSBzeXN0ZW0uJyk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHtuYW1lOiAnc2NyaXB0VGFnJyArIGksIHR5cGU6ICdUQUcnLCB2YWx1ZTogc2NyaXB0UmVjb3JkLnRhZ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdzY3JpcHQnICsgaSwgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyBUYWJsZSgnc2NyaXB0VGFibGUnLCBbXG4gICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnZGVmYXVsdExhbmdTeXMnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IFRhYmxlKCdkZWZhdWx0TGFuZ1N5cycsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnbG9va3VwT3JkZXInLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdyZXFGZWF0dXJlSW5kZXgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGRlZmF1bHRMYW5nU3lzLnJlcUZlYXR1cmVJbmRleH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHVzaG9ydExpc3QoJ2ZlYXR1cmVJbmRleCcsIGRlZmF1bHRMYW5nU3lzLmZlYXR1cmVJbmRleGVzKSkpfVxuICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdChyZWNvcmRMaXN0KCdsYW5nU3lzJywgc2NyaXB0LmxhbmdTeXNSZWNvcmRzLCBmdW5jdGlvbihsYW5nU3lzUmVjb3JkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZ1N5cyA9IGxhbmdTeXNSZWNvcmQubGFuZ1N5cztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdsYW5nU3lzVGFnJyArIGksIHR5cGU6ICdUQUcnLCB2YWx1ZTogbGFuZ1N5c1JlY29yZC50YWd9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtuYW1lOiAnbGFuZ1N5cycgKyBpLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IFRhYmxlKCdsYW5nU3lzJywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7bmFtZTogJ2xvb2t1cE9yZGVyJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge25hbWU6ICdyZXFGZWF0dXJlSW5kZXgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxhbmdTeXMucmVxRmVhdHVyZUluZGV4fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLmNvbmNhdCh1c2hvcnRMaXN0KCdmZWF0dXJlSW5kZXgnLCBsYW5nU3lzLmZlYXR1cmVJbmRleGVzKSkpfVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfSkpKX1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pXG4gICAgKTtcbn1cblNjcmlwdExpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUYWJsZS5wcm90b3R5cGUpO1xuU2NyaXB0TGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY3JpcHRMaXN0O1xuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkZlYXR1cmVMaXN0XG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7b3BlbnR5cGUuVGFibGV9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG9wZW50eXBlLlRhYmxlXG4gKi9cbmZ1bmN0aW9uIEZlYXR1cmVMaXN0KGZlYXR1cmVMaXN0VGFibGUpIHtcbiAgICBUYWJsZS5jYWxsKHRoaXMsICdmZWF0dXJlTGlzdFRhYmxlJyxcbiAgICAgICAgcmVjb3JkTGlzdCgnZmVhdHVyZVJlY29yZCcsIGZlYXR1cmVMaXN0VGFibGUsIGZ1bmN0aW9uKGZlYXR1cmVSZWNvcmQsIGkpIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZVJlY29yZC5mZWF0dXJlO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7bmFtZTogJ2ZlYXR1cmVUYWcnICsgaSwgdHlwZTogJ1RBRycsIHZhbHVlOiBmZWF0dXJlUmVjb3JkLnRhZ30sXG4gICAgICAgICAgICAgICAge25hbWU6ICdmZWF0dXJlJyArIGksIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgVGFibGUoJ2ZlYXR1cmVUYWJsZScsIFtcbiAgICAgICAgICAgICAgICAgICAge25hbWU6ICdmZWF0dXJlUGFyYW1zJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBmZWF0dXJlLmZlYXR1cmVQYXJhbXN9IF0uY29uY2F0KHVzaG9ydExpc3QoJ2xvb2t1cExpc3RJbmRleCcsIGZlYXR1cmUubG9va3VwTGlzdEluZGV4ZXMpKSl9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9KVxuICAgICk7XG59XG5GZWF0dXJlTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRhYmxlLnByb3RvdHlwZSk7XG5GZWF0dXJlTGlzdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGZWF0dXJlTGlzdDtcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5Mb29rdXBMaXN0XG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7b3BlbnR5cGUuVGFibGV9XG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgb3BlbnR5cGUuVGFibGVcbiAqL1xuZnVuY3Rpb24gTG9va3VwTGlzdChsb29rdXBMaXN0VGFibGUsIHN1YnRhYmxlTWFrZXJzKSB7XG4gICAgVGFibGUuY2FsbCh0aGlzLCAnbG9va3VwTGlzdFRhYmxlJywgdGFibGVMaXN0KCdsb29rdXAnLCBsb29rdXBMaXN0VGFibGUsIGZ1bmN0aW9uKGxvb2t1cFRhYmxlKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZUNhbGxiYWNrID0gc3VidGFibGVNYWtlcnNbbG9va3VwVGFibGUubG9va3VwVHlwZV07XG4gICAgICAgIGNoZWNrLmFzc2VydCghIXN1YnRhYmxlQ2FsbGJhY2ssICdVbmFibGUgdG8gd3JpdGUgR1NVQiBsb29rdXAgdHlwZSAnICsgbG9va3VwVGFibGUubG9va3VwVHlwZSArICcgdGFibGVzLicpO1xuICAgICAgICByZXR1cm4gbmV3IFRhYmxlKCdsb29rdXBUYWJsZScsIFtcbiAgICAgICAgICAgIHtuYW1lOiAnbG9va3VwVHlwZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbG9va3VwVGFibGUubG9va3VwVHlwZX0sXG4gICAgICAgICAgICB7bmFtZTogJ2xvb2t1cEZsYWcnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGxvb2t1cFRhYmxlLmxvb2t1cEZsYWd9XG4gICAgICAgIF0uY29uY2F0KHRhYmxlTGlzdCgnc3VidGFibGUnLCBsb29rdXBUYWJsZS5zdWJ0YWJsZXMsIHN1YnRhYmxlQ2FsbGJhY2spKSk7XG4gICAgfSkpO1xufVxuTG9va3VwTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFRhYmxlLnByb3RvdHlwZSk7XG5Mb29rdXBMaXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExvb2t1cExpc3Q7XG5cbi8vIFJlY29yZCA9IHNhbWUgYXMgVGFibGUsIGJ1dCBpbmxpbmVkIChhIFRhYmxlIGhhcyBhbiBvZmZzZXQgYW5kIGl0cyBkYXRhIGlzIGZ1cnRoZXIgaW4gdGhlIHN0cmVhbSlcbi8vIERvbid0IHVzZSBvZmZzZXRzIGluc2lkZSBSZWNvcmRzIChwcm9iYWJsZSBidWcpLCBvbmx5IGluIFRhYmxlcy5cbnZhciB0YWJsZSA9IHtcbiAgICBUYWJsZTogVGFibGUsXG4gICAgUmVjb3JkOiBUYWJsZSxcbiAgICBDb3ZlcmFnZTogQ292ZXJhZ2UsXG4gICAgU2NyaXB0TGlzdDogU2NyaXB0TGlzdCxcbiAgICBGZWF0dXJlTGlzdDogRmVhdHVyZUxpc3QsXG4gICAgTG9va3VwTGlzdDogTG9va3VwTGlzdCxcbiAgICB1c2hvcnRMaXN0OiB1c2hvcnRMaXN0LFxuICAgIHRhYmxlTGlzdDogdGFibGVMaXN0LFxuICAgIHJlY29yZExpc3Q6IHJlY29yZExpc3QsXG59O1xuXG4vLyBQYXJzaW5nIHV0aWxpdHkgZnVuY3Rpb25zXG5cbi8vIFJldHJpZXZlIGFuIHVuc2lnbmVkIGJ5dGUgZnJvbSB0aGUgRGF0YVZpZXcuXG5mdW5jdGlvbiBnZXRCeXRlKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KTtcbn1cblxuLy8gUmV0cmlldmUgYW4gdW5zaWduZWQgMTYtYml0IHNob3J0IGZyb20gdGhlIERhdGFWaWV3LlxuLy8gVGhlIHZhbHVlIGlzIHN0b3JlZCBpbiBiaWcgZW5kaWFuLlxuZnVuY3Rpb24gZ2V0VVNob3J0KGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDE2KG9mZnNldCwgZmFsc2UpO1xufVxuXG4vLyBSZXRyaWV2ZSBhIHNpZ25lZCAxNi1iaXQgc2hvcnQgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5mdW5jdGlvbiBnZXRTaG9ydChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIGRhdGFWaWV3LmdldEludDE2KG9mZnNldCwgZmFsc2UpO1xufVxuXG4vLyBSZXRyaWV2ZSBhbiB1bnNpZ25lZCAzMi1iaXQgbG9uZyBmcm9tIHRoZSBEYXRhVmlldy5cbi8vIFRoZSB2YWx1ZSBpcyBzdG9yZWQgaW4gYmlnIGVuZGlhbi5cbmZ1bmN0aW9uIGdldFVMb25nKGRhdGFWaWV3LCBvZmZzZXQpIHtcbiAgICByZXR1cm4gZGF0YVZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xufVxuXG4vLyBSZXRyaWV2ZSBhIDMyLWJpdCBzaWduZWQgZml4ZWQtcG9pbnQgbnVtYmVyICgxNi4xNikgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUaGUgdmFsdWUgaXMgc3RvcmVkIGluIGJpZyBlbmRpYW4uXG5mdW5jdGlvbiBnZXRGaXhlZChkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgdmFyIGRlY2ltYWwgPSBkYXRhVmlldy5nZXRJbnQxNihvZmZzZXQsIGZhbHNlKTtcbiAgICB2YXIgZnJhY3Rpb24gPSBkYXRhVmlldy5nZXRVaW50MTYob2Zmc2V0ICsgMiwgZmFsc2UpO1xuICAgIHJldHVybiBkZWNpbWFsICsgZnJhY3Rpb24gLyA2NTUzNTtcbn1cblxuLy8gUmV0cmlldmUgYSA0LWNoYXJhY3RlciB0YWcgZnJvbSB0aGUgRGF0YVZpZXcuXG4vLyBUYWdzIGFyZSB1c2VkIHRvIGlkZW50aWZ5IHRhYmxlcy5cbmZ1bmN0aW9uIGdldFRhZyhkYXRhVmlldywgb2Zmc2V0KSB7XG4gICAgdmFyIHRhZyA9ICcnO1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXQ7IGkgPCBvZmZzZXQgKyA0OyBpICs9IDEpIHtcbiAgICAgICAgdGFnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVZpZXcuZ2V0SW50OChpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhZztcbn1cblxuLy8gUmV0cmlldmUgYW4gb2Zmc2V0IGZyb20gdGhlIERhdGFWaWV3LlxuLy8gT2Zmc2V0cyBhcmUgMSB0byA0IGJ5dGVzIGluIGxlbmd0aCwgZGVwZW5kaW5nIG9uIHRoZSBvZmZTaXplIGFyZ3VtZW50LlxuZnVuY3Rpb24gZ2V0T2Zmc2V0KGRhdGFWaWV3LCBvZmZzZXQsIG9mZlNpemUpIHtcbiAgICB2YXIgdiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvZmZTaXplOyBpICs9IDEpIHtcbiAgICAgICAgdiA8PD0gODtcbiAgICAgICAgdiArPSBkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyBpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdjtcbn1cblxuLy8gUmV0cmlldmUgYSBudW1iZXIgb2YgYnl0ZXMgZnJvbSBzdGFydCBvZmZzZXQgdG8gdGhlIGVuZCBvZmZzZXQgZnJvbSB0aGUgRGF0YVZpZXcuXG5mdW5jdGlvbiBnZXRCeXRlcyhkYXRhVmlldywgc3RhcnRPZmZzZXQsIGVuZE9mZnNldCkge1xuICAgIHZhciBieXRlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBzdGFydE9mZnNldDsgaSA8IGVuZE9mZnNldDsgaSArPSAxKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goZGF0YVZpZXcuZ2V0VWludDgoaSkpO1xuICAgIH1cblxuICAgIHJldHVybiBieXRlcztcbn1cblxuLy8gQ29udmVydCB0aGUgbGlzdCBvZiBieXRlcyB0byBhIHN0cmluZy5cbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgICB2YXIgcyA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcztcbn1cblxudmFyIHR5cGVPZmZzZXRzID0ge1xuICAgIGJ5dGU6IDEsXG4gICAgdVNob3J0OiAyLFxuICAgIHNob3J0OiAyLFxuICAgIHVMb25nOiA0LFxuICAgIGZpeGVkOiA0LFxuICAgIGxvbmdEYXRlVGltZTogOCxcbiAgICB0YWc6IDRcbn07XG5cbi8vIEEgc3RhdGVmdWwgcGFyc2VyIHRoYXQgY2hhbmdlcyB0aGUgb2Zmc2V0IHdoZW5ldmVyIGEgdmFsdWUgaXMgcmV0cmlldmVkLlxuLy8gVGhlIGRhdGEgaXMgYSBEYXRhVmlldy5cbmZ1bmN0aW9uIFBhcnNlcihkYXRhLCBvZmZzZXQpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgPSAwO1xufVxuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAxO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNoYXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRJbnQ4KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCk7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSAxO1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZUNhcmQ4ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZUJ5dGU7XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IHRoaXMuZGF0YS5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ2FyZDE2ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblBhcnNlci5wcm90b3R5cGUucGFyc2VTSUQgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZU9mZnNldDE2ID0gUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVTaG9ydDtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVNob3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHYgPSB0aGlzLmRhdGEuZ2V0SW50MTYodGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlRjJEb3QxNCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gdGhpcy5kYXRhLmdldEludDE2KHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldCkgLyAxNjM4NDtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDI7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVUxvbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IGdldFVMb25nKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0KTtcbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IDQ7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlT2Zmc2V0MzIgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVUxvbmc7XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VGaXhlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ID0gZ2V0Rml4ZWQodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gNDtcbiAgICByZXR1cm4gdjtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJpbmcgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgc3RyaW5nID0gJyc7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSBsZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhVmlldy5nZXRVaW50OChvZmZzZXQgKyBpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZztcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VUYWcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVN0cmluZyg0KTtcbn07XG5cbi8vIExPTkdEQVRFVElNRSBpcyBhIDY0LWJpdCBpbnRlZ2VyLlxuLy8gSmF2YVNjcmlwdCBhbmQgdW5peCB0aW1lc3RhbXBzIHRyYWRpdGlvbmFsbHkgdXNlIDMyIGJpdHMsIHNvIHdlXG4vLyBvbmx5IHRha2UgdGhlIGxhc3QgMzIgYml0cy5cbi8vICsgU2luY2UgdW50aWwgMjAzOCB0aG9zZSBiaXRzIHdpbGwgYmUgZmlsbGVkIGJ5IHplcm9zIHdlIGNhbiBpZ25vcmUgdGhlbS5cblBhcnNlci5wcm90b3R5cGUucGFyc2VMb25nRGF0ZVRpbWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdiA9IGdldFVMb25nKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0ICsgNCk7XG4gICAgLy8gU3VidHJhY3Qgc2Vjb25kcyBiZXR3ZWVuIDAxLzAxLzE5MDQgYW5kIDAxLzAxLzE5NzBcbiAgICAvLyB0byBjb252ZXJ0IEFwcGxlIE1hYyB0aW1lc3RhbXAgdG8gU3RhbmRhcmQgVW5peCB0aW1lc3RhbXBcbiAgICB2IC09IDIwODI4NDQ4MDA7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA4O1xuICAgIHJldHVybiB2O1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZlcnNpb24gPSBmdW5jdGlvbihtaW5vckJhc2UpIHtcbiAgICB2YXIgbWFqb3IgPSBnZXRVU2hvcnQodGhpcy5kYXRhLCB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQpO1xuXG4gICAgLy8gSG93IHRvIGludGVycHJldCB0aGUgbWlub3IgdmVyc2lvbiBpcyB2ZXJ5IHZhZ3VlIGluIHRoZSBzcGVjLiAweDUwMDAgaXMgNSwgMHgxMDAwIGlzIDFcbiAgICAvLyBEZWZhdWx0IHJldHVybnMgdGhlIGNvcnJlY3QgbnVtYmVyIGlmIG1pbm9yID0gMHhOMDAwIHdoZXJlIE4gaXMgMC05XG4gICAgLy8gU2V0IG1pbm9yQmFzZSB0byAxIGZvciB0YWJsZXMgdGhhdCB1c2UgbWlub3IgPSBOIHdoZXJlIE4gaXMgMC05XG4gICAgdmFyIG1pbm9yID0gZ2V0VVNob3J0KHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0ICsgMik7XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSA0O1xuICAgIGlmIChtaW5vckJhc2UgPT09IHVuZGVmaW5lZCkgeyBtaW5vckJhc2UgPSAweDEwMDA7IH1cbiAgICByZXR1cm4gbWFqb3IgKyBtaW5vciAvIG1pbm9yQmFzZSAvIDEwO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24odHlwZSwgYW1vdW50KSB7XG4gICAgaWYgKGFtb3VudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFtb3VudCA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCArPSB0eXBlT2Zmc2V0c1t0eXBlXSAqIGFtb3VudDtcbn07XG5cbi8vLy8vIFBhcnNpbmcgbGlzdHMgYW5kIHJlY29yZHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vLyBQYXJzZSBhIGxpc3Qgb2YgMzIgYml0IHVuc2lnbmVkIGludGVnZXJzLlxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVVMb25nTGlzdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQpIHsgY291bnQgPSB0aGlzLnBhcnNlVUxvbmcoKTsgfVxuICAgIHZhciBvZmZzZXRzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgb2Zmc2V0c1tpXSA9IGRhdGFWaWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gNDtcbiAgICB9XG5cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGNvdW50ICogNDtcbiAgICByZXR1cm4gb2Zmc2V0cztcbn07XG5cbi8vIFBhcnNlIGEgbGlzdCBvZiAxNiBiaXQgdW5zaWduZWQgaW50ZWdlcnMuIFRoZSBsZW5ndGggb2YgdGhlIGxpc3QgY2FuIGJlIHJlYWQgb24gdGhlIHN0cmVhbVxuLy8gb3IgcHJvdmlkZWQgYXMgYW4gYXJndW1lbnQuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlT2Zmc2V0MTZMaXN0ID1cblBhcnNlci5wcm90b3R5cGUucGFyc2VVU2hvcnRMaXN0ID0gZnVuY3Rpb24oY291bnQpIHtcbiAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCkgeyBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTsgfVxuICAgIHZhciBvZmZzZXRzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgb2Zmc2V0c1tpXSA9IGRhdGFWaWV3LmdldFVpbnQxNihvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gMjtcbiAgICB9XG5cbiAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0ICs9IGNvdW50ICogMjtcbiAgICByZXR1cm4gb2Zmc2V0cztcbn07XG5cbi8vIFBhcnNlcyBhIGxpc3Qgb2YgMTYgYml0IHNpZ25lZCBpbnRlZ2Vycy5cblBhcnNlci5wcm90b3R5cGUucGFyc2VTaG9ydExpc3QgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICB2YXIgZGF0YVZpZXcgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgbGlzdFtpXSA9IGRhdGFWaWV3LmdldEludDE2KG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSAyO1xuICAgIH1cblxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gY291bnQgKiAyO1xuICAgIHJldHVybiBsaXN0O1xufTtcblxuLy8gUGFyc2VzIGEgbGlzdCBvZiBieXRlcy5cblBhcnNlci5wcm90b3R5cGUucGFyc2VCeXRlTGlzdCA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIHZhciBkYXRhVmlldyA9IHRoaXMuZGF0YTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBsaXN0W2ldID0gZGF0YVZpZXcuZ2V0VWludDgob2Zmc2V0KyspO1xuICAgIH1cblxuICAgIHRoaXMucmVsYXRpdmVPZmZzZXQgKz0gY291bnQ7XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgbGlzdCBvZiBpdGVtcy5cbiAqIFJlY29yZCBjb3VudCBpcyBvcHRpb25hbCwgaWYgb21pdHRlZCBpdCBpcyByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAqIGl0ZW1DYWxsYmFjayBpcyBvbmUgb2YgdGhlIFBhcnNlciBtZXRob2RzLlxuICovXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTGlzdCA9IGZ1bmN0aW9uKGNvdW50LCBpdGVtQ2FsbGJhY2spIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICghaXRlbUNhbGxiYWNrKSB7XG4gICAgICAgIGl0ZW1DYWxsYmFjayA9IGNvdW50O1xuICAgICAgICBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB9XG4gICAgdmFyIGxpc3QgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBsaXN0W2ldID0gaXRlbUNhbGxiYWNrLmNhbGwodGhpcyQxKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlTGlzdDMyID0gZnVuY3Rpb24oY291bnQsIGl0ZW1DYWxsYmFjaykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKCFpdGVtQ2FsbGJhY2spIHtcbiAgICAgICAgaXRlbUNhbGxiYWNrID0gY291bnQ7XG4gICAgICAgIGNvdW50ID0gdGhpcy5wYXJzZVVMb25nKCk7XG4gICAgfVxuICAgIHZhciBsaXN0ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgbGlzdFtpXSA9IGl0ZW1DYWxsYmFjay5jYWxsKHRoaXMkMSk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIGxpc3Qgb2YgcmVjb3Jkcy5cbiAqIFJlY29yZCBjb3VudCBpcyBvcHRpb25hbCwgaWYgb21pdHRlZCBpdCBpcyByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAqIEV4YW1wbGUgb2YgcmVjb3JkRGVzY3JpcHRpb246IHsgc2VxdWVuY2VJbmRleDogUGFyc2VyLnVTaG9ydCwgbG9va3VwTGlzdEluZGV4OiBQYXJzZXIudVNob3J0IH1cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJlY29yZExpc3QgPSBmdW5jdGlvbihjb3VudCwgcmVjb3JkRGVzY3JpcHRpb24pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIC8vIElmIHRoZSBjb3VudCBhcmd1bWVudCBpcyBhYnNlbnQsIHJlYWQgaXQgaW4gdGhlIHN0cmVhbS5cbiAgICBpZiAoIXJlY29yZERlc2NyaXB0aW9uKSB7XG4gICAgICAgIHJlY29yZERlc2NyaXB0aW9uID0gY291bnQ7XG4gICAgICAgIGNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIH1cbiAgICB2YXIgcmVjb3JkcyA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgdmFyIGZpZWxkcyA9IE9iamVjdC5rZXlzKHJlY29yZERlc2NyaXB0aW9uKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHJlYyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpZWxkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkc1tqXTtcbiAgICAgICAgICAgIHZhciBmaWVsZFR5cGUgPSByZWNvcmREZXNjcmlwdGlvbltmaWVsZE5hbWVdO1xuICAgICAgICAgICAgcmVjW2ZpZWxkTmFtZV0gPSBmaWVsZFR5cGUuY2FsbCh0aGlzJDEpO1xuICAgICAgICB9XG4gICAgICAgIHJlY29yZHNbaV0gPSByZWM7XG4gICAgfVxuICAgIHJldHVybiByZWNvcmRzO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVJlY29yZExpc3QzMiA9IGZ1bmN0aW9uKGNvdW50LCByZWNvcmREZXNjcmlwdGlvbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgLy8gSWYgdGhlIGNvdW50IGFyZ3VtZW50IGlzIGFic2VudCwgcmVhZCBpdCBpbiB0aGUgc3RyZWFtLlxuICAgIGlmICghcmVjb3JkRGVzY3JpcHRpb24pIHtcbiAgICAgICAgcmVjb3JkRGVzY3JpcHRpb24gPSBjb3VudDtcbiAgICAgICAgY291bnQgPSB0aGlzLnBhcnNlVUxvbmcoKTtcbiAgICB9XG4gICAgdmFyIHJlY29yZHMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIHZhciBmaWVsZHMgPSBPYmplY3Qua2V5cyhyZWNvcmREZXNjcmlwdGlvbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciByZWMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWVsZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBmaWVsZE5hbWUgPSBmaWVsZHNbal07XG4gICAgICAgICAgICB2YXIgZmllbGRUeXBlID0gcmVjb3JkRGVzY3JpcHRpb25bZmllbGROYW1lXTtcbiAgICAgICAgICAgIHJlY1tmaWVsZE5hbWVdID0gZmllbGRUeXBlLmNhbGwodGhpcyQxKTtcbiAgICAgICAgfVxuICAgICAgICByZWNvcmRzW2ldID0gcmVjO1xuICAgIH1cbiAgICByZXR1cm4gcmVjb3Jkcztcbn07XG5cbi8vIFBhcnNlIGEgZGF0YSBzdHJ1Y3R1cmUgaW50byBhbiBvYmplY3Rcbi8vIEV4YW1wbGUgb2YgZGVzY3JpcHRpb246IHsgc2VxdWVuY2VJbmRleDogUGFyc2VyLnVTaG9ydCwgbG9va3VwTGlzdEluZGV4OiBQYXJzZXIudVNob3J0IH1cblBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJ1Y3QgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb24uY2FsbCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZmllbGRzID0gT2JqZWN0LmtleXMoZGVzY3JpcHRpb24pO1xuICAgICAgICB2YXIgc3RydWN0ID0ge307XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgZmllbGROYW1lID0gZmllbGRzW2pdO1xuICAgICAgICAgICAgdmFyIGZpZWxkVHlwZSA9IGRlc2NyaXB0aW9uW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICBzdHJ1Y3RbZmllbGROYW1lXSA9IGZpZWxkVHlwZS5jYWxsKHRoaXMkMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cnVjdDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgR1BPUyB2YWx1ZVJlY29yZFxuICogaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2dwb3MjdmFsdWUtcmVjb3JkXG4gKiB2YWx1ZUZvcm1hdCBpcyBvcHRpb25hbCwgaWYgb21pdHRlZCBpdCBpcyByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhbHVlUmVjb3JkID0gZnVuY3Rpb24odmFsdWVGb3JtYXQpIHtcbiAgICBpZiAodmFsdWVGb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZUZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlRm9ybWF0ID09PSAwKSB7XG4gICAgICAgIC8vIHZhbHVlRm9ybWF0MiBpbiBrZXJuaW5nIHBhaXJzIGlzIG1vc3Qgb2Z0ZW4gMFxuICAgICAgICAvLyBpbiB0aGlzIGNhc2UgcmV0dXJuIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGFuIGVtcHR5IG9iamVjdCwgdG8gc2F2ZSBzcGFjZVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB2YWx1ZVJlY29yZCA9IHt9O1xuXG4gICAgaWYgKHZhbHVlRm9ybWF0ICYgMHgwMDAxKSB7IHZhbHVlUmVjb3JkLnhQbGFjZW1lbnQgPSB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAwMikgeyB2YWx1ZVJlY29yZC55UGxhY2VtZW50ID0gdGhpcy5wYXJzZVNob3J0KCk7IH1cbiAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMDQpIHsgdmFsdWVSZWNvcmQueEFkdmFuY2UgPSB0aGlzLnBhcnNlU2hvcnQoKTsgfVxuICAgIGlmICh2YWx1ZUZvcm1hdCAmIDB4MDAwOCkgeyB2YWx1ZVJlY29yZC55QWR2YW5jZSA9IHRoaXMucGFyc2VTaG9ydCgpOyB9XG5cbiAgICAvLyBEZXZpY2UgdGFibGUgKG5vbi12YXJpYWJsZSBmb250KSAvIFZhcmlhdGlvbkluZGV4IHRhYmxlICh2YXJpYWJsZSBmb250KSBub3Qgc3VwcG9ydGVkXG4gICAgLy8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZnItZnIvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2NoYXB0ZXIyI2RldlZhcklkeFRibHNcbiAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMTApIHsgdmFsdWVSZWNvcmQueFBsYURldmljZSA9IHVuZGVmaW5lZDsgdGhpcy5wYXJzZVNob3J0KCk7IH1cbiAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwMjApIHsgdmFsdWVSZWNvcmQueVBsYURldmljZSA9IHVuZGVmaW5lZDsgdGhpcy5wYXJzZVNob3J0KCk7IH1cbiAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwNDApIHsgdmFsdWVSZWNvcmQueEFkdkRldmljZSA9IHVuZGVmaW5lZDsgdGhpcy5wYXJzZVNob3J0KCk7IH1cbiAgICBpZiAodmFsdWVGb3JtYXQgJiAweDAwODApIHsgdmFsdWVSZWNvcmQueUFkdkRldmljZSA9IHVuZGVmaW5lZDsgdGhpcy5wYXJzZVNob3J0KCk7IH1cblxuICAgIHJldHVybiB2YWx1ZVJlY29yZDtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBsaXN0IG9mIEdQT1MgdmFsdWVSZWNvcmRzXG4gKiBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvZ3BvcyN2YWx1ZS1yZWNvcmRcbiAqIHZhbHVlRm9ybWF0IGFuZCB2YWx1ZUNvdW50IGFyZSByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAqL1xuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVZhbHVlUmVjb3JkTGlzdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZhbHVlRm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciB2YWx1ZUNvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkodmFsdWVDb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICAgICAgdmFsdWVzW2ldID0gdGhpcyQxLnBhcnNlVmFsdWVSZWNvcmQodmFsdWVGb3JtYXQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5wYXJzZVBvaW50ZXIgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHZhciBzdHJ1Y3RPZmZzZXQgPSB0aGlzLnBhcnNlT2Zmc2V0MTYoKTtcbiAgICBpZiAoc3RydWN0T2Zmc2V0ID4gMCkge1xuICAgICAgICAvLyBOVUxMIG9mZnNldCA9PiByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VyKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyBzdHJ1Y3RPZmZzZXQpLnBhcnNlU3RydWN0KGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VQb2ludGVyMzIgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHZhciBzdHJ1Y3RPZmZzZXQgPSB0aGlzLnBhcnNlT2Zmc2V0MzIoKTtcbiAgICBpZiAoc3RydWN0T2Zmc2V0ID4gMCkge1xuICAgICAgICAvLyBOVUxMIG9mZnNldCA9PiByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VyKHRoaXMuZGF0YSwgdGhpcy5vZmZzZXQgKyBzdHJ1Y3RPZmZzZXQpLnBhcnNlU3RydWN0KGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBsaXN0IG9mIG9mZnNldHMgdG8gbGlzdHMgb2YgMTYtYml0IGludGVnZXJzLFxuICogb3IgYSBsaXN0IG9mIG9mZnNldHMgdG8gbGlzdHMgb2Ygb2Zmc2V0cyB0byBhbnkga2luZCBvZiBpdGVtcy5cbiAqIElmIGl0ZW1DYWxsYmFjayBpcyBub3QgcHJvdmlkZWQsIGEgbGlzdCBvZiBsaXN0IG9mIFVTaG9ydCBpcyBhc3N1bWVkLlxuICogSWYgcHJvdmlkZWQsIGl0ZW1DYWxsYmFjayBpcyBjYWxsZWQgb24gZWFjaCBpdGVtIGFuZCBtdXN0IHBhcnNlIHRoZSBpdGVtLlxuICogU2VlIGV4YW1wbGVzIGluIHRhYmxlcy9nc3ViLmpzXG4gKi9cblBhcnNlci5wcm90b3R5cGUucGFyc2VMaXN0T2ZMaXN0cyA9IGZ1bmN0aW9uKGl0ZW1DYWxsYmFjaykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG9mZnNldHMgPSB0aGlzLnBhcnNlT2Zmc2V0MTZMaXN0KCk7XG4gICAgdmFyIGNvdW50ID0gb2Zmc2V0cy5sZW5ndGg7XG4gICAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgbGlzdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBzdGFydCA9IG9mZnNldHNbaV07XG4gICAgICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTlVMTCBvZmZzZXRcbiAgICAgICAgICAgIC8vIEFkZCBpIGFzIG93bmVkIHByb3BlcnR5IHRvIGxpc3QuIENvbnZlbmllbnQgd2l0aCBhc3NlcnQuXG4gICAgICAgICAgICBsaXN0W2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcyQxLnJlbGF0aXZlT2Zmc2V0ID0gc3RhcnQ7XG4gICAgICAgIGlmIChpdGVtQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBzdWJPZmZzZXRzID0gdGhpcyQxLnBhcnNlT2Zmc2V0MTZMaXN0KCk7XG4gICAgICAgICAgICB2YXIgc3ViTGlzdCA9IG5ldyBBcnJheShzdWJPZmZzZXRzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1Yk9mZnNldHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzJDEucmVsYXRpdmVPZmZzZXQgPSBzdGFydCArIHN1Yk9mZnNldHNbal07XG4gICAgICAgICAgICAgICAgc3ViTGlzdFtqXSA9IGl0ZW1DYWxsYmFjay5jYWxsKHRoaXMkMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0W2ldID0gc3ViTGlzdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RbaV0gPSB0aGlzJDEucGFyc2VVU2hvcnRMaXN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5yZWxhdGl2ZU9mZnNldCA9IHJlbGF0aXZlT2Zmc2V0O1xuICAgIHJldHVybiBsaXN0O1xufTtcblxuLy8vLy8gQ29tcGxleCB0YWJsZXMgcGFyc2luZyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIFBhcnNlIGEgY292ZXJhZ2UgdGFibGUgaW4gYSBHU1VCLCBHUE9TIG9yIEdERUYgdGFibGUuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NoYXB0ZXIyLmh0bVxuLy8gcGFyc2VyLm9mZnNldCBtdXN0IHBvaW50IHRvIHRoZSBzdGFydCBvZiB0aGUgdGFibGUgY29udGFpbmluZyB0aGUgY292ZXJhZ2UuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlQ292ZXJhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBjb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6IDEsXG4gICAgICAgICAgICBnbHlwaHM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KGNvdW50KVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHZhciByYW5nZXMgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHJhbmdlc1tpXSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogdGhpcyQxLnBhcnNlVVNob3J0KCksXG4gICAgICAgICAgICAgICAgZW5kOiB0aGlzJDEucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcyQxLnBhcnNlVVNob3J0KClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogMixcbiAgICAgICAgICAgIHJhbmdlczogcmFuZ2VzXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignMHgnICsgc3RhcnRPZmZzZXQudG9TdHJpbmcoMTYpICsgJzogQ292ZXJhZ2UgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xufTtcblxuLy8gUGFyc2UgYSBDbGFzcyBEZWZpbml0aW9uIFRhYmxlIGluIGEgR1NVQiwgR1BPUyBvciBHREVGIHRhYmxlLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFwdGVyMi5odG1cblBhcnNlci5wcm90b3R5cGUucGFyc2VDbGFzc0RlZiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogMSxcbiAgICAgICAgICAgIHN0YXJ0R2x5cGg6IHRoaXMucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgIGNsYXNzZXM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KClcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiAyLFxuICAgICAgICAgICAgcmFuZ2VzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IFBhcnNlci51U2hvcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBQYXJzZXIudVNob3J0LFxuICAgICAgICAgICAgICAgIGNsYXNzSWQ6IFBhcnNlci51U2hvcnRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignMHgnICsgc3RhcnRPZmZzZXQudG9TdHJpbmcoMTYpICsgJzogQ2xhc3NEZWYgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xufTtcblxuLy8vLy8gU3RhdGljIG1ldGhvZHMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFRoZXNlIGNvbnZlbmllbmNlIG1ldGhvZHMgY2FuIGJlIHVzZWQgYXMgY2FsbGJhY2tzIGFuZCBzaG91bGQgYmUgY2FsbGVkIHdpdGggXCJ0aGlzXCIgY29udGV4dCBzZXQgdG8gYSBQYXJzZXIgaW5zdGFuY2UuXG5cblBhcnNlci5saXN0ID0gZnVuY3Rpb24oY291bnQsIGl0ZW1DYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXN0KGNvdW50LCBpdGVtQ2FsbGJhY2spO1xuICAgIH07XG59O1xuXG5QYXJzZXIubGlzdDMyID0gZnVuY3Rpb24oY291bnQsIGl0ZW1DYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXN0MzIoY291bnQsIGl0ZW1DYWxsYmFjayk7XG4gICAgfTtcbn07XG5cblBhcnNlci5yZWNvcmRMaXN0ID0gZnVuY3Rpb24oY291bnQsIHJlY29yZERlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJlY29yZExpc3QoY291bnQsIHJlY29yZERlc2NyaXB0aW9uKTtcbiAgICB9O1xufTtcblxuUGFyc2VyLnJlY29yZExpc3QzMiA9IGZ1bmN0aW9uKGNvdW50LCByZWNvcmREZXNjcmlwdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSZWNvcmRMaXN0MzIoY291bnQsIHJlY29yZERlc2NyaXB0aW9uKTtcbiAgICB9O1xufTtcblxuUGFyc2VyLnBvaW50ZXIgPSBmdW5jdGlvbihkZXNjcmlwdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyKGRlc2NyaXB0aW9uKTtcbiAgICB9O1xufTtcblxuUGFyc2VyLnBvaW50ZXIzMiA9IGZ1bmN0aW9uKGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIzMihkZXNjcmlwdGlvbik7XG4gICAgfTtcbn07XG5cblBhcnNlci50YWcgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVGFnO1xuUGFyc2VyLmJ5dGUgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQnl0ZTtcblBhcnNlci51U2hvcnQgPSBQYXJzZXIub2Zmc2V0MTYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0O1xuUGFyc2VyLnVTaG9ydExpc3QgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVVNob3J0TGlzdDtcblBhcnNlci51TG9uZyA9IFBhcnNlci5vZmZzZXQzMiA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VVTG9uZztcblBhcnNlci51TG9uZ0xpc3QgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlVUxvbmdMaXN0O1xuUGFyc2VyLnN0cnVjdCA9IFBhcnNlci5wcm90b3R5cGUucGFyc2VTdHJ1Y3Q7XG5QYXJzZXIuY292ZXJhZ2UgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ292ZXJhZ2U7XG5QYXJzZXIuY2xhc3NEZWYgPSBQYXJzZXIucHJvdG90eXBlLnBhcnNlQ2xhc3NEZWY7XG5cbi8vLy8vIFNjcmlwdCwgRmVhdHVyZSwgTG9va3VwIGxpc3RzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2NoYXB0ZXIyLmh0bVxuXG52YXIgbGFuZ1N5c1RhYmxlID0ge1xuICAgIHJlc2VydmVkOiBQYXJzZXIudVNob3J0LFxuICAgIHJlcUZlYXR1cmVJbmRleDogUGFyc2VyLnVTaG9ydCxcbiAgICBmZWF0dXJlSW5kZXhlczogUGFyc2VyLnVTaG9ydExpc3Rcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VTY3JpcHRMaXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5yZWNvcmRMaXN0KHtcbiAgICAgICAgdGFnOiBQYXJzZXIudGFnLFxuICAgICAgICBzY3JpcHQ6IFBhcnNlci5wb2ludGVyKHtcbiAgICAgICAgICAgIGRlZmF1bHRMYW5nU3lzOiBQYXJzZXIucG9pbnRlcihsYW5nU3lzVGFibGUpLFxuICAgICAgICAgICAgbGFuZ1N5c1JlY29yZHM6IFBhcnNlci5yZWNvcmRMaXN0KHtcbiAgICAgICAgICAgICAgICB0YWc6IFBhcnNlci50YWcsXG4gICAgICAgICAgICAgICAgbGFuZ1N5czogUGFyc2VyLnBvaW50ZXIobGFuZ1N5c1RhYmxlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9KSkgfHwgW107XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlRmVhdHVyZUxpc3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLnJlY29yZExpc3Qoe1xuICAgICAgICB0YWc6IFBhcnNlci50YWcsXG4gICAgICAgIGZlYXR1cmU6IFBhcnNlci5wb2ludGVyKHtcbiAgICAgICAgICAgIGZlYXR1cmVQYXJhbXM6IFBhcnNlci5vZmZzZXQxNixcbiAgICAgICAgICAgIGxvb2t1cExpc3RJbmRleGVzOiBQYXJzZXIudVNob3J0TGlzdFxuICAgICAgICB9KVxuICAgIH0pKSB8fCBbXTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VMb29rdXBMaXN0ID0gZnVuY3Rpb24obG9va3VwVGFibGVQYXJzZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5saXN0KFBhcnNlci5wb2ludGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbG9va3VwVHlwZSA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgY2hlY2suYXJndW1lbnQoMSA8PSBsb29rdXBUeXBlICYmIGxvb2t1cFR5cGUgPD0gOSwgJ0dQT1MvR1NVQiBsb29rdXAgdHlwZSAnICsgbG9va3VwVHlwZSArICcgdW5rbm93bi4nKTtcbiAgICAgICAgdmFyIGxvb2t1cEZsYWcgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciB1c2VNYXJrRmlsdGVyaW5nU2V0ID0gbG9va3VwRmxhZyAmIDB4MTA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb29rdXBUeXBlOiBsb29rdXBUeXBlLFxuICAgICAgICAgICAgbG9va3VwRmxhZzogbG9va3VwRmxhZyxcbiAgICAgICAgICAgIHN1YnRhYmxlczogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIobG9va3VwVGFibGVQYXJzZXJzW2xvb2t1cFR5cGVdKSksXG4gICAgICAgICAgICBtYXJrRmlsdGVyaW5nU2V0OiB1c2VNYXJrRmlsdGVyaW5nU2V0ID8gdGhpcy5wYXJzZVVTaG9ydCgpIDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfSkpKSB8fCBbXTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUucGFyc2VGZWF0dXJlVmFyaWF0aW9uc0xpc3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBvaW50ZXIzMihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1ham9yVmVyc2lvbiA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIG1pbm9yVmVyc2lvbiA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgY2hlY2suYXJndW1lbnQobWFqb3JWZXJzaW9uID09PSAxICYmIG1pbm9yVmVyc2lvbiA8IDEsICdHUE9TL0dTVUIgZmVhdHVyZSB2YXJpYXRpb25zIHRhYmxlIHVua25vd24uJyk7XG4gICAgICAgIHZhciBmZWF0dXJlVmFyaWF0aW9ucyA9IHRoaXMucGFyc2VSZWNvcmRMaXN0MzIoe1xuICAgICAgICAgICAgY29uZGl0aW9uU2V0T2Zmc2V0OiBQYXJzZXIub2Zmc2V0MzIsXG4gICAgICAgICAgICBmZWF0dXJlVGFibGVTdWJzdGl0dXRpb25PZmZzZXQ6IFBhcnNlci5vZmZzZXQzMlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVWYXJpYXRpb25zO1xuICAgIH0pIHx8IFtdO1xufTtcblxudmFyIHBhcnNlID0ge1xuICAgIGdldEJ5dGU6IGdldEJ5dGUsXG4gICAgZ2V0Q2FyZDg6IGdldEJ5dGUsXG4gICAgZ2V0VVNob3J0OiBnZXRVU2hvcnQsXG4gICAgZ2V0Q2FyZDE2OiBnZXRVU2hvcnQsXG4gICAgZ2V0U2hvcnQ6IGdldFNob3J0LFxuICAgIGdldFVMb25nOiBnZXRVTG9uZyxcbiAgICBnZXRGaXhlZDogZ2V0Rml4ZWQsXG4gICAgZ2V0VGFnOiBnZXRUYWcsXG4gICAgZ2V0T2Zmc2V0OiBnZXRPZmZzZXQsXG4gICAgZ2V0Qnl0ZXM6IGdldEJ5dGVzLFxuICAgIGJ5dGVzVG9TdHJpbmc6IGJ5dGVzVG9TdHJpbmcsXG4gICAgUGFyc2VyOiBQYXJzZXIsXG59O1xuXG4vLyBUaGUgYGNtYXBgIHRhYmxlIHN0b3JlcyB0aGUgbWFwcGluZ3MgZnJvbSBjaGFyYWN0ZXJzIHRvIGdseXBocy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvY21hcC5odG1cblxuZnVuY3Rpb24gcGFyc2VDbWFwVGFibGVGb3JtYXQxMihjbWFwLCBwKSB7XG4gICAgLy9Ta2lwIHJlc2VydmVkLlxuICAgIHAucGFyc2VVU2hvcnQoKTtcblxuICAgIC8vIExlbmd0aCBpbiBieXRlcyBvZiB0aGUgc3ViLXRhYmxlcy5cbiAgICBjbWFwLmxlbmd0aCA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNtYXAubGFuZ3VhZ2UgPSBwLnBhcnNlVUxvbmcoKTtcblxuICAgIHZhciBncm91cENvdW50O1xuICAgIGNtYXAuZ3JvdXBDb3VudCA9IGdyb3VwQ291bnQgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjbWFwLmdseXBoSW5kZXhNYXAgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBzdGFydENoYXJDb2RlID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIHZhciBlbmRDaGFyQ29kZSA9IHAucGFyc2VVTG9uZygpO1xuICAgICAgICB2YXIgc3RhcnRHbHlwaElkID0gcC5wYXJzZVVMb25nKCk7XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IHN0YXJ0Q2hhckNvZGU7IGMgPD0gZW5kQ2hhckNvZGU7IGMgKz0gMSkge1xuICAgICAgICAgICAgY21hcC5nbHlwaEluZGV4TWFwW2NdID0gc3RhcnRHbHlwaElkO1xuICAgICAgICAgICAgc3RhcnRHbHlwaElkKys7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ21hcFRhYmxlRm9ybWF0NChjbWFwLCBwLCBkYXRhLCBzdGFydCwgb2Zmc2V0KSB7XG4gICAgLy8gTGVuZ3RoIGluIGJ5dGVzIG9mIHRoZSBzdWItdGFibGVzLlxuICAgIGNtYXAubGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGNtYXAubGFuZ3VhZ2UgPSBwLnBhcnNlVVNob3J0KCk7XG5cbiAgICAvLyBzZWdDb3VudCBpcyBzdG9yZWQgeCAyLlxuICAgIHZhciBzZWdDb3VudDtcbiAgICBjbWFwLnNlZ0NvdW50ID0gc2VnQ291bnQgPSBwLnBhcnNlVVNob3J0KCkgPj4gMTtcblxuICAgIC8vIFNraXAgc2VhcmNoUmFuZ2UsIGVudHJ5U2VsZWN0b3IsIHJhbmdlU2hpZnQuXG4gICAgcC5za2lwKCd1U2hvcnQnLCAzKTtcblxuICAgIC8vIFRoZSBcInVucm9sbGVkXCIgbWFwcGluZyBmcm9tIGNoYXJhY3RlciBjb2RlcyB0byBnbHlwaCBpbmRpY2VzLlxuICAgIGNtYXAuZ2x5cGhJbmRleE1hcCA9IHt9O1xuICAgIHZhciBlbmRDb3VudFBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQgKyAxNCk7XG4gICAgdmFyIHN0YXJ0Q291bnRQYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0ICsgb2Zmc2V0ICsgMTYgKyBzZWdDb3VudCAqIDIpO1xuICAgIHZhciBpZERlbHRhUGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA0KTtcbiAgICB2YXIgaWRSYW5nZU9mZnNldFBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQgKyAxNiArIHNlZ0NvdW50ICogNik7XG4gICAgdmFyIGdseXBoSW5kZXhPZmZzZXQgPSBzdGFydCArIG9mZnNldCArIDE2ICsgc2VnQ291bnQgKiA4O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnQ291bnQgLSAxOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoSW5kZXggPSAodm9pZCAwKTtcbiAgICAgICAgdmFyIGVuZENvdW50ID0gZW5kQ291bnRQYXJzZXIucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIHN0YXJ0Q291bnQgPSBzdGFydENvdW50UGFyc2VyLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBpZERlbHRhID0gaWREZWx0YVBhcnNlci5wYXJzZVNob3J0KCk7XG4gICAgICAgIHZhciBpZFJhbmdlT2Zmc2V0ID0gaWRSYW5nZU9mZnNldFBhcnNlci5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBmb3IgKHZhciBjID0gc3RhcnRDb3VudDsgYyA8PSBlbmRDb3VudDsgYyArPSAxKSB7XG4gICAgICAgICAgICBpZiAoaWRSYW5nZU9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBpZFJhbmdlT2Zmc2V0IGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBpZFJhbmdlT2Zmc2V0IGFycmF5LlxuICAgICAgICAgICAgICAgIC8vIFRha2UgdGhlIGN1cnJlbnQgb2Zmc2V0IGluIHRoZSBpZFJhbmdlT2Zmc2V0IGFycmF5LlxuICAgICAgICAgICAgICAgIGdseXBoSW5kZXhPZmZzZXQgPSAoaWRSYW5nZU9mZnNldFBhcnNlci5vZmZzZXQgKyBpZFJhbmdlT2Zmc2V0UGFyc2VyLnJlbGF0aXZlT2Zmc2V0IC0gMik7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHZhbHVlIG9mIHRoZSBpZFJhbmdlT2Zmc2V0LCB3aGljaCB3aWxsIG1vdmUgdXMgaW50byB0aGUgZ2x5cGhJbmRleCBhcnJheS5cbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ICs9IGlkUmFuZ2VPZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGVuIGFkZCB0aGUgY2hhcmFjdGVyIGluZGV4IG9mIHRoZSBjdXJyZW50IHNlZ21lbnQsIG11bHRpcGxpZWQgYnkgMiBmb3IgVVNIT1JUcy5cbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4T2Zmc2V0ICs9IChjIC0gc3RhcnRDb3VudCkgKiAyO1xuICAgICAgICAgICAgICAgIGdseXBoSW5kZXggPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgZ2x5cGhJbmRleE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoSW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2x5cGhJbmRleCA9IChnbHlwaEluZGV4ICsgaWREZWx0YSkgJiAweEZGRkY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbHlwaEluZGV4ID0gKGMgKyBpZERlbHRhKSAmIDB4RkZGRjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY21hcC5nbHlwaEluZGV4TWFwW2NdID0gZ2x5cGhJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gUGFyc2UgdGhlIGBjbWFwYCB0YWJsZS4gVGhpcyB0YWJsZSBzdG9yZXMgdGhlIG1hcHBpbmdzIGZyb20gY2hhcmFjdGVycyB0byBnbHlwaHMuXG4vLyBUaGVyZSBhcmUgbWFueSBhdmFpbGFibGUgZm9ybWF0cywgYnV0IHdlIG9ubHkgc3VwcG9ydCB0aGUgV2luZG93cyBmb3JtYXQgNCBhbmQgMTIuXG4vLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBgQ21hcEVuY29kaW5nYCBvYmplY3Qgb3IgbnVsbCBpZiBubyBzdXBwb3J0ZWQgZm9ybWF0IGNvdWxkIGJlIGZvdW5kLlxuZnVuY3Rpb24gcGFyc2VDbWFwVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgY21hcCA9IHt9O1xuICAgIGNtYXAudmVyc2lvbiA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCk7XG4gICAgY2hlY2suYXJndW1lbnQoY21hcC52ZXJzaW9uID09PSAwLCAnY21hcCB0YWJsZSB2ZXJzaW9uIHNob3VsZCBiZSAwLicpO1xuXG4gICAgLy8gVGhlIGNtYXAgdGFibGUgY2FuIGNvbnRhaW4gbWFueSBzdWItdGFibGVzLCBlYWNoIHdpdGggdGhlaXIgb3duIGZvcm1hdC5cbiAgICAvLyBXZSdyZSBvbmx5IGludGVyZXN0ZWQgaW4gYSBcInBsYXRmb3JtIDNcIiB0YWJsZS4gVGhpcyBpcyBhIFdpbmRvd3MgZm9ybWF0LlxuICAgIGNtYXAubnVtVGFibGVzID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0ICsgMik7XG4gICAgdmFyIG9mZnNldCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSBjbWFwLm51bVRhYmxlcyAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHZhciBwbGF0Zm9ybUlkID0gcGFyc2UuZ2V0VVNob3J0KGRhdGEsIHN0YXJ0ICsgNCArIChpICogOCkpO1xuICAgICAgICB2YXIgZW5jb2RpbmdJZCA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCBzdGFydCArIDQgKyAoaSAqIDgpICsgMik7XG4gICAgICAgIGlmIChwbGF0Zm9ybUlkID09PSAzICYmIChlbmNvZGluZ0lkID09PSAwIHx8IGVuY29kaW5nSWQgPT09IDEgfHwgZW5jb2RpbmdJZCA9PT0gMTApKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBzdGFydCArIDQgKyAoaSAqIDgpICsgNCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPT09IC0xKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIGNtYXAgdGFibGUgaW4gdGhlIGZvbnQgdGhhdCB3ZSBzdXBwb3J0LlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIGNtYXAgc3ViLXRhYmxlcyBmb3VuZC4nKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQgKyBvZmZzZXQpO1xuICAgIGNtYXAuZm9ybWF0ID0gcC5wYXJzZVVTaG9ydCgpO1xuXG4gICAgaWYgKGNtYXAuZm9ybWF0ID09PSAxMikge1xuICAgICAgICBwYXJzZUNtYXBUYWJsZUZvcm1hdDEyKGNtYXAsIHApO1xuICAgIH0gZWxzZSBpZiAoY21hcC5mb3JtYXQgPT09IDQpIHtcbiAgICAgICAgcGFyc2VDbWFwVGFibGVGb3JtYXQ0KGNtYXAsIHAsIGRhdGEsIHN0YXJ0LCBvZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBmb3JtYXQgNCBhbmQgMTIgY21hcCB0YWJsZXMgYXJlIHN1cHBvcnRlZCAoZm91bmQgZm9ybWF0ICcgKyBjbWFwLmZvcm1hdCArICcpLicpO1xuICAgIH1cblxuICAgIHJldHVybiBjbWFwO1xufVxuXG5mdW5jdGlvbiBhZGRTZWdtZW50KHQsIGNvZGUsIGdseXBoSW5kZXgpIHtcbiAgICB0LnNlZ21lbnRzLnB1c2goe1xuICAgICAgICBlbmQ6IGNvZGUsXG4gICAgICAgIHN0YXJ0OiBjb2RlLFxuICAgICAgICBkZWx0YTogLShjb2RlIC0gZ2x5cGhJbmRleCksXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgZ2x5cGhJbmRleDogZ2x5cGhJbmRleFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUZXJtaW5hdG9yU2VnbWVudCh0KSB7XG4gICAgdC5zZWdtZW50cy5wdXNoKHtcbiAgICAgICAgZW5kOiAweEZGRkYsXG4gICAgICAgIHN0YXJ0OiAweEZGRkYsXG4gICAgICAgIGRlbHRhOiAxLFxuICAgICAgICBvZmZzZXQ6IDBcbiAgICB9KTtcbn1cblxuLy8gTWFrZSBjbWFwIHRhYmxlLCBmb3JtYXQgNCBieSBkZWZhdWx0LCAxMiBpZiBuZWVkZWQgb25seVxuZnVuY3Rpb24gbWFrZUNtYXBUYWJsZShnbHlwaHMpIHtcbiAgICAvLyBQbGFuIDAgaXMgdGhlIGJhc2UgVW5pY29kZSBQbGFuIGJ1dCBlbW9qaXMsIGZvciBleGFtcGxlIGFyZSBvbiBhbm90aGVyIHBsYW4sIGFuZCBuZWVkcyBjbWFwIDEyIGZvcm1hdCAod2l0aCAzMmJpdClcbiAgICB2YXIgaXNQbGFuME9ubHkgPSB0cnVlO1xuICAgIHZhciBpO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBhZGQgY21hcCBmb3JtYXQgMTIgb3IgaWYgZm9ybWF0IDQgb25seSBpcyBmaW5lXG4gICAgZm9yIChpID0gZ2x5cGhzLmxlbmd0aCAtIDE7IGkgPiAwOyBpIC09IDEpIHtcbiAgICAgICAgdmFyIGcgPSBnbHlwaHMuZ2V0KGkpO1xuICAgICAgICBpZiAoZy51bmljb2RlID4gNjU1MzUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgQ01BUCBmb3JtYXQgMTIgKG5lZWRlZCEpJyk7XG4gICAgICAgICAgICBpc1BsYW4wT25seSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY21hcFRhYmxlID0gW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ251bVRhYmxlcycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogaXNQbGFuME9ubHkgPyAxIDogMn0sXG5cbiAgICAgICAgLy8gQ01BUCA0IGhlYWRlclxuICAgICAgICB7bmFtZTogJ3BsYXRmb3JtSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDN9LFxuICAgICAgICB7bmFtZTogJ2VuY29kaW5nSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ29mZnNldCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBpc1BsYW4wT25seSA/IDEyIDogKDEyICsgOCl9XG4gICAgXTtcblxuICAgIGlmICghaXNQbGFuME9ubHkpXG4gICAgICAgIHsgY21hcFRhYmxlID0gY21hcFRhYmxlLmNvbmNhdChbXG4gICAgICAgICAgICAvLyBDTUFQIDEyIGhlYWRlclxuICAgICAgICAgICAge25hbWU6ICdjbWFwMTJQbGF0Zm9ybUlEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAzfSwgLy8gV2UgZW5jb2RlIG9ubHkgZm9yIFBsYXRmb3JtSUQgPSAzIChXaW5kb3dzKSBiZWNhdXNlIGl0IGlzIHN1cHBvcnRlZCBldmVyeXdoZXJlXG4gICAgICAgICAgICB7bmFtZTogJ2NtYXAxMkVuY29kaW5nSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDEwfSxcbiAgICAgICAgICAgIHtuYW1lOiAnY21hcDEyT2Zmc2V0JywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9XG4gICAgICAgIF0pOyB9XG5cbiAgICBjbWFwVGFibGUgPSBjbWFwVGFibGUuY29uY2F0KFtcbiAgICAgICAgLy8gQ01BUCA0IFN1YnRhYmxlXG4gICAgICAgIHtuYW1lOiAnZm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiA0fSxcbiAgICAgICAge25hbWU6ICdjbWFwNExlbmd0aCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbGFuZ3VhZ2UnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NlZ0NvdW50WDInLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NlYXJjaFJhbmdlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdlbnRyeVNlbGVjdG9yJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyYW5nZVNoaWZ0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0pO1xuXG4gICAgdmFyIHQgPSBuZXcgdGFibGUuVGFibGUoJ2NtYXAnLCBjbWFwVGFibGUpO1xuXG4gICAgdC5zZWdtZW50cyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzLmdldChpKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbHlwaC51bmljb2Rlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgYWRkU2VnbWVudCh0LCBnbHlwaC51bmljb2Rlc1tqXSwgaSk7XG4gICAgICAgIH1cblxuICAgICAgICB0LnNlZ21lbnRzID0gdC5zZWdtZW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5zdGFydCAtIGIuc3RhcnQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFkZFRlcm1pbmF0b3JTZWdtZW50KHQpO1xuXG4gICAgdmFyIHNlZ0NvdW50ID0gdC5zZWdtZW50cy5sZW5ndGg7XG4gICAgdmFyIHNlZ0NvdW50VG9SZW1vdmUgPSAwO1xuXG4gICAgLy8gQ01BUCA0XG4gICAgLy8gU2V0IHVwIHBhcmFsbGVsIHNlZ21lbnQgYXJyYXlzLlxuICAgIHZhciBlbmRDb3VudHMgPSBbXTtcbiAgICB2YXIgc3RhcnRDb3VudHMgPSBbXTtcbiAgICB2YXIgaWREZWx0YXMgPSBbXTtcbiAgICB2YXIgaWRSYW5nZU9mZnNldHMgPSBbXTtcbiAgICB2YXIgZ2x5cGhJZHMgPSBbXTtcblxuICAgIC8vIENNQVAgMTJcbiAgICB2YXIgY21hcDEyR3JvdXBzID0gW107XG5cbiAgICAvLyBSZW1pbmRlciB0aGlzIGxvb3AgaXMgbm90IGZvbGxvd2luZyB0aGUgc3BlY2lmaWNhdGlvbiBhdCAxMDAlXG4gICAgLy8gVGhlIHNwZWNpZmljYXRpb24gLT4gZmluZCBzdWl0ZXMgb2YgY2hhcmFjdGVycyBhbmQgbWFrZSBhIGdyb3VwXG4gICAgLy8gSGVyZSB3ZSdyZSBkb2luZyBvbmUgZ3JvdXAgZm9yIGVhY2ggbGV0dGVyXG4gICAgLy8gRG9pbmcgYXMgdGhlIHNwZWMgY2FuIHNhdmUgOCB0aW1lcyAob3IgbW9yZSkgc3BhY2VcbiAgICBmb3IgKGkgPSAwOyBpIDwgc2VnQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICB2YXIgc2VnbWVudCA9IHQuc2VnbWVudHNbaV07XG5cbiAgICAgICAgLy8gQ01BUCA0XG4gICAgICAgIGlmIChzZWdtZW50LmVuZCA8PSA2NTUzNSAmJiBzZWdtZW50LnN0YXJ0IDw9IDY1NTM1KSB7XG4gICAgICAgICAgICBlbmRDb3VudHMgPSBlbmRDb3VudHMuY29uY2F0KHtuYW1lOiAnZW5kXycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuZW5kfSk7XG4gICAgICAgICAgICBzdGFydENvdW50cyA9IHN0YXJ0Q291bnRzLmNvbmNhdCh7bmFtZTogJ3N0YXJ0XycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IHNlZ21lbnQuc3RhcnR9KTtcbiAgICAgICAgICAgIGlkRGVsdGFzID0gaWREZWx0YXMuY29uY2F0KHtuYW1lOiAnaWREZWx0YV8nICsgaSwgdHlwZTogJ1NIT1JUJywgdmFsdWU6IHNlZ21lbnQuZGVsdGF9KTtcbiAgICAgICAgICAgIGlkUmFuZ2VPZmZzZXRzID0gaWRSYW5nZU9mZnNldHMuY29uY2F0KHtuYW1lOiAnaWRSYW5nZU9mZnNldF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzZWdtZW50Lm9mZnNldH0pO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQuZ2x5cGhJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZ2x5cGhJZHMgPSBnbHlwaElkcy5jb25jYXQoe25hbWU6ICdnbHlwaF8nICsgaSwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBzZWdtZW50LmdseXBoSWR9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNraXAgVW5pY29kZSA+IDY1NTM1ICgxNmJpdCB1bnNpZ25lZCBtYXgpIGZvciBDTUFQIDQsIHdpbGwgYmUgYWRkZWQgaW4gQ01BUCAxMlxuICAgICAgICAgICAgc2VnQ291bnRUb1JlbW92ZSArPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ01BUCAxMlxuICAgICAgICAvLyBTa2lwIFRlcm1pbmF0b3IgU2VnbWVudFxuICAgICAgICBpZiAoIWlzUGxhbjBPbmx5ICYmIHNlZ21lbnQuZ2x5cGhJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjbWFwMTJHcm91cHMgPSBjbWFwMTJHcm91cHMuY29uY2F0KHtuYW1lOiAnY21hcDEyU3RhcnRfJyArIGksIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBzZWdtZW50LnN0YXJ0fSk7XG4gICAgICAgICAgICBjbWFwMTJHcm91cHMgPSBjbWFwMTJHcm91cHMuY29uY2F0KHtuYW1lOiAnY21hcDEyRW5kXycgKyBpLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogc2VnbWVudC5lbmR9KTtcbiAgICAgICAgICAgIGNtYXAxMkdyb3VwcyA9IGNtYXAxMkdyb3Vwcy5jb25jYXQoe25hbWU6ICdjbWFwMTJHbHlwaF8nICsgaSwgdHlwZTogJ1VMT05HJywgdmFsdWU6IHNlZ21lbnQuZ2x5cGhJbmRleH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ01BUCA0IFN1YnRhYmxlXG4gICAgdC5zZWdDb3VudFgyID0gKHNlZ0NvdW50IC0gc2VnQ291bnRUb1JlbW92ZSkgKiAyO1xuICAgIHQuc2VhcmNoUmFuZ2UgPSBNYXRoLnBvdygyLCBNYXRoLmZsb29yKE1hdGgubG9nKChzZWdDb3VudCAtIHNlZ0NvdW50VG9SZW1vdmUpKSAvIE1hdGgubG9nKDIpKSkgKiAyO1xuICAgIHQuZW50cnlTZWxlY3RvciA9IE1hdGgubG9nKHQuc2VhcmNoUmFuZ2UgLyAyKSAvIE1hdGgubG9nKDIpO1xuICAgIHQucmFuZ2VTaGlmdCA9IHQuc2VnQ291bnRYMiAtIHQuc2VhcmNoUmFuZ2U7XG5cbiAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChlbmRDb3VudHMpO1xuICAgIHQuZmllbGRzLnB1c2goe25hbWU6ICdyZXNlcnZlZFBhZCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0pO1xuICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KHN0YXJ0Q291bnRzKTtcbiAgICB0LmZpZWxkcyA9IHQuZmllbGRzLmNvbmNhdChpZERlbHRhcyk7XG4gICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoaWRSYW5nZU9mZnNldHMpO1xuICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGdseXBoSWRzKTtcblxuICAgIHQuY21hcDRMZW5ndGggPSAxNCArIC8vIFN1YnRhYmxlIGhlYWRlclxuICAgICAgICBlbmRDb3VudHMubGVuZ3RoICogMiArXG4gICAgICAgIDIgKyAvLyByZXNlcnZlZFBhZFxuICAgICAgICBzdGFydENvdW50cy5sZW5ndGggKiAyICtcbiAgICAgICAgaWREZWx0YXMubGVuZ3RoICogMiArXG4gICAgICAgIGlkUmFuZ2VPZmZzZXRzLmxlbmd0aCAqIDIgK1xuICAgICAgICBnbHlwaElkcy5sZW5ndGggKiAyO1xuXG4gICAgaWYgKCFpc1BsYW4wT25seSkge1xuICAgICAgICAvLyBDTUFQIDEyIFN1YnRhYmxlXG4gICAgICAgIHZhciBjbWFwMTJMZW5ndGggPSAxNiArIC8vIFN1YnRhYmxlIGhlYWRlclxuICAgICAgICAgICAgY21hcDEyR3JvdXBzLmxlbmd0aCAqIDQ7XG5cbiAgICAgICAgdC5jbWFwMTJPZmZzZXQgPSAxMiArICgyICogMikgKyA0ICsgdC5jbWFwNExlbmd0aDtcbiAgICAgICAgdC5maWVsZHMgPSB0LmZpZWxkcy5jb25jYXQoW1xuICAgICAgICAgICAge25hbWU6ICdjbWFwMTJGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDEyfSxcbiAgICAgICAgICAgIHtuYW1lOiAnY21hcDEyUmVzZXJ2ZWQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICAgICAge25hbWU6ICdjbWFwMTJMZW5ndGgnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogY21hcDEyTGVuZ3RofSxcbiAgICAgICAgICAgIHtuYW1lOiAnY21hcDEyTGFuZ3VhZ2UnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgICAgICB7bmFtZTogJ2NtYXAxMm5Hcm91cHMnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogY21hcDEyR3JvdXBzLmxlbmd0aCAvIDN9XG4gICAgICAgIF0pO1xuXG4gICAgICAgIHQuZmllbGRzID0gdC5maWVsZHMuY29uY2F0KGNtYXAxMkdyb3Vwcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG59XG5cbnZhciBjbWFwID0geyBwYXJzZTogcGFyc2VDbWFwVGFibGUsIG1ha2U6IG1ha2VDbWFwVGFibGUgfTtcblxuLy8gR2x5cGggZW5jb2RpbmdcblxudmFyIGNmZlN0YW5kYXJkU3RyaW5ncyA9IFtcbiAgICAnLm5vdGRlZicsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsICdhbXBlcnNhbmQnLCAncXVvdGVyaWdodCcsXG4gICAgJ3BhcmVubGVmdCcsICdwYXJlbnJpZ2h0JywgJ2FzdGVyaXNrJywgJ3BsdXMnLCAnY29tbWEnLCAnaHlwaGVuJywgJ3BlcmlvZCcsICdzbGFzaCcsICd6ZXJvJywgJ29uZScsICd0d28nLFxuICAgICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnLCAnc2l4JywgJ3NldmVuJywgJ2VpZ2h0JywgJ25pbmUnLCAnY29sb24nLCAnc2VtaWNvbG9uJywgJ2xlc3MnLCAnZXF1YWwnLCAnZ3JlYXRlcicsXG4gICAgJ3F1ZXN0aW9uJywgJ2F0JywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLFxuICAgICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJywgJ2JyYWNrZXRsZWZ0JywgJ2JhY2tzbGFzaCcsICdicmFja2V0cmlnaHQnLCAnYXNjaWljaXJjdW0nLCAndW5kZXJzY29yZScsXG4gICAgJ3F1b3RlbGVmdCcsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsICdwJywgJ3EnLCAncicsICdzJywgJ3QnLFxuICAgICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsICdleGNsYW1kb3duJywgJ2NlbnQnLCAnc3RlcmxpbmcnLFxuICAgICdmcmFjdGlvbicsICd5ZW4nLCAnZmxvcmluJywgJ3NlY3Rpb24nLCAnY3VycmVuY3knLCAncXVvdGVzaW5nbGUnLCAncXVvdGVkYmxsZWZ0JywgJ2d1aWxsZW1vdGxlZnQnLFxuICAgICdndWlsc2luZ2xsZWZ0JywgJ2d1aWxzaW5nbHJpZ2h0JywgJ2ZpJywgJ2ZsJywgJ2VuZGFzaCcsICdkYWdnZXInLCAnZGFnZ2VyZGJsJywgJ3BlcmlvZGNlbnRlcmVkJywgJ3BhcmFncmFwaCcsXG4gICAgJ2J1bGxldCcsICdxdW90ZXNpbmdsYmFzZScsICdxdW90ZWRibGJhc2UnLCAncXVvdGVkYmxyaWdodCcsICdndWlsbGVtb3RyaWdodCcsICdlbGxpcHNpcycsICdwZXJ0aG91c2FuZCcsXG4gICAgJ3F1ZXN0aW9uZG93bicsICdncmF2ZScsICdhY3V0ZScsICdjaXJjdW1mbGV4JywgJ3RpbGRlJywgJ21hY3JvbicsICdicmV2ZScsICdkb3RhY2NlbnQnLCAnZGllcmVzaXMnLCAncmluZycsXG4gICAgJ2NlZGlsbGEnLCAnaHVuZ2FydW1sYXV0JywgJ29nb25laycsICdjYXJvbicsICdlbWRhc2gnLCAnQUUnLCAnb3JkZmVtaW5pbmUnLCAnTHNsYXNoJywgJ09zbGFzaCcsICdPRScsXG4gICAgJ29yZG1hc2N1bGluZScsICdhZScsICdkb3RsZXNzaScsICdsc2xhc2gnLCAnb3NsYXNoJywgJ29lJywgJ2dlcm1hbmRibHMnLCAnb25lc3VwZXJpb3InLCAnbG9naWNhbG5vdCcsICdtdScsXG4gICAgJ3RyYWRlbWFyaycsICdFdGgnLCAnb25laGFsZicsICdwbHVzbWludXMnLCAnVGhvcm4nLCAnb25lcXVhcnRlcicsICdkaXZpZGUnLCAnYnJva2VuYmFyJywgJ2RlZ3JlZScsICd0aG9ybicsXG4gICAgJ3RocmVlcXVhcnRlcnMnLCAndHdvc3VwZXJpb3InLCAncmVnaXN0ZXJlZCcsICdtaW51cycsICdldGgnLCAnbXVsdGlwbHknLCAndGhyZWVzdXBlcmlvcicsICdjb3B5cmlnaHQnLFxuICAgICdBYWN1dGUnLCAnQWNpcmN1bWZsZXgnLCAnQWRpZXJlc2lzJywgJ0FncmF2ZScsICdBcmluZycsICdBdGlsZGUnLCAnQ2NlZGlsbGEnLCAnRWFjdXRlJywgJ0VjaXJjdW1mbGV4JyxcbiAgICAnRWRpZXJlc2lzJywgJ0VncmF2ZScsICdJYWN1dGUnLCAnSWNpcmN1bWZsZXgnLCAnSWRpZXJlc2lzJywgJ0lncmF2ZScsICdOdGlsZGUnLCAnT2FjdXRlJywgJ09jaXJjdW1mbGV4JyxcbiAgICAnT2RpZXJlc2lzJywgJ09ncmF2ZScsICdPdGlsZGUnLCAnU2Nhcm9uJywgJ1VhY3V0ZScsICdVY2lyY3VtZmxleCcsICdVZGllcmVzaXMnLCAnVWdyYXZlJywgJ1lhY3V0ZScsXG4gICAgJ1lkaWVyZXNpcycsICdaY2Fyb24nLCAnYWFjdXRlJywgJ2FjaXJjdW1mbGV4JywgJ2FkaWVyZXNpcycsICdhZ3JhdmUnLCAnYXJpbmcnLCAnYXRpbGRlJywgJ2NjZWRpbGxhJywgJ2VhY3V0ZScsXG4gICAgJ2VjaXJjdW1mbGV4JywgJ2VkaWVyZXNpcycsICdlZ3JhdmUnLCAnaWFjdXRlJywgJ2ljaXJjdW1mbGV4JywgJ2lkaWVyZXNpcycsICdpZ3JhdmUnLCAnbnRpbGRlJywgJ29hY3V0ZScsXG4gICAgJ29jaXJjdW1mbGV4JywgJ29kaWVyZXNpcycsICdvZ3JhdmUnLCAnb3RpbGRlJywgJ3NjYXJvbicsICd1YWN1dGUnLCAndWNpcmN1bWZsZXgnLCAndWRpZXJlc2lzJywgJ3VncmF2ZScsXG4gICAgJ3lhY3V0ZScsICd5ZGllcmVzaXMnLCAnemNhcm9uJywgJ2V4Y2xhbXNtYWxsJywgJ0h1bmdhcnVtbGF1dHNtYWxsJywgJ2RvbGxhcm9sZHN0eWxlJywgJ2RvbGxhcnN1cGVyaW9yJyxcbiAgICAnYW1wZXJzYW5kc21hbGwnLCAnQWN1dGVzbWFsbCcsICdwYXJlbmxlZnRzdXBlcmlvcicsICdwYXJlbnJpZ2h0c3VwZXJpb3InLCAnMjY2IGZmJywgJ29uZWRvdGVubGVhZGVyJyxcbiAgICAnemVyb29sZHN0eWxlJywgJ29uZW9sZHN0eWxlJywgJ3R3b29sZHN0eWxlJywgJ3RocmVlb2xkc3R5bGUnLCAnZm91cm9sZHN0eWxlJywgJ2ZpdmVvbGRzdHlsZScsICdzaXhvbGRzdHlsZScsXG4gICAgJ3NldmVub2xkc3R5bGUnLCAnZWlnaHRvbGRzdHlsZScsICduaW5lb2xkc3R5bGUnLCAnY29tbWFzdXBlcmlvcicsICd0aHJlZXF1YXJ0ZXJzZW1kYXNoJywgJ3BlcmlvZHN1cGVyaW9yJyxcbiAgICAncXVlc3Rpb25zbWFsbCcsICdhc3VwZXJpb3InLCAnYnN1cGVyaW9yJywgJ2NlbnRzdXBlcmlvcicsICdkc3VwZXJpb3InLCAnZXN1cGVyaW9yJywgJ2lzdXBlcmlvcicsICdsc3VwZXJpb3InLFxuICAgICdtc3VwZXJpb3InLCAnbnN1cGVyaW9yJywgJ29zdXBlcmlvcicsICdyc3VwZXJpb3InLCAnc3N1cGVyaW9yJywgJ3RzdXBlcmlvcicsICdmZicsICdmZmknLCAnZmZsJyxcbiAgICAncGFyZW5sZWZ0aW5mZXJpb3InLCAncGFyZW5yaWdodGluZmVyaW9yJywgJ0NpcmN1bWZsZXhzbWFsbCcsICdoeXBoZW5zdXBlcmlvcicsICdHcmF2ZXNtYWxsJywgJ0FzbWFsbCcsXG4gICAgJ0JzbWFsbCcsICdDc21hbGwnLCAnRHNtYWxsJywgJ0VzbWFsbCcsICdGc21hbGwnLCAnR3NtYWxsJywgJ0hzbWFsbCcsICdJc21hbGwnLCAnSnNtYWxsJywgJ0tzbWFsbCcsICdMc21hbGwnLFxuICAgICdNc21hbGwnLCAnTnNtYWxsJywgJ09zbWFsbCcsICdQc21hbGwnLCAnUXNtYWxsJywgJ1JzbWFsbCcsICdTc21hbGwnLCAnVHNtYWxsJywgJ1VzbWFsbCcsICdWc21hbGwnLCAnV3NtYWxsJyxcbiAgICAnWHNtYWxsJywgJ1lzbWFsbCcsICdac21hbGwnLCAnY29sb25tb25ldGFyeScsICdvbmVmaXR0ZWQnLCAncnVwaWFoJywgJ1RpbGRlc21hbGwnLCAnZXhjbGFtZG93bnNtYWxsJyxcbiAgICAnY2VudG9sZHN0eWxlJywgJ0xzbGFzaHNtYWxsJywgJ1NjYXJvbnNtYWxsJywgJ1pjYXJvbnNtYWxsJywgJ0RpZXJlc2lzc21hbGwnLCAnQnJldmVzbWFsbCcsICdDYXJvbnNtYWxsJyxcbiAgICAnRG90YWNjZW50c21hbGwnLCAnTWFjcm9uc21hbGwnLCAnZmlndXJlZGFzaCcsICdoeXBoZW5pbmZlcmlvcicsICdPZ29uZWtzbWFsbCcsICdSaW5nc21hbGwnLCAnQ2VkaWxsYXNtYWxsJyxcbiAgICAncXVlc3Rpb25kb3duc21hbGwnLCAnb25lZWlnaHRoJywgJ3RocmVlZWlnaHRocycsICdmaXZlZWlnaHRocycsICdzZXZlbmVpZ2h0aHMnLCAnb25ldGhpcmQnLCAndHdvdGhpcmRzJyxcbiAgICAnemVyb3N1cGVyaW9yJywgJ2ZvdXJzdXBlcmlvcicsICdmaXZlc3VwZXJpb3InLCAnc2l4c3VwZXJpb3InLCAnc2V2ZW5zdXBlcmlvcicsICdlaWdodHN1cGVyaW9yJywgJ25pbmVzdXBlcmlvcicsXG4gICAgJ3plcm9pbmZlcmlvcicsICdvbmVpbmZlcmlvcicsICd0d29pbmZlcmlvcicsICd0aHJlZWluZmVyaW9yJywgJ2ZvdXJpbmZlcmlvcicsICdmaXZlaW5mZXJpb3InLCAnc2l4aW5mZXJpb3InLFxuICAgICdzZXZlbmluZmVyaW9yJywgJ2VpZ2h0aW5mZXJpb3InLCAnbmluZWluZmVyaW9yJywgJ2NlbnRpbmZlcmlvcicsICdkb2xsYXJpbmZlcmlvcicsICdwZXJpb2RpbmZlcmlvcicsXG4gICAgJ2NvbW1haW5mZXJpb3InLCAnQWdyYXZlc21hbGwnLCAnQWFjdXRlc21hbGwnLCAnQWNpcmN1bWZsZXhzbWFsbCcsICdBdGlsZGVzbWFsbCcsICdBZGllcmVzaXNzbWFsbCcsXG4gICAgJ0FyaW5nc21hbGwnLCAnQUVzbWFsbCcsICdDY2VkaWxsYXNtYWxsJywgJ0VncmF2ZXNtYWxsJywgJ0VhY3V0ZXNtYWxsJywgJ0VjaXJjdW1mbGV4c21hbGwnLCAnRWRpZXJlc2lzc21hbGwnLFxuICAgICdJZ3JhdmVzbWFsbCcsICdJYWN1dGVzbWFsbCcsICdJY2lyY3VtZmxleHNtYWxsJywgJ0lkaWVyZXNpc3NtYWxsJywgJ0V0aHNtYWxsJywgJ050aWxkZXNtYWxsJywgJ09ncmF2ZXNtYWxsJyxcbiAgICAnT2FjdXRlc21hbGwnLCAnT2NpcmN1bWZsZXhzbWFsbCcsICdPdGlsZGVzbWFsbCcsICdPZGllcmVzaXNzbWFsbCcsICdPRXNtYWxsJywgJ09zbGFzaHNtYWxsJywgJ1VncmF2ZXNtYWxsJyxcbiAgICAnVWFjdXRlc21hbGwnLCAnVWNpcmN1bWZsZXhzbWFsbCcsICdVZGllcmVzaXNzbWFsbCcsICdZYWN1dGVzbWFsbCcsICdUaG9ybnNtYWxsJywgJ1lkaWVyZXNpc3NtYWxsJywgJzAwMS4wMDAnLFxuICAgICcwMDEuMDAxJywgJzAwMS4wMDInLCAnMDAxLjAwMycsICdCbGFjaycsICdCb2xkJywgJ0Jvb2snLCAnTGlnaHQnLCAnTWVkaXVtJywgJ1JlZ3VsYXInLCAnUm9tYW4nLCAnU2VtaWJvbGQnXTtcblxudmFyIGNmZlN0YW5kYXJkRW5jb2RpbmcgPSBbXG4gICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJycsICcnLCAnJywgJycsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsICdhbXBlcnNhbmQnLCAncXVvdGVyaWdodCcsXG4gICAgJ3BhcmVubGVmdCcsICdwYXJlbnJpZ2h0JywgJ2FzdGVyaXNrJywgJ3BsdXMnLCAnY29tbWEnLCAnaHlwaGVuJywgJ3BlcmlvZCcsICdzbGFzaCcsICd6ZXJvJywgJ29uZScsICd0d28nLFxuICAgICd0aHJlZScsICdmb3VyJywgJ2ZpdmUnLCAnc2l4JywgJ3NldmVuJywgJ2VpZ2h0JywgJ25pbmUnLCAnY29sb24nLCAnc2VtaWNvbG9uJywgJ2xlc3MnLCAnZXF1YWwnLCAnZ3JlYXRlcicsXG4gICAgJ3F1ZXN0aW9uJywgJ2F0JywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLFxuICAgICdUJywgJ1UnLCAnVicsICdXJywgJ1gnLCAnWScsICdaJywgJ2JyYWNrZXRsZWZ0JywgJ2JhY2tzbGFzaCcsICdicmFja2V0cmlnaHQnLCAnYXNjaWljaXJjdW0nLCAndW5kZXJzY29yZScsXG4gICAgJ3F1b3RlbGVmdCcsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsICdwJywgJ3EnLCAncicsICdzJywgJ3QnLFxuICAgICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJ2V4Y2xhbWRvd24nLCAnY2VudCcsICdzdGVybGluZycsICdmcmFjdGlvbicsICd5ZW4nLCAnZmxvcmluJywgJ3NlY3Rpb24nLCAnY3VycmVuY3knLCAncXVvdGVzaW5nbGUnLFxuICAgICdxdW90ZWRibGxlZnQnLCAnZ3VpbGxlbW90bGVmdCcsICdndWlsc2luZ2xsZWZ0JywgJ2d1aWxzaW5nbHJpZ2h0JywgJ2ZpJywgJ2ZsJywgJycsICdlbmRhc2gnLCAnZGFnZ2VyJyxcbiAgICAnZGFnZ2VyZGJsJywgJ3BlcmlvZGNlbnRlcmVkJywgJycsICdwYXJhZ3JhcGgnLCAnYnVsbGV0JywgJ3F1b3Rlc2luZ2xiYXNlJywgJ3F1b3RlZGJsYmFzZScsICdxdW90ZWRibHJpZ2h0JyxcbiAgICAnZ3VpbGxlbW90cmlnaHQnLCAnZWxsaXBzaXMnLCAncGVydGhvdXNhbmQnLCAnJywgJ3F1ZXN0aW9uZG93bicsICcnLCAnZ3JhdmUnLCAnYWN1dGUnLCAnY2lyY3VtZmxleCcsICd0aWxkZScsXG4gICAgJ21hY3JvbicsICdicmV2ZScsICdkb3RhY2NlbnQnLCAnZGllcmVzaXMnLCAnJywgJ3JpbmcnLCAnY2VkaWxsYScsICcnLCAnaHVuZ2FydW1sYXV0JywgJ29nb25laycsICdjYXJvbicsXG4gICAgJ2VtZGFzaCcsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnQUUnLCAnJywgJ29yZGZlbWluaW5lJywgJycsICcnLCAnJyxcbiAgICAnJywgJ0xzbGFzaCcsICdPc2xhc2gnLCAnT0UnLCAnb3JkbWFzY3VsaW5lJywgJycsICcnLCAnJywgJycsICcnLCAnYWUnLCAnJywgJycsICcnLCAnZG90bGVzc2knLCAnJywgJycsXG4gICAgJ2xzbGFzaCcsICdvc2xhc2gnLCAnb2UnLCAnZ2VybWFuZGJscyddO1xuXG52YXIgY2ZmRXhwZXJ0RW5jb2RpbmcgPSBbXG4gICAgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsXG4gICAgJycsICcnLCAnJywgJycsICdzcGFjZScsICdleGNsYW1zbWFsbCcsICdIdW5nYXJ1bWxhdXRzbWFsbCcsICcnLCAnZG9sbGFyb2xkc3R5bGUnLCAnZG9sbGFyc3VwZXJpb3InLFxuICAgICdhbXBlcnNhbmRzbWFsbCcsICdBY3V0ZXNtYWxsJywgJ3BhcmVubGVmdHN1cGVyaW9yJywgJ3BhcmVucmlnaHRzdXBlcmlvcicsICd0d29kb3RlbmxlYWRlcicsICdvbmVkb3RlbmxlYWRlcicsXG4gICAgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnZnJhY3Rpb24nLCAnemVyb29sZHN0eWxlJywgJ29uZW9sZHN0eWxlJywgJ3R3b29sZHN0eWxlJywgJ3RocmVlb2xkc3R5bGUnLFxuICAgICdmb3Vyb2xkc3R5bGUnLCAnZml2ZW9sZHN0eWxlJywgJ3NpeG9sZHN0eWxlJywgJ3NldmVub2xkc3R5bGUnLCAnZWlnaHRvbGRzdHlsZScsICduaW5lb2xkc3R5bGUnLCAnY29sb24nLFxuICAgICdzZW1pY29sb24nLCAnY29tbWFzdXBlcmlvcicsICd0aHJlZXF1YXJ0ZXJzZW1kYXNoJywgJ3BlcmlvZHN1cGVyaW9yJywgJ3F1ZXN0aW9uc21hbGwnLCAnJywgJ2FzdXBlcmlvcicsXG4gICAgJ2JzdXBlcmlvcicsICdjZW50c3VwZXJpb3InLCAnZHN1cGVyaW9yJywgJ2VzdXBlcmlvcicsICcnLCAnJywgJ2lzdXBlcmlvcicsICcnLCAnJywgJ2xzdXBlcmlvcicsICdtc3VwZXJpb3InLFxuICAgICduc3VwZXJpb3InLCAnb3N1cGVyaW9yJywgJycsICcnLCAncnN1cGVyaW9yJywgJ3NzdXBlcmlvcicsICd0c3VwZXJpb3InLCAnJywgJ2ZmJywgJ2ZpJywgJ2ZsJywgJ2ZmaScsICdmZmwnLFxuICAgICdwYXJlbmxlZnRpbmZlcmlvcicsICcnLCAncGFyZW5yaWdodGluZmVyaW9yJywgJ0NpcmN1bWZsZXhzbWFsbCcsICdoeXBoZW5zdXBlcmlvcicsICdHcmF2ZXNtYWxsJywgJ0FzbWFsbCcsXG4gICAgJ0JzbWFsbCcsICdDc21hbGwnLCAnRHNtYWxsJywgJ0VzbWFsbCcsICdGc21hbGwnLCAnR3NtYWxsJywgJ0hzbWFsbCcsICdJc21hbGwnLCAnSnNtYWxsJywgJ0tzbWFsbCcsICdMc21hbGwnLFxuICAgICdNc21hbGwnLCAnTnNtYWxsJywgJ09zbWFsbCcsICdQc21hbGwnLCAnUXNtYWxsJywgJ1JzbWFsbCcsICdTc21hbGwnLCAnVHNtYWxsJywgJ1VzbWFsbCcsICdWc21hbGwnLCAnV3NtYWxsJyxcbiAgICAnWHNtYWxsJywgJ1lzbWFsbCcsICdac21hbGwnLCAnY29sb25tb25ldGFyeScsICdvbmVmaXR0ZWQnLCAncnVwaWFoJywgJ1RpbGRlc21hbGwnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJyxcbiAgICAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLCAnJywgJycsICcnLFxuICAgICdleGNsYW1kb3duc21hbGwnLCAnY2VudG9sZHN0eWxlJywgJ0xzbGFzaHNtYWxsJywgJycsICcnLCAnU2Nhcm9uc21hbGwnLCAnWmNhcm9uc21hbGwnLCAnRGllcmVzaXNzbWFsbCcsXG4gICAgJ0JyZXZlc21hbGwnLCAnQ2Fyb25zbWFsbCcsICcnLCAnRG90YWNjZW50c21hbGwnLCAnJywgJycsICdNYWNyb25zbWFsbCcsICcnLCAnJywgJ2ZpZ3VyZWRhc2gnLCAnaHlwaGVuaW5mZXJpb3InLFxuICAgICcnLCAnJywgJ09nb25la3NtYWxsJywgJ1JpbmdzbWFsbCcsICdDZWRpbGxhc21hbGwnLCAnJywgJycsICcnLCAnb25lcXVhcnRlcicsICdvbmVoYWxmJywgJ3RocmVlcXVhcnRlcnMnLFxuICAgICdxdWVzdGlvbmRvd25zbWFsbCcsICdvbmVlaWdodGgnLCAndGhyZWVlaWdodGhzJywgJ2ZpdmVlaWdodGhzJywgJ3NldmVuZWlnaHRocycsICdvbmV0aGlyZCcsICd0d290aGlyZHMnLCAnJyxcbiAgICAnJywgJ3plcm9zdXBlcmlvcicsICdvbmVzdXBlcmlvcicsICd0d29zdXBlcmlvcicsICd0aHJlZXN1cGVyaW9yJywgJ2ZvdXJzdXBlcmlvcicsICdmaXZlc3VwZXJpb3InLFxuICAgICdzaXhzdXBlcmlvcicsICdzZXZlbnN1cGVyaW9yJywgJ2VpZ2h0c3VwZXJpb3InLCAnbmluZXN1cGVyaW9yJywgJ3plcm9pbmZlcmlvcicsICdvbmVpbmZlcmlvcicsICd0d29pbmZlcmlvcicsXG4gICAgJ3RocmVlaW5mZXJpb3InLCAnZm91cmluZmVyaW9yJywgJ2ZpdmVpbmZlcmlvcicsICdzaXhpbmZlcmlvcicsICdzZXZlbmluZmVyaW9yJywgJ2VpZ2h0aW5mZXJpb3InLFxuICAgICduaW5laW5mZXJpb3InLCAnY2VudGluZmVyaW9yJywgJ2RvbGxhcmluZmVyaW9yJywgJ3BlcmlvZGluZmVyaW9yJywgJ2NvbW1haW5mZXJpb3InLCAnQWdyYXZlc21hbGwnLFxuICAgICdBYWN1dGVzbWFsbCcsICdBY2lyY3VtZmxleHNtYWxsJywgJ0F0aWxkZXNtYWxsJywgJ0FkaWVyZXNpc3NtYWxsJywgJ0FyaW5nc21hbGwnLCAnQUVzbWFsbCcsICdDY2VkaWxsYXNtYWxsJyxcbiAgICAnRWdyYXZlc21hbGwnLCAnRWFjdXRlc21hbGwnLCAnRWNpcmN1bWZsZXhzbWFsbCcsICdFZGllcmVzaXNzbWFsbCcsICdJZ3JhdmVzbWFsbCcsICdJYWN1dGVzbWFsbCcsXG4gICAgJ0ljaXJjdW1mbGV4c21hbGwnLCAnSWRpZXJlc2lzc21hbGwnLCAnRXRoc21hbGwnLCAnTnRpbGRlc21hbGwnLCAnT2dyYXZlc21hbGwnLCAnT2FjdXRlc21hbGwnLFxuICAgICdPY2lyY3VtZmxleHNtYWxsJywgJ090aWxkZXNtYWxsJywgJ09kaWVyZXNpc3NtYWxsJywgJ09Fc21hbGwnLCAnT3NsYXNoc21hbGwnLCAnVWdyYXZlc21hbGwnLCAnVWFjdXRlc21hbGwnLFxuICAgICdVY2lyY3VtZmxleHNtYWxsJywgJ1VkaWVyZXNpc3NtYWxsJywgJ1lhY3V0ZXNtYWxsJywgJ1Rob3Juc21hbGwnLCAnWWRpZXJlc2lzc21hbGwnXTtcblxudmFyIHN0YW5kYXJkTmFtZXMgPSBbXG4gICAgJy5ub3RkZWYnLCAnLm51bGwnLCAnbm9ubWFya2luZ3JldHVybicsICdzcGFjZScsICdleGNsYW0nLCAncXVvdGVkYmwnLCAnbnVtYmVyc2lnbicsICdkb2xsYXInLCAncGVyY2VudCcsXG4gICAgJ2FtcGVyc2FuZCcsICdxdW90ZXNpbmdsZScsICdwYXJlbmxlZnQnLCAncGFyZW5yaWdodCcsICdhc3RlcmlzaycsICdwbHVzJywgJ2NvbW1hJywgJ2h5cGhlbicsICdwZXJpb2QnLCAnc2xhc2gnLFxuICAgICd6ZXJvJywgJ29uZScsICd0d28nLCAndGhyZWUnLCAnZm91cicsICdmaXZlJywgJ3NpeCcsICdzZXZlbicsICdlaWdodCcsICduaW5lJywgJ2NvbG9uJywgJ3NlbWljb2xvbicsICdsZXNzJyxcbiAgICAnZXF1YWwnLCAnZ3JlYXRlcicsICdxdWVzdGlvbicsICdhdCcsICdBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsXG4gICAgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWicsICdicmFja2V0bGVmdCcsICdiYWNrc2xhc2gnLCAnYnJhY2tldHJpZ2h0JyxcbiAgICAnYXNjaWljaXJjdW0nLCAndW5kZXJzY29yZScsICdncmF2ZScsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZicsICdnJywgJ2gnLCAnaScsICdqJywgJ2snLCAnbCcsICdtJywgJ24nLCAnbycsXG4gICAgJ3AnLCAncScsICdyJywgJ3MnLCAndCcsICd1JywgJ3YnLCAndycsICd4JywgJ3knLCAneicsICdicmFjZWxlZnQnLCAnYmFyJywgJ2JyYWNlcmlnaHQnLCAnYXNjaWl0aWxkZScsXG4gICAgJ0FkaWVyZXNpcycsICdBcmluZycsICdDY2VkaWxsYScsICdFYWN1dGUnLCAnTnRpbGRlJywgJ09kaWVyZXNpcycsICdVZGllcmVzaXMnLCAnYWFjdXRlJywgJ2FncmF2ZScsXG4gICAgJ2FjaXJjdW1mbGV4JywgJ2FkaWVyZXNpcycsICdhdGlsZGUnLCAnYXJpbmcnLCAnY2NlZGlsbGEnLCAnZWFjdXRlJywgJ2VncmF2ZScsICdlY2lyY3VtZmxleCcsICdlZGllcmVzaXMnLFxuICAgICdpYWN1dGUnLCAnaWdyYXZlJywgJ2ljaXJjdW1mbGV4JywgJ2lkaWVyZXNpcycsICdudGlsZGUnLCAnb2FjdXRlJywgJ29ncmF2ZScsICdvY2lyY3VtZmxleCcsICdvZGllcmVzaXMnLFxuICAgICdvdGlsZGUnLCAndWFjdXRlJywgJ3VncmF2ZScsICd1Y2lyY3VtZmxleCcsICd1ZGllcmVzaXMnLCAnZGFnZ2VyJywgJ2RlZ3JlZScsICdjZW50JywgJ3N0ZXJsaW5nJywgJ3NlY3Rpb24nLFxuICAgICdidWxsZXQnLCAncGFyYWdyYXBoJywgJ2dlcm1hbmRibHMnLCAncmVnaXN0ZXJlZCcsICdjb3B5cmlnaHQnLCAndHJhZGVtYXJrJywgJ2FjdXRlJywgJ2RpZXJlc2lzJywgJ25vdGVxdWFsJyxcbiAgICAnQUUnLCAnT3NsYXNoJywgJ2luZmluaXR5JywgJ3BsdXNtaW51cycsICdsZXNzZXF1YWwnLCAnZ3JlYXRlcmVxdWFsJywgJ3llbicsICdtdScsICdwYXJ0aWFsZGlmZicsICdzdW1tYXRpb24nLFxuICAgICdwcm9kdWN0JywgJ3BpJywgJ2ludGVncmFsJywgJ29yZGZlbWluaW5lJywgJ29yZG1hc2N1bGluZScsICdPbWVnYScsICdhZScsICdvc2xhc2gnLCAncXVlc3Rpb25kb3duJyxcbiAgICAnZXhjbGFtZG93bicsICdsb2dpY2Fsbm90JywgJ3JhZGljYWwnLCAnZmxvcmluJywgJ2FwcHJveGVxdWFsJywgJ0RlbHRhJywgJ2d1aWxsZW1vdGxlZnQnLCAnZ3VpbGxlbW90cmlnaHQnLFxuICAgICdlbGxpcHNpcycsICdub25icmVha2luZ3NwYWNlJywgJ0FncmF2ZScsICdBdGlsZGUnLCAnT3RpbGRlJywgJ09FJywgJ29lJywgJ2VuZGFzaCcsICdlbWRhc2gnLCAncXVvdGVkYmxsZWZ0JyxcbiAgICAncXVvdGVkYmxyaWdodCcsICdxdW90ZWxlZnQnLCAncXVvdGVyaWdodCcsICdkaXZpZGUnLCAnbG96ZW5nZScsICd5ZGllcmVzaXMnLCAnWWRpZXJlc2lzJywgJ2ZyYWN0aW9uJyxcbiAgICAnY3VycmVuY3knLCAnZ3VpbHNpbmdsbGVmdCcsICdndWlsc2luZ2xyaWdodCcsICdmaScsICdmbCcsICdkYWdnZXJkYmwnLCAncGVyaW9kY2VudGVyZWQnLCAncXVvdGVzaW5nbGJhc2UnLFxuICAgICdxdW90ZWRibGJhc2UnLCAncGVydGhvdXNhbmQnLCAnQWNpcmN1bWZsZXgnLCAnRWNpcmN1bWZsZXgnLCAnQWFjdXRlJywgJ0VkaWVyZXNpcycsICdFZ3JhdmUnLCAnSWFjdXRlJyxcbiAgICAnSWNpcmN1bWZsZXgnLCAnSWRpZXJlc2lzJywgJ0lncmF2ZScsICdPYWN1dGUnLCAnT2NpcmN1bWZsZXgnLCAnYXBwbGUnLCAnT2dyYXZlJywgJ1VhY3V0ZScsICdVY2lyY3VtZmxleCcsXG4gICAgJ1VncmF2ZScsICdkb3RsZXNzaScsICdjaXJjdW1mbGV4JywgJ3RpbGRlJywgJ21hY3JvbicsICdicmV2ZScsICdkb3RhY2NlbnQnLCAncmluZycsICdjZWRpbGxhJywgJ2h1bmdhcnVtbGF1dCcsXG4gICAgJ29nb25laycsICdjYXJvbicsICdMc2xhc2gnLCAnbHNsYXNoJywgJ1NjYXJvbicsICdzY2Fyb24nLCAnWmNhcm9uJywgJ3pjYXJvbicsICdicm9rZW5iYXInLCAnRXRoJywgJ2V0aCcsXG4gICAgJ1lhY3V0ZScsICd5YWN1dGUnLCAnVGhvcm4nLCAndGhvcm4nLCAnbWludXMnLCAnbXVsdGlwbHknLCAnb25lc3VwZXJpb3InLCAndHdvc3VwZXJpb3InLCAndGhyZWVzdXBlcmlvcicsXG4gICAgJ29uZWhhbGYnLCAnb25lcXVhcnRlcicsICd0aHJlZXF1YXJ0ZXJzJywgJ2ZyYW5jJywgJ0dicmV2ZScsICdnYnJldmUnLCAnSWRvdGFjY2VudCcsICdTY2VkaWxsYScsICdzY2VkaWxsYScsXG4gICAgJ0NhY3V0ZScsICdjYWN1dGUnLCAnQ2Nhcm9uJywgJ2NjYXJvbicsICdkY3JvYXQnXTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBlbmNvZGluZyB1c2VkIGZvciBmb250cyBjcmVhdGVkIGZyb20gc2NyYXRjaC5cbiAqIEl0IGxvb3BzIHRocm91Z2ggYWxsIGdseXBocyBhbmQgZmluZHMgdGhlIGFwcHJvcHJpYXRlIHVuaWNvZGUgdmFsdWUuXG4gKiBTaW5jZSBpdCdzIGxpbmVhciB0aW1lLCBvdGhlciBlbmNvZGluZ3Mgd2lsbCBiZSBmYXN0ZXIuXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5EZWZhdWx0RW5jb2RpbmdcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG4gKi9cbmZ1bmN0aW9uIERlZmF1bHRFbmNvZGluZyhmb250KSB7XG4gICAgdGhpcy5mb250ID0gZm9udDtcbn1cblxuRGVmYXVsdEVuY29kaW5nLnByb3RvdHlwZS5jaGFyVG9HbHlwaEluZGV4ID0gZnVuY3Rpb24oYykge1xuICAgIHZhciBjb2RlID0gYy5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBnbHlwaHMgPSB0aGlzLmZvbnQuZ2x5cGhzO1xuICAgIGlmIChnbHlwaHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBoLnVuaWNvZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdseXBoLnVuaWNvZGVzW2pdID09PSBjb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuQ21hcEVuY29kaW5nXG4gKiBAY2xhc3NcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IGNtYXAgLSBhIG9iamVjdCB3aXRoIHRoZSBjbWFwIGVuY29kZWQgZGF0YVxuICovXG5mdW5jdGlvbiBDbWFwRW5jb2RpbmcoY21hcCkge1xuICAgIHRoaXMuY21hcCA9IGNtYXA7XG59XG5cbi8qKlxuICogQHBhcmFtICB7c3RyaW5nfSBjIC0gdGhlIGNoYXJhY3RlclxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgZ2x5cGggaW5kZXguXG4gKi9cbkNtYXBFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gdGhpcy5jbWFwLmdseXBoSW5kZXhNYXBbYy5jaGFyQ29kZUF0KDApXSB8fCAwO1xufTtcblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5DZmZFbmNvZGluZ1xuICogQGNsYXNzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGluZyAtIFRoZSBlbmNvZGluZ1xuICogQHBhcmFtIHtBcnJheX0gY2hhcnNldCAtIFRoZSBjaGFyYWN0ZXIgc2V0LlxuICovXG5mdW5jdGlvbiBDZmZFbmNvZGluZyhlbmNvZGluZywgY2hhcnNldCkge1xuICAgIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgICB0aGlzLmNoYXJzZXQgPSBjaGFyc2V0O1xufVxuXG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30gcyAtIFRoZSBjaGFyYWN0ZXJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4LlxuICovXG5DZmZFbmNvZGluZy5wcm90b3R5cGUuY2hhclRvR2x5cGhJbmRleCA9IGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgY29kZSA9IHMuY2hhckNvZGVBdCgwKTtcbiAgICB2YXIgY2hhck5hbWUgPSB0aGlzLmVuY29kaW5nW2NvZGVdO1xuICAgIHJldHVybiB0aGlzLmNoYXJzZXQuaW5kZXhPZihjaGFyTmFtZSk7XG59O1xuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkdseXBoTmFtZXNcbiAqIEBjbGFzc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zdFxuICovXG5mdW5jdGlvbiBHbHlwaE5hbWVzKHBvc3QpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHN3aXRjaCAocG9zdC52ZXJzaW9uKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMubmFtZXMgPSBzdGFuZGFyZE5hbWVzLnNsaWNlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy5uYW1lcyA9IG5ldyBBcnJheShwb3N0Lm51bWJlck9mR2x5cGhzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3QuZ2x5cGhOYW1lSW5kZXhbaV0gPCBzdGFuZGFyZE5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzJDEubmFtZXNbaV0gPSBzdGFuZGFyZE5hbWVzW3Bvc3QuZ2x5cGhOYW1lSW5kZXhbaV1dO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMkMS5uYW1lc1tpXSA9IHBvc3QubmFtZXNbcG9zdC5nbHlwaE5hbWVJbmRleFtpXSAtIHN0YW5kYXJkTmFtZXMubGVuZ3RoXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIuNTpcbiAgICAgICAgICAgIHRoaXMubmFtZXMgPSBuZXcgQXJyYXkocG9zdC5udW1iZXJPZkdseXBocyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwb3N0Lm51bWJlck9mR2x5cGhzOyBpJDErKykge1xuICAgICAgICAgICAgICAgIHRoaXMkMS5uYW1lc1tpJDFdID0gc3RhbmRhcmROYW1lc1tpJDEgKyBwb3N0LmdseXBoTmFtZUluZGV4W2kkMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgdGhpcy5uYW1lcyA9IFtdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLm5hbWVzID0gW107XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggb2YgYSBnbHlwaCBieSBuYW1lLlxuICogQHBhcmFtICB7c3RyaW5nfSBuYW1lIC0gVGhlIGdseXBoIG5hbWVcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4XG4gKi9cbkdseXBoTmFtZXMucHJvdG90eXBlLm5hbWVUb0dseXBoSW5kZXggPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZXMuaW5kZXhPZihuYW1lKTtcbn07XG5cbi8qKlxuICogQHBhcmFtICB7bnVtYmVyfSBnaWRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuR2x5cGhOYW1lcy5wcm90b3R5cGUuZ2x5cGhJbmRleFRvTmFtZSA9IGZ1bmN0aW9uKGdpZCkge1xuICAgIHJldHVybiB0aGlzLm5hbWVzW2dpZF07XG59O1xuXG4vKipcbiAqIEBhbGlhcyBvcGVudHlwZS5hZGRHbHlwaE5hbWVzXG4gKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG4gKi9cbmZ1bmN0aW9uIGFkZEdseXBoTmFtZXMoZm9udCkge1xuICAgIHZhciBnbHlwaDtcbiAgICB2YXIgZ2x5cGhJbmRleE1hcCA9IGZvbnQudGFibGVzLmNtYXAuZ2x5cGhJbmRleE1hcDtcbiAgICB2YXIgY2hhckNvZGVzID0gT2JqZWN0LmtleXMoZ2x5cGhJbmRleE1hcCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJDb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgYyA9IGNoYXJDb2Rlc1tpXTtcbiAgICAgICAgdmFyIGdseXBoSW5kZXggPSBnbHlwaEluZGV4TWFwW2NdO1xuICAgICAgICBnbHlwaCA9IGZvbnQuZ2x5cGhzLmdldChnbHlwaEluZGV4KTtcbiAgICAgICAgZ2x5cGguYWRkVW5pY29kZShwYXJzZUludChjKSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgZm9udC5nbHlwaHMubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgICBnbHlwaCA9IGZvbnQuZ2x5cGhzLmdldChpJDEpO1xuICAgICAgICBpZiAoZm9udC5jZmZFbmNvZGluZykge1xuICAgICAgICAgICAgaWYgKGZvbnQuaXNDSURGb250KSB7XG4gICAgICAgICAgICAgICAgZ2x5cGgubmFtZSA9ICdnaWQnICsgaSQxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbHlwaC5uYW1lID0gZm9udC5jZmZFbmNvZGluZy5jaGFyc2V0W2kkMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZm9udC5nbHlwaE5hbWVzLm5hbWVzKSB7XG4gICAgICAgICAgICBnbHlwaC5uYW1lID0gZm9udC5nbHlwaE5hbWVzLmdseXBoSW5kZXhUb05hbWUoaSQxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gRHJhd2luZyB1dGlsaXR5IGZ1bmN0aW9ucy5cblxuLy8gRHJhdyBhIGxpbmUgb24gdGhlIGdpdmVuIGNvbnRleHQgZnJvbSBwb2ludCBgeDEseTFgIHRvIHBvaW50IGB4Mix5MmAuXG5mdW5jdGlvbiBsaW5lKGN0eCwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICBjdHguc3Ryb2tlKCk7XG59XG5cbnZhciBkcmF3ID0geyBsaW5lOiBsaW5lIH07XG5cbi8vIFRoZSBgZ2x5ZmAgdGFibGUgZGVzY3JpYmVzIHRoZSBnbHlwaHMgaW4gVHJ1ZVR5cGUgb3V0bGluZSBmb3JtYXQuXG4vLyBodHRwOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9vdHNwZWMvZ2x5Zi5odG1cblxuLy8gUGFyc2UgdGhlIGNvb3JkaW5hdGUgZGF0YSBmb3IgYSBnbHlwaC5cbmZ1bmN0aW9uIHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHByZXZpb3VzVmFsdWUsIHNob3J0VmVjdG9yQml0TWFzaywgc2FtZUJpdE1hc2spIHtcbiAgICB2YXIgdjtcbiAgICBpZiAoKGZsYWcgJiBzaG9ydFZlY3RvckJpdE1hc2spID4gMCkge1xuICAgICAgICAvLyBUaGUgY29vcmRpbmF0ZSBpcyAxIGJ5dGUgbG9uZy5cbiAgICAgICAgdiA9IHAucGFyc2VCeXRlKCk7XG4gICAgICAgIC8vIFRoZSBgc2FtZWAgYml0IGlzIHJlLXVzZWQgZm9yIHNob3J0IHZhbHVlcyB0byBzaWduaWZ5IHRoZSBzaWduIG9mIHRoZSB2YWx1ZS5cbiAgICAgICAgaWYgKChmbGFnICYgc2FtZUJpdE1hc2spID09PSAwKSB7XG4gICAgICAgICAgICB2ID0gLXY7XG4gICAgICAgIH1cblxuICAgICAgICB2ID0gcHJldmlvdXNWYWx1ZSArIHY7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gIFRoZSBjb29yZGluYXRlIGlzIDIgYnl0ZXMgbG9uZy5cbiAgICAgICAgLy8gSWYgdGhlIGBzYW1lYCBiaXQgaXMgc2V0LCB0aGUgY29vcmRpbmF0ZSBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgY29vcmRpbmF0ZS5cbiAgICAgICAgaWYgKChmbGFnICYgc2FtZUJpdE1hc2spID4gMCkge1xuICAgICAgICAgICAgdiA9IHByZXZpb3VzVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQYXJzZSB0aGUgY29vcmRpbmF0ZSBhcyBhIHNpZ25lZCAxNi1iaXQgZGVsdGEgdmFsdWUuXG4gICAgICAgICAgICB2ID0gcHJldmlvdXNWYWx1ZSArIHAucGFyc2VTaG9ydCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHY7XG59XG5cbi8vIFBhcnNlIGEgVHJ1ZVR5cGUgZ2x5cGguXG5mdW5jdGlvbiBwYXJzZUdseXBoKGdseXBoLCBkYXRhLCBzdGFydCkge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgZ2x5cGgubnVtYmVyT2ZDb250b3VycyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGdseXBoLl94TWluID0gcC5wYXJzZVNob3J0KCk7XG4gICAgZ2x5cGguX3lNaW4gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBnbHlwaC5feE1heCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGdseXBoLl95TWF4ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgdmFyIGZsYWdzO1xuICAgIHZhciBmbGFnO1xuXG4gICAgaWYgKGdseXBoLm51bWJlck9mQ29udG91cnMgPiAwKSB7XG4gICAgICAgIC8vIFRoaXMgZ2x5cGggaXMgbm90IGEgY29tcG9zaXRlLlxuICAgICAgICB2YXIgZW5kUG9pbnRJbmRpY2VzID0gZ2x5cGguZW5kUG9pbnRJbmRpY2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGgubnVtYmVyT2ZDb250b3VyczsgaSArPSAxKSB7XG4gICAgICAgICAgICBlbmRQb2ludEluZGljZXMucHVzaChwLnBhcnNlVVNob3J0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25MZW5ndGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIGdseXBoLmluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aDsgaSQxICs9IDEpIHtcbiAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9ucy5wdXNoKHAucGFyc2VCeXRlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG51bWJlck9mQ29vcmRpbmF0ZXMgPSBlbmRQb2ludEluZGljZXNbZW5kUG9pbnRJbmRpY2VzLmxlbmd0aCAtIDFdICsgMTtcbiAgICAgICAgZmxhZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSQyICs9IDEpIHtcbiAgICAgICAgICAgIGZsYWcgPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgZmxhZ3MucHVzaChmbGFnKTtcbiAgICAgICAgICAgIC8vIElmIGJpdCAzIGlzIHNldCwgd2UgcmVwZWF0IHRoaXMgZmxhZyBuIHRpbWVzLCB3aGVyZSBuIGlzIHRoZSBuZXh0IGJ5dGUuXG4gICAgICAgICAgICBpZiAoKGZsYWcgJiA4KSA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVwZWF0Q291bnQgPSBwLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVwZWF0Q291bnQ7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFncy5wdXNoKGZsYWcpO1xuICAgICAgICAgICAgICAgICAgICBpJDIgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjaGVjay5hcmd1bWVudChmbGFncy5sZW5ndGggPT09IG51bWJlck9mQ29vcmRpbmF0ZXMsICdCYWQgZmxhZ3MuJyk7XG5cbiAgICAgICAgaWYgKGVuZFBvaW50SW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICAgICAgICB2YXIgcG9pbnQ7XG4gICAgICAgICAgICAvLyBYL1kgY29vcmRpbmF0ZXMgYXJlIHJlbGF0aXZlIHRvIHRoZSBwcmV2aW91cyBwb2ludCwgZXhjZXB0IGZvciB0aGUgZmlyc3QgcG9pbnQgd2hpY2ggaXMgcmVsYXRpdmUgdG8gMCwwLlxuICAgICAgICAgICAgaWYgKG51bWJlck9mQ29vcmRpbmF0ZXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSQzICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2kkM107XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0ge307XG4gICAgICAgICAgICAgICAgICAgIHBvaW50Lm9uQ3VydmUgPSAhIShmbGFnICYgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50Lmxhc3RQb2ludE9mQ29udG91ciA9IGVuZFBvaW50SW5kaWNlcy5pbmRleE9mKGkkMykgPj0gMDtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBweCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQ0ID0gMDsgaSQ0IDwgbnVtYmVyT2ZDb29yZGluYXRlczsgaSQ0ICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZsYWdzW2kkNF07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0gcG9pbnRzW2kkNF07XG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnggPSBwYXJzZUdseXBoQ29vcmRpbmF0ZShwLCBmbGFnLCBweCwgMiwgMTYpO1xuICAgICAgICAgICAgICAgICAgICBweCA9IHBvaW50Lng7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHB5ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDUgPSAwOyBpJDUgPCBudW1iZXJPZkNvb3JkaW5hdGVzOyBpJDUgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmxhZ3NbaSQ1XTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQgPSBwb2ludHNbaSQ1XTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQueSA9IHBhcnNlR2x5cGhDb29yZGluYXRlKHAsIGZsYWcsIHB5LCA0LCAzMik7XG4gICAgICAgICAgICAgICAgICAgIHB5ID0gcG9pbnQueTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChnbHlwaC5udW1iZXJPZkNvbnRvdXJzID09PSAwKSB7XG4gICAgICAgIGdseXBoLnBvaW50cyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGdseXBoLmlzQ29tcG9zaXRlID0gdHJ1ZTtcbiAgICAgICAgZ2x5cGgucG9pbnRzID0gW107XG4gICAgICAgIGdseXBoLmNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdmFyIG1vcmVDb21wb25lbnRzID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKG1vcmVDb21wb25lbnRzKSB7XG4gICAgICAgICAgICBmbGFncyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB7XG4gICAgICAgICAgICAgICAgZ2x5cGhJbmRleDogcC5wYXJzZVVTaG9ydCgpLFxuICAgICAgICAgICAgICAgIHhTY2FsZTogMSxcbiAgICAgICAgICAgICAgICBzY2FsZTAxOiAwLFxuICAgICAgICAgICAgICAgIHNjYWxlMTA6IDAsXG4gICAgICAgICAgICAgICAgeVNjYWxlOiAxLFxuICAgICAgICAgICAgICAgIGR4OiAwLFxuICAgICAgICAgICAgICAgIGR5OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKChmbGFncyAmIDEpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBhcmd1bWVudHMgYXJlIHdvcmRzXG4gICAgICAgICAgICAgICAgaWYgKChmbGFncyAmIDIpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZHggPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmR5ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdmFsdWVzIGFyZSBtYXRjaGVkIHBvaW50c1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQubWF0Y2hlZFBvaW50cyA9IFtwLnBhcnNlVVNob3J0KCksIHAucGFyc2VVU2hvcnQoKV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBhcmd1bWVudHMgYXJlIGJ5dGVzXG4gICAgICAgICAgICAgICAgaWYgKChmbGFncyAmIDIpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXMgYXJlIG9mZnNldFxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZHggPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZHkgPSBwLnBhcnNlQ2hhcigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBhcmUgbWF0Y2hlZCBwb2ludHNcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm1hdGNoZWRQb2ludHMgPSBbcC5wYXJzZUJ5dGUoKSwgcC5wYXJzZUJ5dGUoKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgOCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHNjYWxlXG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnhTY2FsZSA9IGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiA2NCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhbiBYIC8gWSBzY2FsZVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC54U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiAxMjgpID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSAyeDIgdHJhbnNmb3JtYXRpb25cbiAgICAgICAgICAgICAgICBjb21wb25lbnQueFNjYWxlID0gcC5wYXJzZUYyRG90MTQoKTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnQuc2NhbGUwMSA9IHAucGFyc2VGMkRvdDE0KCk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LnNjYWxlMTAgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC55U2NhbGUgPSBwLnBhcnNlRjJEb3QxNCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbHlwaC5jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgICAgIG1vcmVDb21wb25lbnRzID0gISEoZmxhZ3MgJiAzMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYWdzICYgMHgxMDApIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgaW5zdHJ1Y3Rpb25zXG4gICAgICAgICAgICBnbHlwaC5pbnN0cnVjdGlvbkxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIGdseXBoLmluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQ2ID0gMDsgaSQ2IDwgZ2x5cGguaW5zdHJ1Y3Rpb25MZW5ndGg7IGkkNiArPSAxKSB7XG4gICAgICAgICAgICAgICAgZ2x5cGguaW5zdHJ1Y3Rpb25zLnB1c2gocC5wYXJzZUJ5dGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIFRyYW5zZm9ybSBhbiBhcnJheSBvZiBwb2ludHMgYW5kIHJldHVybiBhIG5ldyBhcnJheS5cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50cyhwb2ludHMsIHRyYW5zZm9ybSkge1xuICAgIHZhciBuZXdQb2ludHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcHQgPSBwb2ludHNbaV07XG4gICAgICAgIHZhciBuZXdQdCA9IHtcbiAgICAgICAgICAgIHg6IHRyYW5zZm9ybS54U2NhbGUgKiBwdC54ICsgdHJhbnNmb3JtLnNjYWxlMDEgKiBwdC55ICsgdHJhbnNmb3JtLmR4LFxuICAgICAgICAgICAgeTogdHJhbnNmb3JtLnNjYWxlMTAgKiBwdC54ICsgdHJhbnNmb3JtLnlTY2FsZSAqIHB0LnkgKyB0cmFuc2Zvcm0uZHksXG4gICAgICAgICAgICBvbkN1cnZlOiBwdC5vbkN1cnZlLFxuICAgICAgICAgICAgbGFzdFBvaW50T2ZDb250b3VyOiBwdC5sYXN0UG9pbnRPZkNvbnRvdXJcbiAgICAgICAgfTtcbiAgICAgICAgbmV3UG9pbnRzLnB1c2gobmV3UHQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdQb2ludHM7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRvdXJzKHBvaW50cykge1xuICAgIHZhciBjb250b3VycyA9IFtdO1xuICAgIHZhciBjdXJyZW50Q29udG91ciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBwdCA9IHBvaW50c1tpXTtcbiAgICAgICAgY3VycmVudENvbnRvdXIucHVzaChwdCk7XG4gICAgICAgIGlmIChwdC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcbiAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY3VycmVudENvbnRvdXIpO1xuICAgICAgICAgICAgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrLmFyZ3VtZW50KGN1cnJlbnRDb250b3VyLmxlbmd0aCA9PT0gMCwgJ1RoZXJlIGFyZSBzdGlsbCBwb2ludHMgbGVmdCBpbiB0aGUgY3VycmVudCBjb250b3VyLicpO1xuICAgIHJldHVybiBjb250b3Vycztcbn1cblxuLy8gQ29udmVydCB0aGUgVHJ1ZVR5cGUgZ2x5cGggb3V0bGluZSB0byBhIFBhdGguXG5mdW5jdGlvbiBnZXRQYXRoKHBvaW50cykge1xuICAgIHZhciBwID0gbmV3IFBhdGgoKTtcbiAgICBpZiAoIXBvaW50cykge1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICB2YXIgY29udG91cnMgPSBnZXRDb250b3Vycyhwb2ludHMpO1xuXG4gICAgZm9yICh2YXIgY29udG91ckluZGV4ID0gMDsgY29udG91ckluZGV4IDwgY29udG91cnMubGVuZ3RoOyArK2NvbnRvdXJJbmRleCkge1xuICAgICAgICB2YXIgY29udG91ciA9IGNvbnRvdXJzW2NvbnRvdXJJbmRleF07XG5cbiAgICAgICAgdmFyIHByZXYgPSBudWxsO1xuICAgICAgICB2YXIgY3VyciA9IGNvbnRvdXJbY29udG91ci5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG5leHQgPSBjb250b3VyWzBdO1xuXG4gICAgICAgIGlmIChjdXJyLm9uQ3VydmUpIHtcbiAgICAgICAgICAgIHAubW92ZVRvKGN1cnIueCwgY3Vyci55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuZXh0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICBwLm1vdmVUbyhuZXh0LngsIG5leHQueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIGJvdGggZmlyc3QgYW5kIGxhc3QgcG9pbnRzIGFyZSBvZmYtY3VydmUsIHN0YXJ0IGF0IHRoZWlyIG1pZGRsZS5cbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSB7eDogKGN1cnIueCArIG5leHQueCkgKiAwLjUsIHk6IChjdXJyLnkgKyBuZXh0LnkpICogMC41fTtcbiAgICAgICAgICAgICAgICBwLm1vdmVUbyhzdGFydC54LCBzdGFydC55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udG91ci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcHJldiA9IGN1cnI7XG4gICAgICAgICAgICBjdXJyID0gbmV4dDtcbiAgICAgICAgICAgIG5leHQgPSBjb250b3VyWyhpICsgMSkgJSBjb250b3VyLmxlbmd0aF07XG5cbiAgICAgICAgICAgIGlmIChjdXJyLm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgc3RyYWlnaHQgbGluZS5cbiAgICAgICAgICAgICAgICBwLmxpbmVUbyhjdXJyLngsIGN1cnIueSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2MiA9IHByZXY7XG4gICAgICAgICAgICAgICAgdmFyIG5leHQyID0gbmV4dDtcblxuICAgICAgICAgICAgICAgIGlmICghcHJldi5vbkN1cnZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXYyID0geyB4OiAoY3Vyci54ICsgcHJldi54KSAqIDAuNSwgeTogKGN1cnIueSArIHByZXYueSkgKiAwLjUgfTtcbiAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8ocHJldjIueCwgcHJldjIueSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0Lm9uQ3VydmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dDIgPSB7IHg6IChjdXJyLnggKyBuZXh0LngpICogMC41LCB5OiAoY3Vyci55ICsgbmV4dC55KSAqIDAuNSB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHAubGluZVRvKHByZXYyLngsIHByZXYyLnkpO1xuICAgICAgICAgICAgICAgIHAucXVhZHJhdGljQ3VydmVUbyhjdXJyLngsIGN1cnIueSwgbmV4dDIueCwgbmV4dDIueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gYnVpbGRQYXRoKGdseXBocywgZ2x5cGgpIHtcbiAgICBpZiAoZ2x5cGguaXNDb21wb3NpdGUpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbHlwaC5jb21wb25lbnRzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgY29tcG9uZW50ID0gZ2x5cGguY29tcG9uZW50c1tqXTtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnRHbHlwaCA9IGdseXBocy5nZXQoY29tcG9uZW50LmdseXBoSW5kZXgpO1xuICAgICAgICAgICAgLy8gRm9yY2UgdGhlIHR0ZkdseXBoTG9hZGVyIHRvIHBhcnNlIHRoZSBnbHlwaC5cbiAgICAgICAgICAgIGNvbXBvbmVudEdseXBoLmdldFBhdGgoKTtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRHbHlwaC5wb2ludHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSAodm9pZCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50Lm1hdGNoZWRQb2ludHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnQgcG9zaXRpb25lZCBieSBvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRQb2ludHMgPSB0cmFuc2Zvcm1Qb2ludHMoY29tcG9uZW50R2x5cGgucG9pbnRzLCBjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudCBwb3NpdGlvbmVkIGJ5IG1hdGNoZWQgcG9pbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmICgoY29tcG9uZW50Lm1hdGNoZWRQb2ludHNbMF0gPiBnbHlwaC5wb2ludHMubGVuZ3RoIC0gMSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb21wb25lbnQubWF0Y2hlZFBvaW50c1sxXSA+IGNvbXBvbmVudEdseXBoLnBvaW50cy5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ01hdGNoZWQgcG9pbnRzIG91dCBvZiByYW5nZSBpbiAnICsgZ2x5cGgubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0UHQgPSBnbHlwaC5wb2ludHNbY29tcG9uZW50Lm1hdGNoZWRQb2ludHNbMF1dO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2Vjb25kUHQgPSBjb21wb25lbnRHbHlwaC5wb2ludHNbY29tcG9uZW50Lm1hdGNoZWRQb2ludHNbMV1dO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeFNjYWxlOiBjb21wb25lbnQueFNjYWxlLCBzY2FsZTAxOiBjb21wb25lbnQuc2NhbGUwMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlMTA6IGNvbXBvbmVudC5zY2FsZTEwLCB5U2NhbGU6IGNvbXBvbmVudC55U2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkeDogMCwgZHk6IDBcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kUHQgPSB0cmFuc2Zvcm1Qb2ludHMoW3NlY29uZFB0XSwgdHJhbnNmb3JtKVswXTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmR4ID0gZmlyc3RQdC54IC0gc2Vjb25kUHQueDtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtLmR5ID0gZmlyc3RQdC55IC0gc2Vjb25kUHQueTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRQb2ludHMgPSB0cmFuc2Zvcm1Qb2ludHMoY29tcG9uZW50R2x5cGgucG9pbnRzLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnbHlwaC5wb2ludHMgPSBnbHlwaC5wb2ludHMuY29uY2F0KHRyYW5zZm9ybWVkUG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnZXRQYXRoKGdseXBoLnBvaW50cyk7XG59XG5cbi8vIFBhcnNlIGFsbCB0aGUgZ2x5cGhzIGFjY29yZGluZyB0byB0aGUgb2Zmc2V0cyBmcm9tIHRoZSBgbG9jYWAgdGFibGUuXG5mdW5jdGlvbiBwYXJzZUdseWZUYWJsZShkYXRhLCBzdGFydCwgbG9jYSwgZm9udCkge1xuICAgIHZhciBnbHlwaHMgPSBuZXcgZ2x5cGhzZXQuR2x5cGhTZXQoZm9udCk7XG5cbiAgICAvLyBUaGUgbGFzdCBlbGVtZW50IG9mIHRoZSBsb2NhIHRhYmxlIGlzIGludmFsaWQuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NhLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gbG9jYVtpXTtcbiAgICAgICAgdmFyIG5leHRPZmZzZXQgPSBsb2NhW2kgKyAxXTtcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gbmV4dE9mZnNldCkge1xuICAgICAgICAgICAgZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQudHRmR2x5cGhMb2FkZXIoZm9udCwgaSwgcGFyc2VHbHlwaCwgZGF0YSwgc3RhcnQgKyBvZmZzZXQsIGJ1aWxkUGF0aCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQuZ2x5cGhMb2FkZXIoZm9udCwgaSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBocztcbn1cblxudmFyIGdseWYgPSB7IGdldFBhdGg6IGdldFBhdGgsIHBhcnNlOiBwYXJzZUdseWZUYWJsZSB9O1xuXG4vLyBUaGUgR2x5cGggb2JqZWN0XG5cbmZ1bmN0aW9uIGdldFBhdGhEZWZpbml0aW9uKGdseXBoLCBwYXRoKSB7XG4gICAgdmFyIF9wYXRoID0gcGF0aCB8fCBuZXcgUGF0aCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBfcGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIF9wYXRoID0gX3BhdGgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9wYXRoO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgX3BhdGggPSBwO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQHR5cGVkZWYgR2x5cGhPcHRpb25zXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gLSBUaGUgZ2x5cGggbmFtZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt1bmljb2RlXVxuICogQHByb3BlcnR5IHtBcnJheX0gW3VuaWNvZGVzXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt4TWluXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt5TWluXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt4TWF4XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt5TWF4XVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFthZHZhbmNlV2lkdGhdXG4gKi9cblxuLy8gQSBHbHlwaCBpcyBhbiBpbmRpdmlkdWFsIG1hcmsgdGhhdCBvZnRlbiBjb3JyZXNwb25kcyB0byBhIGNoYXJhY3Rlci5cbi8vIFNvbWUgZ2x5cGhzLCBzdWNoIGFzIGxpZ2F0dXJlcywgYXJlIGEgY29tYmluYXRpb24gb2YgbWFueSBjaGFyYWN0ZXJzLlxuLy8gR2x5cGhzIGFyZSB0aGUgYmFzaWMgYnVpbGRpbmcgYmxvY2tzIG9mIGEgZm9udC5cbi8vXG4vLyBUaGUgYEdseXBoYCBjbGFzcyBjb250YWlucyB1dGlsaXR5IG1ldGhvZHMgZm9yIGRyYXdpbmcgdGhlIHBhdGggYW5kIGl0cyBwb2ludHMuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLkdseXBoXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7R2x5cGhPcHRpb25zfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEdseXBoKG9wdGlvbnMpIHtcbiAgICAvLyBCeSBwdXR0aW5nIGFsbCB0aGUgY29kZSBvbiBhIHByb3RvdHlwZSBmdW5jdGlvbiAod2hpY2ggaXMgb25seSBkZWNsYXJlZCBvbmNlKVxuICAgIC8vIHdlIHJlZHVjZSB0aGUgbWVtb3J5IHJlcXVpcmVtZW50cyBmb3IgbGFyZ2VyIGZvbnRzIGJ5IHNvbWUgMiVcbiAgICB0aGlzLmJpbmRDb25zdHJ1Y3RvclZhbHVlcyhvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gIHtHbHlwaE9wdGlvbnN9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5iaW5kQ29uc3RydWN0b3JWYWx1ZXMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXggfHwgMDtcblxuICAgIC8vIFRoZXNlIHRocmVlIHZhbHVlcyBjYW5ub3QgYmUgZGVmZXJyZWQgZm9yIG1lbW9yeSBvcHRpbWl6YXRpb246XG4gICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IG51bGw7XG4gICAgdGhpcy51bmljb2RlID0gb3B0aW9ucy51bmljb2RlIHx8IHVuZGVmaW5lZDtcbiAgICB0aGlzLnVuaWNvZGVzID0gb3B0aW9ucy51bmljb2RlcyB8fCBvcHRpb25zLnVuaWNvZGUgIT09IHVuZGVmaW5lZCA/IFtvcHRpb25zLnVuaWNvZGVdIDogW107XG5cbiAgICAvLyBCdXQgYnkgYmluZGluZyB0aGVzZSB2YWx1ZXMgb25seSB3aGVuIG5lY2Vzc2FyeSwgd2UgcmVkdWNlIGNhblxuICAgIC8vIHRoZSBtZW1vcnkgcmVxdWlyZW1lbnRzIGJ5IGFsbW9zdCAzJSBmb3IgbGFyZ2VyIGZvbnRzLlxuICAgIGlmIChvcHRpb25zLnhNaW4pIHtcbiAgICAgICAgdGhpcy54TWluID0gb3B0aW9ucy54TWluO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnlNaW4pIHtcbiAgICAgICAgdGhpcy55TWluID0gb3B0aW9ucy55TWluO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnhNYXgpIHtcbiAgICAgICAgdGhpcy54TWF4ID0gb3B0aW9ucy54TWF4O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLnlNYXgpIHtcbiAgICAgICAgdGhpcy55TWF4ID0gb3B0aW9ucy55TWF4O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmFkdmFuY2VXaWR0aCkge1xuICAgICAgICB0aGlzLmFkdmFuY2VXaWR0aCA9IG9wdGlvbnMuYWR2YW5jZVdpZHRoO1xuICAgIH1cblxuICAgIC8vIFRoZSBwYXRoIGZvciBhIGdseXBoIGlzIHRoZSBtb3N0IG1lbW9yeSBpbnRlbnNpdmUsIGFuZCBpcyBib3VuZCBhcyBhIHZhbHVlXG4gICAgLy8gd2l0aCBhIGdldHRlci9zZXR0ZXIgdG8gZW5zdXJlIHdlIGFjdHVhbGx5IGRvIHBhdGggcGFyc2luZyBvbmx5IG9uY2UgdGhlXG4gICAgLy8gcGF0aCBpcyBhY3R1YWxseSBuZWVkZWQgYnkgYW55dGhpbmcuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwYXRoJywgZ2V0UGF0aERlZmluaXRpb24odGhpcywgb3B0aW9ucy5wYXRoKSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfVxuICovXG5HbHlwaC5wcm90b3R5cGUuYWRkVW5pY29kZSA9IGZ1bmN0aW9uKHVuaWNvZGUpIHtcbiAgICBpZiAodGhpcy51bmljb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy51bmljb2RlID0gdW5pY29kZTtcbiAgICB9XG5cbiAgICB0aGlzLnVuaWNvZGVzLnB1c2godW5pY29kZSk7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgbWluaW11bSBib3VuZGluZyBib3ggZm9yIHRoaXMgZ2x5cGguXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5Cb3VuZGluZ0JveH1cbiAqL1xuR2x5cGgucHJvdG90eXBlLmdldEJvdW5kaW5nQm94ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aC5nZXRCb3VuZGluZ0JveCgpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnbHlwaCB0byBhIFBhdGggd2UgY2FuIGRyYXcgb24gYSBkcmF3aW5nIGNvbnRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnMgLSB4U2NhbGUsIHlTY2FsZSB0byBzdHJldGNoIHRoZSBnbHlwaC5cbiAqIEBwYXJhbSAge29wZW50eXBlLkZvbnR9IGlmIGhpbnRpbmcgaXMgdG8gYmUgdXNlZCwgdGhlIGZvbnRcbiAqIEByZXR1cm4ge29wZW50eXBlLlBhdGh9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5nZXRQYXRoID0gZnVuY3Rpb24oeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZvbnQpIHtcbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogNzI7XG4gICAgdmFyIGNvbW1hbmRzO1xuICAgIHZhciBoUG9pbnRzO1xuICAgIGlmICghb3B0aW9ucykgeyBvcHRpb25zID0geyB9OyB9XG4gICAgdmFyIHhTY2FsZSA9IG9wdGlvbnMueFNjYWxlO1xuICAgIHZhciB5U2NhbGUgPSBvcHRpb25zLnlTY2FsZTtcblxuICAgIGlmIChvcHRpb25zLmhpbnRpbmcgJiYgZm9udCAmJiBmb250LmhpbnRpbmcpIHtcbiAgICAgICAgLy8gaW4gY2FzZSBvZiBoaW50aW5nLCB0aGUgaGludGluZyBlbmdpbmUgdGFrZXMgY2FyZVxuICAgICAgICAvLyBvZiBzY2FsaW5nIHRoZSBwb2ludHMgKG5vdCB0aGUgcGF0aCkgYmVmb3JlIGhpbnRpbmcuXG4gICAgICAgIGhQb2ludHMgPSB0aGlzLnBhdGggJiYgZm9udC5oaW50aW5nLmV4ZWModGhpcywgZm9udFNpemUpO1xuICAgICAgICAvLyBpbiBjYXNlIHRoZSBoaW50aW5nIGVuZ2luZSBmYWlsZWQgaFBvaW50cyBpcyB1bmRlZmluZWRcbiAgICAgICAgLy8gYW5kIHRodXMgcmV2ZXJ0cyB0byBwbGFpbiByZW5kaW5nXG4gICAgfVxuXG4gICAgaWYgKGhQb2ludHMpIHtcbiAgICAgICAgY29tbWFuZHMgPSBnbHlmLmdldFBhdGgoaFBvaW50cykuY29tbWFuZHM7XG4gICAgICAgIHggPSBNYXRoLnJvdW5kKHgpO1xuICAgICAgICB5ID0gTWF0aC5yb3VuZCh5KTtcbiAgICAgICAgLy8gVE9ETyBpbiBjYXNlIG9mIGhpbnRpbmcgeHlTY2FsaW5nIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXG4gICAgICAgIHhTY2FsZSA9IHlTY2FsZSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWFuZHMgPSB0aGlzLnBhdGguY29tbWFuZHM7XG4gICAgICAgIHZhciBzY2FsZSA9IDEgLyB0aGlzLnBhdGgudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuICAgICAgICBpZiAoeFNjYWxlID09PSB1bmRlZmluZWQpIHsgeFNjYWxlID0gc2NhbGU7IH1cbiAgICAgICAgaWYgKHlTY2FsZSA9PT0gdW5kZWZpbmVkKSB7IHlTY2FsZSA9IHNjYWxlOyB9XG4gICAgfVxuXG4gICAgdmFyIHAgPSBuZXcgUGF0aCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNtZCA9IGNvbW1hbmRzW2ldO1xuICAgICAgICBpZiAoY21kLnR5cGUgPT09ICdNJykge1xuICAgICAgICAgICAgcC5tb3ZlVG8oeCArIChjbWQueCAqIHhTY2FsZSksIHkgKyAoLWNtZC55ICogeVNjYWxlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdMJykge1xuICAgICAgICAgICAgcC5saW5lVG8oeCArIChjbWQueCAqIHhTY2FsZSksIHkgKyAoLWNtZC55ICogeVNjYWxlKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdRJykge1xuICAgICAgICAgICAgcC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyAoY21kLngxICogeFNjYWxlKSwgeSArICgtY21kLnkxICogeVNjYWxlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ICsgKGNtZC54ICogeFNjYWxlKSwgeSArICgtY21kLnkgKiB5U2NhbGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICBwLmN1cnZlVG8oeCArIChjbWQueDEgKiB4U2NhbGUpLCB5ICsgKC1jbWQueTEgKiB5U2NhbGUpLFxuICAgICAgICAgICAgICAgICAgICAgIHggKyAoY21kLngyICogeFNjYWxlKSwgeSArICgtY21kLnkyICogeVNjYWxlKSxcbiAgICAgICAgICAgICAgICAgICAgICB4ICsgKGNtZC54ICogeFNjYWxlKSwgeSArICgtY21kLnkgKiB5U2NhbGUpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjbWQudHlwZSA9PT0gJ1onKSB7XG4gICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG59O1xuXG4vKipcbiAqIFNwbGl0IHRoZSBnbHlwaCBpbnRvIGNvbnRvdXJzLlxuICogVGhpcyBmdW5jdGlvbiBpcyBoZXJlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYW5kIHRvXG4gKiBwcm92aWRlIHJhdyBhY2Nlc3MgdG8gdGhlIFRydWVUeXBlIGdseXBoIG91dGxpbmVzLlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5nZXRDb250b3VycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMucG9pbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBjb250b3VycyA9IFtdO1xuICAgIHZhciBjdXJyZW50Q29udG91ciA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHB0ID0gdGhpcyQxLnBvaW50c1tpXTtcbiAgICAgICAgY3VycmVudENvbnRvdXIucHVzaChwdCk7XG4gICAgICAgIGlmIChwdC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcbiAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY3VycmVudENvbnRvdXIpO1xuICAgICAgICAgICAgY3VycmVudENvbnRvdXIgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrLmFyZ3VtZW50KGN1cnJlbnRDb250b3VyLmxlbmd0aCA9PT0gMCwgJ1RoZXJlIGFyZSBzdGlsbCBwb2ludHMgbGVmdCBpbiB0aGUgY3VycmVudCBjb250b3VyLicpO1xuICAgIHJldHVybiBjb250b3Vycztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSB4TWluL3lNaW4veE1heC95TWF4L2xzYi9yc2IgZm9yIGEgR2x5cGguXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkdseXBoLnByb3RvdHlwZS5nZXRNZXRyaWNzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvbW1hbmRzID0gdGhpcy5wYXRoLmNvbW1hbmRzO1xuICAgIHZhciB4Q29vcmRzID0gW107XG4gICAgdmFyIHlDb29yZHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjbWQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlICE9PSAnWicpIHtcbiAgICAgICAgICAgIHhDb29yZHMucHVzaChjbWQueCk7XG4gICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnUScgfHwgY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgeENvb3Jkcy5wdXNoKGNtZC54MSk7XG4gICAgICAgICAgICB5Q29vcmRzLnB1c2goY21kLnkxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbWQudHlwZSA9PT0gJ0MnKSB7XG4gICAgICAgICAgICB4Q29vcmRzLnB1c2goY21kLngyKTtcbiAgICAgICAgICAgIHlDb29yZHMucHVzaChjbWQueTIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1ldHJpY3MgPSB7XG4gICAgICAgIHhNaW46IE1hdGgubWluLmFwcGx5KG51bGwsIHhDb29yZHMpLFxuICAgICAgICB5TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB5Q29vcmRzKSxcbiAgICAgICAgeE1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeENvb3JkcyksXG4gICAgICAgIHlNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHlDb29yZHMpLFxuICAgICAgICBsZWZ0U2lkZUJlYXJpbmc6IHRoaXMubGVmdFNpZGVCZWFyaW5nXG4gICAgfTtcblxuICAgIGlmICghaXNGaW5pdGUobWV0cmljcy54TWluKSkge1xuICAgICAgICBtZXRyaWNzLnhNaW4gPSAwO1xuICAgIH1cblxuICAgIGlmICghaXNGaW5pdGUobWV0cmljcy54TWF4KSkge1xuICAgICAgICBtZXRyaWNzLnhNYXggPSB0aGlzLmFkdmFuY2VXaWR0aDtcbiAgICB9XG5cbiAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueU1pbikpIHtcbiAgICAgICAgbWV0cmljcy55TWluID0gMDtcbiAgICB9XG5cbiAgICBpZiAoIWlzRmluaXRlKG1ldHJpY3MueU1heCkpIHtcbiAgICAgICAgbWV0cmljcy55TWF4ID0gMDtcbiAgICB9XG5cbiAgICBtZXRyaWNzLnJpZ2h0U2lkZUJlYXJpbmcgPSB0aGlzLmFkdmFuY2VXaWR0aCAtIG1ldHJpY3MubGVmdFNpZGVCZWFyaW5nIC0gKG1ldHJpY3MueE1heCAtIG1ldHJpY3MueE1pbik7XG4gICAgcmV0dXJuIG1ldHJpY3M7XG59O1xuXG4vKipcbiAqIERyYXcgdGhlIGdseXBoIG9uIHRoZSBnaXZlbiBjb250ZXh0LlxuICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge09iamVjdD19IG9wdGlvbnMgLSB4U2NhbGUsIHlTY2FsZSB0byBzdHJldGNoIHRoZSBnbHlwaC5cbiAqL1xuR2x5cGgucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihjdHgsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdGhpcy5nZXRQYXRoKHgsIHksIGZvbnRTaXplLCBvcHRpb25zKS5kcmF3KGN0eCk7XG59O1xuXG4vKipcbiAqIERyYXcgdGhlIHBvaW50cyBvZiB0aGUgZ2x5cGguXG4gKiBPbi1jdXJ2ZSBwb2ludHMgd2lsbCBiZSBkcmF3biBpbiBibHVlLCBvZmYtY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gcmVkLlxuICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqL1xuR2x5cGgucHJvdG90eXBlLmRyYXdQb2ludHMgPSBmdW5jdGlvbihjdHgsIHgsIHksIGZvbnRTaXplKSB7XG4gICAgZnVuY3Rpb24gZHJhd0NpcmNsZXMobCwgeCwgeSwgc2NhbGUpIHtcbiAgICAgICAgdmFyIFBJX1NRID0gTWF0aC5QSSAqIDI7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyAobFtqXS54ICogc2NhbGUpLCB5ICsgKGxbal0ueSAqIHNjYWxlKSk7XG4gICAgICAgICAgICBjdHguYXJjKHggKyAobFtqXS54ICogc2NhbGUpLCB5ICsgKGxbal0ueSAqIHNjYWxlKSwgMiwgMCwgUElfU1EsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICB9XG5cbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogMjQ7XG4gICAgdmFyIHNjYWxlID0gMSAvIHRoaXMucGF0aC51bml0c1BlckVtICogZm9udFNpemU7XG5cbiAgICB2YXIgYmx1ZUNpcmNsZXMgPSBbXTtcbiAgICB2YXIgcmVkQ2lyY2xlcyA9IFtdO1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5jb21tYW5kcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgY21kID0gcGF0aC5jb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC54ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJsdWVDaXJjbGVzLnB1c2goe3g6IGNtZC54LCB5OiAtY21kLnl9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbWQueDEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVkQ2lyY2xlcy5wdXNoKHt4OiBjbWQueDEsIHk6IC1jbWQueTF9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbWQueDIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVkQ2lyY2xlcy5wdXNoKHt4OiBjbWQueDIsIHk6IC1jbWQueTJ9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGN0eC5maWxsU3R5bGUgPSAnYmx1ZSc7XG4gICAgZHJhd0NpcmNsZXMoYmx1ZUNpcmNsZXMsIHgsIHksIHNjYWxlKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ3JlZCc7XG4gICAgZHJhd0NpcmNsZXMocmVkQ2lyY2xlcywgeCwgeSwgc2NhbGUpO1xufTtcblxuLyoqXG4gKiBEcmF3IGxpbmVzIGluZGljYXRpbmcgaW1wb3J0YW50IGZvbnQgbWVhc3VyZW1lbnRzLlxuICogQmxhY2sgbGluZXMgaW5kaWNhdGUgdGhlIG9yaWdpbiBvZiB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gKHBvaW50IDAsMCkuXG4gKiBCbHVlIGxpbmVzIGluZGljYXRlIHRoZSBnbHlwaCBib3VuZGluZyBib3guXG4gKiBHcmVlbiBsaW5lIGluZGljYXRlcyB0aGUgYWR2YW5jZSB3aWR0aCBvZiB0aGUgZ2x5cGguXG4gKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LCBsaWtlIENhbnZhcy5cbiAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICovXG5HbHlwaC5wcm90b3R5cGUuZHJhd01ldHJpY3MgPSBmdW5jdGlvbihjdHgsIHgsIHksIGZvbnRTaXplKSB7XG4gICAgdmFyIHNjYWxlO1xuICAgIHggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcbiAgICB5ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IDA7XG4gICAgZm9udFNpemUgPSBmb250U2l6ZSAhPT0gdW5kZWZpbmVkID8gZm9udFNpemUgOiAyNDtcbiAgICBzY2FsZSA9IDEgLyB0aGlzLnBhdGgudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuXG4gICAgLy8gRHJhdyB0aGUgb3JpZ2luXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ2JsYWNrJztcbiAgICBkcmF3LmxpbmUoY3R4LCB4LCAtMTAwMDAsIHgsIDEwMDAwKTtcbiAgICBkcmF3LmxpbmUoY3R4LCAtMTAwMDAsIHksIDEwMDAwLCB5KTtcblxuICAgIC8vIFRoaXMgY29kZSBpcyBoZXJlIGR1ZSB0byBtZW1vcnkgb3B0aW1pemF0aW9uOiBieSBub3QgdXNpbmdcbiAgICAvLyBkZWZhdWx0cyBpbiB0aGUgY29uc3RydWN0b3IsIHdlIHNhdmUgYSBub3RhYmxlIGFtb3VudCBvZiBtZW1vcnkuXG4gICAgdmFyIHhNaW4gPSB0aGlzLnhNaW4gfHwgMDtcbiAgICB2YXIgeU1pbiA9IHRoaXMueU1pbiB8fCAwO1xuICAgIHZhciB4TWF4ID0gdGhpcy54TWF4IHx8IDA7XG4gICAgdmFyIHlNYXggPSB0aGlzLnlNYXggfHwgMDtcbiAgICB2YXIgYWR2YW5jZVdpZHRoID0gdGhpcy5hZHZhbmNlV2lkdGggfHwgMDtcblxuICAgIC8vIERyYXcgdGhlIGdseXBoIGJveFxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdibHVlJztcbiAgICBkcmF3LmxpbmUoY3R4LCB4ICsgKHhNaW4gKiBzY2FsZSksIC0xMDAwMCwgeCArICh4TWluICogc2NhbGUpLCAxMDAwMCk7XG4gICAgZHJhdy5saW5lKGN0eCwgeCArICh4TWF4ICogc2NhbGUpLCAtMTAwMDAsIHggKyAoeE1heCAqIHNjYWxlKSwgMTAwMDApO1xuICAgIGRyYXcubGluZShjdHgsIC0xMDAwMCwgeSArICgteU1pbiAqIHNjYWxlKSwgMTAwMDAsIHkgKyAoLXlNaW4gKiBzY2FsZSkpO1xuICAgIGRyYXcubGluZShjdHgsIC0xMDAwMCwgeSArICgteU1heCAqIHNjYWxlKSwgMTAwMDAsIHkgKyAoLXlNYXggKiBzY2FsZSkpO1xuXG4gICAgLy8gRHJhdyB0aGUgYWR2YW5jZSB3aWR0aFxuICAgIGN0eC5zdHJva2VTdHlsZSA9ICdncmVlbic7XG4gICAgZHJhdy5saW5lKGN0eCwgeCArIChhZHZhbmNlV2lkdGggKiBzY2FsZSksIC0xMDAwMCwgeCArIChhZHZhbmNlV2lkdGggKiBzY2FsZSksIDEwMDAwKTtcbn07XG5cbi8vIFRoZSBHbHlwaFNldCBvYmplY3RcblxuLy8gRGVmaW5lIGEgcHJvcGVydHkgb24gdGhlIGdseXBoIHRoYXQgZGVwZW5kcyBvbiB0aGUgcGF0aCBiZWluZyBsb2FkZWQuXG5mdW5jdGlvbiBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgZXh0ZXJuYWxOYW1lLCBpbnRlcm5hbE5hbWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2x5cGgsIGV4dGVybmFsTmFtZSwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUmVxdWVzdCB0aGUgcGF0aCBwcm9wZXJ0eSB0byBtYWtlIHN1cmUgdGhlIHBhdGggaXMgbG9hZGVkLlxuICAgICAgICAgICAgZ2x5cGgucGF0aDsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICByZXR1cm4gZ2x5cGhbaW50ZXJuYWxOYW1lXTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgICAgICAgICAgZ2x5cGhbaW50ZXJuYWxOYW1lXSA9IG5ld1ZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBBIEdseXBoU2V0IHJlcHJlc2VudHMgYWxsIGdseXBocyBhdmFpbGFibGUgaW4gdGhlIGZvbnQsIGJ1dCBtb2RlbGxlZCB1c2luZ1xuICogYSBkZWZlcnJlZCBnbHlwaCBsb2FkZXIsIGZvciByZXRyaWV2aW5nIGdseXBocyBvbmx5IG9uY2UgdGhleSBhcmUgYWJzb2x1dGVseVxuICogbmVjZXNzYXJ5LCB0byBrZWVwIHRoZSBtZW1vcnkgZm9vdHByaW50IGRvd24uXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5HbHlwaFNldFxuICogQGNsYXNzXG4gKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG4gKiBAcGFyYW0ge0FycmF5fVxuICovXG5mdW5jdGlvbiBHbHlwaFNldChmb250LCBnbHlwaHMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMuZm9udCA9IGZvbnQ7XG4gICAgdGhpcy5nbHlwaHMgPSB7fTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShnbHlwaHMpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzJDEuZ2x5cGhzW2ldID0gZ2x5cGhzW2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSAoZ2x5cGhzICYmIGdseXBocy5sZW5ndGgpIHx8IDA7XG59XG5cbi8qKlxuICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gKi9cbkdseXBoU2V0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5nbHlwaHNbaW5kZXhdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuZ2x5cGhzW2luZGV4XSA9IHRoaXMuZ2x5cGhzW2luZGV4XSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdseXBoc1tpbmRleF07XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSAge09iamVjdH1cbiAqL1xuR2x5cGhTZXQucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihpbmRleCwgbG9hZGVyKSB7XG4gICAgdGhpcy5nbHlwaHNbaW5kZXhdID0gbG9hZGVyO1xuICAgIHRoaXMubGVuZ3RoKys7XG59O1xuXG4vKipcbiAqIEBhbGlhcyBvcGVudHlwZS5nbHlwaExvYWRlclxuICogQHBhcmFtICB7b3BlbnR5cGUuRm9udH0gZm9udFxuICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gKi9cbmZ1bmN0aW9uIGdseXBoTG9hZGVyKGZvbnQsIGluZGV4KSB7XG4gICAgcmV0dXJuIG5ldyBHbHlwaCh7aW5kZXg6IGluZGV4LCBmb250OiBmb250fSk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdHViIGdseXBoIHRoYXQgY2FuIGJlIGZpbGxlZCB3aXRoIGFsbCBtZXRhZGF0YSAqZXhjZXB0KlxuICogdGhlIFwicG9pbnRzXCIgYW5kIFwicGF0aFwiIHByb3BlcnRpZXMsIHdoaWNoIG11c3QgYmUgbG9hZGVkIG9ubHkgb25jZVxuICogdGhlIGdseXBoJ3MgcGF0aCBpcyBhY3R1YWxseSByZXF1ZXN0ZWQgZm9yIHRleHQgc2hhcGluZy5cbiAqIEBhbGlhcyBvcGVudHlwZS50dGZHbHlwaExvYWRlclxuICogQHBhcmFtICB7b3BlbnR5cGUuRm9udH0gZm9udFxuICogQHBhcmFtICB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtICB7RnVuY3Rpb259IHBhcnNlR2x5cGhcbiAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuICogQHBhcmFtICB7bnVtYmVyfSBwb3NpdGlvblxuICogQHBhcmFtICB7RnVuY3Rpb259IGJ1aWxkUGF0aFxuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gKi9cbmZ1bmN0aW9uIHR0ZkdseXBoTG9hZGVyKGZvbnQsIGluZGV4LCBwYXJzZUdseXBoLCBkYXRhLCBwb3NpdGlvbiwgYnVpbGRQYXRoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ2x5cGggPSBuZXcgR2x5cGgoe2luZGV4OiBpbmRleCwgZm9udDogZm9udH0pO1xuXG4gICAgICAgIGdseXBoLnBhdGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHBhcnNlR2x5cGgoZ2x5cGgsIGRhdGEsIHBvc2l0aW9uKTtcbiAgICAgICAgICAgIHZhciBwYXRoID0gYnVpbGRQYXRoKGZvbnQuZ2x5cGhzLCBnbHlwaCk7XG4gICAgICAgICAgICBwYXRoLnVuaXRzUGVyRW0gPSBmb250LnVuaXRzUGVyRW07XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfTtcblxuICAgICAgICBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgJ3hNaW4nLCAnX3hNaW4nKTtcbiAgICAgICAgZGVmaW5lRGVwZW5kZW50UHJvcGVydHkoZ2x5cGgsICd4TWF4JywgJ194TWF4Jyk7XG4gICAgICAgIGRlZmluZURlcGVuZGVudFByb3BlcnR5KGdseXBoLCAneU1pbicsICdfeU1pbicpO1xuICAgICAgICBkZWZpbmVEZXBlbmRlbnRQcm9wZXJ0eShnbHlwaCwgJ3lNYXgnLCAnX3lNYXgnKTtcblxuICAgICAgICByZXR1cm4gZ2x5cGg7XG4gICAgfTtcbn1cbi8qKlxuICogQGFsaWFzIG9wZW50eXBlLmNmZkdseXBoTG9hZGVyXG4gKiBAcGFyYW0gIHtvcGVudHlwZS5Gb250fSBmb250XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gcGFyc2VDRkZDaGFyc3RyaW5nXG4gKiBAcGFyYW0gIHtzdHJpbmd9IGNoYXJzdHJpbmdcbiAqIEByZXR1cm4ge29wZW50eXBlLkdseXBofVxuICovXG5mdW5jdGlvbiBjZmZHbHlwaExvYWRlcihmb250LCBpbmRleCwgcGFyc2VDRkZDaGFyc3RyaW5nLCBjaGFyc3RyaW5nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ2x5cGggPSBuZXcgR2x5cGgoe2luZGV4OiBpbmRleCwgZm9udDogZm9udH0pO1xuXG4gICAgICAgIGdseXBoLnBhdGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gcGFyc2VDRkZDaGFyc3RyaW5nKGZvbnQsIGdseXBoLCBjaGFyc3RyaW5nKTtcbiAgICAgICAgICAgIHBhdGgudW5pdHNQZXJFbSA9IGZvbnQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBnbHlwaDtcbiAgICB9O1xufVxuXG52YXIgZ2x5cGhzZXQgPSB7IEdseXBoU2V0OiBHbHlwaFNldCwgZ2x5cGhMb2FkZXI6IGdseXBoTG9hZGVyLCB0dGZHbHlwaExvYWRlcjogdHRmR2x5cGhMb2FkZXIsIGNmZkdseXBoTG9hZGVyOiBjZmZHbHlwaExvYWRlciB9O1xuXG4vLyBUaGUgYENGRmAgdGFibGUgY29udGFpbnMgdGhlIGdseXBoIG91dGxpbmVzIGluIFBvc3RTY3JpcHQgZm9ybWF0LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jZmYuaHRtXG4vLyBodHRwOi8vZG93bmxvYWQubWljcm9zb2Z0LmNvbS9kb3dubG9hZC84LzAvMS84MDFhMTkxYy0wMjlkLTRhZjMtOTY0Mi01NTVmNmZlNTE0ZWUvY2ZmLnBkZlxuLy8gaHR0cDovL2Rvd25sb2FkLm1pY3Jvc29mdC5jb20vZG93bmxvYWQvOC8wLzEvODAxYTE5MWMtMDI5ZC00YWYzLTk2NDItNTU1ZjZmZTUxNGVlL3R5cGUyLnBkZlxuXG4vLyBDdXN0b20gZXF1YWxzIGZ1bmN0aW9uIHRoYXQgY2FuIGFsc28gY2hlY2sgbGlzdHMuXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKCFlcXVhbHMoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBTdWJyb3V0aW5lcyBhcmUgZW5jb2RlZCB1c2luZyB0aGUgbmVnYXRpdmUgaGFsZiBvZiB0aGUgbnVtYmVyIHNwYWNlLlxuLy8gU2VlIHR5cGUgMiBjaGFwdGVyIDQuNyBcIlN1YnJvdXRpbmUgb3BlcmF0b3JzXCIuXG5mdW5jdGlvbiBjYWxjQ0ZGU3Vicm91dGluZUJpYXMoc3VicnMpIHtcbiAgICB2YXIgYmlhcztcbiAgICBpZiAoc3VicnMubGVuZ3RoIDwgMTI0MCkge1xuICAgICAgICBiaWFzID0gMTA3O1xuICAgIH0gZWxzZSBpZiAoc3VicnMubGVuZ3RoIDwgMzM5MDApIHtcbiAgICAgICAgYmlhcyA9IDExMzE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYmlhcyA9IDMyNzY4O1xuICAgIH1cblxuICAgIHJldHVybiBiaWFzO1xufVxuXG4vLyBQYXJzZSBhIGBDRkZgIElOREVYIGFycmF5LlxuLy8gQW4gaW5kZXggYXJyYXkgY29uc2lzdHMgb2YgYSBsaXN0IG9mIG9mZnNldHMsIHRoZW4gYSBsaXN0IG9mIG9iamVjdHMgYXQgdGhvc2Ugb2Zmc2V0cy5cbmZ1bmN0aW9uIHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3RhcnQsIGNvbnZlcnNpb25Gbikge1xuICAgIHZhciBvZmZzZXRzID0gW107XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICB2YXIgY291bnQgPSBwYXJzZS5nZXRDYXJkMTYoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBvYmplY3RPZmZzZXQ7XG4gICAgdmFyIGVuZE9mZnNldDtcbiAgICBpZiAoY291bnQgIT09IDApIHtcbiAgICAgICAgdmFyIG9mZnNldFNpemUgPSBwYXJzZS5nZXRCeXRlKGRhdGEsIHN0YXJ0ICsgMik7XG4gICAgICAgIG9iamVjdE9mZnNldCA9IHN0YXJ0ICsgKChjb3VudCArIDEpICogb2Zmc2V0U2l6ZSkgKyAyO1xuICAgICAgICB2YXIgcG9zID0gc3RhcnQgKyAzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ICsgMTsgaSArPSAxKSB7XG4gICAgICAgICAgICBvZmZzZXRzLnB1c2gocGFyc2UuZ2V0T2Zmc2V0KGRhdGEsIHBvcywgb2Zmc2V0U2l6ZSkpO1xuICAgICAgICAgICAgcG9zICs9IG9mZnNldFNpemU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgdG90YWwgc2l6ZSBvZiB0aGUgaW5kZXggYXJyYXkgaXMgNCBoZWFkZXIgYnl0ZXMgKyB0aGUgdmFsdWUgb2YgdGhlIGxhc3Qgb2Zmc2V0LlxuICAgICAgICBlbmRPZmZzZXQgPSBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2NvdW50XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbmRPZmZzZXQgPSBzdGFydCArIDI7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgb2Zmc2V0cy5sZW5ndGggLSAxOyBpJDEgKz0gMSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBwYXJzZS5nZXRCeXRlcyhkYXRhLCBvYmplY3RPZmZzZXQgKyBvZmZzZXRzW2kkMV0sIG9iamVjdE9mZnNldCArIG9mZnNldHNbaSQxICsgMV0pO1xuICAgICAgICBpZiAoY29udmVyc2lvbkZuKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGNvbnZlcnNpb25Gbih2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmplY3RzLnB1c2godmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB7b2JqZWN0czogb2JqZWN0cywgc3RhcnRPZmZzZXQ6IHN0YXJ0LCBlbmRPZmZzZXQ6IGVuZE9mZnNldH07XG59XG5cbi8vIFBhcnNlIGEgYENGRmAgRElDVCByZWFsIHZhbHVlLlxuZnVuY3Rpb24gcGFyc2VGbG9hdE9wZXJhbmQocGFyc2VyKSB7XG4gICAgdmFyIHMgPSAnJztcbiAgICB2YXIgZW9mID0gMTU7XG4gICAgdmFyIGxvb2t1cCA9IFsnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsICcuJywgJ0UnLCAnRS0nLCBudWxsLCAnLSddO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBiID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICB2YXIgbjEgPSBiID4+IDQ7XG4gICAgICAgIHZhciBuMiA9IGIgJiAxNTtcblxuICAgICAgICBpZiAobjEgPT09IGVvZikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzICs9IGxvb2t1cFtuMV07XG5cbiAgICAgICAgaWYgKG4yID09PSBlb2YpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcyArPSBsb29rdXBbbjJdO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUZsb2F0KHMpO1xufVxuXG4vLyBQYXJzZSBhIGBDRkZgIERJQ1Qgb3BlcmFuZC5cbmZ1bmN0aW9uIHBhcnNlT3BlcmFuZChwYXJzZXIsIGIwKSB7XG4gICAgdmFyIGIxO1xuICAgIHZhciBiMjtcbiAgICB2YXIgYjM7XG4gICAgdmFyIGI0O1xuICAgIGlmIChiMCA9PT0gMjgpIHtcbiAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGIyID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICByZXR1cm4gYjEgPDwgOCB8IGIyO1xuICAgIH1cblxuICAgIGlmIChiMCA9PT0gMjkpIHtcbiAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIGIyID0gcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICBiMyA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcbiAgICAgICAgYjQgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIHJldHVybiBiMSA8PCAyNCB8IGIyIDw8IDE2IHwgYjMgPDwgOCB8IGI0O1xuICAgIH1cblxuICAgIGlmIChiMCA9PT0gMzApIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXRPcGVyYW5kKHBhcnNlcik7XG4gICAgfVxuXG4gICAgaWYgKGIwID49IDMyICYmIGIwIDw9IDI0Nikge1xuICAgICAgICByZXR1cm4gYjAgLSAxMzk7XG4gICAgfVxuXG4gICAgaWYgKGIwID49IDI0NyAmJiBiMCA8PSAyNTApIHtcbiAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIHJldHVybiAoYjAgLSAyNDcpICogMjU2ICsgYjEgKyAxMDg7XG4gICAgfVxuXG4gICAgaWYgKGIwID49IDI1MSAmJiBiMCA8PSAyNTQpIHtcbiAgICAgICAgYjEgPSBwYXJzZXIucGFyc2VCeXRlKCk7XG4gICAgICAgIHJldHVybiAtKGIwIC0gMjUxKSAqIDI1NiAtIGIxIC0gMTA4O1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBiMCAnICsgYjApO1xufVxuXG4vLyBDb252ZXJ0IHRoZSBlbnRyaWVzIHJldHVybmVkIGJ5IGBwYXJzZURpY3RgIHRvIGEgcHJvcGVyIGRpY3Rpb25hcnkuXG4vLyBJZiBhIHZhbHVlIGlzIGEgbGlzdCBvZiBvbmUsIGl0IGlzIHVucGFja2VkLlxuZnVuY3Rpb24gZW50cmllc1RvT2JqZWN0KGVudHJpZXMpIHtcbiAgICB2YXIgbyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW50cmllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIga2V5ID0gZW50cmllc1tpXVswXTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGVudHJpZXNbaV1bMV07XG4gICAgICAgIHZhciB2YWx1ZSA9ICh2b2lkIDApO1xuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KGtleSkgJiYgIWlzTmFOKG9ba2V5XSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0ICcgKyBvICsgJyBhbHJlYWR5IGhhcyBrZXkgJyArIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICBvW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbztcbn1cblxuLy8gUGFyc2UgYSBgQ0ZGYCBESUNUIG9iamVjdC5cbi8vIEEgZGljdGlvbmFyeSBjb250YWlucyBrZXktdmFsdWUgcGFpcnMgaW4gYSBjb21wYWN0IHRva2VuaXplZCBmb3JtYXQuXG5mdW5jdGlvbiBwYXJzZUNGRkRpY3QoZGF0YSwgc3RhcnQsIHNpemUpIHtcbiAgICBzdGFydCA9IHN0YXJ0ICE9PSB1bmRlZmluZWQgPyBzdGFydCA6IDA7XG4gICAgdmFyIHBhcnNlciA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBlbnRyaWVzID0gW107XG4gICAgdmFyIG9wZXJhbmRzID0gW107XG4gICAgc2l6ZSA9IHNpemUgIT09IHVuZGVmaW5lZCA/IHNpemUgOiBkYXRhLmxlbmd0aDtcblxuICAgIHdoaWxlIChwYXJzZXIucmVsYXRpdmVPZmZzZXQgPCBzaXplKSB7XG4gICAgICAgIHZhciBvcCA9IHBhcnNlci5wYXJzZUJ5dGUoKTtcblxuICAgICAgICAvLyBUaGUgZmlyc3QgYnl0ZSBmb3IgZWFjaCBkaWN0IGl0ZW0gZGlzdGluZ3Vpc2hlcyBiZXR3ZWVuIG9wZXJhdG9yIChrZXkpIGFuZCBvcGVyYW5kICh2YWx1ZSkuXG4gICAgICAgIC8vIFZhbHVlcyA8PSAyMSBhcmUgb3BlcmF0b3JzLlxuICAgICAgICBpZiAob3AgPD0gMjEpIHtcbiAgICAgICAgICAgIC8vIFR3by1ieXRlIG9wZXJhdG9ycyBoYXZlIGFuIGluaXRpYWwgZXNjYXBlIGJ5dGUgb2YgMTIuXG4gICAgICAgICAgICBpZiAob3AgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgb3AgPSAxMjAwICsgcGFyc2VyLnBhcnNlQnl0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goW29wLCBvcGVyYW5kc10pO1xuICAgICAgICAgICAgb3BlcmFuZHMgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNpbmNlIHRoZSBvcGVyYW5kcyAodmFsdWVzKSBjb21lIGJlZm9yZSB0aGUgb3BlcmF0b3JzIChrZXlzKSwgd2Ugc3RvcmUgYWxsIG9wZXJhbmRzIGluIGEgbGlzdFxuICAgICAgICAgICAgLy8gdW50aWwgd2UgZW5jb3VudGVyIGFuIG9wZXJhdG9yLlxuICAgICAgICAgICAgb3BlcmFuZHMucHVzaChwYXJzZU9wZXJhbmQocGFyc2VyLCBvcCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGVudHJpZXNUb09iamVjdChlbnRyaWVzKTtcbn1cblxuLy8gR2l2ZW4gYSBTdHJpbmcgSW5kZXggKFNJRCksIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHN0cmluZy5cbi8vIFN0cmluZ3MgYmVsb3cgaW5kZXggMzkyIGFyZSBzdGFuZGFyZCBDRkYgc3RyaW5ncyBhbmQgYXJlIG5vdCBlbmNvZGVkIGluIHRoZSBmb250LlxuZnVuY3Rpb24gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4IDw9IDM5MCkge1xuICAgICAgICBpbmRleCA9IGNmZlN0YW5kYXJkU3RyaW5nc1tpbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggPSBzdHJpbmdzW2luZGV4IC0gMzkxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG59XG5cbi8vIEludGVycHJldCBhIGRpY3Rpb25hcnkgYW5kIHJldHVybiBhIG5ldyBkaWN0aW9uYXJ5IHdpdGggcmVhZGFibGUga2V5cyBhbmQgdmFsdWVzIGZvciBtaXNzaW5nIGVudHJpZXMuXG4vLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGBtZXRhYCB3aGljaCBpcyBhIGxpc3Qgb2Ygb2JqZWN0cyBjb250YWluaW5nIGBvcGVyYW5kYCwgYG5hbWVgIGFuZCBgZGVmYXVsdGAuXG5mdW5jdGlvbiBpbnRlcnByZXREaWN0KGRpY3QsIG1ldGEsIHN0cmluZ3MpIHtcbiAgICB2YXIgbmV3RGljdCA9IHt9O1xuICAgIHZhciB2YWx1ZTtcblxuICAgIC8vIEJlY2F1c2Ugd2UgYWxzbyB3YW50IHRvIGluY2x1ZGUgbWlzc2luZyB2YWx1ZXMsIHdlIHN0YXJ0IG91dCBmcm9tIHRoZSBtZXRhIGxpc3RcbiAgICAvLyBhbmQgbG9va3VwIHZhbHVlcyBpbiB0aGUgZGljdC5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIG0gPSBtZXRhW2ldO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG0udHlwZSkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIHZhbHVlcy5sZW5ndGggPSBtLnR5cGUubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtLnR5cGUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRpY3RbbS5vcF0gIT09IHVuZGVmaW5lZCA/IGRpY3RbbS5vcF1bal0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgbS52YWx1ZVtqXSAhPT0gdW5kZWZpbmVkID8gbS52YWx1ZVtqXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtLnR5cGVbal0gPT09ICdTSUQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0Q0ZGU3RyaW5nKHN0cmluZ3MsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWVzW2pdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdEaWN0W20ubmFtZV0gPSB2YWx1ZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGRpY3RbbS5vcF07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbS52YWx1ZSAhPT0gdW5kZWZpbmVkID8gbS52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtLnR5cGUgPT09ICdTSUQnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRDRkZTdHJpbmcoc3RyaW5ncywgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3RGljdFttLm5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RGljdDtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBoZWFkZXIuXG5mdW5jdGlvbiBwYXJzZUNGRkhlYWRlcihkYXRhLCBzdGFydCkge1xuICAgIHZhciBoZWFkZXIgPSB7fTtcbiAgICBoZWFkZXIuZm9ybWF0TWFqb3IgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCk7XG4gICAgaGVhZGVyLmZvcm1hdE1pbm9yID0gcGFyc2UuZ2V0Q2FyZDgoZGF0YSwgc3RhcnQgKyAxKTtcbiAgICBoZWFkZXIuc2l6ZSA9IHBhcnNlLmdldENhcmQ4KGRhdGEsIHN0YXJ0ICsgMik7XG4gICAgaGVhZGVyLm9mZnNldFNpemUgPSBwYXJzZS5nZXRDYXJkOChkYXRhLCBzdGFydCArIDMpO1xuICAgIGhlYWRlci5zdGFydE9mZnNldCA9IHN0YXJ0O1xuICAgIGhlYWRlci5lbmRPZmZzZXQgPSBzdGFydCArIDQ7XG4gICAgcmV0dXJuIGhlYWRlcjtcbn1cblxudmFyIFRPUF9ESUNUX01FVEEgPSBbXG4gICAge25hbWU6ICd2ZXJzaW9uJywgb3A6IDAsIHR5cGU6ICdTSUQnfSxcbiAgICB7bmFtZTogJ25vdGljZScsIG9wOiAxLCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICdjb3B5cmlnaHQnLCBvcDogMTIwMCwgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnZnVsbE5hbWUnLCBvcDogMiwgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnZmFtaWx5TmFtZScsIG9wOiAzLCB0eXBlOiAnU0lEJ30sXG4gICAge25hbWU6ICd3ZWlnaHQnLCBvcDogNCwgdHlwZTogJ1NJRCd9LFxuICAgIHtuYW1lOiAnaXNGaXhlZFBpdGNoJywgb3A6IDEyMDEsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdpdGFsaWNBbmdsZScsIG9wOiAxMjAyLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAndW5kZXJsaW5lUG9zaXRpb24nLCBvcDogMTIwMywgdHlwZTogJ251bWJlcicsIHZhbHVlOiAtMTAwfSxcbiAgICB7bmFtZTogJ3VuZGVybGluZVRoaWNrbmVzcycsIG9wOiAxMjA0LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDUwfSxcbiAgICB7bmFtZTogJ3BhaW50VHlwZScsIG9wOiAxMjA1LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnY2hhcnN0cmluZ1R5cGUnLCBvcDogMTIwNiwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAyfSxcbiAgICB7XG4gICAgICAgIG5hbWU6ICdmb250TWF0cml4JyxcbiAgICAgICAgb3A6IDEyMDcsXG4gICAgICAgIHR5cGU6IFsncmVhbCcsICdyZWFsJywgJ3JlYWwnLCAncmVhbCcsICdyZWFsJywgJ3JlYWwnXSxcbiAgICAgICAgdmFsdWU6IFswLjAwMSwgMCwgMCwgMC4wMDEsIDAsIDBdXG4gICAgfSxcbiAgICB7bmFtZTogJ3VuaXF1ZUlkJywgb3A6IDEzLCB0eXBlOiAnbnVtYmVyJ30sXG4gICAge25hbWU6ICdmb250QkJveCcsIG9wOiA1LCB0eXBlOiBbJ251bWJlcicsICdudW1iZXInLCAnbnVtYmVyJywgJ251bWJlciddLCB2YWx1ZTogWzAsIDAsIDAsIDBdfSxcbiAgICB7bmFtZTogJ3N0cm9rZVdpZHRoJywgb3A6IDEyMDgsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICd4dWlkJywgb3A6IDE0LCB0eXBlOiBbXSwgdmFsdWU6IG51bGx9LFxuICAgIHtuYW1lOiAnY2hhcnNldCcsIG9wOiAxNSwgdHlwZTogJ29mZnNldCcsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2VuY29kaW5nJywgb3A6IDE2LCB0eXBlOiAnb2Zmc2V0JywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnY2hhclN0cmluZ3MnLCBvcDogMTcsIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdwcml2YXRlJywgb3A6IDE4LCB0eXBlOiBbJ251bWJlcicsICdvZmZzZXQnXSwgdmFsdWU6IFswLCAwXX0sXG4gICAge25hbWU6ICdyb3MnLCBvcDogMTIzMCwgdHlwZTogWydTSUQnLCAnU0lEJywgJ251bWJlciddfSxcbiAgICB7bmFtZTogJ2NpZEZvbnRWZXJzaW9uJywgb3A6IDEyMzEsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdjaWRGb250UmV2aXNpb24nLCBvcDogMTIzMiwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfSxcbiAgICB7bmFtZTogJ2NpZEZvbnRUeXBlJywgb3A6IDEyMzMsIHR5cGU6ICdudW1iZXInLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdjaWRDb3VudCcsIG9wOiAxMjM0LCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDg3MjB9LFxuICAgIHtuYW1lOiAndWlkQmFzZScsIG9wOiAxMjM1LCB0eXBlOiAnbnVtYmVyJ30sXG4gICAge25hbWU6ICdmZEFycmF5Jywgb3A6IDEyMzYsIHR5cGU6ICdvZmZzZXQnfSxcbiAgICB7bmFtZTogJ2ZkU2VsZWN0Jywgb3A6IDEyMzcsIHR5cGU6ICdvZmZzZXQnfSxcbiAgICB7bmFtZTogJ2ZvbnROYW1lJywgb3A6IDEyMzgsIHR5cGU6ICdTSUQnfVxuXTtcblxudmFyIFBSSVZBVEVfRElDVF9NRVRBID0gW1xuICAgIHtuYW1lOiAnc3VicnMnLCBvcDogMTksIHR5cGU6ICdvZmZzZXQnLCB2YWx1ZTogMH0sXG4gICAge25hbWU6ICdkZWZhdWx0V2lkdGhYJywgb3A6IDIwLCB0eXBlOiAnbnVtYmVyJywgdmFsdWU6IDB9LFxuICAgIHtuYW1lOiAnbm9taW5hbFdpZHRoWCcsIG9wOiAyMSwgdHlwZTogJ251bWJlcicsIHZhbHVlOiAwfVxuXTtcblxuLy8gUGFyc2UgdGhlIENGRiB0b3AgZGljdGlvbmFyeS4gQSBDRkYgdGFibGUgY2FuIGNvbnRhaW4gbXVsdGlwbGUgZm9udHMsIGVhY2ggd2l0aCB0aGVpciBvd24gdG9wIGRpY3Rpb25hcnkuXG4vLyBUaGUgdG9wIGRpY3Rpb25hcnkgY29udGFpbnMgdGhlIGVzc2VudGlhbCBtZXRhZGF0YSBmb3IgdGhlIGZvbnQsIHRvZ2V0aGVyIHdpdGggdGhlIHByaXZhdGUgZGljdGlvbmFyeS5cbmZ1bmN0aW9uIHBhcnNlQ0ZGVG9wRGljdChkYXRhLCBzdHJpbmdzKSB7XG4gICAgdmFyIGRpY3QgPSBwYXJzZUNGRkRpY3QoZGF0YSwgMCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICByZXR1cm4gaW50ZXJwcmV0RGljdChkaWN0LCBUT1BfRElDVF9NRVRBLCBzdHJpbmdzKTtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBwcml2YXRlIGRpY3Rpb25hcnkuIFdlIGRvbid0IGZ1bGx5IHBhcnNlIG91dCBhbGwgdGhlIHZhbHVlcywgb25seSB0aGUgb25lcyB3ZSBuZWVkLlxuZnVuY3Rpb24gcGFyc2VDRkZQcml2YXRlRGljdChkYXRhLCBzdGFydCwgc2l6ZSwgc3RyaW5ncykge1xuICAgIHZhciBkaWN0ID0gcGFyc2VDRkZEaWN0KGRhdGEsIHN0YXJ0LCBzaXplKTtcbiAgICByZXR1cm4gaW50ZXJwcmV0RGljdChkaWN0LCBQUklWQVRFX0RJQ1RfTUVUQSwgc3RyaW5ncyk7XG59XG5cbi8vIFJldHVybnMgYSBsaXN0IG9mIFwiVG9wIERJQ1RcInMgZm91bmQgdXNpbmcgYW4gSU5ERVggbGlzdC5cbi8vIFVzZWQgdG8gcmVhZCBib3RoIHRoZSB1c3VhbCBoaWdoLWxldmVsIFRvcCBESUNUcyBhbmQgYWxzbyB0aGUgRkRBcnJheVxuLy8gZGlzY292ZXJlZCBpbnNpZGUgQ0lELWtleWVkIGZvbnRzLiAgV2hlbiBhIFRvcCBESUNUIGhhcyBhIHJlZmVyZW5jZSB0b1xuLy8gYSBQcml2YXRlIERJQ1QgdGhhdCBpcyByZWFkIGFuZCBzYXZlZCBpbnRvIHRoZSBUb3AgRElDVC5cbi8vXG4vLyBJbiBhZGRpdGlvbiB0byB0aGUgZXhwZWN0ZWQvb3B0aW9uYWwgdmFsdWVzIGFzIG91dGxpbmVkIGluIFRPUF9ESUNUX01FVEFcbi8vIHRoZSBmb2xsb3dpbmcgdmFsdWVzIG1pZ2h0IGJlIHNhdmVkIGludG8gdGhlIFRvcCBESUNULlxuLy9cbi8vICAgIF9zdWJycyBbXSAgICAgICAgYXJyYXkgb2YgbG9jYWwgQ0ZGIHN1YnJvdXRpbmVzIGZyb20gUHJpdmF0ZSBESUNUXG4vLyAgICBfc3VicnNCaWFzICAgICAgIGJpYXMgdmFsdWUgY29tcHV0ZWQgZnJvbSBudW1iZXIgb2Ygc3Vicm91dGluZXNcbi8vICAgICAgICAgICAgICAgICAgICAgIChzZWUgY2FsY0NGRlN1YnJvdXRpbmVCaWFzKCkgYW5kIHBhcnNlQ0ZGQ2hhcnN0cmluZygpKVxuLy8gICAgX2RlZmF1bHRXaWR0aFggICBkZWZhdWx0IHdpZHRocyBmb3IgQ0ZGIGNoYXJhY3RlcnNcbi8vICAgIF9ub21pbmFsV2lkdGhYICAgYmlhcyBhZGRlZCB0byB3aWR0aCBlbWJlZGRlZCB3aXRoaW4gZ2x5cGggZGVzY3JpcHRpb25cbi8vXG4vLyAgICBfcHJpdmF0ZURpY3QgICAgIHNhdmVkIGNvcHkgb2YgcGFyc2VkIFByaXZhdGUgRElDVCBmcm9tIFRvcCBESUNUXG5mdW5jdGlvbiBnYXRoZXJDRkZUb3BEaWN0cyhkYXRhLCBzdGFydCwgY2ZmSW5kZXgsIHN0cmluZ3MpIHtcbiAgICB2YXIgdG9wRGljdEFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaVRvcERpY3QgPSAwOyBpVG9wRGljdCA8IGNmZkluZGV4Lmxlbmd0aDsgaVRvcERpY3QgKz0gMSkge1xuICAgICAgICB2YXIgdG9wRGljdERhdGEgPSBuZXcgRGF0YVZpZXcobmV3IFVpbnQ4QXJyYXkoY2ZmSW5kZXhbaVRvcERpY3RdKS5idWZmZXIpO1xuICAgICAgICB2YXIgdG9wRGljdCA9IHBhcnNlQ0ZGVG9wRGljdCh0b3BEaWN0RGF0YSwgc3RyaW5ncyk7XG4gICAgICAgIHRvcERpY3QuX3N1YnJzID0gW107XG4gICAgICAgIHRvcERpY3QuX3N1YnJzQmlhcyA9IDA7XG4gICAgICAgIHZhciBwcml2YXRlU2l6ZSA9IHRvcERpY3QucHJpdmF0ZVswXTtcbiAgICAgICAgdmFyIHByaXZhdGVPZmZzZXQgPSB0b3BEaWN0LnByaXZhdGVbMV07XG4gICAgICAgIGlmIChwcml2YXRlU2l6ZSAhPT0gMCAmJiBwcml2YXRlT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgcHJpdmF0ZURpY3QgPSBwYXJzZUNGRlByaXZhdGVEaWN0KGRhdGEsIHByaXZhdGVPZmZzZXQgKyBzdGFydCwgcHJpdmF0ZVNpemUsIHN0cmluZ3MpO1xuICAgICAgICAgICAgdG9wRGljdC5fZGVmYXVsdFdpZHRoWCA9IHByaXZhdGVEaWN0LmRlZmF1bHRXaWR0aFg7XG4gICAgICAgICAgICB0b3BEaWN0Ll9ub21pbmFsV2lkdGhYID0gcHJpdmF0ZURpY3Qubm9taW5hbFdpZHRoWDtcbiAgICAgICAgICAgIGlmIChwcml2YXRlRGljdC5zdWJycyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHZhciBzdWJyT2Zmc2V0ID0gcHJpdmF0ZU9mZnNldCArIHByaXZhdGVEaWN0LnN1YnJzO1xuICAgICAgICAgICAgICAgIHZhciBzdWJySW5kZXggPSBwYXJzZUNGRkluZGV4KGRhdGEsIHN1YnJPZmZzZXQgKyBzdGFydCk7XG4gICAgICAgICAgICAgICAgdG9wRGljdC5fc3VicnMgPSBzdWJySW5kZXgub2JqZWN0cztcbiAgICAgICAgICAgICAgICB0b3BEaWN0Ll9zdWJyc0JpYXMgPSBjYWxjQ0ZGU3Vicm91dGluZUJpYXModG9wRGljdC5fc3VicnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9wRGljdC5fcHJpdmF0ZURpY3QgPSBwcml2YXRlRGljdDtcbiAgICAgICAgfVxuICAgICAgICB0b3BEaWN0QXJyYXkucHVzaCh0b3BEaWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvcERpY3RBcnJheTtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBjaGFyc2V0IHRhYmxlLCB3aGljaCBjb250YWlucyBpbnRlcm5hbCBuYW1lcyBmb3IgYWxsIHRoZSBnbHlwaHMuXG4vLyBUaGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgbGlzdCBvZiBnbHlwaCBuYW1lcy5cbi8vIFNlZSBBZG9iZSBUTiAjNTE3NiBjaGFwdGVyIDEzLCBcIkNoYXJzZXRzXCIuXG5mdW5jdGlvbiBwYXJzZUNGRkNoYXJzZXQoZGF0YSwgc3RhcnQsIG5HbHlwaHMsIHN0cmluZ3MpIHtcbiAgICB2YXIgc2lkO1xuICAgIHZhciBjb3VudDtcbiAgICB2YXIgcGFyc2VyID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG5cbiAgICAvLyBUaGUgLm5vdGRlZiBnbHlwaCBpcyBub3QgaW5jbHVkZWQsIHNvIHN1YnRyYWN0IDEuXG4gICAgbkdseXBocyAtPSAxO1xuICAgIHZhciBjaGFyc2V0ID0gWycubm90ZGVmJ107XG5cbiAgICB2YXIgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkdseXBoczsgaSArPSAxKSB7XG4gICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcbiAgICAgICAgICAgIGNoYXJzZXQucHVzaChnZXRDRkZTdHJpbmcoc3RyaW5ncywgc2lkKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICB3aGlsZSAoY2hhcnNldC5sZW5ndGggPD0gbkdseXBocykge1xuICAgICAgICAgICAgc2lkID0gcGFyc2VyLnBhcnNlU0lEKCk7XG4gICAgICAgICAgICBjb3VudCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPD0gY291bnQ7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgICAgICAgICBzaWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHdoaWxlIChjaGFyc2V0Lmxlbmd0aCA8PSBuR2x5cGhzKSB7XG4gICAgICAgICAgICBzaWQgPSBwYXJzZXIucGFyc2VTSUQoKTtcbiAgICAgICAgICAgIGNvdW50ID0gcGFyc2VyLnBhcnNlQ2FyZDE2KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPD0gY291bnQ7IGkkMiArPSAxKSB7XG4gICAgICAgICAgICAgICAgY2hhcnNldC5wdXNoKGdldENGRlN0cmluZyhzdHJpbmdzLCBzaWQpKTtcbiAgICAgICAgICAgICAgICBzaWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjaGFyc2V0IGZvcm1hdCAnICsgZm9ybWF0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2hhcnNldDtcbn1cblxuLy8gUGFyc2UgdGhlIENGRiBlbmNvZGluZyBkYXRhLiBPbmx5IG9uZSBlbmNvZGluZyBjYW4gYmUgc3BlY2lmaWVkIHBlciBmb250LlxuLy8gU2VlIEFkb2JlIFROICM1MTc2IGNoYXB0ZXIgMTIsIFwiRW5jb2RpbmdzXCIuXG5mdW5jdGlvbiBwYXJzZUNGRkVuY29kaW5nKGRhdGEsIHN0YXJ0LCBjaGFyc2V0KSB7XG4gICAgdmFyIGNvZGU7XG4gICAgdmFyIGVuYyA9IHt9O1xuICAgIHZhciBwYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIHZhciBuQ29kZXMgPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Db2RlczsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb2RlID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIGVuY1tjb2RlXSA9IGk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICB2YXIgblJhbmdlcyA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgIGNvZGUgPSAxO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBuUmFuZ2VzOyBpJDEgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGZpcnN0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIHZhciBuTGVmdCA9IHBhcnNlci5wYXJzZUNhcmQ4KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gZmlyc3Q7IGogPD0gZmlyc3QgKyBuTGVmdDsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgZW5jW2pdID0gY29kZTtcbiAgICAgICAgICAgICAgICBjb2RlICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcgZm9ybWF0ICcgKyBmb3JtYXQpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ2ZmRW5jb2RpbmcoZW5jLCBjaGFyc2V0KTtcbn1cblxuLy8gVGFrZSBpbiBjaGFyc3RyaW5nIGNvZGUgYW5kIHJldHVybiBhIEdseXBoIG9iamVjdC5cbi8vIFRoZSBlbmNvZGluZyBpcyBkZXNjcmliZWQgaW4gdGhlIFR5cGUgMiBDaGFyc3RyaW5nIEZvcm1hdFxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9jaGFyc3RyMi5odG1cbmZ1bmN0aW9uIHBhcnNlQ0ZGQ2hhcnN0cmluZyhmb250LCBnbHlwaCwgY29kZSkge1xuICAgIHZhciBjMXg7XG4gICAgdmFyIGMxeTtcbiAgICB2YXIgYzJ4O1xuICAgIHZhciBjMnk7XG4gICAgdmFyIHAgPSBuZXcgUGF0aCgpO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBuU3RlbXMgPSAwO1xuICAgIHZhciBoYXZlV2lkdGggPSBmYWxzZTtcbiAgICB2YXIgb3BlbiA9IGZhbHNlO1xuICAgIHZhciB4ID0gMDtcbiAgICB2YXIgeSA9IDA7XG4gICAgdmFyIHN1YnJzO1xuICAgIHZhciBzdWJyc0JpYXM7XG4gICAgdmFyIGRlZmF1bHRXaWR0aFg7XG4gICAgdmFyIG5vbWluYWxXaWR0aFg7XG4gICAgaWYgKGZvbnQuaXNDSURGb250KSB7XG4gICAgICAgIHZhciBmZEluZGV4ID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX2ZkU2VsZWN0W2dseXBoLmluZGV4XTtcbiAgICAgICAgdmFyIGZkRGljdCA9IGZvbnQudGFibGVzLmNmZi50b3BEaWN0Ll9mZEFycmF5W2ZkSW5kZXhdO1xuICAgICAgICBzdWJycyA9IGZkRGljdC5fc3VicnM7XG4gICAgICAgIHN1YnJzQmlhcyA9IGZkRGljdC5fc3VicnNCaWFzO1xuICAgICAgICBkZWZhdWx0V2lkdGhYID0gZmREaWN0Ll9kZWZhdWx0V2lkdGhYO1xuICAgICAgICBub21pbmFsV2lkdGhYID0gZmREaWN0Ll9ub21pbmFsV2lkdGhYO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN1YnJzID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX3N1YnJzO1xuICAgICAgICBzdWJyc0JpYXMgPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fc3VicnNCaWFzO1xuICAgICAgICBkZWZhdWx0V2lkdGhYID0gZm9udC50YWJsZXMuY2ZmLnRvcERpY3QuX2RlZmF1bHRXaWR0aFg7XG4gICAgICAgIG5vbWluYWxXaWR0aFggPSBmb250LnRhYmxlcy5jZmYudG9wRGljdC5fbm9taW5hbFdpZHRoWDtcbiAgICB9XG4gICAgdmFyIHdpZHRoID0gZGVmYXVsdFdpZHRoWDtcblxuICAgIGZ1bmN0aW9uIG5ld0NvbnRvdXIoeCwgeSkge1xuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgcC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHAubW92ZVRvKHgsIHkpO1xuICAgICAgICBvcGVuID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVN0ZW1zKCkge1xuICAgICAgICB2YXIgaGFzV2lkdGhBcmc7XG5cbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiBzdGVtIG9wZXJhdG9ycyBvbiB0aGUgc3RhY2sgaXMgYWx3YXlzIGV2ZW4uXG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyB1bmV2ZW4sIHRoYXQgbWVhbnMgYSB3aWR0aCBpcyBzcGVjaWZpZWQuXG4gICAgICAgIGhhc1dpZHRoQXJnID0gc3RhY2subGVuZ3RoICUgMiAhPT0gMDtcbiAgICAgICAgaWYgKGhhc1dpZHRoQXJnICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIG5vbWluYWxXaWR0aFg7XG4gICAgICAgIH1cblxuICAgICAgICBuU3RlbXMgKz0gc3RhY2subGVuZ3RoID4+IDE7XG4gICAgICAgIHN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgIGhhdmVXaWR0aCA9IHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2UkJDEoY29kZSkge1xuICAgICAgICB2YXIgYjE7XG4gICAgICAgIHZhciBiMjtcbiAgICAgICAgdmFyIGIzO1xuICAgICAgICB2YXIgYjQ7XG4gICAgICAgIHZhciBjb2RlSW5kZXg7XG4gICAgICAgIHZhciBzdWJyQ29kZTtcbiAgICAgICAgdmFyIGpweDtcbiAgICAgICAgdmFyIGpweTtcbiAgICAgICAgdmFyIGMzeDtcbiAgICAgICAgdmFyIGMzeTtcbiAgICAgICAgdmFyIGM0eDtcbiAgICAgICAgdmFyIGM0eTtcblxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgY29kZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2ID0gY29kZVtpXTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIHN3aXRjaCAodikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTogLy8gaHN0ZW1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IC8vIHZzdGVtXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3RlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiAvLyB2bW92ZXRvXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAxICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIG5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udG91cih4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA1OiAvLyBybGluZXRvXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNjogLy8gaGxpbmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiAvLyB2bGluZXRvXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDg6IC8vIHJyY3VydmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMDogLy8gY2FsbHN1YnJcbiAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gc3RhY2sucG9wKCkgKyBzdWJyc0JpYXM7XG4gICAgICAgICAgICAgICAgICAgIHN1YnJDb2RlID0gc3VicnNbY29kZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZSQkMShzdWJyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDExOiAvLyByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI6IC8vIGZsZXggb3BlcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgIHYgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNTogLy8gZmxleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwtIGR4MSBkeTEgZHgyIGR5MiBkeDMgZHkzIGR4NCBkeTQgZHg1IGR5NSBkeDYgZHk2IGZkIGZsZXggKDEyIDM1KSB8LVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5MlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpweSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5M1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeCA9IGpweCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMzeSA9IGpweSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eCA9IGMzeCArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGM0eSA9IGMzeSArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjNHggICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR4NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjNHkgICArIHN0YWNrLnNoaWZ0KCk7ICAgIC8vIGR5NlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnNoaWZ0KCk7ICAgICAgICAgICAgICAgIC8vIGZsZXggZGVwdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMzeCwgYzN5LCBjNHgsIGM0eSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM0OiAvLyBoZmxleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwtIGR4MSBkeDIgZHkyIGR4MyBkeDQgZHg1IGR4NiBoZmxleCAoMTIgMzQpIHwtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geTsgICAgICAgICAgICAgICAgICAgICAgLy8gZHkxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB5ID0gYzJ5OyAgICAgICAgICAgICAgICAgICAgLy8gZHkzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0gYzJ5OyAgICAgICAgICAgICAgICAgICAgLy8gZHk0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR4ID0gYzN4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR5ID0geTsgICAgICAgICAgICAgICAgICAgICAgLy8gZHk1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGM0eCArIHN0YWNrLnNoaWZ0KCk7ICAgICAgLy8gZHg2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNjogLy8gaGZsZXgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfC0gZHgxIGR5MSBkeDIgZHkyIGR4MyBkeDQgZHg1IGR5NSBkeDYgaGZsZXgxICgxMiAzNikgfC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICAgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHggPSBjMnggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcHkgPSBjMnk7ICAgICAgICAgICAgICAgICAgICAvLyBkeTNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3ggPSBqcHggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjM3kgPSBjMnk7ICAgICAgICAgICAgICAgICAgICAvLyBkeTRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHggPSBjM3ggKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeDVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjNHkgPSBjM3kgKyBzdGFjay5zaGlmdCgpOyAgICAvLyBkeTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzR4ICsgc3RhY2suc2hpZnQoKTsgICAgICAvLyBkeDZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCBqcHgsIGpweSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMzeCwgYzN5LCBjNHgsIGM0eSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM3OiAvLyBmbGV4MVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHwtIGR4MSBkeTEgZHgyIGR5MiBkeDMgZHkzIGR4NCBkeTQgZHg1IGR5NSBkNiBmbGV4MSAoMTIgMzcpIHwtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSAgICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHgzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHkzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN4ID0ganB4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzN5ID0ganB5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHk0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR4ID0gYzN4ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHg1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYzR5ID0gYzN5ICsgc3RhY2suc2hpZnQoKTsgICAgLy8gZHk1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGM0eCAtIHgpID4gTWF0aC5hYnMoYzR5IC0geSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGM0eCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGM0eSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwganB4LCBqcHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjM3gsIGMzeSwgYzR4LCBjNHksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnR2x5cGggJyArIGdseXBoLmluZGV4ICsgJzogdW5rbm93biBvcGVyYXRvciAnICsgMTIwMCArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDogLy8gZW5kY2hhclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMCAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxODogLy8gaHN0ZW1obVxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTk6IC8vIGhpbnRtYXNrXG4gICAgICAgICAgICAgICAgY2FzZSAyMDogLy8gY250cm1hc2tcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IChuU3RlbXMgKyA3KSA+PiAzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIxOiAvLyBybW92ZXRvXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAyICYmICFoYXZlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gc3RhY2suc2hpZnQoKSArIG5vbWluYWxXaWR0aFg7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXZlV2lkdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgeSArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgeCArPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29udG91cih4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyMjogLy8gaG1vdmV0b1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID4gMSAmJiAhaGF2ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IHN0YWNrLnNoaWZ0KCkgKyBub21pbmFsV2lkdGhYO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGF2ZVdpZHRoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRvdXIoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjM6IC8vIHZzdGVtaG1cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI0OiAvLyByY3VydmVsaW5lXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB4ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjU6IC8vIHJsaW5lY3VydmVcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGMxeSA9IHkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGMyeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI2OiAvLyB2dmN1cnZldG9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggKz0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF5ID0geSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMng7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyNzogLy8gaGhjdXJ2ZXRvXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ICs9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gYzJ4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjg6IC8vIHNob3J0aW50XG4gICAgICAgICAgICAgICAgICAgIGIxID0gY29kZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgYjIgPSBjb2RlW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCgoKGIxIDw8IDI0KSB8IChiMiA8PCAxNikpID4+IDE2KTtcbiAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI5OiAvLyBjYWxsZ3N1YnJcbiAgICAgICAgICAgICAgICAgICAgY29kZUluZGV4ID0gc3RhY2sucG9wKCkgKyBmb250LmdzdWJyc0JpYXM7XG4gICAgICAgICAgICAgICAgICAgIHN1YnJDb2RlID0gZm9udC5nc3VicnNbY29kZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZSQkMShzdWJyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDMwOiAvLyB2aGN1cnZldG9cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBjMXggPSB4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnggPSBjMXggKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ5ID0gYzF5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBjMnkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIChzdGFjay5sZW5ndGggPT09IDEgPyBzdGFjay5zaGlmdCgpIDogMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLmN1cnZlVG8oYzF4LCBjMXksIGMyeCwgYzJ5LCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzE6IC8vIGh2Y3VydmV0b1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYzF4ID0geCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgYzJ4ID0gYzF4ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeSA9IGMxeSArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBjMnggKyAoc3RhY2subGVuZ3RoID09PSAxID8gc3RhY2suc2hpZnQoKSA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5jdXJ2ZVRvKGMxeCwgYzF5LCBjMngsIGMyeSwgeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGMxeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMXkgPSB5ICsgc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMyeCA9IGMxeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjMnkgPSBjMXkgKyBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGMyeCArIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYzJ5ICsgKHN0YWNrLmxlbmd0aCA9PT0gMSA/IHN0YWNrLnNoaWZ0KCkgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAuY3VydmVUbyhjMXgsIGMxeSwgYzJ4LCBjMnksIHgsIHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgPCAzMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0dseXBoICcgKyBnbHlwaC5pbmRleCArICc6IHVua25vd24gb3BlcmF0b3IgJyArIHYpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYgPCAyNDcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godiAtIDEzOSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodiA8IDI1MSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCgodiAtIDI0NykgKiAyNTYgKyBiMSArIDEwOCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodiA8IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCgtKHYgLSAyNTEpICogMjU2IC0gYjEgLSAxMDgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYjEgPSBjb2RlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYjIgPSBjb2RlW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIzID0gY29kZVtpICsgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBiNCA9IGNvZGVbaSArIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCgoKGIxIDw8IDI0KSB8IChiMiA8PCAxNikgfCAoYjMgPDwgOCkgfCBiNCkgLyA2NTUzNik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhcnNlJCQxKGNvZGUpO1xuXG4gICAgZ2x5cGguYWR2YW5jZVdpZHRoID0gd2lkdGg7XG4gICAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ0ZGRkRTZWxlY3QoZGF0YSwgc3RhcnQsIG5HbHlwaHMsIGZkQXJyYXlDb3VudCkge1xuICAgIHZhciBmZFNlbGVjdCA9IFtdO1xuICAgIHZhciBmZEluZGV4O1xuICAgIHZhciBwYXJzZXIgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgZm9ybWF0ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICBpZiAoZm9ybWF0ID09PSAwKSB7XG4gICAgICAgIC8vIFNpbXBsZSBsaXN0IG9mIG5HbHlwaHMgZWxlbWVudHNcbiAgICAgICAgZm9yICh2YXIgaUdpZCA9IDA7IGlHaWQgPCBuR2x5cGhzOyBpR2lkKyspIHtcbiAgICAgICAgICAgIGZkSW5kZXggPSBwYXJzZXIucGFyc2VDYXJkOCgpO1xuICAgICAgICAgICAgaWYgKGZkSW5kZXggPj0gZmRBcnJheUNvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDRkYgdGFibGUgQ0lEIEZvbnQgRkRTZWxlY3QgaGFzIGJhZCBGRCBpbmRleCB2YWx1ZSAnICsgZmRJbmRleCArICcgKEZEIGNvdW50ICcgKyBmZEFycmF5Q291bnQgKyAnKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmRTZWxlY3QucHVzaChmZEluZGV4KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAzKSB7XG4gICAgICAgIC8vIFJhbmdlc1xuICAgICAgICB2YXIgblJhbmdlcyA9IHBhcnNlci5wYXJzZUNhcmQxNigpO1xuICAgICAgICB2YXIgZmlyc3QgPSBwYXJzZXIucGFyc2VDYXJkMTYoKTtcbiAgICAgICAgaWYgKGZpcnN0ICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCBmb3JtYXQgMyByYW5nZSBoYXMgYmFkIGluaXRpYWwgR0lEICcgKyBmaXJzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIGZvciAodmFyIGlSYW5nZSA9IDA7IGlSYW5nZSA8IG5SYW5nZXM7IGlSYW5nZSsrKSB7XG4gICAgICAgICAgICBmZEluZGV4ID0gcGFyc2VyLnBhcnNlQ2FyZDgoKTtcbiAgICAgICAgICAgIG5leHQgPSBwYXJzZXIucGFyc2VDYXJkMTYoKTtcbiAgICAgICAgICAgIGlmIChmZEluZGV4ID49IGZkQXJyYXlDb3VudCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIHRhYmxlIENJRCBGb250IEZEU2VsZWN0IGhhcyBiYWQgRkQgaW5kZXggdmFsdWUgJyArIGZkSW5kZXggKyAnIChGRCBjb3VudCAnICsgZmRBcnJheUNvdW50ICsgJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ID4gbkdseXBocykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIFRhYmxlIENJRCBGb250IEZEU2VsZWN0IGZvcm1hdCAzIHJhbmdlIGhhcyBiYWQgR0lEICcgKyBuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOyBmaXJzdCA8IG5leHQ7IGZpcnN0KyspIHtcbiAgICAgICAgICAgICAgICBmZFNlbGVjdC5wdXNoKGZkSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlyc3QgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0ICE9PSBuR2x5cGhzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCBmb3JtYXQgMyByYW5nZSBoYXMgYmFkIGZpbmFsIEdJRCAnICsgbmV4dCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NGRiBUYWJsZSBDSUQgRm9udCBGRFNlbGVjdCB0YWJsZSBoYXMgdW5zdXBwb3J0ZWQgZm9ybWF0ICcgKyBmb3JtYXQpO1xuICAgIH1cbiAgICByZXR1cm4gZmRTZWxlY3Q7XG59XG5cbi8vIFBhcnNlIHRoZSBgQ0ZGYCB0YWJsZSwgd2hpY2ggY29udGFpbnMgdGhlIGdseXBoIG91dGxpbmVzIGluIFBvc3RTY3JpcHQgZm9ybWF0LlxuZnVuY3Rpb24gcGFyc2VDRkZUYWJsZShkYXRhLCBzdGFydCwgZm9udCkge1xuICAgIGZvbnQudGFibGVzLmNmZiA9IHt9O1xuICAgIHZhciBoZWFkZXIgPSBwYXJzZUNGRkhlYWRlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIG5hbWVJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgaGVhZGVyLmVuZE9mZnNldCwgcGFyc2UuYnl0ZXNUb1N0cmluZyk7XG4gICAgdmFyIHRvcERpY3RJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgbmFtZUluZGV4LmVuZE9mZnNldCk7XG4gICAgdmFyIHN0cmluZ0luZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCB0b3BEaWN0SW5kZXguZW5kT2Zmc2V0LCBwYXJzZS5ieXRlc1RvU3RyaW5nKTtcbiAgICB2YXIgZ2xvYmFsU3VickluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdHJpbmdJbmRleC5lbmRPZmZzZXQpO1xuICAgIGZvbnQuZ3N1YnJzID0gZ2xvYmFsU3VickluZGV4Lm9iamVjdHM7XG4gICAgZm9udC5nc3VicnNCaWFzID0gY2FsY0NGRlN1YnJvdXRpbmVCaWFzKGZvbnQuZ3N1YnJzKTtcblxuICAgIHZhciB0b3BEaWN0QXJyYXkgPSBnYXRoZXJDRkZUb3BEaWN0cyhkYXRhLCBzdGFydCwgdG9wRGljdEluZGV4Lm9iamVjdHMsIHN0cmluZ0luZGV4Lm9iamVjdHMpO1xuICAgIGlmICh0b3BEaWN0QXJyYXkubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ0ZGIHRhYmxlIGhhcyB0b28gbWFueSBmb250cyBpbiBcXCdGb250U2V0XFwnIC0gY291bnQgb2YgZm9udHMgTmFtZUluZGV4Lmxlbmd0aCA9ICcgKyB0b3BEaWN0QXJyYXkubGVuZ3RoKTtcbiAgICB9XG5cbiAgICB2YXIgdG9wRGljdCA9IHRvcERpY3RBcnJheVswXTtcbiAgICBmb250LnRhYmxlcy5jZmYudG9wRGljdCA9IHRvcERpY3Q7XG5cbiAgICBpZiAodG9wRGljdC5fcHJpdmF0ZURpY3QpIHtcbiAgICAgICAgZm9udC5kZWZhdWx0V2lkdGhYID0gdG9wRGljdC5fcHJpdmF0ZURpY3QuZGVmYXVsdFdpZHRoWDtcbiAgICAgICAgZm9udC5ub21pbmFsV2lkdGhYID0gdG9wRGljdC5fcHJpdmF0ZURpY3Qubm9taW5hbFdpZHRoWDtcbiAgICB9XG5cbiAgICBpZiAodG9wRGljdC5yb3NbMF0gIT09IHVuZGVmaW5lZCAmJiB0b3BEaWN0LnJvc1sxXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvbnQuaXNDSURGb250ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZm9udC5pc0NJREZvbnQpIHtcbiAgICAgICAgdmFyIGZkQXJyYXlPZmZzZXQgPSB0b3BEaWN0LmZkQXJyYXk7XG4gICAgICAgIHZhciBmZFNlbGVjdE9mZnNldCA9IHRvcERpY3QuZmRTZWxlY3Q7XG4gICAgICAgIGlmIChmZEFycmF5T2Zmc2V0ID09PSAwIHx8IGZkU2VsZWN0T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvbnQgaXMgbWFya2VkIGFzIGEgQ0lEIGZvbnQsIGJ1dCBGREFycmF5IGFuZC9vciBGRFNlbGVjdCBpbmZvcm1hdGlvbiBpcyBtaXNzaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgZmRBcnJheU9mZnNldCArPSBzdGFydDtcbiAgICAgICAgdmFyIGZkQXJyYXlJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgZmRBcnJheU9mZnNldCk7XG4gICAgICAgIHZhciBmZEFycmF5ID0gZ2F0aGVyQ0ZGVG9wRGljdHMoZGF0YSwgc3RhcnQsIGZkQXJyYXlJbmRleC5vYmplY3RzLCBzdHJpbmdJbmRleC5vYmplY3RzKTtcbiAgICAgICAgdG9wRGljdC5fZmRBcnJheSA9IGZkQXJyYXk7XG4gICAgICAgIGZkU2VsZWN0T2Zmc2V0ICs9IHN0YXJ0O1xuICAgICAgICB0b3BEaWN0Ll9mZFNlbGVjdCA9IHBhcnNlQ0ZGRkRTZWxlY3QoZGF0YSwgZmRTZWxlY3RPZmZzZXQsIGZvbnQubnVtR2x5cGhzLCBmZEFycmF5Lmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIHByaXZhdGVEaWN0T2Zmc2V0ID0gc3RhcnQgKyB0b3BEaWN0LnByaXZhdGVbMV07XG4gICAgdmFyIHByaXZhdGVEaWN0ID0gcGFyc2VDRkZQcml2YXRlRGljdChkYXRhLCBwcml2YXRlRGljdE9mZnNldCwgdG9wRGljdC5wcml2YXRlWzBdLCBzdHJpbmdJbmRleC5vYmplY3RzKTtcbiAgICBmb250LmRlZmF1bHRXaWR0aFggPSBwcml2YXRlRGljdC5kZWZhdWx0V2lkdGhYO1xuICAgIGZvbnQubm9taW5hbFdpZHRoWCA9IHByaXZhdGVEaWN0Lm5vbWluYWxXaWR0aFg7XG5cbiAgICBpZiAocHJpdmF0ZURpY3Quc3VicnMgIT09IDApIHtcbiAgICAgICAgdmFyIHN1YnJPZmZzZXQgPSBwcml2YXRlRGljdE9mZnNldCArIHByaXZhdGVEaWN0LnN1YnJzO1xuICAgICAgICB2YXIgc3VickluZGV4ID0gcGFyc2VDRkZJbmRleChkYXRhLCBzdWJyT2Zmc2V0KTtcbiAgICAgICAgZm9udC5zdWJycyA9IHN1YnJJbmRleC5vYmplY3RzO1xuICAgICAgICBmb250LnN1YnJzQmlhcyA9IGNhbGNDRkZTdWJyb3V0aW5lQmlhcyhmb250LnN1YnJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250LnN1YnJzID0gW107XG4gICAgICAgIGZvbnQuc3VicnNCaWFzID0gMDtcbiAgICB9XG5cbiAgICAvLyBPZmZzZXRzIGluIHRoZSB0b3AgZGljdCBhcmUgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgQ0ZGIGRhdGEsIHNvIGFkZCB0aGUgQ0ZGIHN0YXJ0IG9mZnNldC5cbiAgICB2YXIgY2hhclN0cmluZ3NJbmRleCA9IHBhcnNlQ0ZGSW5kZXgoZGF0YSwgc3RhcnQgKyB0b3BEaWN0LmNoYXJTdHJpbmdzKTtcbiAgICBmb250Lm5HbHlwaHMgPSBjaGFyU3RyaW5nc0luZGV4Lm9iamVjdHMubGVuZ3RoO1xuXG4gICAgdmFyIGNoYXJzZXQgPSBwYXJzZUNGRkNoYXJzZXQoZGF0YSwgc3RhcnQgKyB0b3BEaWN0LmNoYXJzZXQsIGZvbnQubkdseXBocywgc3RyaW5nSW5kZXgub2JqZWN0cyk7XG4gICAgaWYgKHRvcERpY3QuZW5jb2RpbmcgPT09IDApIHtcbiAgICAgICAgLy8gU3RhbmRhcmQgZW5jb2RpbmdcbiAgICAgICAgZm9udC5jZmZFbmNvZGluZyA9IG5ldyBDZmZFbmNvZGluZyhjZmZTdGFuZGFyZEVuY29kaW5nLCBjaGFyc2V0KTtcbiAgICB9IGVsc2UgaWYgKHRvcERpY3QuZW5jb2RpbmcgPT09IDEpIHtcbiAgICAgICAgLy8gRXhwZXJ0IGVuY29kaW5nXG4gICAgICAgIGZvbnQuY2ZmRW5jb2RpbmcgPSBuZXcgQ2ZmRW5jb2RpbmcoY2ZmRXhwZXJ0RW5jb2RpbmcsIGNoYXJzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvbnQuY2ZmRW5jb2RpbmcgPSBwYXJzZUNGRkVuY29kaW5nKGRhdGEsIHN0YXJ0ICsgdG9wRGljdC5lbmNvZGluZywgY2hhcnNldCk7XG4gICAgfVxuXG4gICAgLy8gUHJlZmVyIHRoZSBDTUFQIGVuY29kaW5nIHRvIHRoZSBDRkYgZW5jb2RpbmcuXG4gICAgZm9udC5lbmNvZGluZyA9IGZvbnQuZW5jb2RpbmcgfHwgZm9udC5jZmZFbmNvZGluZztcblxuICAgIGZvbnQuZ2x5cGhzID0gbmV3IGdseXBoc2V0LkdseXBoU2V0KGZvbnQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZm9udC5uR2x5cGhzOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNoYXJTdHJpbmcgPSBjaGFyU3RyaW5nc0luZGV4Lm9iamVjdHNbaV07XG4gICAgICAgIGZvbnQuZ2x5cGhzLnB1c2goaSwgZ2x5cGhzZXQuY2ZmR2x5cGhMb2FkZXIoZm9udCwgaSwgcGFyc2VDRkZDaGFyc3RyaW5nLCBjaGFyU3RyaW5nKSk7XG4gICAgfVxufVxuXG4vLyBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgU3RyaW5nIElEIChTSUQpLlxuLy8gVGhlIGxpc3Qgb2Ygc3RyaW5ncyBpcyBtb2RpZmllZCBpbiBwbGFjZS5cbmZ1bmN0aW9uIGVuY29kZVN0cmluZyhzLCBzdHJpbmdzKSB7XG4gICAgdmFyIHNpZDtcblxuICAgIC8vIElzIHRoZSBzdHJpbmcgaW4gdGhlIENGRiBzdGFuZGFyZCBzdHJpbmdzP1xuICAgIHZhciBpID0gY2ZmU3RhbmRhcmRTdHJpbmdzLmluZGV4T2Yocyk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgICBzaWQgPSBpO1xuICAgIH1cblxuICAgIC8vIElzIHRoZSBzdHJpbmcgYWxyZWFkeSBpbiB0aGUgc3RyaW5nIGluZGV4P1xuICAgIGkgPSBzdHJpbmdzLmluZGV4T2Yocyk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgICBzaWQgPSBpICsgY2ZmU3RhbmRhcmRTdHJpbmdzLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaWQgPSBjZmZTdGFuZGFyZFN0cmluZ3MubGVuZ3RoICsgc3RyaW5ncy5sZW5ndGg7XG4gICAgICAgIHN0cmluZ3MucHVzaChzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2lkO1xufVxuXG5mdW5jdGlvbiBtYWtlSGVhZGVyKCkge1xuICAgIHJldHVybiBuZXcgdGFibGUuUmVjb3JkKCdIZWFkZXInLCBbXG4gICAgICAgIHtuYW1lOiAnbWFqb3InLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogMX0sXG4gICAgICAgIHtuYW1lOiAnbWlub3InLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnaGRyU2l6ZScsIHR5cGU6ICdDYXJkOCcsIHZhbHVlOiA0fSxcbiAgICAgICAge25hbWU6ICdtYWpvcicsIHR5cGU6ICdDYXJkOCcsIHZhbHVlOiAxfVxuICAgIF0pO1xufVxuXG5mdW5jdGlvbiBtYWtlTmFtZUluZGV4KGZvbnROYW1lcykge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlJlY29yZCgnTmFtZSBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICduYW1lcycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbiAgICB0Lm5hbWVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb250TmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdC5uYW1lcy5wdXNoKHtuYW1lOiAnbmFtZV8nICsgaSwgdHlwZTogJ05BTUUnLCB2YWx1ZTogZm9udE5hbWVzW2ldfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG59XG5cbi8vIEdpdmVuIGEgZGljdGlvbmFyeSdzIG1ldGFkYXRhLCBjcmVhdGUgYSBESUNUIHN0cnVjdHVyZS5cbmZ1bmN0aW9uIG1ha2VEaWN0KG1ldGEsIGF0dHJzLCBzdHJpbmdzKSB7XG4gICAgdmFyIG0gPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gbWV0YVtpXTtcbiAgICAgICAgdmFyIHZhbHVlID0gYXR0cnNbZW50cnkubmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcXVhbHModmFsdWUsIGVudHJ5LnZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdTSUQnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlbmNvZGVTdHJpbmcodmFsdWUsIHN0cmluZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtW2VudHJ5Lm9wXSA9IHtuYW1lOiBlbnRyeS5uYW1lLCB0eXBlOiBlbnRyeS50eXBlLCB2YWx1ZTogdmFsdWV9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIFRoZSBUb3AgRElDVCBob3VzZXMgdGhlIGdsb2JhbCBmb250IGF0dHJpYnV0ZXMuXG5mdW5jdGlvbiBtYWtlVG9wRGljdChhdHRycywgc3RyaW5ncykge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlJlY29yZCgnVG9wIERJQ1QnLCBbXG4gICAgICAgIHtuYW1lOiAnZGljdCcsIHR5cGU6ICdESUNUJywgdmFsdWU6IHt9fVxuICAgIF0pO1xuICAgIHQuZGljdCA9IG1ha2VEaWN0KFRPUF9ESUNUX01FVEEsIGF0dHJzLCBzdHJpbmdzKTtcbiAgICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbWFrZVRvcERpY3RJbmRleCh0b3BEaWN0KSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuUmVjb3JkKCdUb3AgRElDVCBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICd0b3BEaWN0cycsIHR5cGU6ICdJTkRFWCcsIHZhbHVlOiBbXX1cbiAgICBdKTtcbiAgICB0LnRvcERpY3RzID0gW3tuYW1lOiAndG9wRGljdF8wJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IHRvcERpY3R9XTtcbiAgICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbWFrZVN0cmluZ0luZGV4KHN0cmluZ3MpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5SZWNvcmQoJ1N0cmluZyBJTkRFWCcsIFtcbiAgICAgICAge25hbWU6ICdzdHJpbmdzJywgdHlwZTogJ0lOREVYJywgdmFsdWU6IFtdfVxuICAgIF0pO1xuICAgIHQuc3RyaW5ncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5ncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB0LnN0cmluZ3MucHVzaCh7bmFtZTogJ3N0cmluZ18nICsgaSwgdHlwZTogJ1NUUklORycsIHZhbHVlOiBzdHJpbmdzW2ldfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VHbG9iYWxTdWJySW5kZXgoKSB7XG4gICAgLy8gQ3VycmVudGx5IHdlIGRvbid0IHVzZSBzdWJyb3V0aW5lcy5cbiAgICByZXR1cm4gbmV3IHRhYmxlLlJlY29yZCgnR2xvYmFsIFN1YnIgSU5ERVgnLCBbXG4gICAgICAgIHtuYW1lOiAnc3VicnMnLCB0eXBlOiAnSU5ERVgnLCB2YWx1ZTogW119XG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VDaGFyc2V0cyhnbHlwaE5hbWVzLCBzdHJpbmdzKSB7XG4gICAgdmFyIHQgPSBuZXcgdGFibGUuUmVjb3JkKCdDaGFyc2V0cycsIFtcbiAgICAgICAge25hbWU6ICdmb3JtYXQnLCB0eXBlOiAnQ2FyZDgnLCB2YWx1ZTogMH1cbiAgICBdKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdseXBoTmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoTmFtZSA9IGdseXBoTmFtZXNbaV07XG4gICAgICAgIHZhciBnbHlwaFNJRCA9IGVuY29kZVN0cmluZyhnbHlwaE5hbWUsIHN0cmluZ3MpO1xuICAgICAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAnZ2x5cGhfJyArIGksIHR5cGU6ICdTSUQnLCB2YWx1ZTogZ2x5cGhTSUR9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gZ2x5cGhUb09wcyhnbHlwaCkge1xuICAgIHZhciBvcHMgPSBbXTtcbiAgICB2YXIgcGF0aCA9IGdseXBoLnBhdGg7XG4gICAgb3BzLnB1c2goe25hbWU6ICd3aWR0aCcsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZ2x5cGguYWR2YW5jZVdpZHRofSk7XG4gICAgdmFyIHggPSAwO1xuICAgIHZhciB5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGguY29tbWFuZHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGR4ID0gKHZvaWQgMCk7XG4gICAgICAgIHZhciBkeSA9ICh2b2lkIDApO1xuICAgICAgICB2YXIgY21kID0gcGF0aC5jb21tYW5kc1tpXTtcbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnUScpIHtcbiAgICAgICAgICAgIC8vIENGRiBvbmx5IHN1cHBvcnRzIGLDqXppZXIgY3VydmVzLCBzbyBjb252ZXJ0IHRoZSBxdWFkIHRvIGEgYsOpemllci5cbiAgICAgICAgICAgIHZhciBfMTMgPSAxIC8gMztcbiAgICAgICAgICAgIHZhciBfMjMgPSAyIC8gMztcblxuICAgICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gY3JlYXRlIGEgbmV3IGNvbW1hbmQgc28gd2UgZG9uJ3QgY2hhbmdlIHRoZSBvcmlnaW5hbCBwYXRoLlxuICAgICAgICAgICAgY21kID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdDJyxcbiAgICAgICAgICAgICAgICB4OiBjbWQueCxcbiAgICAgICAgICAgICAgICB5OiBjbWQueSxcbiAgICAgICAgICAgICAgICB4MTogXzEzICogeCArIF8yMyAqIGNtZC54MSxcbiAgICAgICAgICAgICAgICB5MTogXzEzICogeSArIF8yMyAqIGNtZC55MSxcbiAgICAgICAgICAgICAgICB4MjogXzEzICogY21kLnggKyBfMjMgKiBjbWQueDEsXG4gICAgICAgICAgICAgICAgeTI6IF8xMyAqIGNtZC55ICsgXzIzICogY21kLnkxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNtZC50eXBlID09PSAnTScpIHtcbiAgICAgICAgICAgIGR4ID0gTWF0aC5yb3VuZChjbWQueCAtIHgpO1xuICAgICAgICAgICAgZHkgPSBNYXRoLnJvdW5kKGNtZC55IC0geSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R4JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeH0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeScsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHl9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAncm1vdmV0bycsIHR5cGU6ICdPUCcsIHZhbHVlOiAyMX0pO1xuICAgICAgICAgICAgeCA9IE1hdGgucm91bmQoY21kLngpO1xuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQoY21kLnkpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZC50eXBlID09PSAnTCcpIHtcbiAgICAgICAgICAgIGR4ID0gTWF0aC5yb3VuZChjbWQueCAtIHgpO1xuICAgICAgICAgICAgZHkgPSBNYXRoLnJvdW5kKGNtZC55IC0geSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R4JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeH0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeScsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHl9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAncmxpbmV0bycsIHR5cGU6ICdPUCcsIHZhbHVlOiA1fSk7XG4gICAgICAgICAgICB4ID0gTWF0aC5yb3VuZChjbWQueCk7XG4gICAgICAgICAgICB5ID0gTWF0aC5yb3VuZChjbWQueSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY21kLnR5cGUgPT09ICdDJykge1xuICAgICAgICAgICAgdmFyIGR4MSA9IE1hdGgucm91bmQoY21kLngxIC0geCk7XG4gICAgICAgICAgICB2YXIgZHkxID0gTWF0aC5yb3VuZChjbWQueTEgLSB5KTtcbiAgICAgICAgICAgIHZhciBkeDIgPSBNYXRoLnJvdW5kKGNtZC54MiAtIGNtZC54MSk7XG4gICAgICAgICAgICB2YXIgZHkyID0gTWF0aC5yb3VuZChjbWQueTIgLSBjbWQueTEpO1xuICAgICAgICAgICAgZHggPSBNYXRoLnJvdW5kKGNtZC54IC0gY21kLngyKTtcbiAgICAgICAgICAgIGR5ID0gTWF0aC5yb3VuZChjbWQueSAtIGNtZC55Mik7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R4MScsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHgxfSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5MScsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHkxfSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R4MicsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHgyfSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R5MicsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHkyfSk7XG4gICAgICAgICAgICBvcHMucHVzaCh7bmFtZTogJ2R4JywgdHlwZTogJ05VTUJFUicsIHZhbHVlOiBkeH0pO1xuICAgICAgICAgICAgb3BzLnB1c2goe25hbWU6ICdkeScsIHR5cGU6ICdOVU1CRVInLCB2YWx1ZTogZHl9KTtcbiAgICAgICAgICAgIG9wcy5wdXNoKHtuYW1lOiAncnJjdXJ2ZXRvJywgdHlwZTogJ09QJywgdmFsdWU6IDh9KTtcbiAgICAgICAgICAgIHggPSBNYXRoLnJvdW5kKGNtZC54KTtcbiAgICAgICAgICAgIHkgPSBNYXRoLnJvdW5kKGNtZC55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnRvdXJzIGFyZSBjbG9zZWQgYXV0b21hdGljYWxseS5cbiAgICB9XG5cbiAgICBvcHMucHVzaCh7bmFtZTogJ2VuZGNoYXInLCB0eXBlOiAnT1AnLCB2YWx1ZTogMTR9KTtcbiAgICByZXR1cm4gb3BzO1xufVxuXG5mdW5jdGlvbiBtYWtlQ2hhclN0cmluZ3NJbmRleChnbHlwaHMpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5SZWNvcmQoJ0NoYXJTdHJpbmdzIElOREVYJywgW1xuICAgICAgICB7bmFtZTogJ2NoYXJTdHJpbmdzJywgdHlwZTogJ0lOREVYJywgdmFsdWU6IFtdfVxuICAgIF0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzLmdldChpKTtcbiAgICAgICAgdmFyIG9wcyA9IGdseXBoVG9PcHMoZ2x5cGgpO1xuICAgICAgICB0LmNoYXJTdHJpbmdzLnB1c2goe25hbWU6IGdseXBoLm5hbWUsIHR5cGU6ICdDSEFSU1RSSU5HJywgdmFsdWU6IG9wc30pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBtYWtlUHJpdmF0ZURpY3QoYXR0cnMsIHN0cmluZ3MpIHtcbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5SZWNvcmQoJ1ByaXZhdGUgRElDVCcsIFtcbiAgICAgICAge25hbWU6ICdkaWN0JywgdHlwZTogJ0RJQ1QnLCB2YWx1ZToge319XG4gICAgXSk7XG4gICAgdC5kaWN0ID0gbWFrZURpY3QoUFJJVkFURV9ESUNUX01FVEEsIGF0dHJzLCBzdHJpbmdzKTtcbiAgICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gbWFrZUNGRlRhYmxlKGdseXBocywgb3B0aW9ucykge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdDRkYgJywgW1xuICAgICAgICB7bmFtZTogJ2hlYWRlcicsIHR5cGU6ICdSRUNPUkQnfSxcbiAgICAgICAge25hbWU6ICduYW1lSW5kZXgnLCB0eXBlOiAnUkVDT1JEJ30sXG4gICAgICAgIHtuYW1lOiAndG9wRGljdEluZGV4JywgdHlwZTogJ1JFQ09SRCd9LFxuICAgICAgICB7bmFtZTogJ3N0cmluZ0luZGV4JywgdHlwZTogJ1JFQ09SRCd9LFxuICAgICAgICB7bmFtZTogJ2dsb2JhbFN1YnJJbmRleCcsIHR5cGU6ICdSRUNPUkQnfSxcbiAgICAgICAge25hbWU6ICdjaGFyc2V0cycsIHR5cGU6ICdSRUNPUkQnfSxcbiAgICAgICAge25hbWU6ICdjaGFyU3RyaW5nc0luZGV4JywgdHlwZTogJ1JFQ09SRCd9LFxuICAgICAgICB7bmFtZTogJ3ByaXZhdGVEaWN0JywgdHlwZTogJ1JFQ09SRCd9XG4gICAgXSk7XG5cbiAgICB2YXIgZm9udFNjYWxlID0gMSAvIG9wdGlvbnMudW5pdHNQZXJFbTtcbiAgICAvLyBXZSB1c2Ugbm9uLXplcm8gdmFsdWVzIGZvciB0aGUgb2Zmc2V0cyBzbyB0aGF0IHRoZSBESUNUIGVuY29kZXMgdGhlbS5cbiAgICAvLyBUaGlzIGlzIGltcG9ydGFudCBiZWNhdXNlIHRoZSBzaXplIG9mIHRoZSBUb3AgRElDVCBwbGF5cyBhIHJvbGUgaW4gb2Zmc2V0IGNhbGN1bGF0aW9uLFxuICAgIC8vIGFuZCB0aGUgc2l6ZSBzaG91bGRuJ3QgY2hhbmdlIGFmdGVyIHdlJ3ZlIHdyaXR0ZW4gY29ycmVjdCBvZmZzZXRzLlxuICAgIHZhciBhdHRycyA9IHtcbiAgICAgICAgdmVyc2lvbjogb3B0aW9ucy52ZXJzaW9uLFxuICAgICAgICBmdWxsTmFtZTogb3B0aW9ucy5mdWxsTmFtZSxcbiAgICAgICAgZmFtaWx5TmFtZTogb3B0aW9ucy5mYW1pbHlOYW1lLFxuICAgICAgICB3ZWlnaHQ6IG9wdGlvbnMud2VpZ2h0TmFtZSxcbiAgICAgICAgZm9udEJCb3g6IG9wdGlvbnMuZm9udEJCb3ggfHwgWzAsIDAsIDAsIDBdLFxuICAgICAgICBmb250TWF0cml4OiBbZm9udFNjYWxlLCAwLCAwLCBmb250U2NhbGUsIDAsIDBdLFxuICAgICAgICBjaGFyc2V0OiA5OTksXG4gICAgICAgIGVuY29kaW5nOiAwLFxuICAgICAgICBjaGFyU3RyaW5nczogOTk5LFxuICAgICAgICBwcml2YXRlOiBbMCwgOTk5XVxuICAgIH07XG5cbiAgICB2YXIgcHJpdmF0ZUF0dHJzID0ge307XG5cbiAgICB2YXIgZ2x5cGhOYW1lcyA9IFtdO1xuICAgIHZhciBnbHlwaDtcblxuICAgIC8vIFNraXAgZmlyc3QgZ2x5cGggKC5ub3RkZWYpXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBnbHlwaHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZ2x5cGggPSBnbHlwaHMuZ2V0KGkpO1xuICAgICAgICBnbHlwaE5hbWVzLnB1c2goZ2x5cGgubmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHN0cmluZ3MgPSBbXTtcblxuICAgIHQuaGVhZGVyID0gbWFrZUhlYWRlcigpO1xuICAgIHQubmFtZUluZGV4ID0gbWFrZU5hbWVJbmRleChbb3B0aW9ucy5wb3N0U2NyaXB0TmFtZV0pO1xuICAgIHZhciB0b3BEaWN0ID0gbWFrZVRvcERpY3QoYXR0cnMsIHN0cmluZ3MpO1xuICAgIHQudG9wRGljdEluZGV4ID0gbWFrZVRvcERpY3RJbmRleCh0b3BEaWN0KTtcbiAgICB0Lmdsb2JhbFN1YnJJbmRleCA9IG1ha2VHbG9iYWxTdWJySW5kZXgoKTtcbiAgICB0LmNoYXJzZXRzID0gbWFrZUNoYXJzZXRzKGdseXBoTmFtZXMsIHN0cmluZ3MpO1xuICAgIHQuY2hhclN0cmluZ3NJbmRleCA9IG1ha2VDaGFyU3RyaW5nc0luZGV4KGdseXBocyk7XG4gICAgdC5wcml2YXRlRGljdCA9IG1ha2VQcml2YXRlRGljdChwcml2YXRlQXR0cnMsIHN0cmluZ3MpO1xuXG4gICAgLy8gTmVlZHMgdG8gY29tZSBhdCB0aGUgZW5kLCB0byBlbmNvZGUgYWxsIGN1c3RvbSBzdHJpbmdzIHVzZWQgaW4gdGhlIGZvbnQuXG4gICAgdC5zdHJpbmdJbmRleCA9IG1ha2VTdHJpbmdJbmRleChzdHJpbmdzKTtcblxuICAgIHZhciBzdGFydE9mZnNldCA9IHQuaGVhZGVyLnNpemVPZigpICtcbiAgICAgICAgdC5uYW1lSW5kZXguc2l6ZU9mKCkgK1xuICAgICAgICB0LnRvcERpY3RJbmRleC5zaXplT2YoKSArXG4gICAgICAgIHQuc3RyaW5nSW5kZXguc2l6ZU9mKCkgK1xuICAgICAgICB0Lmdsb2JhbFN1YnJJbmRleC5zaXplT2YoKTtcbiAgICBhdHRycy5jaGFyc2V0ID0gc3RhcnRPZmZzZXQ7XG5cbiAgICAvLyBXZSB1c2UgdGhlIENGRiBzdGFuZGFyZCBlbmNvZGluZzsgcHJvcGVyIGVuY29kaW5nIHdpbGwgYmUgaGFuZGxlZCBpbiBjbWFwLlxuICAgIGF0dHJzLmVuY29kaW5nID0gMDtcbiAgICBhdHRycy5jaGFyU3RyaW5ncyA9IGF0dHJzLmNoYXJzZXQgKyB0LmNoYXJzZXRzLnNpemVPZigpO1xuICAgIGF0dHJzLnByaXZhdGVbMV0gPSBhdHRycy5jaGFyU3RyaW5ncyArIHQuY2hhclN0cmluZ3NJbmRleC5zaXplT2YoKTtcblxuICAgIC8vIFJlY3JlYXRlIHRoZSBUb3AgRElDVCBJTkRFWCB3aXRoIHRoZSBjb3JyZWN0IG9mZnNldHMuXG4gICAgdG9wRGljdCA9IG1ha2VUb3BEaWN0KGF0dHJzLCBzdHJpbmdzKTtcbiAgICB0LnRvcERpY3RJbmRleCA9IG1ha2VUb3BEaWN0SW5kZXgodG9wRGljdCk7XG5cbiAgICByZXR1cm4gdDtcbn1cblxudmFyIGNmZiA9IHsgcGFyc2U6IHBhcnNlQ0ZGVGFibGUsIG1ha2U6IG1ha2VDRkZUYWJsZSB9O1xuXG4vLyBUaGUgYGhlYWRgIHRhYmxlIGNvbnRhaW5zIGdsb2JhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZm9udC5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvaGVhZC5odG1cblxuLy8gUGFyc2UgdGhlIGhlYWRlciBgaGVhZGAgdGFibGVcbmZ1bmN0aW9uIHBhcnNlSGVhZFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIGhlYWQgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGhlYWQudmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKCk7XG4gICAgaGVhZC5mb250UmV2aXNpb24gPSBNYXRoLnJvdW5kKHAucGFyc2VGaXhlZCgpICogMTAwMCkgLyAxMDAwO1xuICAgIGhlYWQuY2hlY2tTdW1BZGp1c3RtZW50ID0gcC5wYXJzZVVMb25nKCk7XG4gICAgaGVhZC5tYWdpY051bWJlciA9IHAucGFyc2VVTG9uZygpO1xuICAgIGNoZWNrLmFyZ3VtZW50KGhlYWQubWFnaWNOdW1iZXIgPT09IDB4NUYwRjNDRjUsICdGb250IGhlYWRlciBoYXMgd3JvbmcgbWFnaWMgbnVtYmVyLicpO1xuICAgIGhlYWQuZmxhZ3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaGVhZC51bml0c1BlckVtID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQuY3JlYXRlZCA9IHAucGFyc2VMb25nRGF0ZVRpbWUoKTtcbiAgICBoZWFkLm1vZGlmaWVkID0gcC5wYXJzZUxvbmdEYXRlVGltZSgpO1xuICAgIGhlYWQueE1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQueU1pbiA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQueE1heCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQueU1heCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhlYWQubWFjU3R5bGUgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaGVhZC5sb3dlc3RSZWNQUEVNID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGhlYWQuZm9udERpcmVjdGlvbkhpbnQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLmluZGV4VG9Mb2NGb3JtYXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoZWFkLmdseXBoRGF0YUZvcm1hdCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHJldHVybiBoZWFkO1xufVxuXG5mdW5jdGlvbiBtYWtlSGVhZFRhYmxlKG9wdGlvbnMpIHtcbiAgICAvLyBBcHBsZSBNYWMgdGltZXN0YW1wIGVwb2NoIGlzIDAxLzAxLzE5MDQgbm90IDAxLzAxLzE5NzBcbiAgICB2YXIgdGltZXN0YW1wID0gTWF0aC5yb3VuZChuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApICsgMjA4Mjg0NDgwMDtcbiAgICB2YXIgY3JlYXRlZFRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcblxuICAgIGlmIChvcHRpb25zLmNyZWF0ZWRUaW1lc3RhbXApIHtcbiAgICAgICAgY3JlYXRlZFRpbWVzdGFtcCA9IG9wdGlvbnMuY3JlYXRlZFRpbWVzdGFtcCArIDIwODI4NDQ4MDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnaGVhZCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMTAwMDB9LFxuICAgICAgICB7bmFtZTogJ2ZvbnRSZXZpc2lvbicsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAweDAwMDEwMDAwfSxcbiAgICAgICAge25hbWU6ICdjaGVja1N1bUFkanVzdG1lbnQnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWFnaWNOdW1iZXInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMHg1RjBGM0NGNX0sXG4gICAgICAgIHtuYW1lOiAnZmxhZ3MnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VuaXRzUGVyRW0nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDEwMDB9LFxuICAgICAgICB7bmFtZTogJ2NyZWF0ZWQnLCB0eXBlOiAnTE9OR0RBVEVUSU1FJywgdmFsdWU6IGNyZWF0ZWRUaW1lc3RhbXB9LFxuICAgICAgICB7bmFtZTogJ21vZGlmaWVkJywgdHlwZTogJ0xPTkdEQVRFVElNRScsIHZhbHVlOiB0aW1lc3RhbXB9LFxuICAgICAgICB7bmFtZTogJ3hNaW4nLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneU1pbicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd4TWF4JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3lNYXgnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWFjU3R5bGUnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2xvd2VzdFJlY1BQRU0nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2ZvbnREaXJlY3Rpb25IaW50JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDJ9LFxuICAgICAgICB7bmFtZTogJ2luZGV4VG9Mb2NGb3JtYXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnZ2x5cGhEYXRhRm9ybWF0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9XG4gICAgXSwgb3B0aW9ucyk7XG59XG5cbnZhciBoZWFkID0geyBwYXJzZTogcGFyc2VIZWFkVGFibGUsIG1ha2U6IG1ha2VIZWFkVGFibGUgfTtcblxuLy8gVGhlIGBoaGVhYCB0YWJsZSBjb250YWlucyBpbmZvcm1hdGlvbiBmb3IgaG9yaXpvbnRhbCBsYXlvdXQuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2hoZWEuaHRtXG5cbi8vIFBhcnNlIHRoZSBob3Jpem9udGFsIGhlYWRlciBgaGhlYWAgdGFibGVcbmZ1bmN0aW9uIHBhcnNlSGhlYVRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIGhoZWEgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIGhoZWEudmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKCk7XG4gICAgaGhlYS5hc2NlbmRlciA9IHAucGFyc2VTaG9ydCgpO1xuICAgIGhoZWEuZGVzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5saW5lR2FwID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5hZHZhbmNlV2lkdGhNYXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaGhlYS5taW5MZWZ0U2lkZUJlYXJpbmcgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLm1pblJpZ2h0U2lkZUJlYXJpbmcgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLnhNYXhFeHRlbnQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLmNhcmV0U2xvcGVSaXNlID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5jYXJldFNsb3BlUnVuID0gcC5wYXJzZVNob3J0KCk7XG4gICAgaGhlYS5jYXJldE9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHAucmVsYXRpdmVPZmZzZXQgKz0gODtcbiAgICBoaGVhLm1ldHJpY0RhdGFGb3JtYXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBoaGVhLm51bWJlck9mSE1ldHJpY3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgcmV0dXJuIGhoZWE7XG59XG5cbmZ1bmN0aW9uIG1ha2VIaGVhVGFibGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2hoZWEnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAweDAwMDEwMDAwfSxcbiAgICAgICAge25hbWU6ICdhc2NlbmRlcicsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdkZXNjZW5kZXInLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbGluZUdhcCcsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdhZHZhbmNlV2lkdGhNYXgnLCB0eXBlOiAnVUZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21pbkxlZnRTaWRlQmVhcmluZycsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtaW5SaWdodFNpZGVCZWFyaW5nJywgdHlwZTogJ0ZXT1JEJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3hNYXhFeHRlbnQnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnY2FyZXRTbG9wZVJpc2UnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMX0sXG4gICAgICAgIHtuYW1lOiAnY2FyZXRTbG9wZVJ1bicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdjYXJldE9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyZXNlcnZlZDEnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAncmVzZXJ2ZWQyJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3Jlc2VydmVkMycsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyZXNlcnZlZDQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWV0cmljRGF0YUZvcm1hdCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdudW1iZXJPZkhNZXRyaWNzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0sIG9wdGlvbnMpO1xufVxuXG52YXIgaGhlYSA9IHsgcGFyc2U6IHBhcnNlSGhlYVRhYmxlLCBtYWtlOiBtYWtlSGhlYVRhYmxlIH07XG5cbi8vIFRoZSBgaG10eGAgdGFibGUgY29udGFpbnMgdGhlIGhvcml6b250YWwgbWV0cmljcyBmb3IgYWxsIGdseXBocy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvaG10eC5odG1cblxuLy8gUGFyc2UgdGhlIGBobXR4YCB0YWJsZSwgd2hpY2ggY29udGFpbnMgdGhlIGhvcml6b250YWwgbWV0cmljcyBmb3IgYWxsIGdseXBocy5cbi8vIFRoaXMgZnVuY3Rpb24gYXVnbWVudHMgdGhlIGdseXBoIGFycmF5LCBhZGRpbmcgdGhlIGFkdmFuY2VXaWR0aCBhbmQgbGVmdFNpZGVCZWFyaW5nIHRvIGVhY2ggZ2x5cGguXG5mdW5jdGlvbiBwYXJzZUhtdHhUYWJsZShkYXRhLCBzdGFydCwgbnVtTWV0cmljcywgbnVtR2x5cGhzLCBnbHlwaHMpIHtcbiAgICB2YXIgYWR2YW5jZVdpZHRoO1xuICAgIHZhciBsZWZ0U2lkZUJlYXJpbmc7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUdseXBoczsgaSArPSAxKSB7XG4gICAgICAgIC8vIElmIHRoZSBmb250IGlzIG1vbm9zcGFjZWQsIG9ubHkgb25lIGVudHJ5IGlzIG5lZWRlZC4gVGhpcyBsYXN0IGVudHJ5IGFwcGxpZXMgdG8gYWxsIHN1YnNlcXVlbnQgZ2x5cGhzLlxuICAgICAgICBpZiAoaSA8IG51bU1ldHJpY3MpIHtcbiAgICAgICAgICAgIGFkdmFuY2VXaWR0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIGxlZnRTaWRlQmVhcmluZyA9IHAucGFyc2VTaG9ydCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzLmdldChpKTtcbiAgICAgICAgZ2x5cGguYWR2YW5jZVdpZHRoID0gYWR2YW5jZVdpZHRoO1xuICAgICAgICBnbHlwaC5sZWZ0U2lkZUJlYXJpbmcgPSBsZWZ0U2lkZUJlYXJpbmc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtYWtlSG10eFRhYmxlKGdseXBocykge1xuICAgIHZhciB0ID0gbmV3IHRhYmxlLlRhYmxlKCdobXR4JywgW10pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBocy5nZXQoaSk7XG4gICAgICAgIHZhciBhZHZhbmNlV2lkdGggPSBnbHlwaC5hZHZhbmNlV2lkdGggfHwgMDtcbiAgICAgICAgdmFyIGxlZnRTaWRlQmVhcmluZyA9IGdseXBoLmxlZnRTaWRlQmVhcmluZyB8fCAwO1xuICAgICAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAnYWR2YW5jZVdpZHRoXycgKyBpLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IGFkdmFuY2VXaWR0aH0pO1xuICAgICAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAnbGVmdFNpZGVCZWFyaW5nXycgKyBpLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogbGVmdFNpZGVCZWFyaW5nfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG59XG5cbnZhciBobXR4ID0geyBwYXJzZTogcGFyc2VIbXR4VGFibGUsIG1ha2U6IG1ha2VIbXR4VGFibGUgfTtcblxuLy8gVGhlIGBsdGFnYCB0YWJsZSBzdG9yZXMgSUVURiBCQ1AtNDcgbGFuZ3VhZ2UgdGFncy4gSXQgYWxsb3dzIHN1cHBvcnRpbmdcbi8vIGxhbmd1YWdlcyBmb3Igd2hpY2ggVHJ1ZVR5cGUgZG9lcyBub3QgYXNzaWduIGEgbnVtZXJpYyBjb2RlLlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2ZvbnRzL1RydWVUeXBlLVJlZmVyZW5jZS1NYW51YWwvUk0wNi9DaGFwNmx0YWcuaHRtbFxuLy8gaHR0cDovL3d3dy53My5vcmcvSW50ZXJuYXRpb25hbC9hcnRpY2xlcy9sYW5ndWFnZS10YWdzL1xuLy8gaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9sYW5ndWFnZS1zdWJ0YWctcmVnaXN0cnkvbGFuZ3VhZ2Utc3VidGFnLXJlZ2lzdHJ5XG5cbmZ1bmN0aW9uIG1ha2VMdGFnVGFibGUodGFncykge1xuICAgIHZhciByZXN1bHQgPSBuZXcgdGFibGUuVGFibGUoJ2x0YWcnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAxfSxcbiAgICAgICAge25hbWU6ICdmbGFncycsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdudW1UYWdzJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IHRhZ3MubGVuZ3RofVxuICAgIF0pO1xuXG4gICAgdmFyIHN0cmluZ1Bvb2wgPSAnJztcbiAgICB2YXIgc3RyaW5nUG9vbE9mZnNldCA9IDEyICsgdGFncy5sZW5ndGggKiA0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFncy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcG9zID0gc3RyaW5nUG9vbC5pbmRleE9mKHRhZ3NbaV0pO1xuICAgICAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICAgICAgcG9zID0gc3RyaW5nUG9vbC5sZW5ndGg7XG4gICAgICAgICAgICBzdHJpbmdQb29sICs9IHRhZ3NbaV07XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICdvZmZzZXQgJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc3RyaW5nUG9vbE9mZnNldCArIHBvc30pO1xuICAgICAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICdsZW5ndGggJyArIGksIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogdGFnc1tpXS5sZW5ndGh9KTtcbiAgICB9XG5cbiAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICdzdHJpbmdQb29sJywgdHlwZTogJ0NIQVJBUlJBWScsIHZhbHVlOiBzdHJpbmdQb29sfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VMdGFnVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEsICdVbnN1cHBvcnRlZCBsdGFnIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgLy8gVGhlICdsdGFnJyBzcGVjaWZpY2F0aW9uIGRvZXMgbm90IGRlZmluZSBhbnkgZmxhZ3M7IHNraXAgdGhlIGZpZWxkLlxuICAgIHAuc2tpcCgndUxvbmcnLCAxKTtcbiAgICB2YXIgbnVtVGFncyA9IHAucGFyc2VVTG9uZygpO1xuXG4gICAgdmFyIHRhZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVRhZ3M7IGkrKykge1xuICAgICAgICB2YXIgdGFnID0gJyc7XG4gICAgICAgIHZhciBvZmZzZXQgPSBzdGFydCArIHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IG9mZnNldDsgaiA8IG9mZnNldCArIGxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICB0YWcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhLmdldEludDgoaikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFncy5wdXNoKHRhZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhZ3M7XG59XG5cbnZhciBsdGFnID0geyBtYWtlOiBtYWtlTHRhZ1RhYmxlLCBwYXJzZTogcGFyc2VMdGFnVGFibGUgfTtcblxuLy8gVGhlIGBtYXhwYCB0YWJsZSBlc3RhYmxpc2hlcyB0aGUgbWVtb3J5IHJlcXVpcmVtZW50cyBmb3IgdGhlIGZvbnQuXG4vLyBXZSBuZWVkIGl0IGp1c3QgdG8gZ2V0IHRoZSBudW1iZXIgb2YgZ2x5cGhzIGluIHRoZSBmb250LlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9tYXhwLmh0bVxuXG4vLyBQYXJzZSB0aGUgbWF4aW11bSBwcm9maWxlIGBtYXhwYCB0YWJsZS5cbmZ1bmN0aW9uIHBhcnNlTWF4cFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIG1heHAgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIG1heHAudmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKCk7XG4gICAgbWF4cC5udW1HbHlwaHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKG1heHAudmVyc2lvbiA9PT0gMS4wKSB7XG4gICAgICAgIG1heHAubWF4UG9pbnRzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbnRvdXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heENvbXBvc2l0ZVBvaW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhDb21wb3NpdGVDb250b3VycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhab25lcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhUd2lsaWdodFBvaW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhTdG9yYWdlID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBtYXhwLm1heEZ1bmN0aW9uRGVmcyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhJbnN0cnVjdGlvbkRlZnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4U3RhY2tFbGVtZW50cyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgbWF4cC5tYXhTaXplT2ZJbnN0cnVjdGlvbnMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29tcG9uZW50RWxlbWVudHMgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG1heHAubWF4Q29tcG9uZW50RGVwdGggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heHA7XG59XG5cbmZ1bmN0aW9uIG1ha2VNYXhwVGFibGUobnVtR2x5cGhzKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnbWF4cCcsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IDB4MDAwMDUwMDB9LFxuICAgICAgICB7bmFtZTogJ251bUdseXBocycsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbnVtR2x5cGhzfVxuICAgIF0pO1xufVxuXG52YXIgbWF4cCA9IHsgcGFyc2U6IHBhcnNlTWF4cFRhYmxlLCBtYWtlOiBtYWtlTWF4cFRhYmxlIH07XG5cbi8vIFRoZSBgbmFtZWAgbmFtaW5nIHRhYmxlLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9uYW1lLmh0bVxuXG4vLyBOYW1lSURzIGZvciB0aGUgbmFtZSB0YWJsZS5cbnZhciBuYW1lVGFibGVOYW1lcyA9IFtcbiAgICAnY29weXJpZ2h0JywgICAgICAgICAgICAgIC8vIDBcbiAgICAnZm9udEZhbWlseScsICAgICAgICAgICAgIC8vIDFcbiAgICAnZm9udFN1YmZhbWlseScsICAgICAgICAgIC8vIDJcbiAgICAndW5pcXVlSUQnLCAgICAgICAgICAgICAgIC8vIDNcbiAgICAnZnVsbE5hbWUnLCAgICAgICAgICAgICAgIC8vIDRcbiAgICAndmVyc2lvbicsICAgICAgICAgICAgICAgIC8vIDVcbiAgICAncG9zdFNjcmlwdE5hbWUnLCAgICAgICAgIC8vIDZcbiAgICAndHJhZGVtYXJrJywgICAgICAgICAgICAgIC8vIDdcbiAgICAnbWFudWZhY3R1cmVyJywgICAgICAgICAgIC8vIDhcbiAgICAnZGVzaWduZXInLCAgICAgICAgICAgICAgIC8vIDlcbiAgICAnZGVzY3JpcHRpb24nLCAgICAgICAgICAgIC8vIDEwXG4gICAgJ21hbnVmYWN0dXJlclVSTCcsICAgICAgICAvLyAxMVxuICAgICdkZXNpZ25lclVSTCcsICAgICAgICAgICAgLy8gMTJcbiAgICAnbGljZW5zZScsICAgICAgICAgICAgICAgIC8vIDEzXG4gICAgJ2xpY2Vuc2VVUkwnLCAgICAgICAgICAgICAvLyAxNFxuICAgICdyZXNlcnZlZCcsICAgICAgICAgICAgICAgLy8gMTVcbiAgICAncHJlZmVycmVkRmFtaWx5JywgICAgICAgIC8vIDE2XG4gICAgJ3ByZWZlcnJlZFN1YmZhbWlseScsICAgICAvLyAxN1xuICAgICdjb21wYXRpYmxlRnVsbE5hbWUnLCAgICAgLy8gMThcbiAgICAnc2FtcGxlVGV4dCcsICAgICAgICAgICAgIC8vIDE5XG4gICAgJ3Bvc3RTY3JpcHRGaW5kRm9udE5hbWUnLCAvLyAyMFxuICAgICd3d3NGYW1pbHknLCAgICAgICAgICAgICAgLy8gMjFcbiAgICAnd3dzU3ViZmFtaWx5JyAgICAgICAgICAgIC8vIDIyXG5dO1xuXG52YXIgbWFjTGFuZ3VhZ2VzID0ge1xuICAgIDA6ICdlbicsXG4gICAgMTogJ2ZyJyxcbiAgICAyOiAnZGUnLFxuICAgIDM6ICdpdCcsXG4gICAgNDogJ25sJyxcbiAgICA1OiAnc3YnLFxuICAgIDY6ICdlcycsXG4gICAgNzogJ2RhJyxcbiAgICA4OiAncHQnLFxuICAgIDk6ICdubycsXG4gICAgMTA6ICdoZScsXG4gICAgMTE6ICdqYScsXG4gICAgMTI6ICdhcicsXG4gICAgMTM6ICdmaScsXG4gICAgMTQ6ICdlbCcsXG4gICAgMTU6ICdpcycsXG4gICAgMTY6ICdtdCcsXG4gICAgMTc6ICd0cicsXG4gICAgMTg6ICdocicsXG4gICAgMTk6ICd6aC1IYW50JyxcbiAgICAyMDogJ3VyJyxcbiAgICAyMTogJ2hpJyxcbiAgICAyMjogJ3RoJyxcbiAgICAyMzogJ2tvJyxcbiAgICAyNDogJ2x0JyxcbiAgICAyNTogJ3BsJyxcbiAgICAyNjogJ2h1JyxcbiAgICAyNzogJ2VzJyxcbiAgICAyODogJ2x2JyxcbiAgICAyOTogJ3NlJyxcbiAgICAzMDogJ2ZvJyxcbiAgICAzMTogJ2ZhJyxcbiAgICAzMjogJ3J1JyxcbiAgICAzMzogJ3poJyxcbiAgICAzNDogJ25sLUJFJyxcbiAgICAzNTogJ2dhJyxcbiAgICAzNjogJ3NxJyxcbiAgICAzNzogJ3JvJyxcbiAgICAzODogJ2N6JyxcbiAgICAzOTogJ3NrJyxcbiAgICA0MDogJ3NpJyxcbiAgICA0MTogJ3lpJyxcbiAgICA0MjogJ3NyJyxcbiAgICA0MzogJ21rJyxcbiAgICA0NDogJ2JnJyxcbiAgICA0NTogJ3VrJyxcbiAgICA0NjogJ2JlJyxcbiAgICA0NzogJ3V6JyxcbiAgICA0ODogJ2trJyxcbiAgICA0OTogJ2F6LUN5cmwnLFxuICAgIDUwOiAnYXotQXJhYicsXG4gICAgNTE6ICdoeScsXG4gICAgNTI6ICdrYScsXG4gICAgNTM6ICdtbycsXG4gICAgNTQ6ICdreScsXG4gICAgNTU6ICd0ZycsXG4gICAgNTY6ICd0aycsXG4gICAgNTc6ICdtbi1DTicsXG4gICAgNTg6ICdtbicsXG4gICAgNTk6ICdwcycsXG4gICAgNjA6ICdrcycsXG4gICAgNjE6ICdrdScsXG4gICAgNjI6ICdzZCcsXG4gICAgNjM6ICdibycsXG4gICAgNjQ6ICduZScsXG4gICAgNjU6ICdzYScsXG4gICAgNjY6ICdtcicsXG4gICAgNjc6ICdibicsXG4gICAgNjg6ICdhcycsXG4gICAgNjk6ICdndScsXG4gICAgNzA6ICdwYScsXG4gICAgNzE6ICdvcicsXG4gICAgNzI6ICdtbCcsXG4gICAgNzM6ICdrbicsXG4gICAgNzQ6ICd0YScsXG4gICAgNzU6ICd0ZScsXG4gICAgNzY6ICdzaScsXG4gICAgNzc6ICdteScsXG4gICAgNzg6ICdrbScsXG4gICAgNzk6ICdsbycsXG4gICAgODA6ICd2aScsXG4gICAgODE6ICdpZCcsXG4gICAgODI6ICd0bCcsXG4gICAgODM6ICdtcycsXG4gICAgODQ6ICdtcy1BcmFiJyxcbiAgICA4NTogJ2FtJyxcbiAgICA4NjogJ3RpJyxcbiAgICA4NzogJ29tJyxcbiAgICA4ODogJ3NvJyxcbiAgICA4OTogJ3N3JyxcbiAgICA5MDogJ3J3JyxcbiAgICA5MTogJ3JuJyxcbiAgICA5MjogJ255JyxcbiAgICA5MzogJ21nJyxcbiAgICA5NDogJ2VvJyxcbiAgICAxMjg6ICdjeScsXG4gICAgMTI5OiAnZXUnLFxuICAgIDEzMDogJ2NhJyxcbiAgICAxMzE6ICdsYScsXG4gICAgMTMyOiAncXUnLFxuICAgIDEzMzogJ2duJyxcbiAgICAxMzQ6ICdheScsXG4gICAgMTM1OiAndHQnLFxuICAgIDEzNjogJ3VnJyxcbiAgICAxMzc6ICdkeicsXG4gICAgMTM4OiAnanYnLFxuICAgIDEzOTogJ3N1JyxcbiAgICAxNDA6ICdnbCcsXG4gICAgMTQxOiAnYWYnLFxuICAgIDE0MjogJ2JyJyxcbiAgICAxNDM6ICdpdScsXG4gICAgMTQ0OiAnZ2QnLFxuICAgIDE0NTogJ2d2JyxcbiAgICAxNDY6ICdnYScsXG4gICAgMTQ3OiAndG8nLFxuICAgIDE0ODogJ2VsLXBvbHl0b24nLFxuICAgIDE0OTogJ2tsJyxcbiAgICAxNTA6ICdheicsXG4gICAgMTUxOiAnbm4nXG59O1xuXG4vLyBNYWNPUyBsYW5ndWFnZSBJRCDihpIgTWFjT1Mgc2NyaXB0IElEXG4vL1xuLy8gTm90ZSB0aGF0IHRoZSBzY3JpcHQgSUQgaXMgbm90IHN1ZmZpY2llbnQgdG8gZGV0ZXJtaW5lIHdoYXQgZW5jb2Rpbmdcbi8vIHRvIHVzZSBpbiBUcnVlVHlwZSBmaWxlcy4gRm9yIHNvbWUgbGFuZ3VhZ2VzLCBNYWNPUyB1c2VkIGEgbW9kaWZpY2F0aW9uXG4vLyBvZiBhIG1haW5zdHJlYW0gc2NyaXB0LiBGb3IgZXhhbXBsZSwgYW4gSWNlbGFuZGljIG5hbWUgd291bGQgYmUgc3RvcmVkXG4vLyB3aXRoIHNtUm9tYW4gaW4gdGhlIFRydWVUeXBlIG5hbWluZyB0YWJsZSwgYnV0IHRoZSBhY3R1YWwgZW5jb2Rpbmdcbi8vIGlzIGEgc3BlY2lhbCBJY2VsYW5kaWMgdmVyc2lvbiBvZiB0aGUgbm9ybWFsIE1hY2ludG9zaCBSb21hbiBlbmNvZGluZy5cbi8vIEFzIGFub3RoZXIgZXhhbXBsZSwgSW51a3RpdHV0IHVzZXMgYW4gOC1iaXQgZW5jb2RpbmcgZm9yIENhbmFkaWFuIEFib3JpZ2luYWxcbi8vIFN5bGxhYmxlcyBidXQgTWFjT1MgaGFkIHJ1biBvdXQgb2YgYXZhaWxhYmxlIHNjcmlwdCBjb2Rlcywgc28gdGhpcyB3YXNcbi8vIGRvbmUgYXMgYSAocHJldHR5IHJhZGljYWwpIFwibW9kaWZpY2F0aW9uXCIgb2YgRXRoaW9waWMuXG4vL1xuLy8gaHR0cDovL3VuaWNvZGUub3JnL1B1YmxpYy9NQVBQSU5HUy9WRU5ET1JTL0FQUExFL1JlYWRtZS50eHRcbnZhciBtYWNMYW5ndWFnZVRvU2NyaXB0ID0ge1xuICAgIDA6IDAsICAvLyBsYW5nRW5nbGlzaCDihpIgc21Sb21hblxuICAgIDE6IDAsICAvLyBsYW5nRnJlbmNoIOKGkiBzbVJvbWFuXG4gICAgMjogMCwgIC8vIGxhbmdHZXJtYW4g4oaSIHNtUm9tYW5cbiAgICAzOiAwLCAgLy8gbGFuZ0l0YWxpYW4g4oaSIHNtUm9tYW5cbiAgICA0OiAwLCAgLy8gbGFuZ0R1dGNoIOKGkiBzbVJvbWFuXG4gICAgNTogMCwgIC8vIGxhbmdTd2VkaXNoIOKGkiBzbVJvbWFuXG4gICAgNjogMCwgIC8vIGxhbmdTcGFuaXNoIOKGkiBzbVJvbWFuXG4gICAgNzogMCwgIC8vIGxhbmdEYW5pc2gg4oaSIHNtUm9tYW5cbiAgICA4OiAwLCAgLy8gbGFuZ1BvcnR1Z3Vlc2Ug4oaSIHNtUm9tYW5cbiAgICA5OiAwLCAgLy8gbGFuZ05vcndlZ2lhbiDihpIgc21Sb21hblxuICAgIDEwOiA1LCAgLy8gbGFuZ0hlYnJldyDihpIgc21IZWJyZXdcbiAgICAxMTogMSwgIC8vIGxhbmdKYXBhbmVzZSDihpIgc21KYXBhbmVzZVxuICAgIDEyOiA0LCAgLy8gbGFuZ0FyYWJpYyDihpIgc21BcmFiaWNcbiAgICAxMzogMCwgIC8vIGxhbmdGaW5uaXNoIOKGkiBzbVJvbWFuXG4gICAgMTQ6IDYsICAvLyBsYW5nR3JlZWsg4oaSIHNtR3JlZWtcbiAgICAxNTogMCwgIC8vIGxhbmdJY2VsYW5kaWMg4oaSIHNtUm9tYW4gKG1vZGlmaWVkKVxuICAgIDE2OiAwLCAgLy8gbGFuZ01hbHRlc2Ug4oaSIHNtUm9tYW5cbiAgICAxNzogMCwgIC8vIGxhbmdUdXJraXNoIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAxODogMCwgIC8vIGxhbmdDcm9hdGlhbiDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMTk6IDIsICAvLyBsYW5nVHJhZENoaW5lc2Ug4oaSIHNtVHJhZENoaW5lc2VcbiAgICAyMDogNCwgIC8vIGxhbmdVcmR1IOKGkiBzbUFyYWJpY1xuICAgIDIxOiA5LCAgLy8gbGFuZ0hpbmRpIOKGkiBzbURldmFuYWdhcmlcbiAgICAyMjogMjEsICAvLyBsYW5nVGhhaSDihpIgc21UaGFpXG4gICAgMjM6IDMsICAvLyBsYW5nS29yZWFuIOKGkiBzbUtvcmVhblxuICAgIDI0OiAyOSwgIC8vIGxhbmdMaXRodWFuaWFuIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cbiAgICAyNTogMjksICAvLyBsYW5nUG9saXNoIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cbiAgICAyNjogMjksICAvLyBsYW5nSHVuZ2FyaWFuIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cbiAgICAyNzogMjksICAvLyBsYW5nRXN0b25pYW4g4oaSIHNtQ2VudHJhbEV1cm9Sb21hblxuICAgIDI4OiAyOSwgIC8vIGxhbmdMYXR2aWFuIOKGkiBzbUNlbnRyYWxFdXJvUm9tYW5cbiAgICAyOTogMCwgIC8vIGxhbmdTYW1pIOKGkiBzbVJvbWFuXG4gICAgMzA6IDAsICAvLyBsYW5nRmFyb2VzZSDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMzE6IDQsICAvLyBsYW5nRmFyc2kg4oaSIHNtQXJhYmljIChtb2RpZmllZClcbiAgICAzMjogNywgIC8vIGxhbmdSdXNzaWFuIOKGkiBzbUN5cmlsbGljXG4gICAgMzM6IDI1LCAgLy8gbGFuZ1NpbXBDaGluZXNlIOKGkiBzbVNpbXBDaGluZXNlXG4gICAgMzQ6IDAsICAvLyBsYW5nRmxlbWlzaCDihpIgc21Sb21hblxuICAgIDM1OiAwLCAgLy8gbGFuZ0lyaXNoR2FlbGljIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAzNjogMCwgIC8vIGxhbmdBbGJhbmlhbiDihpIgc21Sb21hblxuICAgIDM3OiAwLCAgLy8gbGFuZ1JvbWFuaWFuIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAzODogMjksICAvLyBsYW5nQ3plY2gg4oaSIHNtQ2VudHJhbEV1cm9Sb21hblxuICAgIDM5OiAyOSwgIC8vIGxhbmdTbG92YWsg4oaSIHNtQ2VudHJhbEV1cm9Sb21hblxuICAgIDQwOiAwLCAgLy8gbGFuZ1Nsb3ZlbmlhbiDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgNDE6IDUsICAvLyBsYW5nWWlkZGlzaCDihpIgc21IZWJyZXdcbiAgICA0MjogNywgIC8vIGxhbmdTZXJiaWFuIOKGkiBzbUN5cmlsbGljXG4gICAgNDM6IDcsICAvLyBsYW5nTWFjZWRvbmlhbiDihpIgc21DeXJpbGxpY1xuICAgIDQ0OiA3LCAgLy8gbGFuZ0J1bGdhcmlhbiDihpIgc21DeXJpbGxpY1xuICAgIDQ1OiA3LCAgLy8gbGFuZ1VrcmFpbmlhbiDihpIgc21DeXJpbGxpYyAobW9kaWZpZWQpXG4gICAgNDY6IDcsICAvLyBsYW5nQnllbG9ydXNzaWFuIOKGkiBzbUN5cmlsbGljXG4gICAgNDc6IDcsICAvLyBsYW5nVXpiZWsg4oaSIHNtQ3lyaWxsaWNcbiAgICA0ODogNywgIC8vIGxhbmdLYXpha2gg4oaSIHNtQ3lyaWxsaWNcbiAgICA0OTogNywgIC8vIGxhbmdBemVyYmFpamFuaSDihpIgc21DeXJpbGxpY1xuICAgIDUwOiA0LCAgLy8gbGFuZ0F6ZXJiYWlqYW5BciDihpIgc21BcmFiaWNcbiAgICA1MTogMjQsICAvLyBsYW5nQXJtZW5pYW4g4oaSIHNtQXJtZW5pYW5cbiAgICA1MjogMjMsICAvLyBsYW5nR2VvcmdpYW4g4oaSIHNtR2VvcmdpYW5cbiAgICA1MzogNywgIC8vIGxhbmdNb2xkYXZpYW4g4oaSIHNtQ3lyaWxsaWNcbiAgICA1NDogNywgIC8vIGxhbmdLaXJnaGl6IOKGkiBzbUN5cmlsbGljXG4gICAgNTU6IDcsICAvLyBsYW5nVGFqaWtpIOKGkiBzbUN5cmlsbGljXG4gICAgNTY6IDcsICAvLyBsYW5nVHVya21lbiDihpIgc21DeXJpbGxpY1xuICAgIDU3OiAyNywgIC8vIGxhbmdNb25nb2xpYW4g4oaSIHNtTW9uZ29saWFuXG4gICAgNTg6IDcsICAvLyBsYW5nTW9uZ29saWFuQ3lyIOKGkiBzbUN5cmlsbGljXG4gICAgNTk6IDQsICAvLyBsYW5nUGFzaHRvIOKGkiBzbUFyYWJpY1xuICAgIDYwOiA0LCAgLy8gbGFuZ0t1cmRpc2gg4oaSIHNtQXJhYmljXG4gICAgNjE6IDQsICAvLyBsYW5nS2FzaG1pcmkg4oaSIHNtQXJhYmljXG4gICAgNjI6IDQsICAvLyBsYW5nU2luZGhpIOKGkiBzbUFyYWJpY1xuICAgIDYzOiAyNiwgIC8vIGxhbmdUaWJldGFuIOKGkiBzbVRpYmV0YW5cbiAgICA2NDogOSwgIC8vIGxhbmdOZXBhbGkg4oaSIHNtRGV2YW5hZ2FyaVxuICAgIDY1OiA5LCAgLy8gbGFuZ1NhbnNrcml0IOKGkiBzbURldmFuYWdhcmlcbiAgICA2NjogOSwgIC8vIGxhbmdNYXJhdGhpIOKGkiBzbURldmFuYWdhcmlcbiAgICA2NzogMTMsICAvLyBsYW5nQmVuZ2FsaSDihpIgc21CZW5nYWxpXG4gICAgNjg6IDEzLCAgLy8gbGFuZ0Fzc2FtZXNlIOKGkiBzbUJlbmdhbGlcbiAgICA2OTogMTEsICAvLyBsYW5nR3VqYXJhdGkg4oaSIHNtR3VqYXJhdGlcbiAgICA3MDogMTAsICAvLyBsYW5nUHVuamFiaSDihpIgc21HdXJtdWtoaVxuICAgIDcxOiAxMiwgIC8vIGxhbmdPcml5YSDihpIgc21Pcml5YVxuICAgIDcyOiAxNywgIC8vIGxhbmdNYWxheWFsYW0g4oaSIHNtTWFsYXlhbGFtXG4gICAgNzM6IDE2LCAgLy8gbGFuZ0thbm5hZGEg4oaSIHNtS2FubmFkYVxuICAgIDc0OiAxNCwgIC8vIGxhbmdUYW1pbCDihpIgc21UYW1pbFxuICAgIDc1OiAxNSwgIC8vIGxhbmdUZWx1Z3Ug4oaSIHNtVGVsdWd1XG4gICAgNzY6IDE4LCAgLy8gbGFuZ1NpbmhhbGVzZSDihpIgc21TaW5oYWxlc2VcbiAgICA3NzogMTksICAvLyBsYW5nQnVybWVzZSDihpIgc21CdXJtZXNlXG4gICAgNzg6IDIwLCAgLy8gbGFuZ0tobWVyIOKGkiBzbUtobWVyXG4gICAgNzk6IDIyLCAgLy8gbGFuZ0xhbyDihpIgc21MYW9cbiAgICA4MDogMzAsICAvLyBsYW5nVmlldG5hbWVzZSDihpIgc21WaWV0bmFtZXNlXG4gICAgODE6IDAsICAvLyBsYW5nSW5kb25lc2lhbiDihpIgc21Sb21hblxuICAgIDgyOiAwLCAgLy8gbGFuZ1RhZ2Fsb2cg4oaSIHNtUm9tYW5cbiAgICA4MzogMCwgIC8vIGxhbmdNYWxheVJvbWFuIOKGkiBzbVJvbWFuXG4gICAgODQ6IDQsICAvLyBsYW5nTWFsYXlBcmFiaWMg4oaSIHNtQXJhYmljXG4gICAgODU6IDI4LCAgLy8gbGFuZ0FtaGFyaWMg4oaSIHNtRXRoaW9waWNcbiAgICA4NjogMjgsICAvLyBsYW5nVGlncmlueWEg4oaSIHNtRXRoaW9waWNcbiAgICA4NzogMjgsICAvLyBsYW5nT3JvbW8g4oaSIHNtRXRoaW9waWNcbiAgICA4ODogMCwgIC8vIGxhbmdTb21hbGkg4oaSIHNtUm9tYW5cbiAgICA4OTogMCwgIC8vIGxhbmdTd2FoaWxpIOKGkiBzbVJvbWFuXG4gICAgOTA6IDAsICAvLyBsYW5nS2lueWFyd2FuZGEg4oaSIHNtUm9tYW5cbiAgICA5MTogMCwgIC8vIGxhbmdSdW5kaSDihpIgc21Sb21hblxuICAgIDkyOiAwLCAgLy8gbGFuZ055YW5qYSDihpIgc21Sb21hblxuICAgIDkzOiAwLCAgLy8gbGFuZ01hbGFnYXN5IOKGkiBzbVJvbWFuXG4gICAgOTQ6IDAsICAvLyBsYW5nRXNwZXJhbnRvIOKGkiBzbVJvbWFuXG4gICAgMTI4OiAwLCAgLy8gbGFuZ1dlbHNoIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAxMjk6IDAsICAvLyBsYW5nQmFzcXVlIOKGkiBzbVJvbWFuXG4gICAgMTMwOiAwLCAgLy8gbGFuZ0NhdGFsYW4g4oaSIHNtUm9tYW5cbiAgICAxMzE6IDAsICAvLyBsYW5nTGF0aW4g4oaSIHNtUm9tYW5cbiAgICAxMzI6IDAsICAvLyBsYW5nUXVlY2h1YSDihpIgc21Sb21hblxuICAgIDEzMzogMCwgIC8vIGxhbmdHdWFyYW5pIOKGkiBzbVJvbWFuXG4gICAgMTM0OiAwLCAgLy8gbGFuZ0F5bWFyYSDihpIgc21Sb21hblxuICAgIDEzNTogNywgIC8vIGxhbmdUYXRhciDihpIgc21DeXJpbGxpY1xuICAgIDEzNjogNCwgIC8vIGxhbmdVaWdodXIg4oaSIHNtQXJhYmljXG4gICAgMTM3OiAyNiwgIC8vIGxhbmdEem9uZ2toYSDihpIgc21UaWJldGFuXG4gICAgMTM4OiAwLCAgLy8gbGFuZ0phdmFuZXNlUm9tIOKGkiBzbVJvbWFuXG4gICAgMTM5OiAwLCAgLy8gbGFuZ1N1bmRhbmVzZVJvbSDihpIgc21Sb21hblxuICAgIDE0MDogMCwgIC8vIGxhbmdHYWxpY2lhbiDihpIgc21Sb21hblxuICAgIDE0MTogMCwgIC8vIGxhbmdBZnJpa2FhbnMg4oaSIHNtUm9tYW5cbiAgICAxNDI6IDAsICAvLyBsYW5nQnJldG9uIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAxNDM6IDI4LCAgLy8gbGFuZ0ludWt0aXR1dCDihpIgc21FdGhpb3BpYyAobW9kaWZpZWQpXG4gICAgMTQ0OiAwLCAgLy8gbGFuZ1Njb3R0aXNoR2FlbGljIOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAxNDU6IDAsICAvLyBsYW5nTWFueEdhZWxpYyDihpIgc21Sb21hbiAobW9kaWZpZWQpXG4gICAgMTQ2OiAwLCAgLy8gbGFuZ0lyaXNoR2FlbGljU2NyaXB0IOKGkiBzbVJvbWFuIChtb2RpZmllZClcbiAgICAxNDc6IDAsICAvLyBsYW5nVG9uZ2FuIOKGkiBzbVJvbWFuXG4gICAgMTQ4OiA2LCAgLy8gbGFuZ0dyZWVrQW5jaWVudCDihpIgc21Sb21hblxuICAgIDE0OTogMCwgIC8vIGxhbmdHcmVlbmxhbmRpYyDihpIgc21Sb21hblxuICAgIDE1MDogMCwgIC8vIGxhbmdBemVyYmFpamFuUm9tYW4g4oaSIHNtUm9tYW5cbiAgICAxNTE6IDAgICAvLyBsYW5nTnlub3JzayDihpIgc21Sb21hblxufTtcblxuLy8gV2hpbGUgTWljcm9zb2Z0IGluZGljYXRlcyBhIHJlZ2lvbi9jb3VudHJ5IGZvciBhbGwgaXRzIGxhbmd1YWdlXG4vLyBJRHMsIHdlIG9taXQgdGhlIHJlZ2lvbiBjb2RlIGlmIGl0J3MgZXF1YWwgdG8gdGhlIFwibW9zdCBsaWtlbHlcbi8vIHJlZ2lvbiBzdWJ0YWdcIiBhY2NvcmRpbmcgdG8gVW5pY29kZSBDTERSLiBGb3Igc2NyaXB0cywgd2Ugb21pdFxuLy8gdGhlIHN1YnRhZyBpZiBpdCBpcyBlcXVhbCB0byB0aGUgU3VwcHJlc3MtU2NyaXB0IGVudHJ5IGluIHRoZVxuLy8gSUFOQSBsYW5ndWFnZSBzdWJ0YWcgcmVnaXN0cnkgZm9yIElFVEYgQkNQIDQ3LlxuLy9cbi8vIEZvciBleGFtcGxlLCBNaWNyb3NvZnQgc3RhdGVzIHRoYXQgaXRzIGxhbmd1YWdlIGNvZGUgMHgwNDFBIGlzXG4vLyBDcm9hdGlhbiBpbiBDcm9hdGlhLiBXZSB0cmFuc2Zvcm0gdGhpcyB0byB0aGUgQkNQIDQ3IGxhbmd1YWdlIGNvZGUgJ2hyJ1xuLy8gYW5kIG5vdCAnaHItSFInIGJlY2F1c2UgQ3JvYXRpYSBpcyB0aGUgZGVmYXVsdCBjb3VudHJ5IGZvciBDcm9hdGlhbixcbi8vIGFjY29yZGluZyB0byBVbmljb2RlIENMRFIuIEFzIGFub3RoZXIgZXhhbXBsZSwgTWljcm9zb2Z0IHN0YXRlc1xuLy8gdGhhdCAweDEwMUEgaXMgQ3JvYXRpYW4gKExhdGluKSBpbiBCb3NuaWEtSGVyemVnb3ZpbmEuIFdlIHRyYW5zZm9ybVxuLy8gdGhpcyB0byAnaHItQkEnIGFuZCBub3QgJ2hyLUxhdG4tQkEnIGJlY2F1c2UgTGF0aW4gaXMgdGhlIGRlZmF1bHQgc2NyaXB0XG4vLyBmb3IgdGhlIENyb2F0aWFuIGxhbmd1YWdlLCBhY2NvcmRpbmcgdG8gSUFOQS5cbi8vXG4vLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL2NsZHIvY2hhcnRzL2xhdGVzdC9zdXBwbGVtZW50YWwvbGlrZWx5X3N1YnRhZ3MuaHRtbFxuLy8gaHR0cDovL3d3dy5pYW5hLm9yZy9hc3NpZ25tZW50cy9sYW5ndWFnZS1zdWJ0YWctcmVnaXN0cnkvbGFuZ3VhZ2Utc3VidGFnLXJlZ2lzdHJ5XG52YXIgd2luZG93c0xhbmd1YWdlcyA9IHtcbiAgICAweDA0MzY6ICdhZicsXG4gICAgMHgwNDFDOiAnc3EnLFxuICAgIDB4MDQ4NDogJ2dzdycsXG4gICAgMHgwNDVFOiAnYW0nLFxuICAgIDB4MTQwMTogJ2FyLURaJyxcbiAgICAweDNDMDE6ICdhci1CSCcsXG4gICAgMHgwQzAxOiAnYXInLFxuICAgIDB4MDgwMTogJ2FyLUlRJyxcbiAgICAweDJDMDE6ICdhci1KTycsXG4gICAgMHgzNDAxOiAnYXItS1cnLFxuICAgIDB4MzAwMTogJ2FyLUxCJyxcbiAgICAweDEwMDE6ICdhci1MWScsXG4gICAgMHgxODAxOiAnYXJ5JyxcbiAgICAweDIwMDE6ICdhci1PTScsXG4gICAgMHg0MDAxOiAnYXItUUEnLFxuICAgIDB4MDQwMTogJ2FyLVNBJyxcbiAgICAweDI4MDE6ICdhci1TWScsXG4gICAgMHgxQzAxOiAnYWViJyxcbiAgICAweDM4MDE6ICdhci1BRScsXG4gICAgMHgyNDAxOiAnYXItWUUnLFxuICAgIDB4MDQyQjogJ2h5JyxcbiAgICAweDA0NEQ6ICdhcycsXG4gICAgMHgwODJDOiAnYXotQ3lybCcsXG4gICAgMHgwNDJDOiAnYXonLFxuICAgIDB4MDQ2RDogJ2JhJyxcbiAgICAweDA0MkQ6ICdldScsXG4gICAgMHgwNDIzOiAnYmUnLFxuICAgIDB4MDg0NTogJ2JuJyxcbiAgICAweDA0NDU6ICdibi1JTicsXG4gICAgMHgyMDFBOiAnYnMtQ3lybCcsXG4gICAgMHgxNDFBOiAnYnMnLFxuICAgIDB4MDQ3RTogJ2JyJyxcbiAgICAweDA0MDI6ICdiZycsXG4gICAgMHgwNDAzOiAnY2EnLFxuICAgIDB4MEMwNDogJ3poLUhLJyxcbiAgICAweDE0MDQ6ICd6aC1NTycsXG4gICAgMHgwODA0OiAnemgnLFxuICAgIDB4MTAwNDogJ3poLVNHJyxcbiAgICAweDA0MDQ6ICd6aC1UVycsXG4gICAgMHgwNDgzOiAnY28nLFxuICAgIDB4MDQxQTogJ2hyJyxcbiAgICAweDEwMUE6ICdoci1CQScsXG4gICAgMHgwNDA1OiAnY3MnLFxuICAgIDB4MDQwNjogJ2RhJyxcbiAgICAweDA0OEM6ICdwcnMnLFxuICAgIDB4MDQ2NTogJ2R2JyxcbiAgICAweDA4MTM6ICdubC1CRScsXG4gICAgMHgwNDEzOiAnbmwnLFxuICAgIDB4MEMwOTogJ2VuLUFVJyxcbiAgICAweDI4MDk6ICdlbi1CWicsXG4gICAgMHgxMDA5OiAnZW4tQ0EnLFxuICAgIDB4MjQwOTogJ2VuLTAyOScsXG4gICAgMHg0MDA5OiAnZW4tSU4nLFxuICAgIDB4MTgwOTogJ2VuLUlFJyxcbiAgICAweDIwMDk6ICdlbi1KTScsXG4gICAgMHg0NDA5OiAnZW4tTVknLFxuICAgIDB4MTQwOTogJ2VuLU5aJyxcbiAgICAweDM0MDk6ICdlbi1QSCcsXG4gICAgMHg0ODA5OiAnZW4tU0cnLFxuICAgIDB4MUMwOTogJ2VuLVpBJyxcbiAgICAweDJDMDk6ICdlbi1UVCcsXG4gICAgMHgwODA5OiAnZW4tR0InLFxuICAgIDB4MDQwOTogJ2VuJyxcbiAgICAweDMwMDk6ICdlbi1aVycsXG4gICAgMHgwNDI1OiAnZXQnLFxuICAgIDB4MDQzODogJ2ZvJyxcbiAgICAweDA0NjQ6ICdmaWwnLFxuICAgIDB4MDQwQjogJ2ZpJyxcbiAgICAweDA4MEM6ICdmci1CRScsXG4gICAgMHgwQzBDOiAnZnItQ0EnLFxuICAgIDB4MDQwQzogJ2ZyJyxcbiAgICAweDE0MEM6ICdmci1MVScsXG4gICAgMHgxODBDOiAnZnItTUMnLFxuICAgIDB4MTAwQzogJ2ZyLUNIJyxcbiAgICAweDA0NjI6ICdmeScsXG4gICAgMHgwNDU2OiAnZ2wnLFxuICAgIDB4MDQzNzogJ2thJyxcbiAgICAweDBDMDc6ICdkZS1BVCcsXG4gICAgMHgwNDA3OiAnZGUnLFxuICAgIDB4MTQwNzogJ2RlLUxJJyxcbiAgICAweDEwMDc6ICdkZS1MVScsXG4gICAgMHgwODA3OiAnZGUtQ0gnLFxuICAgIDB4MDQwODogJ2VsJyxcbiAgICAweDA0NkY6ICdrbCcsXG4gICAgMHgwNDQ3OiAnZ3UnLFxuICAgIDB4MDQ2ODogJ2hhJyxcbiAgICAweDA0MEQ6ICdoZScsXG4gICAgMHgwNDM5OiAnaGknLFxuICAgIDB4MDQwRTogJ2h1JyxcbiAgICAweDA0MEY6ICdpcycsXG4gICAgMHgwNDcwOiAnaWcnLFxuICAgIDB4MDQyMTogJ2lkJyxcbiAgICAweDA0NUQ6ICdpdScsXG4gICAgMHgwODVEOiAnaXUtTGF0bicsXG4gICAgMHgwODNDOiAnZ2EnLFxuICAgIDB4MDQzNDogJ3hoJyxcbiAgICAweDA0MzU6ICd6dScsXG4gICAgMHgwNDEwOiAnaXQnLFxuICAgIDB4MDgxMDogJ2l0LUNIJyxcbiAgICAweDA0MTE6ICdqYScsXG4gICAgMHgwNDRCOiAna24nLFxuICAgIDB4MDQzRjogJ2trJyxcbiAgICAweDA0NTM6ICdrbScsXG4gICAgMHgwNDg2OiAncXVjJyxcbiAgICAweDA0ODc6ICdydycsXG4gICAgMHgwNDQxOiAnc3cnLFxuICAgIDB4MDQ1NzogJ2tvaycsXG4gICAgMHgwNDEyOiAna28nLFxuICAgIDB4MDQ0MDogJ2t5JyxcbiAgICAweDA0NTQ6ICdsbycsXG4gICAgMHgwNDI2OiAnbHYnLFxuICAgIDB4MDQyNzogJ2x0JyxcbiAgICAweDA4MkU6ICdkc2InLFxuICAgIDB4MDQ2RTogJ2xiJyxcbiAgICAweDA0MkY6ICdtaycsXG4gICAgMHgwODNFOiAnbXMtQk4nLFxuICAgIDB4MDQzRTogJ21zJyxcbiAgICAweDA0NEM6ICdtbCcsXG4gICAgMHgwNDNBOiAnbXQnLFxuICAgIDB4MDQ4MTogJ21pJyxcbiAgICAweDA0N0E6ICdhcm4nLFxuICAgIDB4MDQ0RTogJ21yJyxcbiAgICAweDA0N0M6ICdtb2gnLFxuICAgIDB4MDQ1MDogJ21uJyxcbiAgICAweDA4NTA6ICdtbi1DTicsXG4gICAgMHgwNDYxOiAnbmUnLFxuICAgIDB4MDQxNDogJ25iJyxcbiAgICAweDA4MTQ6ICdubicsXG4gICAgMHgwNDgyOiAnb2MnLFxuICAgIDB4MDQ0ODogJ29yJyxcbiAgICAweDA0NjM6ICdwcycsXG4gICAgMHgwNDE1OiAncGwnLFxuICAgIDB4MDQxNjogJ3B0JyxcbiAgICAweDA4MTY6ICdwdC1QVCcsXG4gICAgMHgwNDQ2OiAncGEnLFxuICAgIDB4MDQ2QjogJ3F1LUJPJyxcbiAgICAweDA4NkI6ICdxdS1FQycsXG4gICAgMHgwQzZCOiAncXUnLFxuICAgIDB4MDQxODogJ3JvJyxcbiAgICAweDA0MTc6ICdybScsXG4gICAgMHgwNDE5OiAncnUnLFxuICAgIDB4MjQzQjogJ3NtbicsXG4gICAgMHgxMDNCOiAnc21qLU5PJyxcbiAgICAweDE0M0I6ICdzbWonLFxuICAgIDB4MEMzQjogJ3NlLUZJJyxcbiAgICAweDA0M0I6ICdzZScsXG4gICAgMHgwODNCOiAnc2UtU0UnLFxuICAgIDB4MjAzQjogJ3NtcycsXG4gICAgMHgxODNCOiAnc21hLU5PJyxcbiAgICAweDFDM0I6ICdzbXMnLFxuICAgIDB4MDQ0RjogJ3NhJyxcbiAgICAweDFDMUE6ICdzci1DeXJsLUJBJyxcbiAgICAweDBDMUE6ICdzcicsXG4gICAgMHgxODFBOiAnc3ItTGF0bi1CQScsXG4gICAgMHgwODFBOiAnc3ItTGF0bicsXG4gICAgMHgwNDZDOiAnbnNvJyxcbiAgICAweDA0MzI6ICd0bicsXG4gICAgMHgwNDVCOiAnc2knLFxuICAgIDB4MDQxQjogJ3NrJyxcbiAgICAweDA0MjQ6ICdzbCcsXG4gICAgMHgyQzBBOiAnZXMtQVInLFxuICAgIDB4NDAwQTogJ2VzLUJPJyxcbiAgICAweDM0MEE6ICdlcy1DTCcsXG4gICAgMHgyNDBBOiAnZXMtQ08nLFxuICAgIDB4MTQwQTogJ2VzLUNSJyxcbiAgICAweDFDMEE6ICdlcy1ETycsXG4gICAgMHgzMDBBOiAnZXMtRUMnLFxuICAgIDB4NDQwQTogJ2VzLVNWJyxcbiAgICAweDEwMEE6ICdlcy1HVCcsXG4gICAgMHg0ODBBOiAnZXMtSE4nLFxuICAgIDB4MDgwQTogJ2VzLU1YJyxcbiAgICAweDRDMEE6ICdlcy1OSScsXG4gICAgMHgxODBBOiAnZXMtUEEnLFxuICAgIDB4M0MwQTogJ2VzLVBZJyxcbiAgICAweDI4MEE6ICdlcy1QRScsXG4gICAgMHg1MDBBOiAnZXMtUFInLFxuXG4gICAgLy8gTWljcm9zb2Z0IGhhcyBkZWZpbmVkIHR3byBkaWZmZXJlbnQgbGFuZ3VhZ2UgY29kZXMgZm9yXG4gICAgLy8g4oCcU3BhbmlzaCB3aXRoIG1vZGVybiBzb3J0aW5n4oCdIGFuZCDigJxTcGFuaXNoIHdpdGggdHJhZGl0aW9uYWxcbiAgICAvLyBzb3J0aW5n4oCdLiBUaGlzIG1ha2VzIHNlbnNlIGZvciBjb2xsYXRpb24gQVBJcywgYW5kIGl0IHdvdWxkIGJlXG4gICAgLy8gcG9zc2libGUgdG8gZXhwcmVzcyB0aGlzIGluIEJDUCA0NyBsYW5ndWFnZSB0YWdzIHZpYSBVbmljb2RlXG4gICAgLy8gZXh0ZW5zaW9ucyAoZWcuLCBlcy11LWNvLXRyYWQgaXMgU3BhbmlzaCB3aXRoIHRyYWRpdGlvbmFsXG4gICAgLy8gc29ydGluZykuIEhvd2V2ZXIsIGZvciBzdG9yaW5nIG5hbWVzIGluIGZvbnRzLCB0aGUgZGlzdGluY3Rpb25cbiAgICAvLyBkb2VzIG5vdCBtYWtlIHNlbnNlLCBzbyB3ZSBnaXZlIOKAnGVz4oCdIGluIGJvdGggY2FzZXMuXG4gICAgMHgwQzBBOiAnZXMnLFxuICAgIDB4MDQwQTogJ2VzJyxcblxuICAgIDB4NTQwQTogJ2VzLVVTJyxcbiAgICAweDM4MEE6ICdlcy1VWScsXG4gICAgMHgyMDBBOiAnZXMtVkUnLFxuICAgIDB4MDgxRDogJ3N2LUZJJyxcbiAgICAweDA0MUQ6ICdzdicsXG4gICAgMHgwNDVBOiAnc3lyJyxcbiAgICAweDA0Mjg6ICd0ZycsXG4gICAgMHgwODVGOiAndHptJyxcbiAgICAweDA0NDk6ICd0YScsXG4gICAgMHgwNDQ0OiAndHQnLFxuICAgIDB4MDQ0QTogJ3RlJyxcbiAgICAweDA0MUU6ICd0aCcsXG4gICAgMHgwNDUxOiAnYm8nLFxuICAgIDB4MDQxRjogJ3RyJyxcbiAgICAweDA0NDI6ICd0aycsXG4gICAgMHgwNDgwOiAndWcnLFxuICAgIDB4MDQyMjogJ3VrJyxcbiAgICAweDA0MkU6ICdoc2InLFxuICAgIDB4MDQyMDogJ3VyJyxcbiAgICAweDA4NDM6ICd1ei1DeXJsJyxcbiAgICAweDA0NDM6ICd1eicsXG4gICAgMHgwNDJBOiAndmknLFxuICAgIDB4MDQ1MjogJ2N5JyxcbiAgICAweDA0ODg6ICd3bycsXG4gICAgMHgwNDg1OiAnc2FoJyxcbiAgICAweDA0Nzg6ICdpaScsXG4gICAgMHgwNDZBOiAneW8nXG59O1xuXG4vLyBSZXR1cm5zIGEgSUVURiBCQ1AgNDcgbGFuZ3VhZ2UgY29kZSwgZm9yIGV4YW1wbGUgJ3poLUhhbnQnXG4vLyBmb3IgJ0NoaW5lc2UgaW4gdGhlIHRyYWRpdGlvbmFsIHNjcmlwdCcuXG5mdW5jdGlvbiBnZXRMYW5ndWFnZUNvZGUocGxhdGZvcm1JRCwgbGFuZ3VhZ2VJRCwgbHRhZykge1xuICAgIHN3aXRjaCAocGxhdGZvcm1JRCkge1xuICAgICAgICBjYXNlIDA6ICAvLyBVbmljb2RlXG4gICAgICAgICAgICBpZiAobGFuZ3VhZ2VJRCA9PT0gMHhGRkZGKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd1bmQnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsdGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGx0YWdbbGFuZ3VhZ2VJRF07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTogIC8vIE1hY2ludG9zaFxuICAgICAgICAgICAgcmV0dXJuIG1hY0xhbmd1YWdlc1tsYW5ndWFnZUlEXTtcblxuICAgICAgICBjYXNlIDM6ICAvLyBXaW5kb3dzXG4gICAgICAgICAgICByZXR1cm4gd2luZG93c0xhbmd1YWdlc1tsYW5ndWFnZUlEXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG52YXIgdXRmMTYgPSAndXRmLTE2JztcblxuLy8gTWFjT1Mgc2NyaXB0IElEIOKGkiBlbmNvZGluZy4gVGhpcyB0YWJsZSBzdG9yZXMgdGhlIGRlZmF1bHQgY2FzZSxcbi8vIHdoaWNoIGNhbiBiZSBvdmVycmlkZGVuIGJ5IG1hY0xhbmd1YWdlRW5jb2RpbmdzLlxudmFyIG1hY1NjcmlwdEVuY29kaW5ncyA9IHtcbiAgICAwOiAnbWFjaW50b3NoJywgICAgICAgICAgIC8vIHNtUm9tYW5cbiAgICAxOiAneC1tYWMtamFwYW5lc2UnLCAgICAgIC8vIHNtSmFwYW5lc2VcbiAgICAyOiAneC1tYWMtY2hpbmVzZXRyYWQnLCAgIC8vIHNtVHJhZENoaW5lc2VcbiAgICAzOiAneC1tYWMta29yZWFuJywgICAgICAgIC8vIHNtS29yZWFuXG4gICAgNjogJ3gtbWFjLWdyZWVrJywgICAgICAgICAvLyBzbUdyZWVrXG4gICAgNzogJ3gtbWFjLWN5cmlsbGljJywgICAgICAvLyBzbUN5cmlsbGljXG4gICAgOTogJ3gtbWFjLWRldmFuYWdhaScsICAgICAvLyBzbURldmFuYWdhcmlcbiAgICAxMDogJ3gtbWFjLWd1cm11a2hpJywgICAgIC8vIHNtR3VybXVraGlcbiAgICAxMTogJ3gtbWFjLWd1amFyYXRpJywgICAgIC8vIHNtR3VqYXJhdGlcbiAgICAxMjogJ3gtbWFjLW9yaXlhJywgICAgICAgIC8vIHNtT3JpeWFcbiAgICAxMzogJ3gtbWFjLWJlbmdhbGknLCAgICAgIC8vIHNtQmVuZ2FsaVxuICAgIDE0OiAneC1tYWMtdGFtaWwnLCAgICAgICAgLy8gc21UYW1pbFxuICAgIDE1OiAneC1tYWMtdGVsdWd1JywgICAgICAgLy8gc21UZWx1Z3VcbiAgICAxNjogJ3gtbWFjLWthbm5hZGEnLCAgICAgIC8vIHNtS2FubmFkYVxuICAgIDE3OiAneC1tYWMtbWFsYXlhbGFtJywgICAgLy8gc21NYWxheWFsYW1cbiAgICAxODogJ3gtbWFjLXNpbmhhbGVzZScsICAgIC8vIHNtU2luaGFsZXNlXG4gICAgMTk6ICd4LW1hYy1idXJtZXNlJywgICAgICAvLyBzbUJ1cm1lc2VcbiAgICAyMDogJ3gtbWFjLWtobWVyJywgICAgICAgIC8vIHNtS2htZXJcbiAgICAyMTogJ3gtbWFjLXRoYWknLCAgICAgICAgIC8vIHNtVGhhaVxuICAgIDIyOiAneC1tYWMtbGFvJywgICAgICAgICAgLy8gc21MYW9cbiAgICAyMzogJ3gtbWFjLWdlb3JnaWFuJywgICAgIC8vIHNtR2VvcmdpYW5cbiAgICAyNDogJ3gtbWFjLWFybWVuaWFuJywgICAgIC8vIHNtQXJtZW5pYW5cbiAgICAyNTogJ3gtbWFjLWNoaW5lc2VzaW1wJywgIC8vIHNtU2ltcENoaW5lc2VcbiAgICAyNjogJ3gtbWFjLXRpYmV0YW4nLCAgICAgIC8vIHNtVGliZXRhblxuICAgIDI3OiAneC1tYWMtbW9uZ29saWFuJywgICAgLy8gc21Nb25nb2xpYW5cbiAgICAyODogJ3gtbWFjLWV0aGlvcGljJywgICAgIC8vIHNtRXRoaW9waWNcbiAgICAyOTogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIHNtQ2VudHJhbEV1cm9Sb21hblxuICAgIDMwOiAneC1tYWMtdmlldG5hbWVzZScsICAgLy8gc21WaWV0bmFtZXNlXG4gICAgMzE6ICd4LW1hYy1leHRhcmFiaWMnICAgICAvLyBzbUV4dEFyYWJpY1xufTtcblxuLy8gTWFjT1MgbGFuZ3VhZ2UgSUQg4oaSIGVuY29kaW5nLiBUaGlzIHRhYmxlIHN0b3JlcyB0aGUgZXhjZXB0aW9uYWxcbi8vIGNhc2VzLCB3aGljaCBvdmVycmlkZSBtYWNTY3JpcHRFbmNvZGluZ3MuIEZvciB3cml0aW5nIE1hY09TIG5hbWluZ1xuLy8gdGFibGVzLCB3ZSBuZWVkIHRvIGVtaXQgYSBNYWNPUyBzY3JpcHQgSUQuIFRoZXJlZm9yZSwgd2UgY2Fubm90XG4vLyBtZXJnZSBtYWNTY3JpcHRFbmNvZGluZ3MgaW50byBtYWNMYW5ndWFnZUVuY29kaW5ncy5cbi8vXG4vLyBodHRwOi8vdW5pY29kZS5vcmcvUHVibGljL01BUFBJTkdTL1ZFTkRPUlMvQVBQTEUvUmVhZG1lLnR4dFxudmFyIG1hY0xhbmd1YWdlRW5jb2RpbmdzID0ge1xuICAgIDE1OiAneC1tYWMtaWNlbGFuZGljJywgICAgLy8gbGFuZ0ljZWxhbmRpY1xuICAgIDE3OiAneC1tYWMtdHVya2lzaCcsICAgICAgLy8gbGFuZ1R1cmtpc2hcbiAgICAxODogJ3gtbWFjLWNyb2F0aWFuJywgICAgIC8vIGxhbmdDcm9hdGlhblxuICAgIDI0OiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gbGFuZ0xpdGh1YW5pYW5cbiAgICAyNTogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdQb2xpc2hcbiAgICAyNjogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdIdW5nYXJpYW5cbiAgICAyNzogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdFc3RvbmlhblxuICAgIDI4OiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gbGFuZ0xhdHZpYW5cbiAgICAzMDogJ3gtbWFjLWljZWxhbmRpYycsICAgIC8vIGxhbmdGYXJvZXNlXG4gICAgMzc6ICd4LW1hYy1yb21hbmlhbicsICAgICAvLyBsYW5nUm9tYW5pYW5cbiAgICAzODogJ3gtbWFjLWNlJywgICAgICAgICAgIC8vIGxhbmdDemVjaFxuICAgIDM5OiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gbGFuZ1Nsb3Zha1xuICAgIDQwOiAneC1tYWMtY2UnLCAgICAgICAgICAgLy8gbGFuZ1Nsb3ZlbmlhblxuICAgIDE0MzogJ3gtbWFjLWludWl0JywgICAgICAgLy8gbGFuZ0ludWt0aXR1dFxuICAgIDE0NjogJ3gtbWFjLWdhZWxpYycgICAgICAgLy8gbGFuZ0lyaXNoR2FlbGljU2NyaXB0XG59O1xuXG5mdW5jdGlvbiBnZXRFbmNvZGluZyhwbGF0Zm9ybUlELCBlbmNvZGluZ0lELCBsYW5ndWFnZUlEKSB7XG4gICAgc3dpdGNoIChwbGF0Zm9ybUlEKSB7XG4gICAgICAgIGNhc2UgMDogIC8vIFVuaWNvZGVcbiAgICAgICAgICAgIHJldHVybiB1dGYxNjtcblxuICAgICAgICBjYXNlIDE6ICAvLyBBcHBsZSBNYWNpbnRvc2hcbiAgICAgICAgICAgIHJldHVybiBtYWNMYW5ndWFnZUVuY29kaW5nc1tsYW5ndWFnZUlEXSB8fCBtYWNTY3JpcHRFbmNvZGluZ3NbZW5jb2RpbmdJRF07XG5cbiAgICAgICAgY2FzZSAzOiAgLy8gTWljcm9zb2Z0IFdpbmRvd3NcbiAgICAgICAgICAgIGlmIChlbmNvZGluZ0lEID09PSAxIHx8IGVuY29kaW5nSUQgPT09IDEwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0ZjE2O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vLyBQYXJzZSB0aGUgbmFtaW5nIGBuYW1lYCB0YWJsZS5cbi8vIEZJWE1FOiBGb3JtYXQgMSBhZGRpdGlvbmFsIGZpZWxkcyBhcmUgbm90IHN1cHBvcnRlZCB5ZXQuXG4vLyBsdGFnIGlzIHRoZSBjb250ZW50IG9mIHRoZSBgbHRhZycgdGFibGUsIHN1Y2ggYXMgWydlbicsICd6aC1IYW5zJywgJ2RlLUNILTE5MDQnXS5cbmZ1bmN0aW9uIHBhcnNlTmFtZVRhYmxlKGRhdGEsIHN0YXJ0LCBsdGFnKSB7XG4gICAgdmFyIG5hbWUgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciBmb3JtYXQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGNvdW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIHZhciBzdHJpbmdPZmZzZXQgPSBwLm9mZnNldCArIHAucGFyc2VVU2hvcnQoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHBsYXRmb3JtSUQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBlbmNvZGluZ0lEID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgbGFuZ3VhZ2VJRCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIG5hbWVJRCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gbmFtZVRhYmxlTmFtZXNbbmFtZUlEXSB8fCBuYW1lSUQ7XG4gICAgICAgIHZhciBieXRlTGVuZ3RoID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgbGFuZ3VhZ2UgPSBnZXRMYW5ndWFnZUNvZGUocGxhdGZvcm1JRCwgbGFuZ3VhZ2VJRCwgbHRhZyk7XG4gICAgICAgIHZhciBlbmNvZGluZyA9IGdldEVuY29kaW5nKHBsYXRmb3JtSUQsIGVuY29kaW5nSUQsIGxhbmd1YWdlSUQpO1xuICAgICAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiBsYW5ndWFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgdGV4dCA9ICh2b2lkIDApO1xuICAgICAgICAgICAgaWYgKGVuY29kaW5nID09PSB1dGYxNikge1xuICAgICAgICAgICAgICAgIHRleHQgPSBkZWNvZGUuVVRGMTYoZGF0YSwgc3RyaW5nT2Zmc2V0ICsgb2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGRlY29kZS5NQUNTVFJJTkcoZGF0YSwgc3RyaW5nT2Zmc2V0ICsgb2Zmc2V0LCBieXRlTGVuZ3RoLCBlbmNvZGluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0aW9ucyA9IG5hbWVbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbnMgPSBuYW1lW3Byb3BlcnR5XSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uc1tsYW5ndWFnZV0gPSB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmdUYWdDb3VudCA9IDA7XG4gICAgaWYgKGZvcm1hdCA9PT0gMSkge1xuICAgICAgICAvLyBGSVhNRTogQWxzbyBoYW5kbGUgTWljcm9zb2Z0J3MgJ25hbWUnIHRhYmxlIDEuXG4gICAgICAgIGxhbmdUYWdDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmFtZTtcbn1cblxuLy8gezIzOiAnZm9vJ30g4oaSIHsnZm9vJzogMjN9XG4vLyBbJ2JhcicsICdiYXonXSDihpIgeydiYXInOiAwLCAnYmF6JzogMX1cbmZ1bmN0aW9uIHJldmVyc2VEaWN0KGRpY3QpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIGRpY3QpIHtcbiAgICAgICAgcmVzdWx0W2RpY3Rba2V5XV0gPSBwYXJzZUludChrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VOYW1lUmVjb3JkKHBsYXRmb3JtSUQsIGVuY29kaW5nSUQsIGxhbmd1YWdlSUQsIG5hbWVJRCwgbGVuZ3RoLCBvZmZzZXQpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlJlY29yZCgnTmFtZVJlY29yZCcsIFtcbiAgICAgICAge25hbWU6ICdwbGF0Zm9ybUlEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBwbGF0Zm9ybUlEfSxcbiAgICAgICAge25hbWU6ICdlbmNvZGluZ0lEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBlbmNvZGluZ0lEfSxcbiAgICAgICAge25hbWU6ICdsYW5ndWFnZUlEJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsYW5ndWFnZUlEfSxcbiAgICAgICAge25hbWU6ICduYW1lSUQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IG5hbWVJRH0sXG4gICAgICAgIHtuYW1lOiAnbGVuZ3RoJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBsZW5ndGh9LFxuICAgICAgICB7bmFtZTogJ29mZnNldCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogb2Zmc2V0fVxuICAgIF0pO1xufVxuXG4vLyBGaW5kcyB0aGUgcG9zaXRpb24gb2YgbmVlZGxlIGluIGhheXN0YWNrLCBvciAtMSBpZiBub3QgdGhlcmUuXG4vLyBMaWtlIFN0cmluZy5pbmRleE9mKCksIGJ1dCBmb3IgYXJyYXlzLlxuZnVuY3Rpb24gZmluZFN1YkFycmF5KG5lZWRsZSwgaGF5c3RhY2spIHtcbiAgICB2YXIgbmVlZGxlTGVuZ3RoID0gbmVlZGxlLmxlbmd0aDtcbiAgICB2YXIgbGltaXQgPSBoYXlzdGFjay5sZW5ndGggLSBuZWVkbGVMZW5ndGggKyAxO1xuXG4gICAgbG9vcDpcbiAgICBmb3IgKHZhciBwb3MgPSAwOyBwb3MgPCBsaW1pdDsgcG9zKyspIHtcbiAgICAgICAgZm9yICg7IHBvcyA8IGxpbWl0OyBwb3MrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuZWVkbGVMZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIGlmIChoYXlzdGFja1twb3MgKyBrXSAhPT0gbmVlZGxlW2tdKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGxvb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xufVxuXG5mdW5jdGlvbiBhZGRTdHJpbmdUb1Bvb2wocywgcG9vbCkge1xuICAgIHZhciBvZmZzZXQgPSBmaW5kU3ViQXJyYXkocywgcG9vbCk7XG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gcG9vbC5sZW5ndGg7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IHMubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBwb29sLnB1c2goc1tpXSk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VOYW1lVGFibGUobmFtZXMsIGx0YWcpIHtcbiAgICB2YXIgbmFtZUlEO1xuICAgIHZhciBuYW1lSURzID0gW107XG5cbiAgICB2YXIgbmFtZXNXaXRoTnVtZXJpY0tleXMgPSB7fTtcbiAgICB2YXIgbmFtZVRhYmxlSWRzID0gcmV2ZXJzZURpY3QobmFtZVRhYmxlTmFtZXMpO1xuICAgIGZvciAodmFyIGtleSBpbiBuYW1lcykge1xuICAgICAgICB2YXIgaWQgPSBuYW1lVGFibGVJZHNba2V5XTtcbiAgICAgICAgaWYgKGlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlkID0ga2V5O1xuICAgICAgICB9XG5cbiAgICAgICAgbmFtZUlEID0gcGFyc2VJbnQoaWQpO1xuXG4gICAgICAgIGlmIChpc05hTihuYW1lSUQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05hbWUgdGFibGUgZW50cnkgXCInICsga2V5ICsgJ1wiIGRvZXMgbm90IGV4aXN0LCBzZWUgbmFtZVRhYmxlTmFtZXMgZm9yIGNvbXBsZXRlIGxpc3QuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lc1dpdGhOdW1lcmljS2V5c1tuYW1lSURdID0gbmFtZXNba2V5XTtcbiAgICAgICAgbmFtZUlEcy5wdXNoKG5hbWVJRCk7XG4gICAgfVxuXG4gICAgdmFyIG1hY0xhbmd1YWdlSWRzID0gcmV2ZXJzZURpY3QobWFjTGFuZ3VhZ2VzKTtcbiAgICB2YXIgd2luZG93c0xhbmd1YWdlSWRzID0gcmV2ZXJzZURpY3Qod2luZG93c0xhbmd1YWdlcyk7XG5cbiAgICB2YXIgbmFtZVJlY29yZHMgPSBbXTtcbiAgICB2YXIgc3RyaW5nUG9vbCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5hbWVJRCA9IG5hbWVJRHNbaV07XG4gICAgICAgIHZhciB0cmFuc2xhdGlvbnMgPSBuYW1lc1dpdGhOdW1lcmljS2V5c1tuYW1lSURdO1xuICAgICAgICBmb3IgKHZhciBsYW5nIGluIHRyYW5zbGF0aW9ucykge1xuICAgICAgICAgICAgdmFyIHRleHQgPSB0cmFuc2xhdGlvbnNbbGFuZ107XG5cbiAgICAgICAgICAgIC8vIEZvciBNYWNPUywgd2UgdHJ5IHRvIGVtaXQgdGhlIG5hbWUgaW4gdGhlIGZvcm0gdGhhdCB3YXMgaW50cm9kdWNlZFxuICAgICAgICAgICAgLy8gaW4gdGhlIGluaXRpYWwgdmVyc2lvbiBvZiB0aGUgVHJ1ZVR5cGUgc3BlYyAoaW4gdGhlIGxhdGUgMTk4MHMpLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgdGhpcyBjYW4gZmFpbCBmb3IgdmFyaW91cyByZWFzb25zOiB0aGUgcmVxdWVzdGVkIEJDUCA0N1xuICAgICAgICAgICAgLy8gbGFuZ3VhZ2UgY29kZSBtaWdodCBub3QgaGF2ZSBhbiBvbGQtc3R5bGUgTWFjIGVxdWl2YWxlbnQ7XG4gICAgICAgICAgICAvLyB3ZSBtaWdodCBub3QgaGF2ZSBhIGNvZGVjIGZvciB0aGUgbmVlZGVkIGNoYXJhY3RlciBlbmNvZGluZztcbiAgICAgICAgICAgIC8vIG9yIHRoZSBuYW1lIG1pZ2h0IGNvbnRhaW4gY2hhcmFjdGVycyB0aGF0IGNhbm5vdCBiZSBleHByZXNzZWRcbiAgICAgICAgICAgIC8vIGluIHRoZSBvbGQtc3R5bGUgTWFjaW50b3NoIGVuY29kaW5nLiBJbiBjYXNlIG9mIGZhaWx1cmUsIHdlIGVtaXRcbiAgICAgICAgICAgIC8vIHRoZSBuYW1lIGluIGEgbW9yZSBtb2Rlcm4gZmFzaGlvbiAoVW5pY29kZSBlbmNvZGluZyB3aXRoIEJDUCA0N1xuICAgICAgICAgICAgLy8gbGFuZ3VhZ2UgdGFncykgdGhhdCBpcyByZWNvZ25pemVkIGJ5IE1hY09TIDEwLjUsIHJlbGVhc2VkIGluIDIwMDkuXG4gICAgICAgICAgICAvLyBJZiBmb250cyB3ZXJlIG9ubHkgcmVhZCBieSBvcGVyYXRpbmcgc3lzdGVtcywgd2UgY291bGQgc2ltcGx5XG4gICAgICAgICAgICAvLyBlbWl0IGFsbCBuYW1lcyBpbiB0aGUgbW9kZXJuIGZvcm07IHRoaXMgd291bGQgYmUgbXVjaCBlYXNpZXIuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCB0aGVyZSBhcmUgbWFueSBhcHBsaWNhdGlvbnMgYW5kIGxpYnJhcmllcyB0aGF0IHJlYWRcbiAgICAgICAgICAgIC8vICduYW1lJyB0YWJsZXMgZGlyZWN0bHksIGFuZCB0aGVzZSB3aWxsIHVzdWFsbHkgb25seSByZWNvZ25pemVcbiAgICAgICAgICAgIC8vIHRoZSBhbmNpZW50IGZvcm0gKHNpbGVudGx5IHNraXBwaW5nIHRoZSB1bnJlY29nbml6ZWQgbmFtZXMpLlxuICAgICAgICAgICAgdmFyIG1hY1BsYXRmb3JtID0gMTsgIC8vIE1hY2ludG9zaFxuICAgICAgICAgICAgdmFyIG1hY0xhbmd1YWdlID0gbWFjTGFuZ3VhZ2VJZHNbbGFuZ107XG4gICAgICAgICAgICB2YXIgbWFjU2NyaXB0ID0gbWFjTGFuZ3VhZ2VUb1NjcmlwdFttYWNMYW5ndWFnZV07XG4gICAgICAgICAgICB2YXIgbWFjRW5jb2RpbmcgPSBnZXRFbmNvZGluZyhtYWNQbGF0Zm9ybSwgbWFjU2NyaXB0LCBtYWNMYW5ndWFnZSk7XG4gICAgICAgICAgICB2YXIgbWFjTmFtZSA9IGVuY29kZS5NQUNTVFJJTkcodGV4dCwgbWFjRW5jb2RpbmcpO1xuICAgICAgICAgICAgaWYgKG1hY05hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1hY1BsYXRmb3JtID0gMDsgIC8vIFVuaWNvZGVcbiAgICAgICAgICAgICAgICBtYWNMYW5ndWFnZSA9IGx0YWcuaW5kZXhPZihsYW5nKTtcbiAgICAgICAgICAgICAgICBpZiAobWFjTGFuZ3VhZ2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hY0xhbmd1YWdlID0gbHRhZy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGx0YWcucHVzaChsYW5nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtYWNTY3JpcHQgPSA0OyAgLy8gVW5pY29kZSAyLjAgYW5kIGxhdGVyXG4gICAgICAgICAgICAgICAgbWFjTmFtZSA9IGVuY29kZS5VVEYxNih0ZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG1hY05hbWVPZmZzZXQgPSBhZGRTdHJpbmdUb1Bvb2wobWFjTmFtZSwgc3RyaW5nUG9vbCk7XG4gICAgICAgICAgICBuYW1lUmVjb3Jkcy5wdXNoKG1ha2VOYW1lUmVjb3JkKG1hY1BsYXRmb3JtLCBtYWNTY3JpcHQsIG1hY0xhbmd1YWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lSUQsIG1hY05hbWUubGVuZ3RoLCBtYWNOYW1lT2Zmc2V0KSk7XG5cbiAgICAgICAgICAgIHZhciB3aW5MYW5ndWFnZSA9IHdpbmRvd3NMYW5ndWFnZUlkc1tsYW5nXTtcbiAgICAgICAgICAgIGlmICh3aW5MYW5ndWFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpbk5hbWUgPSBlbmNvZGUuVVRGMTYodGV4dCk7XG4gICAgICAgICAgICAgICAgdmFyIHdpbk5hbWVPZmZzZXQgPSBhZGRTdHJpbmdUb1Bvb2wod2luTmFtZSwgc3RyaW5nUG9vbCk7XG4gICAgICAgICAgICAgICAgbmFtZVJlY29yZHMucHVzaChtYWtlTmFtZVJlY29yZCgzLCAxLCB3aW5MYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVJRCwgd2luTmFtZS5sZW5ndGgsIHdpbk5hbWVPZmZzZXQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5hbWVSZWNvcmRzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICByZXR1cm4gKChhLnBsYXRmb3JtSUQgLSBiLnBsYXRmb3JtSUQpIHx8XG4gICAgICAgICAgICAgICAgKGEuZW5jb2RpbmdJRCAtIGIuZW5jb2RpbmdJRCkgfHxcbiAgICAgICAgICAgICAgICAoYS5sYW5ndWFnZUlEIC0gYi5sYW5ndWFnZUlEKSB8fFxuICAgICAgICAgICAgICAgIChhLm5hbWVJRCAtIGIubmFtZUlEKSk7XG4gICAgfSk7XG5cbiAgICB2YXIgdCA9IG5ldyB0YWJsZS5UYWJsZSgnbmFtZScsIFtcbiAgICAgICAge25hbWU6ICdmb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2NvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBuYW1lUmVjb3Jkcy5sZW5ndGh9LFxuICAgICAgICB7bmFtZTogJ3N0cmluZ09mZnNldCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogNiArIG5hbWVSZWNvcmRzLmxlbmd0aCAqIDEyfVxuICAgIF0pO1xuXG4gICAgZm9yICh2YXIgciA9IDA7IHIgPCBuYW1lUmVjb3Jkcy5sZW5ndGg7IHIrKykge1xuICAgICAgICB0LmZpZWxkcy5wdXNoKHtuYW1lOiAncmVjb3JkXycgKyByLCB0eXBlOiAnUkVDT1JEJywgdmFsdWU6IG5hbWVSZWNvcmRzW3JdfSk7XG4gICAgfVxuXG4gICAgdC5maWVsZHMucHVzaCh7bmFtZTogJ3N0cmluZ3MnLCB0eXBlOiAnTElURVJBTCcsIHZhbHVlOiBzdHJpbmdQb29sfSk7XG4gICAgcmV0dXJuIHQ7XG59XG5cbnZhciBfbmFtZSA9IHsgcGFyc2U6IHBhcnNlTmFtZVRhYmxlLCBtYWtlOiBtYWtlTmFtZVRhYmxlIH07XG5cbi8vIFRoZSBgT1MvMmAgdGFibGUgY29udGFpbnMgbWV0cmljcyByZXF1aXJlZCBpbiBPcGVuVHlwZSBmb250cy5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvb3MyLmh0bVxuXG52YXIgdW5pY29kZVJhbmdlcyA9IFtcbiAgICB7YmVnaW46IDB4MDAwMCwgZW5kOiAweDAwN0Z9LCAvLyBCYXNpYyBMYXRpblxuICAgIHtiZWdpbjogMHgwMDgwLCBlbmQ6IDB4MDBGRn0sIC8vIExhdGluLTEgU3VwcGxlbWVudFxuICAgIHtiZWdpbjogMHgwMTAwLCBlbmQ6IDB4MDE3Rn0sIC8vIExhdGluIEV4dGVuZGVkLUFcbiAgICB7YmVnaW46IDB4MDE4MCwgZW5kOiAweDAyNEZ9LCAvLyBMYXRpbiBFeHRlbmRlZC1CXG4gICAge2JlZ2luOiAweDAyNTAsIGVuZDogMHgwMkFGfSwgLy8gSVBBIEV4dGVuc2lvbnNcbiAgICB7YmVnaW46IDB4MDJCMCwgZW5kOiAweDAyRkZ9LCAvLyBTcGFjaW5nIE1vZGlmaWVyIExldHRlcnNcbiAgICB7YmVnaW46IDB4MDMwMCwgZW5kOiAweDAzNkZ9LCAvLyBDb21iaW5pbmcgRGlhY3JpdGljYWwgTWFya3NcbiAgICB7YmVnaW46IDB4MDM3MCwgZW5kOiAweDAzRkZ9LCAvLyBHcmVlayBhbmQgQ29wdGljXG4gICAge2JlZ2luOiAweDJDODAsIGVuZDogMHgyQ0ZGfSwgLy8gQ29wdGljXG4gICAge2JlZ2luOiAweDA0MDAsIGVuZDogMHgwNEZGfSwgLy8gQ3lyaWxsaWNcbiAgICB7YmVnaW46IDB4MDUzMCwgZW5kOiAweDA1OEZ9LCAvLyBBcm1lbmlhblxuICAgIHtiZWdpbjogMHgwNTkwLCBlbmQ6IDB4MDVGRn0sIC8vIEhlYnJld1xuICAgIHtiZWdpbjogMHhBNTAwLCBlbmQ6IDB4QTYzRn0sIC8vIFZhaVxuICAgIHtiZWdpbjogMHgwNjAwLCBlbmQ6IDB4MDZGRn0sIC8vIEFyYWJpY1xuICAgIHtiZWdpbjogMHgwN0MwLCBlbmQ6IDB4MDdGRn0sIC8vIE5Lb1xuICAgIHtiZWdpbjogMHgwOTAwLCBlbmQ6IDB4MDk3Rn0sIC8vIERldmFuYWdhcmlcbiAgICB7YmVnaW46IDB4MDk4MCwgZW5kOiAweDA5RkZ9LCAvLyBCZW5nYWxpXG4gICAge2JlZ2luOiAweDBBMDAsIGVuZDogMHgwQTdGfSwgLy8gR3VybXVraGlcbiAgICB7YmVnaW46IDB4MEE4MCwgZW5kOiAweDBBRkZ9LCAvLyBHdWphcmF0aVxuICAgIHtiZWdpbjogMHgwQjAwLCBlbmQ6IDB4MEI3Rn0sIC8vIE9yaXlhXG4gICAge2JlZ2luOiAweDBCODAsIGVuZDogMHgwQkZGfSwgLy8gVGFtaWxcbiAgICB7YmVnaW46IDB4MEMwMCwgZW5kOiAweDBDN0Z9LCAvLyBUZWx1Z3VcbiAgICB7YmVnaW46IDB4MEM4MCwgZW5kOiAweDBDRkZ9LCAvLyBLYW5uYWRhXG4gICAge2JlZ2luOiAweDBEMDAsIGVuZDogMHgwRDdGfSwgLy8gTWFsYXlhbGFtXG4gICAge2JlZ2luOiAweDBFMDAsIGVuZDogMHgwRTdGfSwgLy8gVGhhaVxuICAgIHtiZWdpbjogMHgwRTgwLCBlbmQ6IDB4MEVGRn0sIC8vIExhb1xuICAgIHtiZWdpbjogMHgxMEEwLCBlbmQ6IDB4MTBGRn0sIC8vIEdlb3JnaWFuXG4gICAge2JlZ2luOiAweDFCMDAsIGVuZDogMHgxQjdGfSwgLy8gQmFsaW5lc2VcbiAgICB7YmVnaW46IDB4MTEwMCwgZW5kOiAweDExRkZ9LCAvLyBIYW5ndWwgSmFtb1xuICAgIHtiZWdpbjogMHgxRTAwLCBlbmQ6IDB4MUVGRn0sIC8vIExhdGluIEV4dGVuZGVkIEFkZGl0aW9uYWxcbiAgICB7YmVnaW46IDB4MUYwMCwgZW5kOiAweDFGRkZ9LCAvLyBHcmVlayBFeHRlbmRlZFxuICAgIHtiZWdpbjogMHgyMDAwLCBlbmQ6IDB4MjA2Rn0sIC8vIEdlbmVyYWwgUHVuY3R1YXRpb25cbiAgICB7YmVnaW46IDB4MjA3MCwgZW5kOiAweDIwOUZ9LCAvLyBTdXBlcnNjcmlwdHMgQW5kIFN1YnNjcmlwdHNcbiAgICB7YmVnaW46IDB4MjBBMCwgZW5kOiAweDIwQ0Z9LCAvLyBDdXJyZW5jeSBTeW1ib2xcbiAgICB7YmVnaW46IDB4MjBEMCwgZW5kOiAweDIwRkZ9LCAvLyBDb21iaW5pbmcgRGlhY3JpdGljYWwgTWFya3MgRm9yIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MjEwMCwgZW5kOiAweDIxNEZ9LCAvLyBMZXR0ZXJsaWtlIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MjE1MCwgZW5kOiAweDIxOEZ9LCAvLyBOdW1iZXIgRm9ybXNcbiAgICB7YmVnaW46IDB4MjE5MCwgZW5kOiAweDIxRkZ9LCAvLyBBcnJvd3NcbiAgICB7YmVnaW46IDB4MjIwMCwgZW5kOiAweDIyRkZ9LCAvLyBNYXRoZW1hdGljYWwgT3BlcmF0b3JzXG4gICAge2JlZ2luOiAweDIzMDAsIGVuZDogMHgyM0ZGfSwgLy8gTWlzY2VsbGFuZW91cyBUZWNobmljYWxcbiAgICB7YmVnaW46IDB4MjQwMCwgZW5kOiAweDI0M0Z9LCAvLyBDb250cm9sIFBpY3R1cmVzXG4gICAge2JlZ2luOiAweDI0NDAsIGVuZDogMHgyNDVGfSwgLy8gT3B0aWNhbCBDaGFyYWN0ZXIgUmVjb2duaXRpb25cbiAgICB7YmVnaW46IDB4MjQ2MCwgZW5kOiAweDI0RkZ9LCAvLyBFbmNsb3NlZCBBbHBoYW51bWVyaWNzXG4gICAge2JlZ2luOiAweDI1MDAsIGVuZDogMHgyNTdGfSwgLy8gQm94IERyYXdpbmdcbiAgICB7YmVnaW46IDB4MjU4MCwgZW5kOiAweDI1OUZ9LCAvLyBCbG9jayBFbGVtZW50c1xuICAgIHtiZWdpbjogMHgyNUEwLCBlbmQ6IDB4MjVGRn0sIC8vIEdlb21ldHJpYyBTaGFwZXNcbiAgICB7YmVnaW46IDB4MjYwMCwgZW5kOiAweDI2RkZ9LCAvLyBNaXNjZWxsYW5lb3VzIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MjcwMCwgZW5kOiAweDI3QkZ9LCAvLyBEaW5nYmF0c1xuICAgIHtiZWdpbjogMHgzMDAwLCBlbmQ6IDB4MzAzRn0sIC8vIENKSyBTeW1ib2xzIEFuZCBQdW5jdHVhdGlvblxuICAgIHtiZWdpbjogMHgzMDQwLCBlbmQ6IDB4MzA5Rn0sIC8vIEhpcmFnYW5hXG4gICAge2JlZ2luOiAweDMwQTAsIGVuZDogMHgzMEZGfSwgLy8gS2F0YWthbmFcbiAgICB7YmVnaW46IDB4MzEwMCwgZW5kOiAweDMxMkZ9LCAvLyBCb3BvbW9mb1xuICAgIHtiZWdpbjogMHgzMTMwLCBlbmQ6IDB4MzE4Rn0sIC8vIEhhbmd1bCBDb21wYXRpYmlsaXR5IEphbW9cbiAgICB7YmVnaW46IDB4QTg0MCwgZW5kOiAweEE4N0Z9LCAvLyBQaGFncy1wYVxuICAgIHtiZWdpbjogMHgzMjAwLCBlbmQ6IDB4MzJGRn0sIC8vIEVuY2xvc2VkIENKSyBMZXR0ZXJzIEFuZCBNb250aHNcbiAgICB7YmVnaW46IDB4MzMwMCwgZW5kOiAweDMzRkZ9LCAvLyBDSksgQ29tcGF0aWJpbGl0eVxuICAgIHtiZWdpbjogMHhBQzAwLCBlbmQ6IDB4RDdBRn0sIC8vIEhhbmd1bCBTeWxsYWJsZXNcbiAgICB7YmVnaW46IDB4RDgwMCwgZW5kOiAweERGRkZ9LCAvLyBOb24tUGxhbmUgMCAqXG4gICAge2JlZ2luOiAweDEwOTAwLCBlbmQ6IDB4MTA5MUZ9LCAvLyBQaG9lbmljaWFcbiAgICB7YmVnaW46IDB4NEUwMCwgZW5kOiAweDlGRkZ9LCAvLyBDSksgVW5pZmllZCBJZGVvZ3JhcGhzXG4gICAge2JlZ2luOiAweEUwMDAsIGVuZDogMHhGOEZGfSwgLy8gUHJpdmF0ZSBVc2UgQXJlYSAocGxhbmUgMClcbiAgICB7YmVnaW46IDB4MzFDMCwgZW5kOiAweDMxRUZ9LCAvLyBDSksgU3Ryb2tlc1xuICAgIHtiZWdpbjogMHhGQjAwLCBlbmQ6IDB4RkI0Rn0sIC8vIEFscGhhYmV0aWMgUHJlc2VudGF0aW9uIEZvcm1zXG4gICAge2JlZ2luOiAweEZCNTAsIGVuZDogMHhGREZGfSwgLy8gQXJhYmljIFByZXNlbnRhdGlvbiBGb3Jtcy1BXG4gICAge2JlZ2luOiAweEZFMjAsIGVuZDogMHhGRTJGfSwgLy8gQ29tYmluaW5nIEhhbGYgTWFya3NcbiAgICB7YmVnaW46IDB4RkUxMCwgZW5kOiAweEZFMUZ9LCAvLyBWZXJ0aWNhbCBGb3Jtc1xuICAgIHtiZWdpbjogMHhGRTUwLCBlbmQ6IDB4RkU2Rn0sIC8vIFNtYWxsIEZvcm0gVmFyaWFudHNcbiAgICB7YmVnaW46IDB4RkU3MCwgZW5kOiAweEZFRkZ9LCAvLyBBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUJcbiAgICB7YmVnaW46IDB4RkYwMCwgZW5kOiAweEZGRUZ9LCAvLyBIYWxmd2lkdGggQW5kIEZ1bGx3aWR0aCBGb3Jtc1xuICAgIHtiZWdpbjogMHhGRkYwLCBlbmQ6IDB4RkZGRn0sIC8vIFNwZWNpYWxzXG4gICAge2JlZ2luOiAweDBGMDAsIGVuZDogMHgwRkZGfSwgLy8gVGliZXRhblxuICAgIHtiZWdpbjogMHgwNzAwLCBlbmQ6IDB4MDc0Rn0sIC8vIFN5cmlhY1xuICAgIHtiZWdpbjogMHgwNzgwLCBlbmQ6IDB4MDdCRn0sIC8vIFRoYWFuYVxuICAgIHtiZWdpbjogMHgwRDgwLCBlbmQ6IDB4MERGRn0sIC8vIFNpbmhhbGFcbiAgICB7YmVnaW46IDB4MTAwMCwgZW5kOiAweDEwOUZ9LCAvLyBNeWFubWFyXG4gICAge2JlZ2luOiAweDEyMDAsIGVuZDogMHgxMzdGfSwgLy8gRXRoaW9waWNcbiAgICB7YmVnaW46IDB4MTNBMCwgZW5kOiAweDEzRkZ9LCAvLyBDaGVyb2tlZVxuICAgIHtiZWdpbjogMHgxNDAwLCBlbmQ6IDB4MTY3Rn0sIC8vIFVuaWZpZWQgQ2FuYWRpYW4gQWJvcmlnaW5hbCBTeWxsYWJpY3NcbiAgICB7YmVnaW46IDB4MTY4MCwgZW5kOiAweDE2OUZ9LCAvLyBPZ2hhbVxuICAgIHtiZWdpbjogMHgxNkEwLCBlbmQ6IDB4MTZGRn0sIC8vIFJ1bmljXG4gICAge2JlZ2luOiAweDE3ODAsIGVuZDogMHgxN0ZGfSwgLy8gS2htZXJcbiAgICB7YmVnaW46IDB4MTgwMCwgZW5kOiAweDE4QUZ9LCAvLyBNb25nb2xpYW5cbiAgICB7YmVnaW46IDB4MjgwMCwgZW5kOiAweDI4RkZ9LCAvLyBCcmFpbGxlIFBhdHRlcm5zXG4gICAge2JlZ2luOiAweEEwMDAsIGVuZDogMHhBNDhGfSwgLy8gWWkgU3lsbGFibGVzXG4gICAge2JlZ2luOiAweDE3MDAsIGVuZDogMHgxNzFGfSwgLy8gVGFnYWxvZ1xuICAgIHtiZWdpbjogMHgxMDMwMCwgZW5kOiAweDEwMzJGfSwgLy8gT2xkIEl0YWxpY1xuICAgIHtiZWdpbjogMHgxMDMzMCwgZW5kOiAweDEwMzRGfSwgLy8gR290aGljXG4gICAge2JlZ2luOiAweDEwNDAwLCBlbmQ6IDB4MTA0NEZ9LCAvLyBEZXNlcmV0XG4gICAge2JlZ2luOiAweDFEMDAwLCBlbmQ6IDB4MUQwRkZ9LCAvLyBCeXphbnRpbmUgTXVzaWNhbCBTeW1ib2xzXG4gICAge2JlZ2luOiAweDFENDAwLCBlbmQ6IDB4MUQ3RkZ9LCAvLyBNYXRoZW1hdGljYWwgQWxwaGFudW1lcmljIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4RkYwMDAsIGVuZDogMHhGRkZGRH0sIC8vIFByaXZhdGUgVXNlIChwbGFuZSAxNSlcbiAgICB7YmVnaW46IDB4RkUwMCwgZW5kOiAweEZFMEZ9LCAvLyBWYXJpYXRpb24gU2VsZWN0b3JzXG4gICAge2JlZ2luOiAweEUwMDAwLCBlbmQ6IDB4RTAwN0Z9LCAvLyBUYWdzXG4gICAge2JlZ2luOiAweDE5MDAsIGVuZDogMHgxOTRGfSwgLy8gTGltYnVcbiAgICB7YmVnaW46IDB4MTk1MCwgZW5kOiAweDE5N0Z9LCAvLyBUYWkgTGVcbiAgICB7YmVnaW46IDB4MTk4MCwgZW5kOiAweDE5REZ9LCAvLyBOZXcgVGFpIEx1ZVxuICAgIHtiZWdpbjogMHgxQTAwLCBlbmQ6IDB4MUExRn0sIC8vIEJ1Z2luZXNlXG4gICAge2JlZ2luOiAweDJDMDAsIGVuZDogMHgyQzVGfSwgLy8gR2xhZ29saXRpY1xuICAgIHtiZWdpbjogMHgyRDMwLCBlbmQ6IDB4MkQ3Rn0sIC8vIFRpZmluYWdoXG4gICAge2JlZ2luOiAweDREQzAsIGVuZDogMHg0REZGfSwgLy8gWWlqaW5nIEhleGFncmFtIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4QTgwMCwgZW5kOiAweEE4MkZ9LCAvLyBTeWxvdGkgTmFncmlcbiAgICB7YmVnaW46IDB4MTAwMDAsIGVuZDogMHgxMDA3Rn0sIC8vIExpbmVhciBCIFN5bGxhYmFyeVxuICAgIHtiZWdpbjogMHgxMDE0MCwgZW5kOiAweDEwMThGfSwgLy8gQW5jaWVudCBHcmVlayBOdW1iZXJzXG4gICAge2JlZ2luOiAweDEwMzgwLCBlbmQ6IDB4MTAzOUZ9LCAvLyBVZ2FyaXRpY1xuICAgIHtiZWdpbjogMHgxMDNBMCwgZW5kOiAweDEwM0RGfSwgLy8gT2xkIFBlcnNpYW5cbiAgICB7YmVnaW46IDB4MTA0NTAsIGVuZDogMHgxMDQ3Rn0sIC8vIFNoYXZpYW5cbiAgICB7YmVnaW46IDB4MTA0ODAsIGVuZDogMHgxMDRBRn0sIC8vIE9zbWFueWFcbiAgICB7YmVnaW46IDB4MTA4MDAsIGVuZDogMHgxMDgzRn0sIC8vIEN5cHJpb3QgU3lsbGFiYXJ5XG4gICAge2JlZ2luOiAweDEwQTAwLCBlbmQ6IDB4MTBBNUZ9LCAvLyBLaGFyb3NodGhpXG4gICAge2JlZ2luOiAweDFEMzAwLCBlbmQ6IDB4MUQzNUZ9LCAvLyBUYWkgWHVhbiBKaW5nIFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MTIwMDAsIGVuZDogMHgxMjNGRn0sIC8vIEN1bmVpZm9ybVxuICAgIHtiZWdpbjogMHgxRDM2MCwgZW5kOiAweDFEMzdGfSwgLy8gQ291bnRpbmcgUm9kIE51bWVyYWxzXG4gICAge2JlZ2luOiAweDFCODAsIGVuZDogMHgxQkJGfSwgLy8gU3VuZGFuZXNlXG4gICAge2JlZ2luOiAweDFDMDAsIGVuZDogMHgxQzRGfSwgLy8gTGVwY2hhXG4gICAge2JlZ2luOiAweDFDNTAsIGVuZDogMHgxQzdGfSwgLy8gT2wgQ2hpa2lcbiAgICB7YmVnaW46IDB4QTg4MCwgZW5kOiAweEE4REZ9LCAvLyBTYXVyYXNodHJhXG4gICAge2JlZ2luOiAweEE5MDAsIGVuZDogMHhBOTJGfSwgLy8gS2F5YWggTGlcbiAgICB7YmVnaW46IDB4QTkzMCwgZW5kOiAweEE5NUZ9LCAvLyBSZWphbmdcbiAgICB7YmVnaW46IDB4QUEwMCwgZW5kOiAweEFBNUZ9LCAvLyBDaGFtXG4gICAge2JlZ2luOiAweDEwMTkwLCBlbmQ6IDB4MTAxQ0Z9LCAvLyBBbmNpZW50IFN5bWJvbHNcbiAgICB7YmVnaW46IDB4MTAxRDAsIGVuZDogMHgxMDFGRn0sIC8vIFBoYWlzdG9zIERpc2NcbiAgICB7YmVnaW46IDB4MTAyQTAsIGVuZDogMHgxMDJERn0sIC8vIENhcmlhblxuICAgIHtiZWdpbjogMHgxRjAzMCwgZW5kOiAweDFGMDlGfSAgLy8gRG9taW5vIFRpbGVzXG5dO1xuXG5mdW5jdGlvbiBnZXRVbmljb2RlUmFuZ2UodW5pY29kZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5pY29kZVJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcmFuZ2UgPSB1bmljb2RlUmFuZ2VzW2ldO1xuICAgICAgICBpZiAodW5pY29kZSA+PSByYW5nZS5iZWdpbiAmJiB1bmljb2RlIDwgcmFuZ2UuZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn1cblxuLy8gUGFyc2UgdGhlIE9TLzIgYW5kIFdpbmRvd3MgbWV0cmljcyBgT1MvMmAgdGFibGVcbmZ1bmN0aW9uIHBhcnNlT1MyVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgb3MyID0ge307XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICBvczIudmVyc2lvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIueEF2Z0NoYXJXaWR0aCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi51c1dlaWdodENsYXNzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi51c1dpZHRoQ2xhc3MgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgb3MyLmZzVHlwZSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIueVN1YnNjcmlwdFhTaXplID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdWJzY3JpcHRZU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WE9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3Vic2NyaXB0WU9mZnNldCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRYU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRZU2l6ZSA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi55U3VwZXJzY3JpcHRYT2Zmc2V0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnlTdXBlcnNjcmlwdFlPZmZzZXQgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN0cmlrZW91dFNpemUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBvczIueVN0cmlrZW91dFBvc2l0aW9uID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNGYW1pbHlDbGFzcyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi5wYW5vc2UgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgb3MyLnBhbm9zZVtpXSA9IHAucGFyc2VCeXRlKCk7XG4gICAgfVxuXG4gICAgb3MyLnVsVW5pY29kZVJhbmdlMSA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi51bFVuaWNvZGVSYW5nZTIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBvczIudWxVbmljb2RlUmFuZ2UzID0gcC5wYXJzZVVMb25nKCk7XG4gICAgb3MyLnVsVW5pY29kZVJhbmdlNCA9IHAucGFyc2VVTG9uZygpO1xuICAgIG9zMi5hY2hWZW5kSUQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCksIHAucGFyc2VCeXRlKCkpO1xuICAgIG9zMi5mc1NlbGVjdGlvbiA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNGaXJzdENoYXJJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNMYXN0Q2hhckluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIG9zMi5zVHlwb0FzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNUeXBvRGVzY2VuZGVyID0gcC5wYXJzZVNob3J0KCk7XG4gICAgb3MyLnNUeXBvTGluZUdhcCA9IHAucGFyc2VTaG9ydCgpO1xuICAgIG9zMi51c1dpbkFzY2VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICBvczIudXNXaW5EZXNjZW50ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChvczIudmVyc2lvbiA+PSAxKSB7XG4gICAgICAgIG9zMi51bENvZGVQYWdlUmFuZ2UxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIG9zMi51bENvZGVQYWdlUmFuZ2UyID0gcC5wYXJzZVVMb25nKCk7XG4gICAgfVxuXG4gICAgaWYgKG9zMi52ZXJzaW9uID49IDIpIHtcbiAgICAgICAgb3MyLnN4SGVpZ2h0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIG9zMi5zQ2FwSGVpZ2h0ID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgIG9zMi51c0RlZmF1bHRDaGFyID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICBvczIudXNCcmVha0NoYXIgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIG9zMi51c01heENvbnRlbnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9zMjtcbn1cblxuZnVuY3Rpb24gbWFrZU9TMlRhYmxlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdPUy8yJywgW1xuICAgICAgICB7bmFtZTogJ3ZlcnNpb24nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB4MDAwM30sXG4gICAgICAgIHtuYW1lOiAneEF2Z0NoYXJXaWR0aCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c1dlaWdodENsYXNzJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1c1dpZHRoQ2xhc3MnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2ZzVHlwZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFhTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDY1MH0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFlTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDY5OX0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFhPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAneVN1YnNjcmlwdFlPZmZzZXQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMTQwfSxcbiAgICAgICAge25hbWU6ICd5U3VwZXJzY3JpcHRYU2l6ZScsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiA2NTB9LFxuICAgICAgICB7bmFtZTogJ3lTdXBlcnNjcmlwdFlTaXplJywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDY5OX0sXG4gICAgICAgIHtuYW1lOiAneVN1cGVyc2NyaXB0WE9mZnNldCcsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd5U3VwZXJzY3JpcHRZT2Zmc2V0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDQ3OX0sXG4gICAgICAgIHtuYW1lOiAneVN0cmlrZW91dFNpemUnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogNDl9LFxuICAgICAgICB7bmFtZTogJ3lTdHJpa2VvdXRQb3NpdGlvbicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAyNTh9LFxuICAgICAgICB7bmFtZTogJ3NGYW1pbHlDbGFzcycsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiRmFtaWx5VHlwZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JTZXJpZlN0eWxlJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYldlaWdodCcsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JQcm9wb3J0aW9uJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYkNvbnRyYXN0JywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYlN0cm9rZVZhcmlhdGlvbicsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JBcm1TdHlsZScsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ2JMZXR0ZXJmb3JtJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnYk1pZGxpbmUnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdiWEhlaWdodCcsIHR5cGU6ICdCWVRFJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bFVuaWNvZGVSYW5nZTInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxVbmljb2RlUmFuZ2UzJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VsVW5pY29kZVJhbmdlNCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdhY2hWZW5kSUQnLCB0eXBlOiAnQ0hBUkFSUkFZJywgdmFsdWU6ICdYWFhYJ30sXG4gICAgICAgIHtuYW1lOiAnZnNTZWxlY3Rpb24nLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzRmlyc3RDaGFySW5kZXgnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzTGFzdENoYXJJbmRleCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnc1R5cG9Bc2NlbmRlcicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzVHlwb0Rlc2NlbmRlcicsIHR5cGU6ICdTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdzVHlwb0xpbmVHYXAnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNXaW5Bc2NlbnQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzV2luRGVzY2VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndWxDb2RlUGFnZVJhbmdlMScsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bENvZGVQYWdlUmFuZ2UyJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3N4SGVpZ2h0JywgdHlwZTogJ1NIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NDYXBIZWlnaHQnLCB0eXBlOiAnU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNEZWZhdWx0Q2hhcicsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAndXNCcmVha0NoYXInLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3VzTWF4Q29udGV4dCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdLCBvcHRpb25zKTtcbn1cblxudmFyIG9zMiA9IHsgcGFyc2U6IHBhcnNlT1MyVGFibGUsIG1ha2U6IG1ha2VPUzJUYWJsZSwgdW5pY29kZVJhbmdlczogdW5pY29kZVJhbmdlcywgZ2V0VW5pY29kZVJhbmdlOiBnZXRVbmljb2RlUmFuZ2UgfTtcblxuLy8gVGhlIGBwb3N0YCB0YWJsZSBzdG9yZXMgYWRkaXRpb25hbCBQb3N0U2NyaXB0IGluZm9ybWF0aW9uLCBzdWNoIGFzIGdseXBoIG5hbWVzLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9wb3N0Lmh0bVxuXG4vLyBQYXJzZSB0aGUgUG9zdFNjcmlwdCBgcG9zdGAgdGFibGVcbmZ1bmN0aW9uIHBhcnNlUG9zdFRhYmxlKGRhdGEsIHN0YXJ0KSB7XG4gICAgdmFyIHBvc3QgPSB7fTtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHBvc3QudmVyc2lvbiA9IHAucGFyc2VWZXJzaW9uKCk7XG4gICAgcG9zdC5pdGFsaWNBbmdsZSA9IHAucGFyc2VGaXhlZCgpO1xuICAgIHBvc3QudW5kZXJsaW5lUG9zaXRpb24gPSBwLnBhcnNlU2hvcnQoKTtcbiAgICBwb3N0LnVuZGVybGluZVRoaWNrbmVzcyA9IHAucGFyc2VTaG9ydCgpO1xuICAgIHBvc3QuaXNGaXhlZFBpdGNoID0gcC5wYXJzZVVMb25nKCk7XG4gICAgcG9zdC5taW5NZW1UeXBlNDIgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm1heE1lbVR5cGU0MiA9IHAucGFyc2VVTG9uZygpO1xuICAgIHBvc3QubWluTWVtVHlwZTEgPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBwb3N0Lm1heE1lbVR5cGUxID0gcC5wYXJzZVVMb25nKCk7XG4gICAgc3dpdGNoIChwb3N0LnZlcnNpb24pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcG9zdC5uYW1lcyA9IHN0YW5kYXJkTmFtZXMuc2xpY2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBwb3N0Lm51bWJlck9mR2x5cGhzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgcG9zdC5nbHlwaE5hbWVJbmRleCA9IG5ldyBBcnJheShwb3N0Lm51bWJlck9mR2x5cGhzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcG9zdC5nbHlwaE5hbWVJbmRleFtpXSA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9zdC5uYW1lcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zdC5nbHlwaE5hbWVJbmRleFtpJDFdID49IHN0YW5kYXJkTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lTGVuZ3RoID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zdC5uYW1lcy5wdXNoKHAucGFyc2VTdHJpbmcobmFtZUxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMi41OlxuICAgICAgICAgICAgcG9zdC5udW1iZXJPZkdseXBocyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHBvc3Qub2Zmc2V0ID0gbmV3IEFycmF5KHBvc3QubnVtYmVyT2ZHbHlwaHMpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgcG9zdC5udW1iZXJPZkdseXBoczsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICBwb3N0Lm9mZnNldFtpJDJdID0gcC5wYXJzZUNoYXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBwb3N0O1xufVxuXG5mdW5jdGlvbiBtYWtlUG9zdFRhYmxlKCkge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ3Bvc3QnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAweDAwMDMwMDAwfSxcbiAgICAgICAge25hbWU6ICdpdGFsaWNBbmdsZScsIHR5cGU6ICdGSVhFRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bmRlcmxpbmVQb3NpdGlvbicsIHR5cGU6ICdGV09SRCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICd1bmRlcmxpbmVUaGlja25lc3MnLCB0eXBlOiAnRldPUkQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnaXNGaXhlZFBpdGNoJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ21pbk1lbVR5cGU0MicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdtYXhNZW1UeXBlNDInLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWluTWVtVHlwZTEnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnbWF4TWVtVHlwZTEnLCB0eXBlOiAnVUxPTkcnLCB2YWx1ZTogMH1cbiAgICBdKTtcbn1cblxudmFyIHBvc3QgPSB7IHBhcnNlOiBwYXJzZVBvc3RUYWJsZSwgbWFrZTogbWFrZVBvc3RUYWJsZSB9O1xuXG4vLyBUaGUgYEdTVUJgIHRhYmxlIGNvbnRhaW5zIGxpZ2F0dXJlcywgYW1vbmcgb3RoZXIgdGhpbmdzLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9nc3ViLmh0bVxuXG52YXIgc3VidGFibGVQYXJzZXJzID0gbmV3IEFycmF5KDkpOyAgICAgICAgIC8vIHN1YnRhYmxlUGFyc2Vyc1swXSBpcyB1bnVzZWRcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNTU1xuc3VidGFibGVQYXJzZXJzWzFdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAxKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgc3Vic3RGb3JtYXQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKHN1YnN0Rm9ybWF0ID09PSAxKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogMSxcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgZGVsdGFHbHlwaElkOiB0aGlzLnBhcnNlVVNob3J0KClcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogMixcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgc3Vic3RpdHV0ZTogdGhpcy5wYXJzZU9mZnNldDE2TGlzdCgpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNoZWNrLmFzc2VydChmYWxzZSwgJzB4JyArIHN0YXJ0LnRvU3RyaW5nKDE2KSArICc6IGxvb2t1cCB0eXBlIDEgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNNU1xuc3VidGFibGVQYXJzZXJzWzJdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAyKCkge1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChzdWJzdEZvcm1hdCA9PT0gMSwgJ0dTVUIgTXVsdGlwbGUgU3Vic3RpdHV0aW9uIFN1YnRhYmxlIGlkZW50aWZpZXItZm9ybWF0IG11c3QgYmUgMScpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgIHNlcXVlbmNlczogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKClcbiAgICB9O1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNBU1xuc3VidGFibGVQYXJzZXJzWzNdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAzKCkge1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChzdWJzdEZvcm1hdCA9PT0gMSwgJ0dTVUIgQWx0ZXJuYXRlIFN1YnN0aXR1dGlvbiBTdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBhbHRlcm5hdGVTZXRzOiB0aGlzLnBhcnNlTGlzdE9mTGlzdHMoKVxuICAgIH07XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0xTXG5zdWJ0YWJsZVBhcnNlcnNbNF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDQoKSB7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHN1YnN0Rm9ybWF0ID09PSAxLCAnR1NVQiBsaWdhdHVyZSB0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBsaWdhdHVyZVNldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGlnR2x5cGg6IHRoaXMucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiB0aGlzLnBhcnNlVVNob3J0TGlzdCh0aGlzLnBhcnNlVVNob3J0KCkgLSAxKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICB9O1xufTtcblxudmFyIGxvb2t1cFJlY29yZERlc2MgPSB7XG4gICAgc2VxdWVuY2VJbmRleDogUGFyc2VyLnVTaG9ydCxcbiAgICBsb29rdXBMaXN0SW5kZXg6IFBhcnNlci51U2hvcnRcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jQ1NGXG5zdWJ0YWJsZVBhcnNlcnNbNV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDUoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5vZmZzZXQgKyB0aGlzLnJlbGF0aXZlT2Zmc2V0O1xuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcblxuICAgIGlmIChzdWJzdEZvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBydWxlU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgIHZhciBzdWJzdENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0aGlzLnBhcnNlVVNob3J0TGlzdChnbHlwaENvdW50IC0gMSksXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KHN1YnN0Q291bnQsIGxvb2t1cFJlY29yZERlc2MpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IHN1YnN0Rm9ybWF0LFxuICAgICAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jb3ZlcmFnZSksXG4gICAgICAgICAgICBjbGFzc0RlZjogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcbiAgICAgICAgICAgIGNsYXNzU2V0czogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBnbHlwaENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgIHZhciBzdWJzdENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KGdseXBoQ291bnQgLSAxKSxcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3Qoc3Vic3RDb3VudCwgbG9va3VwUmVjb3JkRGVzYylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAzKSB7XG4gICAgICAgIHZhciBnbHlwaENvdW50ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgc3Vic3RDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1YnN0Rm9ybWF0OiBzdWJzdEZvcm1hdCxcbiAgICAgICAgICAgIGNvdmVyYWdlczogdGhpcy5wYXJzZUxpc3QoZ2x5cGhDb3VudCwgUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG4gICAgICAgICAgICBsb29rdXBSZWNvcmRzOiB0aGlzLnBhcnNlUmVjb3JkTGlzdChzdWJzdENvdW50LCBsb29rdXBSZWNvcmREZXNjKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjaGVjay5hc3NlcnQoZmFsc2UsICcweCcgKyBzdGFydC50b1N0cmluZygxNikgKyAnOiBsb29rdXAgdHlwZSA1IGZvcm1hdCBtdXN0IGJlIDEsIDIgb3IgMy4nKTtcbn07XG5cbi8vIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9PVFNQRUMvR1NVQi5odG0jQ0NcbnN1YnRhYmxlUGFyc2Vyc1s2XSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwNigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChzdWJzdEZvcm1hdCA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIGNoYWluUnVsZVNldHM6IHRoaXMucGFyc2VMaXN0T2ZMaXN0cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBiYWNrdHJhY2s6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiB0aGlzLnBhcnNlVVNob3J0TGlzdCh0aGlzLnBhcnNlU2hvcnQoKSAtIDEpLFxuICAgICAgICAgICAgICAgICAgICBsb29rYWhlYWQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KCksXG4gICAgICAgICAgICAgICAgICAgIGxvb2t1cFJlY29yZHM6IHRoaXMucGFyc2VSZWNvcmRMaXN0KGxvb2t1cFJlY29yZERlc2MpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChzdWJzdEZvcm1hdCA9PT0gMikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDIsXG4gICAgICAgICAgICBjb3ZlcmFnZTogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSxcbiAgICAgICAgICAgIGJhY2t0cmFja0NsYXNzRGVmOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpLFxuICAgICAgICAgICAgaW5wdXRDbGFzc0RlZjogdGhpcy5wYXJzZVBvaW50ZXIoUGFyc2VyLmNsYXNzRGVmKSxcbiAgICAgICAgICAgIGxvb2thaGVhZENsYXNzRGVmOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpLFxuICAgICAgICAgICAgY2hhaW5DbGFzc1NldDogdGhpcy5wYXJzZUxpc3RPZkxpc3RzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2t0cmFjazogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMucGFyc2VVU2hvcnRMaXN0KHRoaXMucGFyc2VTaG9ydCgpIC0gMSksXG4gICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZDogdGhpcy5wYXJzZVVTaG9ydExpc3QoKSxcbiAgICAgICAgICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3QobG9va3VwUmVjb3JkRGVzYylcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHN1YnN0Rm9ybWF0ID09PSAzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJzdEZvcm1hdDogMyxcbiAgICAgICAgICAgIGJhY2t0cmFja0NvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgICAgIGlucHV0Q292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICAgICAgbG9va2FoZWFkQ292ZXJhZ2U6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5jb3ZlcmFnZSkpLFxuICAgICAgICAgICAgbG9va3VwUmVjb3JkczogdGhpcy5wYXJzZVJlY29yZExpc3QobG9va3VwUmVjb3JkRGVzYylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2hlY2suYXNzZXJ0KGZhbHNlLCAnMHgnICsgc3RhcnQudG9TdHJpbmcoMTYpICsgJzogbG9va3VwIHR5cGUgNiBmb3JtYXQgbXVzdCBiZSAxLCAyIG9yIDMuJyk7XG59O1xuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL0dTVUIuaHRtI0VTXG5zdWJ0YWJsZVBhcnNlcnNbN10gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDcoKSB7XG4gICAgLy8gRXh0ZW5zaW9uIFN1YnN0aXR1dGlvbiBzdWJ0YWJsZVxuICAgIHZhciBzdWJzdEZvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBjaGVjay5hcmd1bWVudChzdWJzdEZvcm1hdCA9PT0gMSwgJ0dTVUIgRXh0ZW5zaW9uIFN1YnN0aXR1dGlvbiBzdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnKTtcbiAgICB2YXIgZXh0ZW5zaW9uTG9va3VwVHlwZSA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgZXh0ZW5zaW9uUGFyc2VyID0gbmV3IFBhcnNlcih0aGlzLmRhdGEsIHRoaXMub2Zmc2V0ICsgdGhpcy5wYXJzZVVMb25nKCkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnN0Rm9ybWF0OiAxLFxuICAgICAgICBsb29rdXBUeXBlOiBleHRlbnNpb25Mb29rdXBUeXBlLFxuICAgICAgICBleHRlbnNpb246IHN1YnRhYmxlUGFyc2Vyc1tleHRlbnNpb25Mb29rdXBUeXBlXS5jYWxsKGV4dGVuc2lvblBhcnNlcilcbiAgICB9O1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9HU1VCLmh0bSNSQ0NTXG5zdWJ0YWJsZVBhcnNlcnNbOF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDgoKSB7XG4gICAgdmFyIHN1YnN0Rm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGNoZWNrLmFyZ3VtZW50KHN1YnN0Rm9ybWF0ID09PSAxLCAnR1NVQiBSZXZlcnNlIENoYWluaW5nIENvbnRleHR1YWwgU2luZ2xlIFN1YnN0aXR1dGlvbiBTdWJ0YWJsZSBpZGVudGlmaWVyLWZvcm1hdCBtdXN0IGJlIDEnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWJzdEZvcm1hdDogc3Vic3RGb3JtYXQsXG4gICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICBiYWNrdHJhY2tDb3ZlcmFnZTogdGhpcy5wYXJzZUxpc3QoUGFyc2VyLnBvaW50ZXIoUGFyc2VyLmNvdmVyYWdlKSksXG4gICAgICAgIGxvb2thaGVhZENvdmVyYWdlOiB0aGlzLnBhcnNlTGlzdChQYXJzZXIucG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpKSxcbiAgICAgICAgc3Vic3RpdHV0ZXM6IHRoaXMucGFyc2VVU2hvcnRMaXN0KClcbiAgICB9O1xufTtcblxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9nc3ViLmh0bVxuZnVuY3Rpb24gcGFyc2VHc3ViVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgdmFyIHAgPSBuZXcgUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oMSk7XG4gICAgY2hlY2suYXJndW1lbnQodGFibGVWZXJzaW9uID09PSAxIHx8IHRhYmxlVmVyc2lvbiA9PT0gMS4xLCAnVW5zdXBwb3J0ZWQgR1NVQiB0YWJsZSB2ZXJzaW9uLicpO1xuICAgIGlmICh0YWJsZVZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IHRhYmxlVmVyc2lvbixcbiAgICAgICAgICAgIHNjcmlwdHM6IHAucGFyc2VTY3JpcHRMaXN0KCksXG4gICAgICAgICAgICBmZWF0dXJlczogcC5wYXJzZUZlYXR1cmVMaXN0KCksXG4gICAgICAgICAgICBsb29rdXBzOiBwLnBhcnNlTG9va3VwTGlzdChzdWJ0YWJsZVBhcnNlcnMpXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnNpb246IHRhYmxlVmVyc2lvbixcbiAgICAgICAgICAgIHNjcmlwdHM6IHAucGFyc2VTY3JpcHRMaXN0KCksXG4gICAgICAgICAgICBmZWF0dXJlczogcC5wYXJzZUZlYXR1cmVMaXN0KCksXG4gICAgICAgICAgICBsb29rdXBzOiBwLnBhcnNlTG9va3VwTGlzdChzdWJ0YWJsZVBhcnNlcnMpLFxuICAgICAgICAgICAgdmFyaWF0aW9uczogcC5wYXJzZUZlYXR1cmVWYXJpYXRpb25zTGlzdCgpXG4gICAgICAgIH07XG4gICAgfVxuXG59XG5cbi8vIEdTVUIgV3JpdGluZyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG52YXIgc3VidGFibGVNYWtlcnMgPSBuZXcgQXJyYXkoOSk7XG5cbnN1YnRhYmxlTWFrZXJzWzFdID0gZnVuY3Rpb24gbWFrZUxvb2t1cDEoc3VidGFibGUpIHtcbiAgICBpZiAoc3VidGFibGUuc3Vic3RGb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnc3Vic3RpdHV0aW9uVGFibGUnLCBbXG4gICAgICAgICAgICB7bmFtZTogJ3N1YnN0Rm9ybWF0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAxfSxcbiAgICAgICAgICAgIHtuYW1lOiAnY292ZXJhZ2UnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkNvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKX0sXG4gICAgICAgICAgICB7bmFtZTogJ2RlbHRhR2x5cGhJRCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogc3VidGFibGUuZGVsdGFHbHlwaElkfVxuICAgICAgICBdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdzdWJzdGl0dXRpb25UYWJsZScsIFtcbiAgICAgICAgICAgIHtuYW1lOiAnc3Vic3RGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDJ9LFxuICAgICAgICAgICAge25hbWU6ICdjb3ZlcmFnZScsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpfVxuICAgICAgICBdLmNvbmNhdCh0YWJsZS51c2hvcnRMaXN0KCdzdWJzdGl0dXRlJywgc3VidGFibGUuc3Vic3RpdHV0ZSkpKTtcbiAgICB9XG4gICAgY2hlY2suZmFpbCgnTG9va3VwIHR5cGUgMSBzdWJzdEZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nKTtcbn07XG5cbnN1YnRhYmxlTWFrZXJzWzNdID0gZnVuY3Rpb24gbWFrZUxvb2t1cDMoc3VidGFibGUpIHtcbiAgICBjaGVjay5hc3NlcnQoc3VidGFibGUuc3Vic3RGb3JtYXQgPT09IDEsICdMb29rdXAgdHlwZSAzIHN1YnN0Rm9ybWF0IG11c3QgYmUgMS4nKTtcbiAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdzdWJzdGl0dXRpb25UYWJsZScsIFtcbiAgICAgICAge25hbWU6ICdzdWJzdEZvcm1hdCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMX0sXG4gICAgICAgIHtuYW1lOiAnY292ZXJhZ2UnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkNvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKX1cbiAgICBdLmNvbmNhdCh0YWJsZS50YWJsZUxpc3QoJ2FsdFNldCcsIHN1YnRhYmxlLmFsdGVybmF0ZVNldHMsIGZ1bmN0aW9uKGFsdGVybmF0ZVNldCkge1xuICAgICAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdhbHRlcm5hdGVTZXRUYWJsZScsIHRhYmxlLnVzaG9ydExpc3QoJ2FsdGVybmF0ZScsIGFsdGVybmF0ZVNldCkpO1xuICAgIH0pKSk7XG59O1xuXG5zdWJ0YWJsZU1ha2Vyc1s0XSA9IGZ1bmN0aW9uIG1ha2VMb29rdXA0KHN1YnRhYmxlKSB7XG4gICAgY2hlY2suYXNzZXJ0KHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAxLCAnTG9va3VwIHR5cGUgNCBzdWJzdEZvcm1hdCBtdXN0IGJlIDEuJyk7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnc3Vic3RpdHV0aW9uVGFibGUnLCBbXG4gICAgICAgIHtuYW1lOiAnc3Vic3RGb3JtYXQnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ2NvdmVyYWdlJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Db3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSl9XG4gICAgXS5jb25jYXQodGFibGUudGFibGVMaXN0KCdsaWdTZXQnLCBzdWJ0YWJsZS5saWdhdHVyZVNldHMsIGZ1bmN0aW9uKGxpZ2F0dXJlU2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ2xpZ2F0dXJlU2V0VGFibGUnLCB0YWJsZS50YWJsZUxpc3QoJ2xpZ2F0dXJlJywgbGlnYXR1cmVTZXQsIGZ1bmN0aW9uKGxpZ2F0dXJlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHRhYmxlLlRhYmxlKCdsaWdhdHVyZVRhYmxlJyxcbiAgICAgICAgICAgICAgICBbe25hbWU6ICdsaWdHbHlwaCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogbGlnYXR1cmUubGlnR2x5cGh9XVxuICAgICAgICAgICAgICAgIC5jb25jYXQodGFibGUudXNob3J0TGlzdCgnY29tcG9uZW50JywgbGlnYXR1cmUuY29tcG9uZW50cywgbGlnYXR1cmUuY29tcG9uZW50cy5sZW5ndGggKyAxKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pKTtcbiAgICB9KSkpO1xufTtcblxuZnVuY3Rpb24gbWFrZUdzdWJUYWJsZShnc3ViKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5UYWJsZSgnR1NVQicsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB4MTAwMDB9LFxuICAgICAgICB7bmFtZTogJ3NjcmlwdHMnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLlNjcmlwdExpc3QoZ3N1Yi5zY3JpcHRzKX0sXG4gICAgICAgIHtuYW1lOiAnZmVhdHVyZXMnLCB0eXBlOiAnVEFCTEUnLCB2YWx1ZTogbmV3IHRhYmxlLkZlYXR1cmVMaXN0KGdzdWIuZmVhdHVyZXMpfSxcbiAgICAgICAge25hbWU6ICdsb29rdXBzJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5Mb29rdXBMaXN0KGdzdWIubG9va3Vwcywgc3VidGFibGVNYWtlcnMpfVxuICAgIF0pO1xufVxuXG52YXIgZ3N1YiA9IHsgcGFyc2U6IHBhcnNlR3N1YlRhYmxlLCBtYWtlOiBtYWtlR3N1YlRhYmxlIH07XG5cbi8vIFRoZSBgR1BPU2AgdGFibGUgY29udGFpbnMga2VybmluZyBwYWlycywgYW1vbmcgb3RoZXIgdGhpbmdzLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9ncG9zLmh0bVxuXG4vLyBQYXJzZSB0aGUgbWV0YWRhdGEgYG1ldGFgIHRhYmxlLlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2ZvbnRzL1RydWVUeXBlLVJlZmVyZW5jZS1NYW51YWwvUk0wNi9DaGFwNm1ldGEuaHRtbFxuZnVuY3Rpb24gcGFyc2VNZXRhVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVUxvbmcoKTtcbiAgICBjaGVjay5hcmd1bWVudCh0YWJsZVZlcnNpb24gPT09IDEsICdVbnN1cHBvcnRlZCBNRVRBIHRhYmxlIHZlcnNpb24uJyk7XG4gICAgcC5wYXJzZVVMb25nKCk7IC8vIGZsYWdzIC0gY3VycmVudGx5IHVudXNlZCBhbmQgc2V0IHRvIDBcbiAgICBwLnBhcnNlVUxvbmcoKTsgLy8gdGFibGVPZmZzZXRcbiAgICB2YXIgbnVtRGF0YU1hcHMgPSBwLnBhcnNlVUxvbmcoKTtcblxuICAgIHZhciB0YWdzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1EYXRhTWFwczsgaSsrKSB7XG4gICAgICAgIHZhciB0YWcgPSBwLnBhcnNlVGFnKCk7XG4gICAgICAgIHZhciBkYXRhT2Zmc2V0ID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIHZhciBkYXRhTGVuZ3RoID0gcC5wYXJzZVVMb25nKCk7XG4gICAgICAgIHZhciB0ZXh0ID0gZGVjb2RlLlVURjgoZGF0YSwgc3RhcnQgKyBkYXRhT2Zmc2V0LCBkYXRhTGVuZ3RoKTtcblxuICAgICAgICB0YWdzW3RhZ10gPSB0ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdGFncztcbn1cblxuZnVuY3Rpb24gbWFrZU1ldGFUYWJsZSh0YWdzKSB7XG4gICAgdmFyIG51bVRhZ3MgPSBPYmplY3Qua2V5cyh0YWdzKS5sZW5ndGg7XG4gICAgdmFyIHN0cmluZ1Bvb2wgPSAnJztcbiAgICB2YXIgc3RyaW5nUG9vbE9mZnNldCA9IDE2ICsgbnVtVGFncyAqIDEyO1xuXG4gICAgdmFyIHJlc3VsdCA9IG5ldyB0YWJsZS5UYWJsZSgnbWV0YScsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDF9LFxuICAgICAgICB7bmFtZTogJ2ZsYWdzJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ29mZnNldCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBzdHJpbmdQb29sT2Zmc2V0fSxcbiAgICAgICAge25hbWU6ICdudW1UYWdzJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IG51bVRhZ3N9XG4gICAgXSk7XG5cbiAgICBmb3IgKHZhciB0YWcgaW4gdGFncykge1xuICAgICAgICB2YXIgcG9zID0gc3RyaW5nUG9vbC5sZW5ndGg7XG4gICAgICAgIHN0cmluZ1Bvb2wgKz0gdGFnc1t0YWddO1xuXG4gICAgICAgIHJlc3VsdC5maWVsZHMucHVzaCh7bmFtZTogJ3RhZyAnICsgdGFnLCB0eXBlOiAnVEFHJywgdmFsdWU6IHRhZ30pO1xuICAgICAgICByZXN1bHQuZmllbGRzLnB1c2goe25hbWU6ICdvZmZzZXQgJyArIHRhZywgdHlwZTogJ1VMT05HJywgdmFsdWU6IHN0cmluZ1Bvb2xPZmZzZXQgKyBwb3N9KTtcbiAgICAgICAgcmVzdWx0LmZpZWxkcy5wdXNoKHtuYW1lOiAnbGVuZ3RoICcgKyB0YWcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiB0YWdzW3RhZ10ubGVuZ3RofSk7XG4gICAgfVxuXG4gICAgcmVzdWx0LmZpZWxkcy5wdXNoKHtuYW1lOiAnc3RyaW5nUG9vbCcsIHR5cGU6ICdDSEFSQVJSQVknLCB2YWx1ZTogc3RyaW5nUG9vbH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIG1ldGEgPSB7IHBhcnNlOiBwYXJzZU1ldGFUYWJsZSwgbWFrZTogbWFrZU1ldGFUYWJsZSB9O1xuXG4vLyBUaGUgYHNmbnRgIHdyYXBwZXIgcHJvdmlkZXMgb3JnYW5pemF0aW9uIGZvciB0aGUgdGFibGVzIGluIHRoZSBmb250LlxuLy8gSXQgaXMgdGhlIHRvcC1sZXZlbCBkYXRhIHN0cnVjdHVyZSBpbiBhIGZvbnQuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL290ZmYuaHRtXG4vLyBSZWNvbW1lbmRhdGlvbnMgZm9yIGNyZWF0aW5nIE9wZW5UeXBlIEZvbnRzOlxuLy8gaHR0cDovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvb3RzcGVjMTQwL3JlY29tLmh0bVxuXG5mdW5jdGlvbiBsb2cyKHYpIHtcbiAgICByZXR1cm4gTWF0aC5sb2codikgLyBNYXRoLmxvZygyKSB8IDA7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVDaGVja1N1bShieXRlcykge1xuICAgIHdoaWxlIChieXRlcy5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICAgIGJ5dGVzLnB1c2goMCk7XG4gICAgfVxuXG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICBzdW0gKz0gKGJ5dGVzW2ldIDw8IDI0KSArXG4gICAgICAgICAgICAoYnl0ZXNbaSArIDFdIDw8IDE2KSArXG4gICAgICAgICAgICAoYnl0ZXNbaSArIDJdIDw8IDgpICtcbiAgICAgICAgICAgIChieXRlc1tpICsgM10pO1xuICAgIH1cblxuICAgIHN1bSAlPSBNYXRoLnBvdygyLCAzMik7XG4gICAgcmV0dXJuIHN1bTtcbn1cblxuZnVuY3Rpb24gbWFrZVRhYmxlUmVjb3JkKHRhZywgY2hlY2tTdW0sIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyB0YWJsZS5SZWNvcmQoJ1RhYmxlIFJlY29yZCcsIFtcbiAgICAgICAge25hbWU6ICd0YWcnLCB0eXBlOiAnVEFHJywgdmFsdWU6IHRhZyAhPT0gdW5kZWZpbmVkID8gdGFnIDogJyd9LFxuICAgICAgICB7bmFtZTogJ2NoZWNrU3VtJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IGNoZWNrU3VtICE9PSB1bmRlZmluZWQgPyBjaGVja1N1bSA6IDB9LFxuICAgICAgICB7bmFtZTogJ29mZnNldCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBvZmZzZXQgIT09IHVuZGVmaW5lZCA/IG9mZnNldCA6IDB9LFxuICAgICAgICB7bmFtZTogJ2xlbmd0aCcsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiBsZW5ndGggIT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IDB9XG4gICAgXSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VTZm50VGFibGUodGFibGVzKSB7XG4gICAgdmFyIHNmbnQgPSBuZXcgdGFibGUuVGFibGUoJ3NmbnQnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdUQUcnLCB2YWx1ZTogJ09UVE8nfSxcbiAgICAgICAge25hbWU6ICdudW1UYWJsZXMnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ3NlYXJjaFJhbmdlJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdlbnRyeVNlbGVjdG9yJywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfSxcbiAgICAgICAge25hbWU6ICdyYW5nZVNoaWZ0JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiAwfVxuICAgIF0pO1xuICAgIHNmbnQudGFibGVzID0gdGFibGVzO1xuICAgIHNmbnQubnVtVGFibGVzID0gdGFibGVzLmxlbmd0aDtcbiAgICB2YXIgaGlnaGVzdFBvd2VyT2YyID0gTWF0aC5wb3coMiwgbG9nMihzZm50Lm51bVRhYmxlcykpO1xuICAgIHNmbnQuc2VhcmNoUmFuZ2UgPSAxNiAqIGhpZ2hlc3RQb3dlck9mMjtcbiAgICBzZm50LmVudHJ5U2VsZWN0b3IgPSBsb2cyKGhpZ2hlc3RQb3dlck9mMik7XG4gICAgc2ZudC5yYW5nZVNoaWZ0ID0gc2ZudC5udW1UYWJsZXMgKiAxNiAtIHNmbnQuc2VhcmNoUmFuZ2U7XG5cbiAgICB2YXIgcmVjb3JkRmllbGRzID0gW107XG4gICAgdmFyIHRhYmxlRmllbGRzID0gW107XG5cbiAgICB2YXIgb2Zmc2V0ID0gc2ZudC5zaXplT2YoKSArIChtYWtlVGFibGVSZWNvcmQoKS5zaXplT2YoKSAqIHNmbnQubnVtVGFibGVzKTtcbiAgICB3aGlsZSAob2Zmc2V0ICUgNCAhPT0gMCkge1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgdGFibGVGaWVsZHMucHVzaCh7bmFtZTogJ3BhZGRpbmcnLCB0eXBlOiAnQllURScsIHZhbHVlOiAwfSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWJsZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHQgPSB0YWJsZXNbaV07XG4gICAgICAgIGNoZWNrLmFyZ3VtZW50KHQudGFibGVOYW1lLmxlbmd0aCA9PT0gNCwgJ1RhYmxlIG5hbWUnICsgdC50YWJsZU5hbWUgKyAnIGlzIGludmFsaWQuJyk7XG4gICAgICAgIHZhciB0YWJsZUxlbmd0aCA9IHQuc2l6ZU9mKCk7XG4gICAgICAgIHZhciB0YWJsZVJlY29yZCA9IG1ha2VUYWJsZVJlY29yZCh0LnRhYmxlTmFtZSwgY29tcHV0ZUNoZWNrU3VtKHQuZW5jb2RlKCkpLCBvZmZzZXQsIHRhYmxlTGVuZ3RoKTtcbiAgICAgICAgcmVjb3JkRmllbGRzLnB1c2goe25hbWU6IHRhYmxlUmVjb3JkLnRhZyArICcgVGFibGUgUmVjb3JkJywgdHlwZTogJ1JFQ09SRCcsIHZhbHVlOiB0YWJsZVJlY29yZH0pO1xuICAgICAgICB0YWJsZUZpZWxkcy5wdXNoKHtuYW1lOiB0LnRhYmxlTmFtZSArICcgdGFibGUnLCB0eXBlOiAnUkVDT1JEJywgdmFsdWU6IHR9KTtcbiAgICAgICAgb2Zmc2V0ICs9IHRhYmxlTGVuZ3RoO1xuICAgICAgICBjaGVjay5hcmd1bWVudCghaXNOYU4ob2Zmc2V0KSwgJ1NvbWV0aGluZyB3ZW50IHdyb25nIGNhbGN1bGF0aW5nIHRoZSBvZmZzZXQuJyk7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgJSA0ICE9PSAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgICAgIHRhYmxlRmllbGRzLnB1c2goe25hbWU6ICdwYWRkaW5nJywgdHlwZTogJ0JZVEUnLCB2YWx1ZTogMH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGFibGUgcmVjb3JkcyBuZWVkIHRvIGJlIHNvcnRlZCBhbHBoYWJldGljYWxseS5cbiAgICByZWNvcmRGaWVsZHMuc29ydChmdW5jdGlvbihyMSwgcjIpIHtcbiAgICAgICAgaWYgKHIxLnZhbHVlLnRhZyA+IHIyLnZhbHVlLnRhZykge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHNmbnQuZmllbGRzID0gc2ZudC5maWVsZHMuY29uY2F0KHJlY29yZEZpZWxkcyk7XG4gICAgc2ZudC5maWVsZHMgPSBzZm50LmZpZWxkcy5jb25jYXQodGFibGVGaWVsZHMpO1xuICAgIHJldHVybiBzZm50O1xufVxuXG4vLyBHZXQgdGhlIG1ldHJpY3MgZm9yIGEgY2hhcmFjdGVyLiBJZiB0aGUgc3RyaW5nIGhhcyBtb3JlIHRoYW4gb25lIGNoYXJhY3RlclxuLy8gdGhpcyBmdW5jdGlvbiByZXR1cm5zIG1ldHJpY3MgZm9yIHRoZSBmaXJzdCBhdmFpbGFibGUgY2hhcmFjdGVyLlxuLy8gWW91IGNhbiBwcm92aWRlIG9wdGlvbmFsIGZhbGxiYWNrIG1ldHJpY3MgaWYgbm8gY2hhcmFjdGVycyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gbWV0cmljc0ZvckNoYXIoZm9udCwgY2hhcnMsIG5vdEZvdW5kTWV0cmljcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGdseXBoSW5kZXggPSBmb250LmNoYXJUb0dseXBoSW5kZXgoY2hhcnNbaV0pO1xuICAgICAgICBpZiAoZ2x5cGhJbmRleCA+IDApIHtcbiAgICAgICAgICAgIHZhciBnbHlwaCA9IGZvbnQuZ2x5cGhzLmdldChnbHlwaEluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBnbHlwaC5nZXRNZXRyaWNzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbm90Rm91bmRNZXRyaWNzO1xufVxuXG5mdW5jdGlvbiBhdmVyYWdlKHZzKSB7XG4gICAgdmFyIHN1bSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBzdW0gKz0gdnNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1bSAvIHZzLmxlbmd0aDtcbn1cblxuLy8gQ29udmVydCB0aGUgZm9udCBvYmplY3QgdG8gYSBTRk5UIGRhdGEgc3RydWN0dXJlLlxuLy8gVGhpcyBzdHJ1Y3R1cmUgY29udGFpbnMgYWxsIHRoZSBuZWNlc3NhcnkgdGFibGVzIGFuZCBtZXRhZGF0YSB0byBjcmVhdGUgYSBiaW5hcnkgT1RGIGZpbGUuXG5mdW5jdGlvbiBmb250VG9TZm50VGFibGUoZm9udCkge1xuICAgIHZhciB4TWlucyA9IFtdO1xuICAgIHZhciB5TWlucyA9IFtdO1xuICAgIHZhciB4TWF4cyA9IFtdO1xuICAgIHZhciB5TWF4cyA9IFtdO1xuICAgIHZhciBhZHZhbmNlV2lkdGhzID0gW107XG4gICAgdmFyIGxlZnRTaWRlQmVhcmluZ3MgPSBbXTtcbiAgICB2YXIgcmlnaHRTaWRlQmVhcmluZ3MgPSBbXTtcbiAgICB2YXIgZmlyc3RDaGFySW5kZXg7XG4gICAgdmFyIGxhc3RDaGFySW5kZXggPSAwO1xuICAgIHZhciB1bFVuaWNvZGVSYW5nZTEgPSAwO1xuICAgIHZhciB1bFVuaWNvZGVSYW5nZTIgPSAwO1xuICAgIHZhciB1bFVuaWNvZGVSYW5nZTMgPSAwO1xuICAgIHZhciB1bFVuaWNvZGVSYW5nZTQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmb250LmdseXBocy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBmb250LmdseXBocy5nZXQoaSk7XG4gICAgICAgIHZhciB1bmljb2RlID0gZ2x5cGgudW5pY29kZSB8IDA7XG5cbiAgICAgICAgaWYgKGlzTmFOKGdseXBoLmFkdmFuY2VXaWR0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignR2x5cGggJyArIGdseXBoLm5hbWUgKyAnICgnICsgaSArICcpOiBhZHZhbmNlV2lkdGggaXMgbm90IGEgbnVtYmVyLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpcnN0Q2hhckluZGV4ID4gdW5pY29kZSB8fCBmaXJzdENoYXJJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBpZ25vcmUgLm5vdGRlZiBjaGFyXG4gICAgICAgICAgICBpZiAodW5pY29kZSA+IDApIHtcbiAgICAgICAgICAgICAgICBmaXJzdENoYXJJbmRleCA9IHVuaWNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGFzdENoYXJJbmRleCA8IHVuaWNvZGUpIHtcbiAgICAgICAgICAgIGxhc3RDaGFySW5kZXggPSB1bmljb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gb3MyLmdldFVuaWNvZGVSYW5nZSh1bmljb2RlKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMzIpIHtcbiAgICAgICAgICAgIHVsVW5pY29kZVJhbmdlMSB8PSAxIDw8IHBvc2l0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uIDwgNjQpIHtcbiAgICAgICAgICAgIHVsVW5pY29kZVJhbmdlMiB8PSAxIDw8IHBvc2l0aW9uIC0gMzI7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPCA5Nikge1xuICAgICAgICAgICAgdWxVbmljb2RlUmFuZ2UzIHw9IDEgPDwgcG9zaXRpb24gLSA2NDtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA8IDEyMykge1xuICAgICAgICAgICAgdWxVbmljb2RlUmFuZ2U0IHw9IDEgPDwgcG9zaXRpb24gLSA5NjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5pY29kZSByYW5nZXMgYml0cyA+IDEyMyBhcmUgcmVzZXJ2ZWQgZm9yIGludGVybmFsIHVzYWdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2tpcCBub24taW1wb3J0YW50IGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChnbHlwaC5uYW1lID09PSAnLm5vdGRlZicpIHsgY29udGludWU7IH1cbiAgICAgICAgdmFyIG1ldHJpY3MgPSBnbHlwaC5nZXRNZXRyaWNzKCk7XG4gICAgICAgIHhNaW5zLnB1c2gobWV0cmljcy54TWluKTtcbiAgICAgICAgeU1pbnMucHVzaChtZXRyaWNzLnlNaW4pO1xuICAgICAgICB4TWF4cy5wdXNoKG1ldHJpY3MueE1heCk7XG4gICAgICAgIHlNYXhzLnB1c2gobWV0cmljcy55TWF4KTtcbiAgICAgICAgbGVmdFNpZGVCZWFyaW5ncy5wdXNoKG1ldHJpY3MubGVmdFNpZGVCZWFyaW5nKTtcbiAgICAgICAgcmlnaHRTaWRlQmVhcmluZ3MucHVzaChtZXRyaWNzLnJpZ2h0U2lkZUJlYXJpbmcpO1xuICAgICAgICBhZHZhbmNlV2lkdGhzLnB1c2goZ2x5cGguYWR2YW5jZVdpZHRoKTtcbiAgICB9XG5cbiAgICB2YXIgZ2xvYmFscyA9IHtcbiAgICAgICAgeE1pbjogTWF0aC5taW4uYXBwbHkobnVsbCwgeE1pbnMpLFxuICAgICAgICB5TWluOiBNYXRoLm1pbi5hcHBseShudWxsLCB5TWlucyksXG4gICAgICAgIHhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHhNYXhzKSxcbiAgICAgICAgeU1heDogTWF0aC5tYXguYXBwbHkobnVsbCwgeU1heHMpLFxuICAgICAgICBhZHZhbmNlV2lkdGhNYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIGFkdmFuY2VXaWR0aHMpLFxuICAgICAgICBhZHZhbmNlV2lkdGhBdmc6IGF2ZXJhZ2UoYWR2YW5jZVdpZHRocyksXG4gICAgICAgIG1pbkxlZnRTaWRlQmVhcmluZzogTWF0aC5taW4uYXBwbHkobnVsbCwgbGVmdFNpZGVCZWFyaW5ncyksXG4gICAgICAgIG1heExlZnRTaWRlQmVhcmluZzogTWF0aC5tYXguYXBwbHkobnVsbCwgbGVmdFNpZGVCZWFyaW5ncyksXG4gICAgICAgIG1pblJpZ2h0U2lkZUJlYXJpbmc6IE1hdGgubWluLmFwcGx5KG51bGwsIHJpZ2h0U2lkZUJlYXJpbmdzKVxuICAgIH07XG4gICAgZ2xvYmFscy5hc2NlbmRlciA9IGZvbnQuYXNjZW5kZXI7XG4gICAgZ2xvYmFscy5kZXNjZW5kZXIgPSBmb250LmRlc2NlbmRlcjtcblxuICAgIHZhciBoZWFkVGFibGUgPSBoZWFkLm1ha2Uoe1xuICAgICAgICBmbGFnczogMywgLy8gMDAwMDAwMTEgKGJhc2VsaW5lIGZvciBmb250IGF0IHk9MDsgbGVmdCBzaWRlYmVhcmluZyBwb2ludCBhdCB4PTApXG4gICAgICAgIHVuaXRzUGVyRW06IGZvbnQudW5pdHNQZXJFbSxcbiAgICAgICAgeE1pbjogZ2xvYmFscy54TWluLFxuICAgICAgICB5TWluOiBnbG9iYWxzLnlNaW4sXG4gICAgICAgIHhNYXg6IGdsb2JhbHMueE1heCxcbiAgICAgICAgeU1heDogZ2xvYmFscy55TWF4LFxuICAgICAgICBsb3dlc3RSZWNQUEVNOiAzLFxuICAgICAgICBjcmVhdGVkVGltZXN0YW1wOiBmb250LmNyZWF0ZWRUaW1lc3RhbXBcbiAgICB9KTtcblxuICAgIHZhciBoaGVhVGFibGUgPSBoaGVhLm1ha2Uoe1xuICAgICAgICBhc2NlbmRlcjogZ2xvYmFscy5hc2NlbmRlcixcbiAgICAgICAgZGVzY2VuZGVyOiBnbG9iYWxzLmRlc2NlbmRlcixcbiAgICAgICAgYWR2YW5jZVdpZHRoTWF4OiBnbG9iYWxzLmFkdmFuY2VXaWR0aE1heCxcbiAgICAgICAgbWluTGVmdFNpZGVCZWFyaW5nOiBnbG9iYWxzLm1pbkxlZnRTaWRlQmVhcmluZyxcbiAgICAgICAgbWluUmlnaHRTaWRlQmVhcmluZzogZ2xvYmFscy5taW5SaWdodFNpZGVCZWFyaW5nLFxuICAgICAgICB4TWF4RXh0ZW50OiBnbG9iYWxzLm1heExlZnRTaWRlQmVhcmluZyArIChnbG9iYWxzLnhNYXggLSBnbG9iYWxzLnhNaW4pLFxuICAgICAgICBudW1iZXJPZkhNZXRyaWNzOiBmb250LmdseXBocy5sZW5ndGhcbiAgICB9KTtcblxuICAgIHZhciBtYXhwVGFibGUgPSBtYXhwLm1ha2UoZm9udC5nbHlwaHMubGVuZ3RoKTtcblxuICAgIHZhciBvczJUYWJsZSA9IG9zMi5tYWtlKHtcbiAgICAgICAgeEF2Z0NoYXJXaWR0aDogTWF0aC5yb3VuZChnbG9iYWxzLmFkdmFuY2VXaWR0aEF2ZyksXG4gICAgICAgIHVzV2VpZ2h0Q2xhc3M6IGZvbnQudGFibGVzLm9zMi51c1dlaWdodENsYXNzLFxuICAgICAgICB1c1dpZHRoQ2xhc3M6IGZvbnQudGFibGVzLm9zMi51c1dpZHRoQ2xhc3MsXG4gICAgICAgIHVzRmlyc3RDaGFySW5kZXg6IGZpcnN0Q2hhckluZGV4LFxuICAgICAgICB1c0xhc3RDaGFySW5kZXg6IGxhc3RDaGFySW5kZXgsXG4gICAgICAgIHVsVW5pY29kZVJhbmdlMTogdWxVbmljb2RlUmFuZ2UxLFxuICAgICAgICB1bFVuaWNvZGVSYW5nZTI6IHVsVW5pY29kZVJhbmdlMixcbiAgICAgICAgdWxVbmljb2RlUmFuZ2UzOiB1bFVuaWNvZGVSYW5nZTMsXG4gICAgICAgIHVsVW5pY29kZVJhbmdlNDogdWxVbmljb2RlUmFuZ2U0LFxuICAgICAgICBmc1NlbGVjdGlvbjogZm9udC50YWJsZXMub3MyLmZzU2VsZWN0aW9uLCAvLyBSRUdVTEFSXG4gICAgICAgIC8vIFNlZSBodHRwOi8vdHlwb3BoaWxlLmNvbS9ub2RlLzEzMDgxIGZvciBtb3JlIGluZm8gb24gdmVydGljYWwgbWV0cmljcy5cbiAgICAgICAgLy8gV2UgZ2V0IG1ldHJpY3MgZm9yIHR5cGljYWwgY2hhcmFjdGVycyAoc3VjaCBhcyBcInhcIiBmb3IgeEhlaWdodCkuXG4gICAgICAgIC8vIFdlIHByb3ZpZGUgc29tZSBmYWxsYmFjayBjaGFyYWN0ZXJzIGlmIGNoYXJhY3RlcnMgYXJlIHVuYXZhaWxhYmxlOiB0aGVpclxuICAgICAgICAvLyBvcmRlcmluZyB3YXMgY2hvc2VuIGV4cGVyaW1lbnRhbGx5LlxuICAgICAgICBzVHlwb0FzY2VuZGVyOiBnbG9iYWxzLmFzY2VuZGVyLFxuICAgICAgICBzVHlwb0Rlc2NlbmRlcjogZ2xvYmFscy5kZXNjZW5kZXIsXG4gICAgICAgIHNUeXBvTGluZUdhcDogMCxcbiAgICAgICAgdXNXaW5Bc2NlbnQ6IGdsb2JhbHMueU1heCxcbiAgICAgICAgdXNXaW5EZXNjZW50OiBNYXRoLmFicyhnbG9iYWxzLnlNaW4pLFxuICAgICAgICB1bENvZGVQYWdlUmFuZ2UxOiAxLCAvLyBGSVhNRTogaGFyZC1jb2RlIExhdGluIDEgc3VwcG9ydCBmb3Igbm93XG4gICAgICAgIHN4SGVpZ2h0OiBtZXRyaWNzRm9yQ2hhcihmb250LCAneHl2dycsIHt5TWF4OiBNYXRoLnJvdW5kKGdsb2JhbHMuYXNjZW5kZXIgLyAyKX0pLnlNYXgsXG4gICAgICAgIHNDYXBIZWlnaHQ6IG1ldHJpY3NGb3JDaGFyKGZvbnQsICdISUtMRUZKTU5UWkJEUFJBR09RU1VWV1hZJywgZ2xvYmFscykueU1heCxcbiAgICAgICAgdXNEZWZhdWx0Q2hhcjogZm9udC5oYXNDaGFyKCcgJykgPyAzMiA6IDAsIC8vIFVzZSBzcGFjZSBhcyB0aGUgZGVmYXVsdCBjaGFyYWN0ZXIsIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgdXNCcmVha0NoYXI6IGZvbnQuaGFzQ2hhcignICcpID8gMzIgOiAwIC8vIFVzZSBzcGFjZSBhcyB0aGUgYnJlYWsgY2hhcmFjdGVyLCBpZiBhdmFpbGFibGUuXG4gICAgfSk7XG5cbiAgICB2YXIgaG10eFRhYmxlID0gaG10eC5tYWtlKGZvbnQuZ2x5cGhzKTtcbiAgICB2YXIgY21hcFRhYmxlID0gY21hcC5tYWtlKGZvbnQuZ2x5cGhzKTtcblxuICAgIHZhciBlbmdsaXNoRmFtaWx5TmFtZSA9IGZvbnQuZ2V0RW5nbGlzaE5hbWUoJ2ZvbnRGYW1pbHknKTtcbiAgICB2YXIgZW5nbGlzaFN0eWxlTmFtZSA9IGZvbnQuZ2V0RW5nbGlzaE5hbWUoJ2ZvbnRTdWJmYW1pbHknKTtcbiAgICB2YXIgZW5nbGlzaEZ1bGxOYW1lID0gZW5nbGlzaEZhbWlseU5hbWUgKyAnICcgKyBlbmdsaXNoU3R5bGVOYW1lO1xuICAgIHZhciBwb3N0U2NyaXB0TmFtZSA9IGZvbnQuZ2V0RW5nbGlzaE5hbWUoJ3Bvc3RTY3JpcHROYW1lJyk7XG4gICAgaWYgKCFwb3N0U2NyaXB0TmFtZSkge1xuICAgICAgICBwb3N0U2NyaXB0TmFtZSA9IGVuZ2xpc2hGYW1pbHlOYW1lLnJlcGxhY2UoL1xccy9nLCAnJykgKyAnLScgKyBlbmdsaXNoU3R5bGVOYW1lO1xuICAgIH1cblxuICAgIHZhciBuYW1lcyA9IHt9O1xuICAgIGZvciAodmFyIG4gaW4gZm9udC5uYW1lcykge1xuICAgICAgICBuYW1lc1tuXSA9IGZvbnQubmFtZXNbbl07XG4gICAgfVxuXG4gICAgaWYgKCFuYW1lcy51bmlxdWVJRCkge1xuICAgICAgICBuYW1lcy51bmlxdWVJRCA9IHtlbjogZm9udC5nZXRFbmdsaXNoTmFtZSgnbWFudWZhY3R1cmVyJykgKyAnOicgKyBlbmdsaXNoRnVsbE5hbWV9O1xuICAgIH1cblxuICAgIGlmICghbmFtZXMucG9zdFNjcmlwdE5hbWUpIHtcbiAgICAgICAgbmFtZXMucG9zdFNjcmlwdE5hbWUgPSB7ZW46IHBvc3RTY3JpcHROYW1lfTtcbiAgICB9XG5cbiAgICBpZiAoIW5hbWVzLnByZWZlcnJlZEZhbWlseSkge1xuICAgICAgICBuYW1lcy5wcmVmZXJyZWRGYW1pbHkgPSBmb250Lm5hbWVzLmZvbnRGYW1pbHk7XG4gICAgfVxuXG4gICAgaWYgKCFuYW1lcy5wcmVmZXJyZWRTdWJmYW1pbHkpIHtcbiAgICAgICAgbmFtZXMucHJlZmVycmVkU3ViZmFtaWx5ID0gZm9udC5uYW1lcy5mb250U3ViZmFtaWx5O1xuICAgIH1cblxuICAgIHZhciBsYW5ndWFnZVRhZ3MgPSBbXTtcbiAgICB2YXIgbmFtZVRhYmxlID0gX25hbWUubWFrZShuYW1lcywgbGFuZ3VhZ2VUYWdzKTtcbiAgICB2YXIgbHRhZ1RhYmxlID0gKGxhbmd1YWdlVGFncy5sZW5ndGggPiAwID8gbHRhZy5tYWtlKGxhbmd1YWdlVGFncykgOiB1bmRlZmluZWQpO1xuXG4gICAgdmFyIHBvc3RUYWJsZSA9IHBvc3QubWFrZSgpO1xuICAgIHZhciBjZmZUYWJsZSA9IGNmZi5tYWtlKGZvbnQuZ2x5cGhzLCB7XG4gICAgICAgIHZlcnNpb246IGZvbnQuZ2V0RW5nbGlzaE5hbWUoJ3ZlcnNpb24nKSxcbiAgICAgICAgZnVsbE5hbWU6IGVuZ2xpc2hGdWxsTmFtZSxcbiAgICAgICAgZmFtaWx5TmFtZTogZW5nbGlzaEZhbWlseU5hbWUsXG4gICAgICAgIHdlaWdodE5hbWU6IGVuZ2xpc2hTdHlsZU5hbWUsXG4gICAgICAgIHBvc3RTY3JpcHROYW1lOiBwb3N0U2NyaXB0TmFtZSxcbiAgICAgICAgdW5pdHNQZXJFbTogZm9udC51bml0c1BlckVtLFxuICAgICAgICBmb250QkJveDogWzAsIGdsb2JhbHMueU1pbiwgZ2xvYmFscy5hc2NlbmRlciwgZ2xvYmFscy5hZHZhbmNlV2lkdGhNYXhdXG4gICAgfSk7XG5cbiAgICB2YXIgbWV0YVRhYmxlID0gKGZvbnQubWV0YXMgJiYgT2JqZWN0LmtleXMoZm9udC5tZXRhcykubGVuZ3RoID4gMCkgPyBtZXRhLm1ha2UoZm9udC5tZXRhcykgOiB1bmRlZmluZWQ7XG5cbiAgICAvLyBUaGUgb3JkZXIgZG9lcyBub3QgbWF0dGVyIGJlY2F1c2UgbWFrZVNmbnRUYWJsZSgpIHdpbGwgc29ydCB0aGVtLlxuICAgIHZhciB0YWJsZXMgPSBbaGVhZFRhYmxlLCBoaGVhVGFibGUsIG1heHBUYWJsZSwgb3MyVGFibGUsIG5hbWVUYWJsZSwgY21hcFRhYmxlLCBwb3N0VGFibGUsIGNmZlRhYmxlLCBobXR4VGFibGVdO1xuICAgIGlmIChsdGFnVGFibGUpIHtcbiAgICAgICAgdGFibGVzLnB1c2gobHRhZ1RhYmxlKTtcbiAgICB9XG4gICAgLy8gT3B0aW9uYWwgdGFibGVzXG4gICAgaWYgKGZvbnQudGFibGVzLmdzdWIpIHtcbiAgICAgICAgdGFibGVzLnB1c2goZ3N1Yi5tYWtlKGZvbnQudGFibGVzLmdzdWIpKTtcbiAgICB9XG4gICAgaWYgKG1ldGFUYWJsZSkge1xuICAgICAgICB0YWJsZXMucHVzaChtZXRhVGFibGUpO1xuICAgIH1cblxuICAgIHZhciBzZm50VGFibGUgPSBtYWtlU2ZudFRhYmxlKHRhYmxlcyk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBmb250J3MgY2hlY2tTdW0gYW5kIHN0b3JlIGl0IGluIGhlYWQuY2hlY2tTdW1BZGp1c3RtZW50LlxuICAgIHZhciBieXRlcyA9IHNmbnRUYWJsZS5lbmNvZGUoKTtcbiAgICB2YXIgY2hlY2tTdW0gPSBjb21wdXRlQ2hlY2tTdW0oYnl0ZXMpO1xuICAgIHZhciB0YWJsZUZpZWxkcyA9IHNmbnRUYWJsZS5maWVsZHM7XG4gICAgdmFyIGNoZWNrU3VtQWRqdXN0ZWQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0YWJsZUZpZWxkcy5sZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgIGlmICh0YWJsZUZpZWxkc1tpJDFdLm5hbWUgPT09ICdoZWFkIHRhYmxlJykge1xuICAgICAgICAgICAgdGFibGVGaWVsZHNbaSQxXS52YWx1ZS5jaGVja1N1bUFkanVzdG1lbnQgPSAweEIxQjBBRkJBIC0gY2hlY2tTdW07XG4gICAgICAgICAgICBjaGVja1N1bUFkanVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjaGVja1N1bUFkanVzdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgaGVhZCB0YWJsZSB3aXRoIGNoZWNrU3VtIHRvIGFkanVzdC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2ZudFRhYmxlO1xufVxuXG52YXIgc2ZudCA9IHsgbWFrZTogbWFrZVNmbnRUYWJsZSwgZm9udFRvVGFibGU6IGZvbnRUb1NmbnRUYWJsZSwgY29tcHV0ZUNoZWNrU3VtOiBjb21wdXRlQ2hlY2tTdW0gfTtcblxuLy8gVGhlIExheW91dCBvYmplY3QgaXMgdGhlIHByb3RvdHlwZSBvZiBTdWJzdGl0dXRpb24gb2JqZWN0cywgYW5kIHByb3ZpZGVzXG4vLyB1dGlsaXR5IG1ldGhvZHMgdG8gbWFuaXB1bGF0ZSBjb21tb24gbGF5b3V0IHRhYmxlcyAoR1BPUywgR1NVQiwgR0RFRi4uLilcblxuZnVuY3Rpb24gc2VhcmNoVGFnKGFyciwgdGFnKSB7XG4gICAgLyoganNoaW50IGJpdHdpc2U6IGZhbHNlICovXG4gICAgdmFyIGltaW4gPSAwO1xuICAgIHZhciBpbWF4ID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGltaW4gPD0gaW1heCkge1xuICAgICAgICB2YXIgaW1pZCA9IChpbWluICsgaW1heCkgPj4+IDE7XG4gICAgICAgIHZhciB2YWwgPSBhcnJbaW1pZF0udGFnO1xuICAgICAgICBpZiAodmFsID09PSB0YWcpIHtcbiAgICAgICAgICAgIHJldHVybiBpbWlkO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbCA8IHRhZykge1xuICAgICAgICAgICAgaW1pbiA9IGltaWQgKyAxO1xuICAgICAgICB9IGVsc2UgeyBpbWF4ID0gaW1pZCAtIDE7IH1cbiAgICB9XG4gICAgLy8gTm90IGZvdW5kOiByZXR1cm4gLTEtaW5zZXJ0aW9uIHBvaW50XG4gICAgcmV0dXJuIC1pbWluIC0gMTtcbn1cblxuZnVuY3Rpb24gYmluU2VhcmNoKGFyciwgdmFsdWUpIHtcbiAgICAvKiBqc2hpbnQgYml0d2lzZTogZmFsc2UgKi9cbiAgICB2YXIgaW1pbiA9IDA7XG4gICAgdmFyIGltYXggPSBhcnIubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoaW1pbiA8PSBpbWF4KSB7XG4gICAgICAgIHZhciBpbWlkID0gKGltaW4gKyBpbWF4KSA+Pj4gMTtcbiAgICAgICAgdmFyIHZhbCA9IGFycltpbWlkXTtcbiAgICAgICAgaWYgKHZhbCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbWlkO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbCA8IHZhbHVlKSB7XG4gICAgICAgICAgICBpbWluID0gaW1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7IGltYXggPSBpbWlkIC0gMTsgfVxuICAgIH1cbiAgICAvLyBOb3QgZm91bmQ6IHJldHVybiAtMS1pbnNlcnRpb24gcG9pbnRcbiAgICByZXR1cm4gLWltaW4gLSAxO1xufVxuXG4vLyBiaW5hcnkgc2VhcmNoIGluIGEgbGlzdCBvZiByYW5nZXMgKGNvdmVyYWdlLCBjbGFzcyBkZWZpbml0aW9uKVxuZnVuY3Rpb24gc2VhcmNoUmFuZ2UocmFuZ2VzLCB2YWx1ZSkge1xuICAgIC8vIGpzaGludCBiaXR3aXNlOiBmYWxzZVxuICAgIHZhciByYW5nZTtcbiAgICB2YXIgaW1pbiA9IDA7XG4gICAgdmFyIGltYXggPSByYW5nZXMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoaW1pbiA8PSBpbWF4KSB7XG4gICAgICAgIHZhciBpbWlkID0gKGltaW4gKyBpbWF4KSA+Pj4gMTtcbiAgICAgICAgcmFuZ2UgPSByYW5nZXNbaW1pZF07XG4gICAgICAgIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICBpZiAoc3RhcnQgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnQgPCB2YWx1ZSkge1xuICAgICAgICAgICAgaW1pbiA9IGltaWQgKyAxO1xuICAgICAgICB9IGVsc2UgeyBpbWF4ID0gaW1pZCAtIDE7IH1cbiAgICB9XG4gICAgaWYgKGltaW4gPiAwKSB7XG4gICAgICAgIHJhbmdlID0gcmFuZ2VzW2ltaW4gLSAxXTtcbiAgICAgICAgaWYgKHZhbHVlID4gcmFuZ2UuZW5kKSB7IHJldHVybiAwOyB9XG4gICAgICAgIHJldHVybiByYW5nZTtcbiAgICB9XG59XG5cbi8qKlxuICogQGV4cG9ydHMgb3BlbnR5cGUuTGF5b3V0XG4gKiBAY2xhc3NcbiAqL1xuZnVuY3Rpb24gTGF5b3V0KGZvbnQsIHRhYmxlTmFtZSkge1xuICAgIHRoaXMuZm9udCA9IGZvbnQ7XG4gICAgdGhpcy50YWJsZU5hbWUgPSB0YWJsZU5hbWU7XG59XG5cbkxheW91dC5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBCaW5hcnkgc2VhcmNoIGFuIG9iamVjdCBieSBcInRhZ1wiIHByb3BlcnR5XG4gICAgICogQGluc3RhbmNlXG4gICAgICogQGZ1bmN0aW9uIHNlYXJjaFRhZ1xuICAgICAqIEBtZW1iZXJvZiBvcGVudHlwZS5MYXlvdXRcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB0YWdcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gICAgc2VhcmNoVGFnOiBzZWFyY2hUYWcsXG5cbiAgICAvKipcbiAgICAgKiBCaW5hcnkgc2VhcmNoIGluIGEgbGlzdCBvZiBudW1iZXJzXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQGZ1bmN0aW9uIGJpblNlYXJjaFxuICAgICAqIEBtZW1iZXJvZiBvcGVudHlwZS5MYXlvdXRcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gYXJyXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgICBiaW5TZWFyY2g6IGJpblNlYXJjaCxcblxuICAgIC8qKlxuICAgICAqIEdldCBvciBjcmVhdGUgdGhlIExheW91dCB0YWJsZSAoR1NVQiwgR1BPUyBldGMpLlxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGNyZWF0ZSAtIFdoZXRoZXIgdG8gY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBHU1VCIG9yIEdQT1MgdGFibGUuXG4gICAgICovXG4gICAgZ2V0VGFibGU6IGZ1bmN0aW9uKGNyZWF0ZSkge1xuICAgICAgICB2YXIgbGF5b3V0ID0gdGhpcy5mb250LnRhYmxlc1t0aGlzLnRhYmxlTmFtZV07XG4gICAgICAgIGlmICghbGF5b3V0ICYmIGNyZWF0ZSkge1xuICAgICAgICAgICAgbGF5b3V0ID0gdGhpcy5mb250LnRhYmxlc1t0aGlzLnRhYmxlTmFtZV0gPSB0aGlzLmNyZWF0ZURlZmF1bHRUYWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYXlvdXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIHNjcmlwdHMgaW4gdGhlIHN1YnN0aXR1dGlvbiB0YWJsZS5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBnZXRTY3JpcHROYW1lczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldFRhYmxlKCk7XG4gICAgICAgIGlmICghbGF5b3V0KSB7IHJldHVybiBbXTsgfVxuICAgICAgICByZXR1cm4gbGF5b3V0LnNjcmlwdHMubWFwKGZ1bmN0aW9uKHNjcmlwdCkge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdC50YWc7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiZXN0IGJldCBmb3IgYSBzY3JpcHQgbmFtZS5cbiAgICAgKiBSZXR1cm5zICdERkxUJyBpZiBpdCBleGlzdHMuXG4gICAgICogSWYgbm90LCByZXR1cm5zICdsYXRuJyBpZiBpdCBleGlzdHMuXG4gICAgICogSWYgbmVpdGhlciBleGlzdCwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFNjcmlwdE5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbGF5b3V0ID0gdGhpcy5nZXRUYWJsZSgpO1xuICAgICAgICBpZiAoIWxheW91dCkgeyByZXR1cm47IH1cbiAgICAgICAgdmFyIGhhc0xhdG4gPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXQuc2NyaXB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBsYXlvdXQuc2NyaXB0c1tpXS50YWc7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ0RGTFQnKSB7IHJldHVybiBuYW1lOyB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ2xhdG4nKSB7IGhhc0xhdG4gPSB0cnVlOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0xhdG4pIHsgcmV0dXJuICdsYXRuJzsgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBMYW5nU3lzUmVjb3JkcyBpbiB0aGUgZ2l2ZW4gc2NyaXB0LlxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNyZWF0ZSAtIGZvcmNlcyB0aGUgY3JlYXRpb24gb2YgdGhpcyBzY3JpcHQgdGFibGUgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIHRhZyBhbmQgc2NyaXB0IHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgZ2V0U2NyaXB0VGFibGU6IGZ1bmN0aW9uKHNjcmlwdCwgY3JlYXRlKSB7XG4gICAgICAgIHZhciBsYXlvdXQgPSB0aGlzLmdldFRhYmxlKGNyZWF0ZSk7XG4gICAgICAgIGlmIChsYXlvdXQpIHtcbiAgICAgICAgICAgIHNjcmlwdCA9IHNjcmlwdCB8fCAnREZMVCc7XG4gICAgICAgICAgICB2YXIgc2NyaXB0cyA9IGxheW91dC5zY3JpcHRzO1xuICAgICAgICAgICAgdmFyIHBvcyA9IHNlYXJjaFRhZyhsYXlvdXQuc2NyaXB0cywgc2NyaXB0KTtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY3JpcHRzW3Bvc10uc2NyaXB0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NyID0ge1xuICAgICAgICAgICAgICAgICAgICB0YWc6IHNjcmlwdCxcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TGFuZ1N5czoge3Jlc2VydmVkOiAwLCByZXFGZWF0dXJlSW5kZXg6IDB4ZmZmZiwgZmVhdHVyZUluZGV4ZXM6IFtdfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmdTeXNSZWNvcmRzOiBbXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzY3JpcHRzLnNwbGljZSgtMSAtIHBvcywgMCwgc2NyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NyLnNjcmlwdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGFuZ3VhZ2Ugc3lzdGVtIHRhYmxlXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RsZnQnXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JlYXRlIC0gZm9yY2VzIHRoZSBjcmVhdGlvbiBvZiB0aGlzIGxhbmdTeXNUYWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRMYW5nU3lzVGFibGU6IGZ1bmN0aW9uKHNjcmlwdCwgbGFuZ3VhZ2UsIGNyZWF0ZSkge1xuICAgICAgICB2YXIgc2NyaXB0VGFibGUgPSB0aGlzLmdldFNjcmlwdFRhYmxlKHNjcmlwdCwgY3JlYXRlKTtcbiAgICAgICAgaWYgKHNjcmlwdFRhYmxlKSB7XG4gICAgICAgICAgICBpZiAoIWxhbmd1YWdlIHx8IGxhbmd1YWdlID09PSAnZGZsdCcgfHwgbGFuZ3VhZ2UgPT09ICdERkxUJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY3JpcHRUYWJsZS5kZWZhdWx0TGFuZ1N5cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwb3MgPSBzZWFyY2hUYWcoc2NyaXB0VGFibGUubGFuZ1N5c1JlY29yZHMsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY3JpcHRUYWJsZS5sYW5nU3lzUmVjb3Jkc1twb3NdLmxhbmdTeXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBsYW5nU3lzUmVjb3JkID0ge1xuICAgICAgICAgICAgICAgICAgICB0YWc6IGxhbmd1YWdlLFxuICAgICAgICAgICAgICAgICAgICBsYW5nU3lzOiB7cmVzZXJ2ZWQ6IDAsIHJlcUZlYXR1cmVJbmRleDogMHhmZmZmLCBmZWF0dXJlSW5kZXhlczogW119XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzY3JpcHRUYWJsZS5sYW5nU3lzUmVjb3Jkcy5zcGxpY2UoLTEgLSBwb3MsIDAsIGxhbmdTeXNSZWNvcmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBsYW5nU3lzUmVjb3JkLmxhbmdTeXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc3BlY2lmaWMgZmVhdHVyZSB0YWJsZS5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGxmdCddXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSBPbmUgb2YgdGhlIGNvZGVzIGxpc3RlZCBhdCBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2ZlYXR1cmVsaXN0Lmh0bVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JlYXRlIC0gZm9yY2VzIHRoZSBjcmVhdGlvbiBvZiB0aGUgZmVhdHVyZSB0YWJsZSBpZiBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRGZWF0dXJlVGFibGU6IGZ1bmN0aW9uKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIGNyZWF0ZSkge1xuICAgICAgICB2YXIgbGFuZ1N5c1RhYmxlID0gdGhpcy5nZXRMYW5nU3lzVGFibGUoc2NyaXB0LCBsYW5ndWFnZSwgY3JlYXRlKTtcbiAgICAgICAgaWYgKGxhbmdTeXNUYWJsZSkge1xuICAgICAgICAgICAgdmFyIGZlYXR1cmVSZWNvcmQ7XG4gICAgICAgICAgICB2YXIgZmVhdEluZGV4ZXMgPSBsYW5nU3lzVGFibGUuZmVhdHVyZUluZGV4ZXM7XG4gICAgICAgICAgICB2YXIgYWxsRmVhdHVyZXMgPSB0aGlzLmZvbnQudGFibGVzW3RoaXMudGFibGVOYW1lXS5mZWF0dXJlcztcbiAgICAgICAgICAgIC8vIFRoZSBGZWF0dXJlSW5kZXggYXJyYXkgb2YgaW5kaWNlcyBpcyBpbiBhcmJpdHJhcnkgb3JkZXIsXG4gICAgICAgICAgICAvLyBldmVuIGlmIGFsbEZlYXR1cmVzIGlzIHNvcnRlZCBhbHBoYWJldGljYWxseSBieSBmZWF0dXJlIHRhZy5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdEluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlUmVjb3JkID0gYWxsRmVhdHVyZXNbZmVhdEluZGV4ZXNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlUmVjb3JkLnRhZyA9PT0gZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmVhdHVyZVJlY29yZC5mZWF0dXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBhbGxGZWF0dXJlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gQXV0b21hdGljIG9yZGVyaW5nIG9mIGZlYXR1cmVzIHdvdWxkIHJlcXVpcmUgdG8gc2hpZnQgZmVhdHVyZSBpbmRleGVzIGluIHRoZSBzY3JpcHQgbGlzdC5cbiAgICAgICAgICAgICAgICBjaGVjay5hc3NlcnQoaW5kZXggPT09IDAgfHwgZmVhdHVyZSA+PSBhbGxGZWF0dXJlc1tpbmRleCAtIDFdLnRhZywgJ0ZlYXR1cmVzIG11c3QgYmUgYWRkZWQgaW4gYWxwaGFiZXRpY2FsIG9yZGVyLicpO1xuICAgICAgICAgICAgICAgIGZlYXR1cmVSZWNvcmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZzogZmVhdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZTogeyBwYXJhbXM6IDAsIGxvb2t1cExpc3RJbmRleGVzOiBbXSB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhbGxGZWF0dXJlcy5wdXNoKGZlYXR1cmVSZWNvcmQpO1xuICAgICAgICAgICAgICAgIGZlYXRJbmRleGVzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmZWF0dXJlUmVjb3JkLmZlYXR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsb29rdXAgdGFibGVzIG9mIGEgZ2l2ZW4gdHlwZSBmb3IgYSBzY3JpcHQvbGFuZ3VhZ2UvZmVhdHVyZS5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGxmdCddXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIGNvZGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbG9va3VwVHlwZSAtIDEgdG8gOVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY3JlYXRlIC0gZm9yY2VzIHRoZSBjcmVhdGlvbiBvZiB0aGUgbG9va3VwIHRhYmxlIGlmIGl0IGRvZXNuJ3QgZXhpc3QsIHdpdGggbm8gc3VidGFibGVzLlxuICAgICAqIEByZXR1cm4ge09iamVjdFtdfVxuICAgICAqL1xuICAgIGdldExvb2t1cFRhYmxlczogZnVuY3Rpb24oc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgbG9va3VwVHlwZSwgY3JlYXRlKSB7XG4gICAgICAgIHZhciBmZWF0dXJlVGFibGUgPSB0aGlzLmdldEZlYXR1cmVUYWJsZShzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCBjcmVhdGUpO1xuICAgICAgICB2YXIgdGFibGVzID0gW107XG4gICAgICAgIGlmIChmZWF0dXJlVGFibGUpIHtcbiAgICAgICAgICAgIHZhciBsb29rdXBUYWJsZTtcbiAgICAgICAgICAgIHZhciBsb29rdXBMaXN0SW5kZXhlcyA9IGZlYXR1cmVUYWJsZS5sb29rdXBMaXN0SW5kZXhlcztcbiAgICAgICAgICAgIHZhciBhbGxMb29rdXBzID0gdGhpcy5mb250LnRhYmxlc1t0aGlzLnRhYmxlTmFtZV0ubG9va3VwcztcbiAgICAgICAgICAgIC8vIGxvb2t1cExpc3RJbmRleGVzIGFyZSBpbiBubyBwYXJ0aWN1bGFyIG9yZGVyLCBzbyB1c2UgbmFpdmUgc2VhcmNoLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb29rdXBMaXN0SW5kZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxvb2t1cFRhYmxlID0gYWxsTG9va3Vwc1tsb29rdXBMaXN0SW5kZXhlc1tpXV07XG4gICAgICAgICAgICAgICAgaWYgKGxvb2t1cFRhYmxlLmxvb2t1cFR5cGUgPT09IGxvb2t1cFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFibGVzLnB1c2gobG9va3VwVGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YWJsZXMubGVuZ3RoID09PSAwICYmIGNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIGxvb2t1cFRhYmxlID0ge1xuICAgICAgICAgICAgICAgICAgICBsb29rdXBUeXBlOiBsb29rdXBUeXBlLFxuICAgICAgICAgICAgICAgICAgICBsb29rdXBGbGFnOiAwLFxuICAgICAgICAgICAgICAgICAgICBzdWJ0YWJsZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBtYXJrRmlsdGVyaW5nU2V0OiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGFsbExvb2t1cHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGFsbExvb2t1cHMucHVzaChsb29rdXBUYWJsZSk7XG4gICAgICAgICAgICAgICAgbG9va3VwTGlzdEluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtsb29rdXBUYWJsZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhYmxlcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCBhIGdseXBoIGluIGEgY2xhc3MgZGVmaW5pdGlvbiB0YWJsZVxuICAgICAqIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9jaGFwdGVyMiNjbGFzcy1kZWZpbml0aW9uLXRhYmxlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNsYXNzRGVmVGFibGUgLSBhbiBPcGVuVHlwZSBMYXlvdXQgY2xhc3MgZGVmaW5pdGlvbiB0YWJsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnbHlwaEluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBnbHlwaCB0byBmaW5kXG4gICAgICogQHJldHVybnMge251bWJlcn0gLTEgaWYgbm90IGZvdW5kXG4gICAgICovXG4gICAgZ2V0R2x5cGhDbGFzczogZnVuY3Rpb24oY2xhc3NEZWZUYWJsZSwgZ2x5cGhJbmRleCkge1xuICAgICAgICBzd2l0Y2ggKGNsYXNzRGVmVGFibGUuZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgaWYgKGNsYXNzRGVmVGFibGUuc3RhcnRHbHlwaCA8PSBnbHlwaEluZGV4ICYmIGdseXBoSW5kZXggPCBjbGFzc0RlZlRhYmxlLnN0YXJ0R2x5cGggKyBjbGFzc0RlZlRhYmxlLmNsYXNzZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc0RlZlRhYmxlLmNsYXNzZXNbZ2x5cGhJbmRleCAtIGNsYXNzRGVmVGFibGUuc3RhcnRHbHlwaF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHZhciByYW5nZSA9IHNlYXJjaFJhbmdlKGNsYXNzRGVmVGFibGUucmFuZ2VzLCBnbHlwaEluZGV4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2UgPyByYW5nZS5jbGFzc0lkIDogMDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgZ2x5cGggaW4gYSBjb3ZlcmFnZSB0YWJsZVxuICAgICAqIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9jaGFwdGVyMiNjb3ZlcmFnZS10YWJsZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb3ZlcmFnZVRhYmxlIC0gYW4gT3BlblR5cGUgTGF5b3V0IGNvdmVyYWdlIHRhYmxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdseXBoSW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIGdseXBoIHRvIGZpbmRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtMSBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBnZXRDb3ZlcmFnZUluZGV4OiBmdW5jdGlvbihjb3ZlcmFnZVRhYmxlLCBnbHlwaEluZGV4KSB7XG4gICAgICAgIHN3aXRjaCAoY292ZXJhZ2VUYWJsZS5mb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBiaW5TZWFyY2goY292ZXJhZ2VUYWJsZS5nbHlwaHMsIGdseXBoSW5kZXgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA+PSAwID8gaW5kZXggOiAtMTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZWFyY2hSYW5nZShjb3ZlcmFnZVRhYmxlLnJhbmdlcywgZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlID8gcmFuZ2UuaW5kZXggKyBnbHlwaEluZGV4IC0gcmFuZ2Uuc3RhcnQgOiAtMTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGdseXBoIGluZGV4ZXMgb2YgYSBjb3ZlcmFnZSB0YWJsZS5cbiAgICAgKiBGb3JtYXQgMTogdGhlIGxpc3QgaXMgc3RvcmVkIHJhd1xuICAgICAqIEZvcm1hdCAyOiBjb21wYWN0IGxpc3QgYXMgcmFuZ2UgcmVjb3Jkcy5cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvdmVyYWdlVGFibGVcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBleHBhbmRDb3ZlcmFnZTogZnVuY3Rpb24oY292ZXJhZ2VUYWJsZSkge1xuICAgICAgICBpZiAoY292ZXJhZ2VUYWJsZS5mb3JtYXQgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3ZlcmFnZVRhYmxlLmdseXBocztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBnbHlwaHMgPSBbXTtcbiAgICAgICAgICAgIHZhciByYW5nZXMgPSBjb3ZlcmFnZVRhYmxlLnJhbmdlcztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0O1xuICAgICAgICAgICAgICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0OyBqIDw9IGVuZDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGdseXBocy5wdXNoKGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnbHlwaHM7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbi8vIFRoZSBQb3NpdGlvbiBvYmplY3QgcHJvdmlkZXMgdXRpbGl0eSBtZXRob2RzIHRvIG1hbmlwdWxhdGVcbi8vIHRoZSBHUE9TIHBvc2l0aW9uIHRhYmxlLlxuXG4vKipcbiAqIEBleHBvcnRzIG9wZW50eXBlLlBvc2l0aW9uXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIG9wZW50eXBlLkxheW91dFxuICogQHBhcmFtIHtvcGVudHlwZS5Gb250fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFBvc2l0aW9uKGZvbnQpIHtcbiAgICBMYXlvdXQuY2FsbCh0aGlzLCBmb250LCAnZ3BvcycpO1xufVxuXG5Qb3NpdGlvbi5wcm90b3R5cGUgPSBMYXlvdXQucHJvdG90eXBlO1xuXG4vKipcbiAqIEZpbmQgYSBnbHlwaCBwYWlyIGluIGEgbGlzdCBvZiBsb29rdXAgdGFibGVzIG9mIHR5cGUgMiBhbmQgcmV0cmlldmUgdGhlIHhBZHZhbmNlIGtlcm5pbmcgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtpbnRlZ2VyfSBsZWZ0SW5kZXggLSBsZWZ0IGdseXBoIGluZGV4XG4gKiBAcGFyYW0ge2ludGVnZXJ9IHJpZ2h0SW5kZXggLSByaWdodCBnbHlwaCBpbmRleFxuICogQHJldHVybnMge2ludGVnZXJ9XG4gKi9cblBvc2l0aW9uLnByb3RvdHlwZS5nZXRLZXJuaW5nVmFsdWUgPSBmdW5jdGlvbihrZXJuaW5nTG9va3VwcywgbGVmdEluZGV4LCByaWdodEluZGV4KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtlcm5pbmdMb29rdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZXMgPSBrZXJuaW5nTG9va3Vwc1tpXS5zdWJ0YWJsZXM7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3VidGFibGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbal07XG4gICAgICAgICAgICB2YXIgY292SW5kZXggPSB0aGlzJDEuZ2V0Q292ZXJhZ2VJbmRleChzdWJ0YWJsZS5jb3ZlcmFnZSwgbGVmdEluZGV4KTtcbiAgICAgICAgICAgIGlmIChjb3ZJbmRleCA8IDApIHsgY29udGludWU7IH1cbiAgICAgICAgICAgIHN3aXRjaCAoc3VidGFibGUucG9zRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAvLyBTZWFyY2ggUGFpciBBZGp1c3RtZW50IFBvc2l0aW9uaW5nIEZvcm1hdCAxXG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWlyU2V0ID0gc3VidGFibGUucGFpclNldHNbY292SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHBhaXJTZXQubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYWlyID0gcGFpclNldFtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWlyLnNlY29uZEdseXBoID09PSByaWdodEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIudmFsdWUxICYmIHBhaXIudmFsdWUxLnhBZHZhbmNlIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7ICAgICAgLy8gbGVmdCBnbHlwaCBmb3VuZCwgbm90IHJpZ2h0IGdseXBoIC0gdHJ5IG5leHQgc3VidGFibGVcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCBQYWlyIEFkanVzdG1lbnQgUG9zaXRpb25pbmcgRm9ybWF0IDJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzMSA9IHRoaXMkMS5nZXRHbHlwaENsYXNzKHN1YnRhYmxlLmNsYXNzRGVmMSwgbGVmdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzMiA9IHRoaXMkMS5nZXRHbHlwaENsYXNzKHN1YnRhYmxlLmNsYXNzRGVmMiwgcmlnaHRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWlyJDEgPSBzdWJ0YWJsZS5jbGFzc1JlY29yZHNbY2xhc3MxXVtjbGFzczJdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpciQxLnZhbHVlMSAmJiBwYWlyJDEudmFsdWUxLnhBZHZhbmNlIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIGtlcm5pbmcgbG9va3VwIHRhYmxlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddIC0gdXNlIGZvbnQucG9zaXRpb24uZ2V0RGVmYXVsdFNjcmlwdE5hbWUoKSBmb3IgYSBiZXR0ZXIgZGVmYXVsdCB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKiBAcmV0dXJuIHtvYmplY3RbXX0gVGhlIGxpc3Qgb2Yga2VybmluZyBsb29rdXAgdGFibGVzIChtYXkgYmUgZW1wdHkpLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gR1BPUyB0YWJsZSAoYW5kIHdlIHNob3VsZCB1c2UgdGhlIGtlcm4gdGFibGUpXG4gKi9cblBvc2l0aW9uLnByb3RvdHlwZS5nZXRLZXJuaW5nVGFibGVzID0gZnVuY3Rpb24oc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIGlmICh0aGlzLmZvbnQudGFibGVzLmdwb3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsICdrZXJuJywgMik7XG4gICAgfVxufTtcblxuLy8gVGhlIFN1YnN0aXR1dGlvbiBvYmplY3QgcHJvdmlkZXMgdXRpbGl0eSBtZXRob2RzIHRvIG1hbmlwdWxhdGVcbi8vIHRoZSBHU1VCIHN1YnN0aXR1dGlvbiB0YWJsZS5cblxuLyoqXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5TdWJzdGl0dXRpb25cbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgb3BlbnR5cGUuTGF5b3V0XG4gKiBAcGFyYW0ge29wZW50eXBlLkZvbnR9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU3Vic3RpdHV0aW9uKGZvbnQpIHtcbiAgICBMYXlvdXQuY2FsbCh0aGlzLCBmb250LCAnZ3N1YicpO1xufVxuXG4vLyBDaGVjayBpZiAyIGFycmF5cyBvZiBwcmltaXRpdmVzIGFyZSBlcXVhbC5cbmZ1bmN0aW9uIGFycmF5c0VxdWFsKGFyMSwgYXIyKSB7XG4gICAgdmFyIG4gPSBhcjEubGVuZ3RoO1xuICAgIGlmIChuICE9PSBhcjIubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIGlmIChhcjFbaV0gIT09IGFyMltpXSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIEZpbmQgdGhlIGZpcnN0IHN1YnRhYmxlIG9mIGEgbG9va3VwIHRhYmxlIGluIGEgcGFydGljdWxhciBmb3JtYXQuXG5mdW5jdGlvbiBnZXRTdWJzdEZvcm1hdChsb29rdXBUYWJsZSwgZm9ybWF0LCBkZWZhdWx0U3VidGFibGUpIHtcbiAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGUuc3VidGFibGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tpXTtcbiAgICAgICAgaWYgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSBmb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdWJ0YWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdFN1YnRhYmxlKSB7XG4gICAgICAgIHN1YnRhYmxlcy5wdXNoKGRlZmF1bHRTdWJ0YWJsZSk7XG4gICAgICAgIHJldHVybiBkZWZhdWx0U3VidGFibGU7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUgPSBMYXlvdXQucHJvdG90eXBlO1xuXG4vKipcbiAqIENyZWF0ZSBhIGRlZmF1bHQgR1NVQiB0YWJsZS5cbiAqIEByZXR1cm4ge09iamVjdH0gZ3N1YiAtIFRoZSBHU1VCIHRhYmxlLlxuICovXG5TdWJzdGl0dXRpb24ucHJvdG90eXBlLmNyZWF0ZURlZmF1bHRUYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIEdlbmVyYXRlIGEgZGVmYXVsdCBlbXB0eSBHU1VCIHRhYmxlIHdpdGgganVzdCBhIERGTFQgc2NyaXB0IGFuZCBkZmx0IGxhbmcgc3lzLlxuICAgIHJldHVybiB7XG4gICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgIHNjcmlwdHM6IFt7XG4gICAgICAgICAgICB0YWc6ICdERkxUJyxcbiAgICAgICAgICAgIHNjcmlwdDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRMYW5nU3lzOiB7IHJlc2VydmVkOiAwLCByZXFGZWF0dXJlSW5kZXg6IDB4ZmZmZiwgZmVhdHVyZUluZGV4ZXM6IFtdIH0sXG4gICAgICAgICAgICAgICAgbGFuZ1N5c1JlY29yZHM6IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1dLFxuICAgICAgICBmZWF0dXJlczogW10sXG4gICAgICAgIGxvb2t1cHM6IFtdXG4gICAgfTtcbn07XG5cbi8qKlxuICogTGlzdCBhbGwgc2luZ2xlIHN1YnN0aXR1dGlvbnMgKGxvb2t1cCB0eXBlIDEpIGZvciBhIGdpdmVuIHNjcmlwdCwgbGFuZ3VhZ2UsIGFuZCBmZWF0dXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtY2hhcmFjdGVyIGZlYXR1cmUgbmFtZSAoJ2FhbHQnLCAnc2FsdCcsICdzczAxJy4uLilcbiAqIEByZXR1cm4ge0FycmF5fSBzdWJzdGl0dXRpb25zIC0gVGhlIGxpc3Qgb2Ygc3Vic3RpdHV0aW9ucy5cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRTaW5nbGUgPSBmdW5jdGlvbihmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IFtdO1xuICAgIHZhciBsb29rdXBUYWJsZXMgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCAxKTtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsb29rdXBUYWJsZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICB2YXIgc3VidGFibGVzID0gbG9va3VwVGFibGVzW2lkeF0uc3VidGFibGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN1YnRhYmxlID0gc3VidGFibGVzW2ldO1xuICAgICAgICAgICAgdmFyIGdseXBocyA9IHRoaXMkMS5leHBhbmRDb3ZlcmFnZShzdWJ0YWJsZS5jb3ZlcmFnZSk7XG4gICAgICAgICAgICB2YXIgaiA9ICh2b2lkIDApO1xuICAgICAgICAgICAgaWYgKHN1YnRhYmxlLnN1YnN0Rm9ybWF0ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gc3VidGFibGUuZGVsdGFHbHlwaElkO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdseXBoID0gZ2x5cGhzW2pdO1xuICAgICAgICAgICAgICAgICAgICBzdWJzdGl0dXRpb25zLnB1c2goeyBzdWI6IGdseXBoLCBieTogZ2x5cGggKyBkZWx0YSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdWJzdGl0dXRlID0gc3VidGFibGUuc3Vic3RpdHV0ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2x5cGhzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh7IHN1YjogZ2x5cGhzW2pdLCBieTogc3Vic3RpdHV0ZVtqXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1YnN0aXR1dGlvbnM7XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIGFsdGVybmF0ZXMgKGxvb2t1cCB0eXBlIDMpIGZvciBhIGdpdmVuIHNjcmlwdCwgbGFuZ3VhZ2UsIGFuZCBmZWF0dXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtY2hhcmFjdGVyIGZlYXR1cmUgbmFtZSAoJ2FhbHQnLCAnc2FsdCcuLi4pXG4gKiBAcmV0dXJuIHtBcnJheX0gYWx0ZXJuYXRlcyAtIFRoZSBsaXN0IG9mIGFsdGVybmF0ZXNcbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRBbHRlcm5hdGVzID0gZnVuY3Rpb24oZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFsdGVybmF0ZXMgPSBbXTtcbiAgICB2YXIgbG9va3VwVGFibGVzID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMyk7XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbG9va3VwVGFibGVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgdmFyIHN1YnRhYmxlcyA9IGxvb2t1cFRhYmxlc1tpZHhdLnN1YnRhYmxlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJ0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdWJ0YWJsZSA9IHN1YnRhYmxlc1tpXTtcbiAgICAgICAgICAgIHZhciBnbHlwaHMgPSB0aGlzJDEuZXhwYW5kQ292ZXJhZ2Uoc3VidGFibGUuY292ZXJhZ2UpO1xuICAgICAgICAgICAgdmFyIGFsdGVybmF0ZVNldHMgPSBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnbHlwaHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBhbHRlcm5hdGVzLnB1c2goeyBzdWI6IGdseXBoc1tqXSwgYnk6IGFsdGVybmF0ZVNldHNbal0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFsdGVybmF0ZXM7XG59O1xuXG4vKipcbiAqIExpc3QgYWxsIGxpZ2F0dXJlcyAobG9va3VwIHR5cGUgNCkgZm9yIGEgZ2l2ZW4gc2NyaXB0LCBsYW5ndWFnZSwgYW5kIGZlYXR1cmUuXG4gKiBUaGUgcmVzdWx0IGlzIGFuIGFycmF5IG9mIGxpZ2F0dXJlIG9iamVjdHMgbGlrZSB7IHN1YjogW2lkc10sIGJ5OiBpZCB9XG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZSAoJ2xpZ2EnLCAncmxpZycsICdkbGlnJy4uLilcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc2NyaXB0PSdERkxUJ11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXVxuICogQHJldHVybiB7QXJyYXl9IGxpZ2F0dXJlcyAtIFRoZSBsaXN0IG9mIGxpZ2F0dXJlcy5cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRMaWdhdHVyZXMgPSBmdW5jdGlvbihmZWF0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbGlnYXR1cmVzID0gW107XG4gICAgdmFyIGxvb2t1cFRhYmxlcyA9IHRoaXMuZ2V0TG9va3VwVGFibGVzKHNjcmlwdCwgbGFuZ3VhZ2UsIGZlYXR1cmUsIDQpO1xuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxvb2t1cFRhYmxlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIHZhciBzdWJ0YWJsZXMgPSBsb29rdXBUYWJsZXNbaWR4XS5zdWJ0YWJsZXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3VidGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3VidGFibGUgPSBzdWJ0YWJsZXNbaV07XG4gICAgICAgICAgICB2YXIgZ2x5cGhzID0gdGhpcyQxLmV4cGFuZENvdmVyYWdlKHN1YnRhYmxlLmNvdmVyYWdlKTtcbiAgICAgICAgICAgIHZhciBsaWdhdHVyZVNldHMgPSBzdWJ0YWJsZS5saWdhdHVyZVNldHM7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdseXBocy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEdseXBoID0gZ2x5cGhzW2pdO1xuICAgICAgICAgICAgICAgIHZhciBsaWdTZXQgPSBsaWdhdHVyZVNldHNbal07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsaWdTZXQubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpZyA9IGxpZ1NldFtrXTtcbiAgICAgICAgICAgICAgICAgICAgbGlnYXR1cmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViOiBbc3RhcnRHbHlwaF0uY29uY2F0KGxpZy5jb21wb25lbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5OiBsaWcubGlnR2x5cGhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaWdhdHVyZXM7XG59O1xuXG4vKipcbiAqIEFkZCBvciBtb2RpZnkgYSBzaW5nbGUgc3Vic3RpdHV0aW9uIChsb29rdXAgdHlwZSAxKVxuICogRm9ybWF0IDIsIG1vcmUgZmxleGlibGUsIGlzIGFsd2F5cyB1c2VkLlxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG4gKiBAcGFyYW0ge09iamVjdH0gc3Vic3RpdHV0aW9uIC0geyBzdWI6IGlkLCBkZWx0YTogbnVtYmVyIH0gZm9yIGZvcm1hdCAxIG9yIHsgc3ViOiBpZCwgYnk6IGlkIH0gZm9yIGZvcm1hdCAyLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkU2luZ2xlID0gZnVuY3Rpb24oZmVhdHVyZSwgc3Vic3RpdHV0aW9uLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgMSwgdHJ1ZSlbMF07XG4gICAgdmFyIHN1YnRhYmxlID0gZ2V0U3Vic3RGb3JtYXQobG9va3VwVGFibGUsIDIsIHsgICAgICAgICAgICAgICAgLy8gbG9va3VwIHR5cGUgMSBzdWJ0YWJsZSwgZm9ybWF0IDIsIGNvdmVyYWdlIGZvcm1hdCAxXG4gICAgICAgIHN1YnN0Rm9ybWF0OiAyLFxuICAgICAgICBjb3ZlcmFnZToge2Zvcm1hdDogMSwgZ2x5cGhzOiBbXX0sXG4gICAgICAgIHN1YnN0aXR1dGU6IFtdXG4gICAgfSk7XG4gICAgY2hlY2suYXNzZXJ0KHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCA9PT0gMSwgJ0xpZ2F0dXJlOiB1bmFibGUgdG8gbW9kaWZ5IGNvdmVyYWdlIHRhYmxlIGZvcm1hdCAnICsgc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0KTtcbiAgICB2YXIgY292ZXJhZ2VHbHlwaCA9IHN1YnN0aXR1dGlvbi5zdWI7XG4gICAgdmFyIHBvcyA9IHRoaXMuYmluU2VhcmNoKHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocywgY292ZXJhZ2VHbHlwaCk7XG4gICAgaWYgKHBvcyA8IDApIHtcbiAgICAgICAgcG9zID0gLTEgLSBwb3M7XG4gICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocy5zcGxpY2UocG9zLCAwLCBjb3ZlcmFnZUdseXBoKTtcbiAgICAgICAgc3VidGFibGUuc3Vic3RpdHV0ZS5zcGxpY2UocG9zLCAwLCAwKTtcbiAgICB9XG4gICAgc3VidGFibGUuc3Vic3RpdHV0ZVtwb3NdID0gc3Vic3RpdHV0aW9uLmJ5O1xufTtcblxuLyoqXG4gKiBBZGQgb3IgbW9kaWZ5IGFuIGFsdGVybmF0ZSBzdWJzdGl0dXRpb24gKGxvb2t1cCB0eXBlIDEpXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZSAoJ2xpZ2EnLCAncmxpZycsICdkbGlnJy4uLilcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdWJzdGl0dXRpb24gLSB7IHN1YjogaWQsIGJ5OiBbaWRzXSB9XG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hZGRBbHRlcm5hdGUgPSBmdW5jdGlvbihmZWF0dXJlLCBzdWJzdGl0dXRpb24sIHNjcmlwdCwgbGFuZ3VhZ2UpIHtcbiAgICB2YXIgbG9va3VwVGFibGUgPSB0aGlzLmdldExvb2t1cFRhYmxlcyhzY3JpcHQsIGxhbmd1YWdlLCBmZWF0dXJlLCAzLCB0cnVlKVswXTtcbiAgICB2YXIgc3VidGFibGUgPSBnZXRTdWJzdEZvcm1hdChsb29rdXBUYWJsZSwgMSwgeyAgICAgICAgICAgICAgICAvLyBsb29rdXAgdHlwZSAzIHN1YnRhYmxlLCBmb3JtYXQgMSwgY292ZXJhZ2UgZm9ybWF0IDFcbiAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgIGNvdmVyYWdlOiB7Zm9ybWF0OiAxLCBnbHlwaHM6IFtdfSxcbiAgICAgICAgYWx0ZXJuYXRlU2V0czogW11cbiAgICB9KTtcbiAgICBjaGVjay5hc3NlcnQoc3VidGFibGUuY292ZXJhZ2UuZm9ybWF0ID09PSAxLCAnTGlnYXR1cmU6IHVuYWJsZSB0byBtb2RpZnkgY292ZXJhZ2UgdGFibGUgZm9ybWF0ICcgKyBzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQpO1xuICAgIHZhciBjb3ZlcmFnZUdseXBoID0gc3Vic3RpdHV0aW9uLnN1YjtcbiAgICB2YXIgcG9zID0gdGhpcy5iaW5TZWFyY2goc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLCBjb3ZlcmFnZUdseXBoKTtcbiAgICBpZiAocG9zIDwgMCkge1xuICAgICAgICBwb3MgPSAtMSAtIHBvcztcbiAgICAgICAgc3VidGFibGUuY292ZXJhZ2UuZ2x5cGhzLnNwbGljZShwb3MsIDAsIGNvdmVyYWdlR2x5cGgpO1xuICAgICAgICBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzLnNwbGljZShwb3MsIDAsIDApO1xuICAgIH1cbiAgICBzdWJ0YWJsZS5hbHRlcm5hdGVTZXRzW3Bvc10gPSBzdWJzdGl0dXRpb24uYnk7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpZ2F0dXJlIChsb29rdXAgdHlwZSA0KVxuICogTGlnYXR1cmVzIHdpdGggbW9yZSBjb21wb25lbnRzIG11c3QgYmUgc3RvcmVkIGFoZWFkIG9mIHRob3NlIHdpdGggZmV3ZXIgY29tcG9uZW50cyBpbiBvcmRlciB0byBiZSBmb3VuZFxuICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmUgLSA0LWxldHRlciBmZWF0dXJlIG5hbWUgKCdsaWdhJywgJ3JsaWcnLCAnZGxpZycuLi4pXG4gKiBAcGFyYW0ge09iamVjdH0gbGlnYXR1cmUgLSB7IHN1YjogW2lkc10sIGJ5OiBpZCB9XG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5hZGRMaWdhdHVyZSA9IGZ1bmN0aW9uKGZlYXR1cmUsIGxpZ2F0dXJlLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgdmFyIGxvb2t1cFRhYmxlID0gdGhpcy5nZXRMb29rdXBUYWJsZXMoc2NyaXB0LCBsYW5ndWFnZSwgZmVhdHVyZSwgNCwgdHJ1ZSlbMF07XG4gICAgdmFyIHN1YnRhYmxlID0gbG9va3VwVGFibGUuc3VidGFibGVzWzBdO1xuICAgIGlmICghc3VidGFibGUpIHtcbiAgICAgICAgc3VidGFibGUgPSB7ICAgICAgICAgICAgICAgIC8vIGxvb2t1cCB0eXBlIDQgc3VidGFibGUsIGZvcm1hdCAxLCBjb3ZlcmFnZSBmb3JtYXQgMVxuICAgICAgICAgICAgc3Vic3RGb3JtYXQ6IDEsXG4gICAgICAgICAgICBjb3ZlcmFnZTogeyBmb3JtYXQ6IDEsIGdseXBoczogW10gfSxcbiAgICAgICAgICAgIGxpZ2F0dXJlU2V0czogW11cbiAgICAgICAgfTtcbiAgICAgICAgbG9va3VwVGFibGUuc3VidGFibGVzWzBdID0gc3VidGFibGU7XG4gICAgfVxuICAgIGNoZWNrLmFzc2VydChzdWJ0YWJsZS5jb3ZlcmFnZS5mb3JtYXQgPT09IDEsICdMaWdhdHVyZTogdW5hYmxlIHRvIG1vZGlmeSBjb3ZlcmFnZSB0YWJsZSBmb3JtYXQgJyArIHN1YnRhYmxlLmNvdmVyYWdlLmZvcm1hdCk7XG4gICAgdmFyIGNvdmVyYWdlR2x5cGggPSBsaWdhdHVyZS5zdWJbMF07XG4gICAgdmFyIGxpZ0NvbXBvbmVudHMgPSBsaWdhdHVyZS5zdWIuc2xpY2UoMSk7XG4gICAgdmFyIGxpZ2F0dXJlVGFibGUgPSB7XG4gICAgICAgIGxpZ0dseXBoOiBsaWdhdHVyZS5ieSxcbiAgICAgICAgY29tcG9uZW50czogbGlnQ29tcG9uZW50c1xuICAgIH07XG4gICAgdmFyIHBvcyA9IHRoaXMuYmluU2VhcmNoKHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocywgY292ZXJhZ2VHbHlwaCk7XG4gICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIC8vIGxpZ2F0dXJlU2V0IGFscmVhZHkgZXhpc3RzXG4gICAgICAgIHZhciBsaWdhdHVyZVNldCA9IHN1YnRhYmxlLmxpZ2F0dXJlU2V0c1twb3NdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpZ2F0dXJlU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBJZiBsaWdhdHVyZSBhbHJlYWR5IGV4aXN0cywgcmV0dXJuLlxuICAgICAgICAgICAgaWYgKGFycmF5c0VxdWFsKGxpZ2F0dXJlU2V0W2ldLmNvbXBvbmVudHMsIGxpZ0NvbXBvbmVudHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxpZ2F0dXJlIGRvZXMgbm90IGV4aXN0OiBhZGQgaXQuXG4gICAgICAgIGxpZ2F0dXJlU2V0LnB1c2gobGlnYXR1cmVUYWJsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGxpZ2F0dXJlU2V0IGFuZCBhZGQgY292ZXJhZ2UgZm9yIHRoZSBmaXJzdCBnbHlwaC5cbiAgICAgICAgcG9zID0gLTEgLSBwb3M7XG4gICAgICAgIHN1YnRhYmxlLmNvdmVyYWdlLmdseXBocy5zcGxpY2UocG9zLCAwLCBjb3ZlcmFnZUdseXBoKTtcbiAgICAgICAgc3VidGFibGUubGlnYXR1cmVTZXRzLnNwbGljZShwb3MsIDAsIFtsaWdhdHVyZVRhYmxlXSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBMaXN0IGFsbCBmZWF0dXJlIGRhdGEgZm9yIGEgZ2l2ZW4gc2NyaXB0IGFuZCBsYW5ndWFnZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBmZWF0dXJlIC0gNC1sZXR0ZXIgZmVhdHVyZSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gW3NjcmlwdD0nREZMVCddXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xhbmd1YWdlPSdkZmx0J11cbiAqIEByZXR1cm4ge0FycmF5fSBzdWJzdGl0dXRpb25zIC0gVGhlIGxpc3Qgb2Ygc3Vic3RpdHV0aW9ucy5cbiAqL1xuU3Vic3RpdHV0aW9uLnByb3RvdHlwZS5nZXRGZWF0dXJlID0gZnVuY3Rpb24oZmVhdHVyZSwgc2NyaXB0LCBsYW5ndWFnZSkge1xuICAgIGlmICgvc3NcXGRcXGQvLnRlc3QoZmVhdHVyZSkpIHtcbiAgICAgICAgLy8gc3MwMSAtIHNzMjBcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2luZ2xlKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGZlYXR1cmUpIHtcbiAgICAgICAgY2FzZSAnYWFsdCc6XG4gICAgICAgIGNhc2UgJ3NhbHQnOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2luZ2xlKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQodGhpcy5nZXRBbHRlcm5hdGVzKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpKTtcbiAgICAgICAgY2FzZSAnZGxpZyc6XG4gICAgICAgIGNhc2UgJ2xpZ2EnOlxuICAgICAgICBjYXNlICdybGlnJzogcmV0dXJuIHRoaXMuZ2V0TGlnYXR1cmVzKGZlYXR1cmUsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBBZGQgYSBzdWJzdGl0dXRpb24gdG8gYSBmZWF0dXJlIGZvciBhIGdpdmVuIHNjcmlwdCBhbmQgbGFuZ3VhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIDQtbGV0dGVyIGZlYXR1cmUgbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IHN1YiAtIHRoZSBzdWJzdGl0dXRpb24gdG8gYWRkIChhbiBvYmplY3QgbGlrZSB7IHN1YjogaWQgb3IgW2lkc10sIGJ5OiBpZCBvciBbaWRzXSB9KVxuICogQHBhcmFtIHtzdHJpbmd9IFtzY3JpcHQ9J0RGTFQnXVxuICogQHBhcmFtIHtzdHJpbmd9IFtsYW5ndWFnZT0nZGZsdCddXG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKSB7XG4gICAgaWYgKC9zc1xcZFxcZC8udGVzdChmZWF0dXJlKSkge1xuICAgICAgICAvLyBzczAxIC0gc3MyMFxuICAgICAgICByZXR1cm4gdGhpcy5hZGRTaW5nbGUoZmVhdHVyZSwgc3ViLCBzY3JpcHQsIGxhbmd1YWdlKTtcbiAgICB9XG4gICAgc3dpdGNoIChmZWF0dXJlKSB7XG4gICAgICAgIGNhc2UgJ2FhbHQnOlxuICAgICAgICBjYXNlICdzYWx0JzpcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3ViLmJ5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZFNpbmdsZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkQWx0ZXJuYXRlKGZlYXR1cmUsIHN1Yiwgc2NyaXB0LCBsYW5ndWFnZSk7XG4gICAgICAgIGNhc2UgJ2RsaWcnOlxuICAgICAgICBjYXNlICdsaWdhJzpcbiAgICAgICAgY2FzZSAncmxpZyc6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRMaWdhdHVyZShmZWF0dXJlLCBzdWIsIHNjcmlwdCwgbGFuZ3VhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuZnVuY3Rpb24gaXNCcm93c2VyKCkge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cblxuZnVuY3Rpb24gbm9kZUJ1ZmZlclRvQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gICAgdmFyIGFiID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlci5sZW5ndGgpO1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZpZXdbaV0gPSBidWZmZXJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFiO1xufVxuXG5mdW5jdGlvbiBhcnJheUJ1ZmZlclRvTm9kZUJ1ZmZlcihhYikge1xuICAgIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKGFiLmJ5dGVMZW5ndGgpO1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IHZpZXdbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gY2hlY2tBcmd1bWVudChleHByZXNzaW9uLCBtZXNzYWdlKSB7XG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICAgIHRocm93IG1lc3NhZ2U7XG4gICAgfVxufVxuXG4vKiBBIFRydWVUeXBlIGZvbnQgaGludGluZyBpbnRlcnByZXRlci5cbipcbiogKGMpIDIwMTcgQXhlbCBLaXR0ZW5iZXJnZXJcbipcbiogVGhpcyBpbnRlcnByZXRlciBoYXMgYmVlbiBpbXBsZW1lbnRlZCBhY2NvcmRpbmcgdG8gdGhpcyBkb2N1bWVudGF0aW9uOlxuKiBodHRwczovL2RldmVsb3Blci5hcHBsZS5jb20vZm9udHMvVHJ1ZVR5cGUtUmVmZXJlbmNlLU1hbnVhbC9STTA1L0NoYXA1Lmh0bWxcbipcbiogQWNjb3JkaW5nIHRvIHRoZSBkb2N1bWVudGF0aW9uIEYyNERPVDYgdmFsdWVzIGFyZSB1c2VkIGZvciBwaXhlbHMuXG4qIFRoYXQgbWVhbnMgY2FsY3VsYXRpb24gaXMgMS82NCBwaXhlbCBhY2N1cmF0ZSBhbmQgdXNlcyBpbnRlZ2VyIG9wZXJhdGlvbnMuXG4qIEhvd2V2ZXIsIEphdmFzY3JpcHQgaGFzIGZsb2F0aW5nIHBvaW50IG9wZXJhdGlvbnMgYnkgZGVmYXVsdCBhbmQgb25seVxuKiB0aG9zZSBhcmUgYXZhaWxhYmxlLiBPbmUgY291bGQgbWFrZSBhIGNhc2UgdG8gc2ltdWxhdGUgdGhlIDEvNjQgYWNjdXJhY3lcbiogZXhhY3RseSBieSB0cnVuY2F0aW5nIGFmdGVyIGV2ZXJ5IGRpdmlzaW9uIG9wZXJhdGlvblxuKiAoZm9yIGV4YW1wbGUgd2l0aCA8PCAwKSB0byBnZXQgcGl4ZWwgZXhhY3RseSByZXN1bHRzIGFzIG90aGVyIFRydWVUeXBlXG4qIGltcGxlbWVudGF0aW9ucy4gSXQgbWF5IG1ha2Ugc2Vuc2Ugc2luY2Ugc29tZSBmb250cyBhcmUgcGl4ZWwgb3B0aW1pemVkXG4qIGJ5IGhhbmQgdXNpbmcgREVMVEFQIGluc3RydWN0aW9ucy4gVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gZG9lc24ndFxuKiBhbmQgcmF0aGVyIHVzZXMgZnVsbCBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24uXG4qXG4qIHhTY2FsZSwgeVNjYWxlIGFuZCByb3RhdGlvbiBpcyBjdXJyZW50bHkgaWdub3JlZC5cbipcbiogQSBmZXcgbm9uLXRyaXZpYWwgaW5zdHJ1Y3Rpb25zIGFyZSBtaXNzaW5nIGFzIEkgZGlkbid0IGVuY291bnRlciB5ZXRcbiogYSBmb250IHRoYXQgdXNlZCB0aGVtIHRvIHRlc3QgYSBwb3NzaWJsZSBpbXBsZW1lbnRhdGlvbi5cbipcbiogU29tZSBmb250cyBzZWVtIHRvIHVzZSB1bmRvY3VtZW50ZWQgZmVhdHVyZXMgcmVnYXJkaW5nIHRoZSB0d2lsaWdodCB6b25lLlxuKiBPbmx5IHNvbWUgb2YgdGhlbSBhcmUgaW1wbGVtZW50ZWQgYXMgdGhleSB3ZXJlIGVuY291bnRlcmVkLlxuKlxuKiBUaGUgZXhwb3J0cy5ERUJVRyBzdGF0ZW1lbnRzIGFyZSByZW1vdmVkIG9uIHRoZSBtaW5pZmllZCBkaXN0cmlidXRpb24gZmlsZS5cbiovXG52YXIgaW5zdHJ1Y3Rpb25UYWJsZTtcbnZhciBleGVjO1xudmFyIGV4ZWNHbHlwaDtcbnZhciBleGVjQ29tcG9uZW50O1xuXG4vKlxuKiBDcmVhdGVzIGEgaGludGluZyBvYmplY3QuXG4qXG4qIFRoZXJlIG91Z2h0IHRvIGJlIGV4YWN0bHkgb25lXG4qIGZvciBlYWNoIHRydWV0eXBlIGZvbnQgdGhhdCBpcyB1c2VkIGZvciBoaW50aW5nLlxuKi9cbmZ1bmN0aW9uIEhpbnRpbmcoZm9udCkge1xuICAgIC8vIHRoZSBmb250IHRoaXMgaGludGluZyBvYmplY3QgaXMgZm9yXG4gICAgdGhpcy5mb250ID0gZm9udDtcblxuICAgIC8vIGNhY2hlZCBzdGF0ZXNcbiAgICB0aGlzLl9mcGdtU3RhdGUgID1cbiAgICB0aGlzLl9wcmVwU3RhdGUgID1cbiAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgLy8gZXJyb3JTdGF0ZVxuICAgIC8vIDAgLi4uIGFsbCBva2F5XG4gICAgLy8gMSAuLi4gaGFkIGFuIGVycm9yIGluIGEgZ2x5ZixcbiAgICAvLyAgICAgICBjb250aW51ZSB3b3JraW5nIGJ1dCBzdG9wIHNwYW1taW5nXG4gICAgLy8gICAgICAgdGhlIGNvbnNvbGVcbiAgICAvLyAyIC4uLiBlcnJvciBhdCBwcmVwLCBzdG9wIGhpbnRpbmcgYXQgdGhpcyBwcGVtXG4gICAgLy8gMyAuLi4gZXJyb3IgYXQgZnBlZywgc3RvcCBoaW50aW5nIGZvciB0aGlzIGZvbnQgYXQgYWxsXG4gICAgdGhpcy5fZXJyb3JTdGF0ZSA9IDA7XG59XG5cbi8qXG4qIE5vdCByb3VuZGluZy5cbiovXG5mdW5jdGlvbiByb3VuZE9mZih2KSB7XG4gICAgcmV0dXJuIHY7XG59XG5cbi8qXG4qIFJvdW5kaW5nIHRvIGdyaWQuXG4qL1xuZnVuY3Rpb24gcm91bmRUb0dyaWQodikge1xuICAgIC8vUm91bmRpbmcgaW4gVFQgaXMgc3VwcG9zZWQgdG8gXCJzeW1tZXRyaWNhbCBhcm91bmQgemVyb1wiXG4gICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIE1hdGgucm91bmQoTWF0aC5hYnModikpO1xufVxuXG4vKlxuKiBSb3VuZGluZyB0byBkb3VibGUgZ3JpZC5cbiovXG5mdW5jdGlvbiByb3VuZFRvRG91YmxlR3JpZCh2KSB7XG4gICAgcmV0dXJuIE1hdGguc2lnbih2KSAqIE1hdGgucm91bmQoTWF0aC5hYnModiAqIDIpKSAvIDI7XG59XG5cbi8qXG4qIFJvdW5kaW5nIHRvIGhhbGYgZ3JpZC5cbiovXG5mdW5jdGlvbiByb3VuZFRvSGFsZkdyaWQodikge1xuICAgIHJldHVybiBNYXRoLnNpZ24odikgKiAoTWF0aC5yb3VuZChNYXRoLmFicyh2KSArIDAuNSkgLSAwLjUpO1xufVxuXG4vKlxuKiBSb3VuZGluZyB0byB1cCB0byBncmlkLlxuKi9cbmZ1bmN0aW9uIHJvdW5kVXBUb0dyaWQodikge1xuICAgIHJldHVybiBNYXRoLnNpZ24odikgKiBNYXRoLmNlaWwoTWF0aC5hYnModikpO1xufVxuXG4vKlxuKiBSb3VuZGluZyB0byBkb3duIHRvIGdyaWQuXG4qL1xuZnVuY3Rpb24gcm91bmREb3duVG9HcmlkKHYpIHtcbiAgICByZXR1cm4gTWF0aC5zaWduKHYpICogTWF0aC5mbG9vcihNYXRoLmFicyh2KSk7XG59XG5cbi8qXG4qIFN1cGVyIHJvdW5kaW5nLlxuKi9cbnZhciByb3VuZFN1cGVyID0gZnVuY3Rpb24gKHYpIHtcbiAgICB2YXIgcGVyaW9kID0gdGhpcy5zclBlcmlvZDtcbiAgICB2YXIgcGhhc2UgPSB0aGlzLnNyUGhhc2U7XG4gICAgdmFyIHRocmVzaG9sZCA9IHRoaXMuc3JUaHJlc2hvbGQ7XG4gICAgdmFyIHNpZ24gPSAxO1xuXG4gICAgaWYgKHYgPCAwKSB7XG4gICAgICAgIHYgPSAtdjtcbiAgICAgICAgc2lnbiA9IC0xO1xuICAgIH1cblxuICAgIHYgKz0gdGhyZXNob2xkIC0gcGhhc2U7XG5cbiAgICB2ID0gTWF0aC50cnVuYyh2IC8gcGVyaW9kKSAqIHBlcmlvZDtcblxuICAgIHYgKz0gcGhhc2U7XG5cbiAgICAvLyBhY2NvcmRpbmcgdG8gaHR0cDovL3hncmlkZml0LnNvdXJjZWZvcmdlLm5ldC9yb3VuZC5odG1sXG4gICAgaWYgKHYgPCAwKSB7IHJldHVybiBwaGFzZSAqIHNpZ247IH1cblxuICAgIHJldHVybiB2ICogc2lnbjtcbn07XG5cbi8qXG4qIFVuaXQgdmVjdG9yIG9mIHgtYXhpcy5cbiovXG52YXIgeFVuaXRWZWN0b3IgPSB7XG4gICAgeDogMSxcblxuICAgIHk6IDAsXG5cbiAgICBheGlzOiAneCcsXG5cbiAgICAvLyBHZXRzIHRoZSBwcm9qZWN0ZWQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgIC8vIG8xL28yIC4uLiBpZiB0cnVlLCByZXNwZWN0aXZlIG9yaWdpbmFsIHBvc2l0aW9uIGlzIHVzZWQuXG4gICAgZGlzdGFuY2U6IGZ1bmN0aW9uIChwMSwgcDIsIG8xLCBvMikge1xuICAgICAgICByZXR1cm4gKG8xID8gcDEueG8gOiBwMS54KSAtIChvMiA/IHAyLnhvIDogcDIueCk7XG4gICAgfSxcblxuICAgIC8vIE1vdmVzIHBvaW50IHAgc28gdGhlIG1vdmVkIHBvc2l0aW9uIGhhcyB0aGUgc2FtZSByZWxhdGl2ZVxuICAgIC8vIHBvc2l0aW9uIHRvIHRoZSBtb3ZlZCBwb3NpdGlvbnMgb2YgcnAxIGFuZCBycDIgdGhhbiB0aGVcbiAgICAvLyBvcmlnaW5hbCBwb3NpdGlvbnMgaGFkLlxuICAgIC8vXG4gICAgLy8gU2VlIEFQUEVORElYIG9uIElOVEVSUE9MQVRFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiAocCwgcnAxLCBycDIsIHB2KSB7XG4gICAgICAgIHZhciBkbzE7XG4gICAgICAgIHZhciBkbzI7XG4gICAgICAgIHZhciBkb2ExO1xuICAgICAgICB2YXIgZG9hMjtcbiAgICAgICAgdmFyIGRtMTtcbiAgICAgICAgdmFyIGRtMjtcbiAgICAgICAgdmFyIGR0O1xuXG4gICAgICAgIGlmICghcHYgfHwgcHYgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIGRvMSA9IHAueG8gLSBycDEueG87XG4gICAgICAgICAgICBkbzIgPSBwLnhvIC0gcnAyLnhvO1xuICAgICAgICAgICAgZG0xID0gcnAxLnggLSBycDEueG87XG4gICAgICAgICAgICBkbTIgPSBycDIueCAtIHJwMi54bztcbiAgICAgICAgICAgIGRvYTEgPSBNYXRoLmFicyhkbzEpO1xuICAgICAgICAgICAgZG9hMiA9IE1hdGguYWJzKGRvMik7XG4gICAgICAgICAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG4gICAgICAgICAgICBpZiAoZHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwLnggPSBwLnhvICsgKGRtMSArIGRtMikgLyAyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcC54ID0gcC54byArIChkbTEgKiBkb2EyICsgZG0yICogZG9hMSkgLyBkdDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvMSA9IHB2LmRpc3RhbmNlKHAsIHJwMSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGRvMiA9IHB2LmRpc3RhbmNlKHAsIHJwMiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGRtMSA9IHB2LmRpc3RhbmNlKHJwMSwgcnAxLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGRtMiA9IHB2LmRpc3RhbmNlKHJwMiwgcnAyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGRvYTEgPSBNYXRoLmFicyhkbzEpO1xuICAgICAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcbiAgICAgICAgZHQgPSBkb2ExICsgZG9hMjtcblxuICAgICAgICBpZiAoZHQgPT09IDApIHtcbiAgICAgICAgICAgIHhVbml0VmVjdG9yLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKyBkbTIpIC8gMiwgcHYsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgeFVuaXRWZWN0b3Iuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0LCBwdiwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8vIFNsb3BlIG9mIGxpbmUgbm9ybWFsIHRvIHRoaXNcbiAgICBub3JtYWxTbG9wZTogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuXG4gICAgLy8gU2V0cyB0aGUgcG9pbnQgJ3AnIHJlbGF0aXZlIHRvIHBvaW50ICdycCdcbiAgICAvLyBieSB0aGUgZGlzdGFuY2UgJ2QnLlxuICAgIC8vXG4gICAgLy8gU2VlIEFQUEVORElYIG9uIFNFVFJFTEFUSVZFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuICAgIC8vXG4gICAgLy8gcCAgIC4uLiBwb2ludCB0byBzZXRcbiAgICAvLyBycCAgLi4uIHJlZmVyZW5jZSBwb2ludFxuICAgIC8vIGQgICAuLi4gZGlzdGFuY2Ugb24gcHJvamVjdGlvbiB2ZWN0b3JcbiAgICAvLyBwdiAgLi4uIHByb2plY3Rpb24gdmVjdG9yICh1bmRlZmluZWQgPSB0aGlzKVxuICAgIC8vIG9yZyAuLi4gaWYgdHJ1ZSwgdXNlcyB0aGUgb3JpZ2luYWwgcG9zaXRpb24gb2YgcnAgYXMgcmVmZXJlbmNlLlxuICAgIHNldFJlbGF0aXZlOiBmdW5jdGlvbiAocCwgcnAsIGQsIHB2LCBvcmcpIHtcbiAgICAgICAgaWYgKCFwdiB8fCBwdiA9PT0gdGhpcykge1xuICAgICAgICAgICAgcC54ID0gKG9yZyA/IHJwLnhvIDogcnAueCkgKyBkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJweCA9IG9yZyA/IHJwLnhvIDogcnAueDtcbiAgICAgICAgdmFyIHJweSA9IG9yZyA/IHJwLnlvIDogcnAueTtcbiAgICAgICAgdmFyIHJwZHggPSBycHggKyBkICogcHYueDtcbiAgICAgICAgdmFyIHJwZHkgPSBycHkgKyBkICogcHYueTtcblxuICAgICAgICBwLnggPSBycGR4ICsgKHAueSAtIHJwZHkpIC8gcHYubm9ybWFsU2xvcGU7XG4gICAgfSxcblxuICAgIC8vIFNsb3BlIG9mIHZlY3RvciBsaW5lLlxuICAgIHNsb3BlOiAwLFxuXG4gICAgLy8gVG91Y2hlcyB0aGUgcG9pbnQgcC5cbiAgICB0b3VjaDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC54VG91Y2hlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8vIFRlc3RzIGlmIGEgcG9pbnQgcCBpcyB0b3VjaGVkLlxuICAgIHRvdWNoZWQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwLnhUb3VjaGVkO1xuICAgIH0sXG5cbiAgICAvLyBVbnRvdWNoZXMgdGhlIHBvaW50IHAuXG4gICAgdW50b3VjaDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC54VG91Y2hlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cbi8qXG4qIFVuaXQgdmVjdG9yIG9mIHktYXhpcy5cbiovXG52YXIgeVVuaXRWZWN0b3IgPSB7XG4gICAgeDogMCxcblxuICAgIHk6IDEsXG5cbiAgICBheGlzOiAneScsXG5cbiAgICAvLyBHZXRzIHRoZSBwcm9qZWN0ZWQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuICAgIC8vIG8xL28yIC4uLiBpZiB0cnVlLCByZXNwZWN0aXZlIG9yaWdpbmFsIHBvc2l0aW9uIGlzIHVzZWQuXG4gICAgZGlzdGFuY2U6IGZ1bmN0aW9uIChwMSwgcDIsIG8xLCBvMikge1xuICAgICAgICByZXR1cm4gKG8xID8gcDEueW8gOiBwMS55KSAtIChvMiA/IHAyLnlvIDogcDIueSk7XG4gICAgfSxcblxuICAgIC8vIE1vdmVzIHBvaW50IHAgc28gdGhlIG1vdmVkIHBvc2l0aW9uIGhhcyB0aGUgc2FtZSByZWxhdGl2ZVxuICAgIC8vIHBvc2l0aW9uIHRvIHRoZSBtb3ZlZCBwb3NpdGlvbnMgb2YgcnAxIGFuZCBycDIgdGhhbiB0aGVcbiAgICAvLyBvcmlnaW5hbCBwb3NpdGlvbnMgaGFkLlxuICAgIC8vXG4gICAgLy8gU2VlIEFQUEVORElYIG9uIElOVEVSUE9MQVRFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiAocCwgcnAxLCBycDIsIHB2KSB7XG4gICAgICAgIHZhciBkbzE7XG4gICAgICAgIHZhciBkbzI7XG4gICAgICAgIHZhciBkb2ExO1xuICAgICAgICB2YXIgZG9hMjtcbiAgICAgICAgdmFyIGRtMTtcbiAgICAgICAgdmFyIGRtMjtcbiAgICAgICAgdmFyIGR0O1xuXG4gICAgICAgIGlmICghcHYgfHwgcHYgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIGRvMSA9IHAueW8gLSBycDEueW87XG4gICAgICAgICAgICBkbzIgPSBwLnlvIC0gcnAyLnlvO1xuICAgICAgICAgICAgZG0xID0gcnAxLnkgLSBycDEueW87XG4gICAgICAgICAgICBkbTIgPSBycDIueSAtIHJwMi55bztcbiAgICAgICAgICAgIGRvYTEgPSBNYXRoLmFicyhkbzEpO1xuICAgICAgICAgICAgZG9hMiA9IE1hdGguYWJzKGRvMik7XG4gICAgICAgICAgICBkdCA9IGRvYTEgKyBkb2EyO1xuXG4gICAgICAgICAgICBpZiAoZHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBwLnkgPSBwLnlvICsgKGRtMSArIGRtMikgLyAyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcC55ID0gcC55byArIChkbTEgKiBkb2EyICsgZG0yICogZG9hMSkgLyBkdDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvMSA9IHB2LmRpc3RhbmNlKHAsIHJwMSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGRvMiA9IHB2LmRpc3RhbmNlKHAsIHJwMiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIGRtMSA9IHB2LmRpc3RhbmNlKHJwMSwgcnAxLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGRtMiA9IHB2LmRpc3RhbmNlKHJwMiwgcnAyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGRvYTEgPSBNYXRoLmFicyhkbzEpO1xuICAgICAgICBkb2EyID0gTWF0aC5hYnMoZG8yKTtcbiAgICAgICAgZHQgPSBkb2ExICsgZG9hMjtcblxuICAgICAgICBpZiAoZHQgPT09IDApIHtcbiAgICAgICAgICAgIHlVbml0VmVjdG9yLnNldFJlbGF0aXZlKHAsIHAsIChkbTEgKyBkbTIpIC8gMiwgcHYsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgeVVuaXRWZWN0b3Iuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0LCBwdiwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8vIFNsb3BlIG9mIGxpbmUgbm9ybWFsIHRvIHRoaXMuXG4gICAgbm9ybWFsU2xvcGU6IDAsXG5cbiAgICAvLyBTZXRzIHRoZSBwb2ludCAncCcgcmVsYXRpdmUgdG8gcG9pbnQgJ3JwJ1xuICAgIC8vIGJ5IHRoZSBkaXN0YW5jZSAnZCdcbiAgICAvL1xuICAgIC8vIFNlZSBBUFBFTkRJWCBvbiBTRVRSRUxBVElWRSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cbiAgICAvL1xuICAgIC8vIHAgICAuLi4gcG9pbnQgdG8gc2V0XG4gICAgLy8gcnAgIC4uLiByZWZlcmVuY2UgcG9pbnRcbiAgICAvLyBkICAgLi4uIGRpc3RhbmNlIG9uIHByb2plY3Rpb24gdmVjdG9yXG4gICAgLy8gcHYgIC4uLiBwcm9qZWN0aW9uIHZlY3RvciAodW5kZWZpbmVkID0gdGhpcylcbiAgICAvLyBvcmcgLi4uIGlmIHRydWUsIHVzZXMgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIG9mIHJwIGFzIHJlZmVyZW5jZS5cbiAgICBzZXRSZWxhdGl2ZTogZnVuY3Rpb24gKHAsIHJwLCBkLCBwdiwgb3JnKSB7XG4gICAgICAgIGlmICghcHYgfHwgcHYgPT09IHRoaXMpIHtcbiAgICAgICAgICAgIHAueSA9IChvcmcgPyBycC55byA6IHJwLnkpICsgZDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBycHggPSBvcmcgPyBycC54byA6IHJwLng7XG4gICAgICAgIHZhciBycHkgPSBvcmcgPyBycC55byA6IHJwLnk7XG4gICAgICAgIHZhciBycGR4ID0gcnB4ICsgZCAqIHB2Lng7XG4gICAgICAgIHZhciBycGR5ID0gcnB5ICsgZCAqIHB2Lnk7XG5cbiAgICAgICAgcC55ID0gcnBkeSArIHB2Lm5vcm1hbFNsb3BlICogKHAueCAtIHJwZHgpO1xuICAgIH0sXG5cbiAgICAvLyBTbG9wZSBvZiB2ZWN0b3IgbGluZS5cbiAgICBzbG9wZTogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuXG4gICAgLy8gVG91Y2hlcyB0aGUgcG9pbnQgcC5cbiAgICB0b3VjaDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC55VG91Y2hlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8vIFRlc3RzIGlmIGEgcG9pbnQgcCBpcyB0b3VjaGVkLlxuICAgIHRvdWNoZWQ6IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHJldHVybiBwLnlUb3VjaGVkO1xuICAgIH0sXG5cbiAgICAvLyBVbnRvdWNoZXMgdGhlIHBvaW50IHAuXG4gICAgdW50b3VjaDogZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcC55VG91Y2hlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5cbk9iamVjdC5mcmVlemUoeFVuaXRWZWN0b3IpO1xuT2JqZWN0LmZyZWV6ZSh5VW5pdFZlY3Rvcik7XG5cbi8qXG4qIENyZWF0ZXMgYSB1bml0IHZlY3RvciB0aGF0IGlzIG5vdCB4LSBvciB5LWF4aXMuXG4qL1xuZnVuY3Rpb24gVW5pdFZlY3Rvcih4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuYXhpcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNsb3BlID0geSAvIHg7XG4gICAgdGhpcy5ub3JtYWxTbG9wZSA9IC14IC8geTtcbiAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xufVxuXG4vKlxuKiBHZXRzIHRoZSBwcm9qZWN0ZWQgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzLlxuKiBvMS9vMiAuLi4gaWYgdHJ1ZSwgcmVzcGVjdGl2ZSBvcmlnaW5hbCBwb3NpdGlvbiBpcyB1c2VkLlxuKi9cblVuaXRWZWN0b3IucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24ocDEsIHAyLCBvMSwgbzIpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnggKiB4VW5pdFZlY3Rvci5kaXN0YW5jZShwMSwgcDIsIG8xLCBvMikgK1xuICAgICAgICB0aGlzLnkgKiB5VW5pdFZlY3Rvci5kaXN0YW5jZShwMSwgcDIsIG8xLCBvMilcbiAgICApO1xufTtcblxuLypcbiogTW92ZXMgcG9pbnQgcCBzbyB0aGUgbW92ZWQgcG9zaXRpb24gaGFzIHRoZSBzYW1lIHJlbGF0aXZlXG4qIHBvc2l0aW9uIHRvIHRoZSBtb3ZlZCBwb3NpdGlvbnMgb2YgcnAxIGFuZCBycDIgdGhhbiB0aGVcbiogb3JpZ2luYWwgcG9zaXRpb25zIGhhZC5cbipcbiogU2VlIEFQUEVORElYIG9uIElOVEVSUE9MQVRFIGF0IHRoZSBib3R0b20gb2YgdGhpcyBmaWxlLlxuKi9cblVuaXRWZWN0b3IucHJvdG90eXBlLmludGVycG9sYXRlID0gZnVuY3Rpb24ocCwgcnAxLCBycDIsIHB2KSB7XG4gICAgdmFyIGRtMTtcbiAgICB2YXIgZG0yO1xuICAgIHZhciBkbzE7XG4gICAgdmFyIGRvMjtcbiAgICB2YXIgZG9hMTtcbiAgICB2YXIgZG9hMjtcbiAgICB2YXIgZHQ7XG5cbiAgICBkbzEgPSBwdi5kaXN0YW5jZShwLCBycDEsIHRydWUsIHRydWUpO1xuICAgIGRvMiA9IHB2LmRpc3RhbmNlKHAsIHJwMiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZG0xID0gcHYuZGlzdGFuY2UocnAxLCBycDEsIGZhbHNlLCB0cnVlKTtcbiAgICBkbTIgPSBwdi5kaXN0YW5jZShycDIsIHJwMiwgZmFsc2UsIHRydWUpO1xuICAgIGRvYTEgPSBNYXRoLmFicyhkbzEpO1xuICAgIGRvYTIgPSBNYXRoLmFicyhkbzIpO1xuICAgIGR0ID0gZG9hMSArIGRvYTI7XG5cbiAgICBpZiAoZHQgPT09IDApIHtcbiAgICAgICAgdGhpcy5zZXRSZWxhdGl2ZShwLCBwLCAoZG0xICsgZG0yKSAvIDIsIHB2LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2V0UmVsYXRpdmUocCwgcCwgKGRtMSAqIGRvYTIgKyBkbTIgKiBkb2ExKSAvIGR0LCBwdiwgdHJ1ZSk7XG59O1xuXG4vKlxuKiBTZXRzIHRoZSBwb2ludCAncCcgcmVsYXRpdmUgdG8gcG9pbnQgJ3JwJ1xuKiBieSB0aGUgZGlzdGFuY2UgJ2QnXG4qXG4qIFNlZSBBUFBFTkRJWCBvbiBTRVRSRUxBVElWRSBhdCB0aGUgYm90dG9tIG9mIHRoaXMgZmlsZS5cbipcbiogcCAgIC4uLiAgcG9pbnQgdG8gc2V0XG4qIHJwICAuLi4gcmVmZXJlbmNlIHBvaW50XG4qIGQgICAuLi4gZGlzdGFuY2Ugb24gcHJvamVjdGlvbiB2ZWN0b3JcbiogcHYgIC4uLiBwcm9qZWN0aW9uIHZlY3RvciAodW5kZWZpbmVkID0gdGhpcylcbiogb3JnIC4uLiBpZiB0cnVlLCB1c2VzIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBvZiBycCBhcyByZWZlcmVuY2UuXG4qL1xuVW5pdFZlY3Rvci5wcm90b3R5cGUuc2V0UmVsYXRpdmUgPSBmdW5jdGlvbihwLCBycCwgZCwgcHYsIG9yZykge1xuICAgIHB2ID0gcHYgfHwgdGhpcztcblxuICAgIHZhciBycHggPSBvcmcgPyBycC54byA6IHJwLng7XG4gICAgdmFyIHJweSA9IG9yZyA/IHJwLnlvIDogcnAueTtcbiAgICB2YXIgcnBkeCA9IHJweCArIGQgKiBwdi54O1xuICAgIHZhciBycGR5ID0gcnB5ICsgZCAqIHB2Lnk7XG5cbiAgICB2YXIgcHZucyA9IHB2Lm5vcm1hbFNsb3BlO1xuICAgIHZhciBmdnMgPSB0aGlzLnNsb3BlO1xuXG4gICAgdmFyIHB4ID0gcC54O1xuICAgIHZhciBweSA9IHAueTtcblxuICAgIHAueCA9IChmdnMgKiBweCAtIHB2bnMgKiBycGR4ICsgcnBkeSAtIHB5KSAvIChmdnMgLSBwdm5zKTtcbiAgICBwLnkgPSBmdnMgKiAocC54IC0gcHgpICsgcHk7XG59O1xuXG4vKlxuKiBUb3VjaGVzIHRoZSBwb2ludCBwLlxuKi9cblVuaXRWZWN0b3IucHJvdG90eXBlLnRvdWNoID0gZnVuY3Rpb24ocCkge1xuICAgIHAueFRvdWNoZWQgPSB0cnVlO1xuICAgIHAueVRvdWNoZWQgPSB0cnVlO1xufTtcblxuLypcbiogUmV0dXJucyBhIHVuaXQgdmVjdG9yIHdpdGggeC95IGNvb3JkaW5hdGVzLlxuKi9cbmZ1bmN0aW9uIGdldFVuaXRWZWN0b3IoeCwgeSkge1xuICAgIHZhciBkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG4gICAgeCAvPSBkO1xuICAgIHkgLz0gZDtcblxuICAgIGlmICh4ID09PSAxICYmIHkgPT09IDApIHsgcmV0dXJuIHhVbml0VmVjdG9yOyB9XG4gICAgZWxzZSBpZiAoeCA9PT0gMCAmJiB5ID09PSAxKSB7IHJldHVybiB5VW5pdFZlY3RvcjsgfVxuICAgIGVsc2UgeyByZXR1cm4gbmV3IFVuaXRWZWN0b3IoeCwgeSk7IH1cbn1cblxuLypcbiogQ3JlYXRlcyBhIHBvaW50IGluIHRoZSBoaW50aW5nIGVuZ2luZS5cbiovXG5mdW5jdGlvbiBIUG9pbnQoXG4gICAgeCxcbiAgICB5LFxuICAgIGxhc3RQb2ludE9mQ29udG91cixcbiAgICBvbkN1cnZlXG4pIHtcbiAgICB0aGlzLnggPSB0aGlzLnhvID0gTWF0aC5yb3VuZCh4ICogNjQpIC8gNjQ7IC8vIGhpbnRlZCB4IHZhbHVlIGFuZCBvcmlnaW5hbCB4LXZhbHVlXG4gICAgdGhpcy55ID0gdGhpcy55byA9IE1hdGgucm91bmQoeSAqIDY0KSAvIDY0OyAvLyBoaW50ZWQgeSB2YWx1ZSBhbmQgb3JpZ2luYWwgeS12YWx1ZVxuXG4gICAgdGhpcy5sYXN0UG9pbnRPZkNvbnRvdXIgPSBsYXN0UG9pbnRPZkNvbnRvdXI7XG4gICAgdGhpcy5vbkN1cnZlID0gb25DdXJ2ZTtcbiAgICB0aGlzLnByZXZQb2ludE9uQ29udG91ciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm5leHRQb2ludE9uQ29udG91ciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnhUb3VjaGVkID0gZmFsc2U7XG4gICAgdGhpcy55VG91Y2hlZCA9IGZhbHNlO1xuXG4gICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO1xufVxuXG4vKlxuKiBSZXR1cm5zIHRoZSBuZXh0IHRvdWNoZWQgcG9pbnQgb24gdGhlIGNvbnRvdXIuXG4qXG4qIHYgIC4uLiB1bml0IHZlY3RvciB0byB0ZXN0IHRvdWNoIGF4aXMuXG4qL1xuSFBvaW50LnByb3RvdHlwZS5uZXh0VG91Y2hlZCA9IGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgcCA9IHRoaXMubmV4dFBvaW50T25Db250b3VyO1xuXG4gICAgd2hpbGUgKCF2LnRvdWNoZWQocCkgJiYgcCAhPT0gdGhpcykgeyBwID0gcC5uZXh0UG9pbnRPbkNvbnRvdXI7IH1cblxuICAgIHJldHVybiBwO1xufTtcblxuLypcbiogUmV0dXJucyB0aGUgcHJldmlvdXMgdG91Y2hlZCBwb2ludCBvbiB0aGUgY29udG91clxuKlxuKiB2ICAuLi4gdW5pdCB2ZWN0b3IgdG8gdGVzdCB0b3VjaCBheGlzLlxuKi9cbkhQb2ludC5wcm90b3R5cGUucHJldlRvdWNoZWQgPSBmdW5jdGlvbih2KSB7XG4gICAgdmFyIHAgPSB0aGlzLnByZXZQb2ludE9uQ29udG91cjtcblxuICAgIHdoaWxlICghdi50b3VjaGVkKHApICYmIHAgIT09IHRoaXMpIHsgcCA9IHAucHJldlBvaW50T25Db250b3VyOyB9XG5cbiAgICByZXR1cm4gcDtcbn07XG5cbi8qXG4qIFRoZSB6ZXJvIHBvaW50LlxuKi9cbnZhciBIUFplcm8gPSBPYmplY3QuZnJlZXplKG5ldyBIUG9pbnQoMCwgMCkpO1xuXG4vKlxuKiBUaGUgZGVmYXVsdCBzdGF0ZSBvZiB0aGUgaW50ZXJwcmV0ZXIuXG4qXG4qIE5vdGU6IEZyZWV6aW5nIHRoZSBkZWZhdWx0U3RhdGUgYW5kIHRoZW4gZGVyaXZpbmcgZnJvbSBpdFxuKiBtYWtlcyB0aGUgVjggSmF2YXNjcmlwdCBlbmdpbmUgZ29pbmcgYXdrd2FyZCxcbiogc28gdGhpcyBpcyBhdm9pZGVkLCBhbGJlaXQgdGhlIGRlZmF1bHRTdGF0ZSBzaG91bGRuJ3RcbiogZXZlciBjaGFuZ2UuXG4qL1xudmFyIGRlZmF1bHRTdGF0ZSA9IHtcbiAgICBjdkN1dEluOiAxNyAvIDE2LCAgICAvLyBjb250cm9sIHZhbHVlIGN1dCBpblxuICAgIGRlbHRhQmFzZTogOSxcbiAgICBkZWx0YVNoaWZ0OiAwLjEyNSxcbiAgICBsb29wOiAxLCAgICAgICAgICAgICAvLyBsb29wcyBzb21lIGluc3RydWN0aW9uc1xuICAgIG1pbkRpczogMSwgICAgICAgICAgIC8vIG1pbmltdW0gZGlzdGFuY2VcbiAgICBhdXRvRmxpcDogdHJ1ZVxufTtcblxuLypcbiogVGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGludGVycHJldGVyLlxuKlxuKiBlbnYgIC4uLiAnZnBnbScgb3IgJ3ByZXAnIG9yICdnbHlmJ1xuKiBwcm9nIC4uLiB0aGUgcHJvZ3JhbVxuKi9cbmZ1bmN0aW9uIFN0YXRlKGVudiwgcHJvZykge1xuICAgIHRoaXMuZW52ID0gZW52O1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLnByb2cgPSBwcm9nO1xuXG4gICAgc3dpdGNoIChlbnYpIHtcbiAgICAgICAgY2FzZSAnZ2x5ZicgOlxuICAgICAgICAgICAgdGhpcy56cDAgPSB0aGlzLnpwMSA9IHRoaXMuenAyID0gMTtcbiAgICAgICAgICAgIHRoaXMucnAwID0gdGhpcy5ycDEgPSB0aGlzLnJwMiA9IDA7XG4gICAgICAgICAgICAvKiBmYWxsIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAncHJlcCcgOlxuICAgICAgICAgICAgdGhpcy5mdiA9IHRoaXMucHYgPSB0aGlzLmRwdiA9IHhVbml0VmVjdG9yO1xuICAgICAgICAgICAgdGhpcy5yb3VuZCA9IHJvdW5kVG9HcmlkO1xuICAgIH1cbn1cblxuLypcbiogRXhlY3V0ZXMgYSBnbHlwaCBwcm9ncmFtLlxuKlxuKiBUaGlzIGRvZXMgdGhlIGhpbnRpbmcgZm9yIGVhY2ggZ2x5cGguXG4qXG4qIFJldHVybnMgYW4gYXJyYXkgb2YgbW92ZWQgcG9pbnRzLlxuKlxuKiBnbHlwaDogdGhlIGdseXBoIHRvIGhpbnRcbiogcHBlbTogdGhlIHNpemUgdGhlIGdseXBoIGlzIHJlbmRlcmVkIGZvclxuKi9cbkhpbnRpbmcucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbihnbHlwaCwgcHBlbSkge1xuICAgIGlmICh0eXBlb2YgcHBlbSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBzaXplIGlzIG5vdCBhIG51bWJlciEnKTtcbiAgICB9XG5cbiAgICAvLyBSZWNlaXZlZCBhIGZhdGFsIGVycm9yLCBkb24ndCBkbyBhbnkgaGludGluZyBhbnltb3JlLlxuICAgIGlmICh0aGlzLl9lcnJvclN0YXRlID4gMikgeyByZXR1cm47IH1cblxuICAgIHZhciBmb250ID0gdGhpcy5mb250O1xuICAgIHZhciBwcmVwU3RhdGUgPSB0aGlzLl9wcmVwU3RhdGU7XG5cbiAgICBpZiAoIXByZXBTdGF0ZSB8fCBwcmVwU3RhdGUucHBlbSAhPT0gcHBlbSkge1xuICAgICAgICB2YXIgZnBnbVN0YXRlID0gdGhpcy5fZnBnbVN0YXRlO1xuXG4gICAgICAgIGlmICghZnBnbVN0YXRlKSB7XG4gICAgICAgICAgICAvLyBFeGVjdXRlcyB0aGUgZnBnbSBzdGF0ZS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdXNlZCBieSBmb250cyB0byBkZWZpbmUgZnVuY3Rpb25zLlxuICAgICAgICAgICAgU3RhdGUucHJvdG90eXBlID0gZGVmYXVsdFN0YXRlO1xuXG4gICAgICAgICAgICBmcGdtU3RhdGUgPVxuICAgICAgICAgICAgdGhpcy5fZnBnbVN0YXRlID1cbiAgICAgICAgICAgICAgICBuZXcgU3RhdGUoJ2ZwZ20nLCBmb250LnRhYmxlcy5mcGdtKTtcblxuICAgICAgICAgICAgZnBnbVN0YXRlLmZ1bmNzID0gWyBdO1xuICAgICAgICAgICAgZnBnbVN0YXRlLmZvbnQgPSBmb250O1xuXG4gICAgICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS1FWEVDIEZQR00tLS0nKTtcbiAgICAgICAgICAgICAgICBmcGdtU3RhdGUuc3RlcCA9IC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGV4ZWMoZnBnbVN0YXRlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSGludGluZyBlcnJvciBpbiBGUEdNOicgKyBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvclN0YXRlID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBFeGVjdXRlcyB0aGUgcHJlcCBwcm9ncmFtIGZvciB0aGlzIHBwZW0gc2V0dGluZy5cbiAgICAgICAgLy8gVGhpcyBpcyB1c2VkIGJ5IGZvbnRzIHRvIHNldCBjdnQgdmFsdWVzXG4gICAgICAgIC8vIGRlcGVuZGluZyBvbiB0byBiZSByZW5kZXJlZCBmb250IHNpemUuXG5cbiAgICAgICAgU3RhdGUucHJvdG90eXBlID0gZnBnbVN0YXRlO1xuICAgICAgICBwcmVwU3RhdGUgPVxuICAgICAgICB0aGlzLl9wcmVwU3RhdGUgPVxuICAgICAgICAgICAgbmV3IFN0YXRlKCdwcmVwJywgZm9udC50YWJsZXMucHJlcCk7XG5cbiAgICAgICAgcHJlcFN0YXRlLnBwZW0gPSBwcGVtO1xuXG4gICAgICAgIC8vIENyZWF0ZXMgYSBjb3B5IG9mIHRoZSBjdnQgdGFibGVcbiAgICAgICAgLy8gYW5kIHNjYWxlcyBpdCB0byB0aGUgY3VycmVudCBwcGVtIHNldHRpbmcuXG4gICAgICAgIHZhciBvQ3Z0ID0gZm9udC50YWJsZXMuY3Z0O1xuICAgICAgICBpZiAob0N2dCkge1xuICAgICAgICAgICAgdmFyIGN2dCA9IHByZXBTdGF0ZS5jdnQgPSBuZXcgQXJyYXkob0N2dC5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gcHBlbSAvIGZvbnQudW5pdHNQZXJFbTtcbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgb0N2dC5sZW5ndGg7IGMrKykge1xuICAgICAgICAgICAgICAgIGN2dFtjXSA9IG9DdnRbY10gKiBzY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXBTdGF0ZS5jdnQgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBQUkVQLS0tJyk7XG4gICAgICAgICAgICBwcmVwU3RhdGUuc3RlcCA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGV4ZWMocHJlcFN0YXRlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yU3RhdGUgPCAyKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0hpbnRpbmcgZXJyb3IgaW4gUFJFUDonICsgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9lcnJvclN0YXRlID0gMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9lcnJvclN0YXRlID4gMSkgeyByZXR1cm47IH1cblxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBleGVjR2x5cGgoZ2x5cGgsIHByZXBTdGF0ZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAodGhpcy5fZXJyb3JTdGF0ZSA8IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIaW50aW5nIGVycm9yOicgKyBlKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdOb3RlOiBmdXJ0aGVyIGhpbnRpbmcgZXJyb3JzIGFyZSBzaWxlbmNlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Vycm9yU3RhdGUgPSAxO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn07XG5cbi8qXG4qIEV4ZWN1dGVzIHRoZSBoaW50aW5nIHByb2dyYW0gZm9yIGEgZ2x5cGguXG4qL1xuZXhlY0dseXBoID0gZnVuY3Rpb24oZ2x5cGgsIHByZXBTdGF0ZSkge1xuICAgIC8vIG9yaWdpbmFsIHBvaW50IHBvc2l0aW9uc1xuICAgIHZhciB4U2NhbGUgPSBwcmVwU3RhdGUucHBlbSAvIHByZXBTdGF0ZS5mb250LnVuaXRzUGVyRW07XG4gICAgdmFyIHlTY2FsZSA9IHhTY2FsZTtcbiAgICB2YXIgY29tcG9uZW50cyA9IGdseXBoLmNvbXBvbmVudHM7XG4gICAgdmFyIGNvbnRvdXJzO1xuICAgIHZhciBnWm9uZTtcbiAgICB2YXIgc3RhdGU7XG5cbiAgICBTdGF0ZS5wcm90b3R5cGUgPSBwcmVwU3RhdGU7XG4gICAgaWYgKCFjb21wb25lbnRzKSB7XG4gICAgICAgIHN0YXRlID0gbmV3IFN0YXRlKCdnbHlmJywgZ2x5cGguaW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCctLS1FWEVDIEdMWVBILS0tJyk7XG4gICAgICAgICAgICBzdGF0ZS5zdGVwID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZXhlY0NvbXBvbmVudChnbHlwaCwgc3RhdGUsIHhTY2FsZSwgeVNjYWxlKTtcbiAgICAgICAgZ1pvbmUgPSBzdGF0ZS5nWm9uZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZm9udCA9IHByZXBTdGF0ZS5mb250O1xuICAgICAgICBnWm9uZSA9IFtdO1xuICAgICAgICBjb250b3VycyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgIHZhciBjZyA9IGZvbnQuZ2x5cGhzLmdldChjLmdseXBoSW5kZXgpO1xuXG4gICAgICAgICAgICBzdGF0ZSA9IG5ldyBTdGF0ZSgnZ2x5ZicsIGNnLmluc3RydWN0aW9ucyk7XG5cbiAgICAgICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJy0tLUVYRUMgQ09NUCAnICsgaSArICctLS0nKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4ZWNDb21wb25lbnQoY2csIHN0YXRlLCB4U2NhbGUsIHlTY2FsZSk7XG4gICAgICAgICAgICAvLyBhcHBlbmRzIHRoZSBjb21wdXRlZCBwb2ludHMgdG8gdGhlIHJlc3VsdCBhcnJheVxuICAgICAgICAgICAgLy8gcG9zdCBwcm9jZXNzZXMgdGhlIGNvbXBvbmVudCBwb2ludHNcbiAgICAgICAgICAgIHZhciBkeCA9IE1hdGgucm91bmQoYy5keCAqIHhTY2FsZSk7XG4gICAgICAgICAgICB2YXIgZHkgPSBNYXRoLnJvdW5kKGMuZHkgKiB5U2NhbGUpO1xuICAgICAgICAgICAgdmFyIGd6ID0gc3RhdGUuZ1pvbmU7XG4gICAgICAgICAgICB2YXIgY2MgPSBzdGF0ZS5jb250b3VycztcbiAgICAgICAgICAgIGZvciAodmFyIHBpID0gMDsgcGkgPCBnei5sZW5ndGg7IHBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGd6W3BpXTtcbiAgICAgICAgICAgICAgICBwLnhUb3VjaGVkID0gcC55VG91Y2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHAueG8gPSBwLnggPSBwLnggKyBkeDtcbiAgICAgICAgICAgICAgICBwLnlvID0gcC55ID0gcC55ICsgZHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBnTGVuID0gZ1pvbmUubGVuZ3RoO1xuICAgICAgICAgICAgZ1pvbmUucHVzaC5hcHBseShnWm9uZSwgZ3opO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjYy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goY2Nbal0gKyBnTGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChnbHlwaC5pbnN0cnVjdGlvbnMgJiYgIXN0YXRlLmluaGliaXRHcmlkRml0KSB7XG4gICAgICAgICAgICAvLyB0aGUgY29tcG9zaXRlIGhhcyBpbnN0cnVjdGlvbnMgb24gaXRzIG93blxuICAgICAgICAgICAgc3RhdGUgPSBuZXcgU3RhdGUoJ2dseWYnLCBnbHlwaC5pbnN0cnVjdGlvbnMpO1xuXG4gICAgICAgICAgICBzdGF0ZS5nWm9uZSA9IHN0YXRlLnowID0gc3RhdGUuejEgPSBzdGF0ZS56MiA9IGdab25lO1xuXG4gICAgICAgICAgICBzdGF0ZS5jb250b3VycyA9IGNvbnRvdXJzO1xuXG4gICAgICAgICAgICAvLyBub3RlOiBIUFplcm8gY2Fubm90IGJlIHVzZWQgaGVyZSwgc2luY2VcbiAgICAgICAgICAgIC8vICAgICAgIHRoZSBwb2ludCBtaWdodCBiZSBtb2RpZmllZFxuICAgICAgICAgICAgZ1pvbmUucHVzaChcbiAgICAgICAgICAgICAgICBuZXcgSFBvaW50KDAsIDApLFxuICAgICAgICAgICAgICAgIG5ldyBIUG9pbnQoTWF0aC5yb3VuZChnbHlwaC5hZHZhbmNlV2lkdGggKiB4U2NhbGUpLCAwKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnLS0tRVhFQyBDT01QT1NJVEUtLS0nKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4ZWMoc3RhdGUpO1xuXG4gICAgICAgICAgICBnWm9uZS5sZW5ndGggLT0gMjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnWm9uZTtcbn07XG5cbi8qXG4qIEV4ZWN1dGVzIHRoZSBoaW50aW5nIHByb2dyYW0gZm9yIGEgY29tcG9uZW50IG9mIGEgbXVsdGktY29tcG9uZW50IGdseXBoXG4qIG9yIG9mIHRoZSBnbHlwaCBpdHNlbGYgZm9yIGEgbm9uLWNvbXBvbmVudCBnbHlwaC5cbiovXG5leGVjQ29tcG9uZW50ID0gZnVuY3Rpb24oZ2x5cGgsIHN0YXRlLCB4U2NhbGUsIHlTY2FsZSlcbntcbiAgICB2YXIgcG9pbnRzID0gZ2x5cGgucG9pbnRzIHx8IFtdO1xuICAgIHZhciBwTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICB2YXIgZ1pvbmUgPSBzdGF0ZS5nWm9uZSA9IHN0YXRlLnowID0gc3RhdGUuejEgPSBzdGF0ZS56MiA9IFtdO1xuICAgIHZhciBjb250b3VycyA9IHN0YXRlLmNvbnRvdXJzID0gW107XG5cbiAgICAvLyBTY2FsZXMgdGhlIG9yaWdpbmFsIHBvaW50cyBhbmRcbiAgICAvLyBtYWtlcyBjb3BpZXMgZm9yIHRoZSBoaW50ZWQgcG9pbnRzLlxuICAgIHZhciBjcDsgLy8gY3VycmVudCBwb2ludFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcExlbjsgaSsrKSB7XG4gICAgICAgIGNwID0gcG9pbnRzW2ldO1xuXG4gICAgICAgIGdab25lW2ldID0gbmV3IEhQb2ludChcbiAgICAgICAgICAgIGNwLnggKiB4U2NhbGUsXG4gICAgICAgICAgICBjcC55ICogeVNjYWxlLFxuICAgICAgICAgICAgY3AubGFzdFBvaW50T2ZDb250b3VyLFxuICAgICAgICAgICAgY3Aub25DdXJ2ZVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIENoYWluIGxpbmtzIHRoZSBjb250b3Vycy5cbiAgICB2YXIgc3A7IC8vIHN0YXJ0IHBvaW50XG4gICAgdmFyIG5wOyAvLyBuZXh0IHBvaW50XG5cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwTGVuOyBpJDErKykge1xuICAgICAgICBjcCA9IGdab25lW2kkMV07XG5cbiAgICAgICAgaWYgKCFzcCkge1xuICAgICAgICAgICAgc3AgPSBjcDtcbiAgICAgICAgICAgIGNvbnRvdXJzLnB1c2goaSQxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjcC5sYXN0UG9pbnRPZkNvbnRvdXIpIHtcbiAgICAgICAgICAgIGNwLm5leHRQb2ludE9uQ29udG91ciA9IHNwO1xuICAgICAgICAgICAgc3AucHJldlBvaW50T25Db250b3VyID0gY3A7XG4gICAgICAgICAgICBzcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5wID0gZ1pvbmVbaSQxICsgMV07XG4gICAgICAgICAgICBjcC5uZXh0UG9pbnRPbkNvbnRvdXIgPSBucDtcbiAgICAgICAgICAgIG5wLnByZXZQb2ludE9uQ29udG91ciA9IGNwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmluaGliaXRHcmlkRml0KSB7IHJldHVybjsgfVxuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1BST0NFU1NJTkcgR0xZUEgnLCBzdGF0ZS5zdGFjayk7XG4gICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHBMZW47IGkkMisrKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhpJDIsIGdab25lW2kkMl0ueCwgZ1pvbmVbaSQyXS55KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdab25lLnB1c2goXG4gICAgICAgIG5ldyBIUG9pbnQoMCwgMCksXG4gICAgICAgIG5ldyBIUG9pbnQoTWF0aC5yb3VuZChnbHlwaC5hZHZhbmNlV2lkdGggKiB4U2NhbGUpLCAwKVxuICAgICk7XG5cbiAgICBleGVjKHN0YXRlKTtcblxuICAgIC8vIFJlbW92ZXMgdGhlIGV4dHJhIHBvaW50cy5cbiAgICBnWm9uZS5sZW5ndGggLT0gMjtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdGSU5JU0hFRCBHTFlQSCcsIHN0YXRlLnN0YWNrKTtcbiAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgcExlbjsgaSQzKyspIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGkkMywgZ1pvbmVbaSQzXS54LCBnWm9uZVtpJDNdLnkpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLypcbiogRXhlY3V0ZXMgdGhlIHByb2dyYW0gbG9hZGVkIGluIHN0YXRlLlxuKi9cbmV4ZWMgPSBmdW5jdGlvbihzdGF0ZSkge1xuICAgIHZhciBwcm9nID0gc3RhdGUucHJvZztcblxuICAgIGlmICghcHJvZykgeyByZXR1cm47IH1cblxuICAgIHZhciBwTGVuID0gcHJvZy5sZW5ndGg7XG4gICAgdmFyIGlucztcblxuICAgIGZvciAoc3RhdGUuaXAgPSAwOyBzdGF0ZS5pcCA8IHBMZW47IHN0YXRlLmlwKyspIHtcbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgc3RhdGUuc3RlcCsrOyB9XG4gICAgICAgIGlucyA9IGluc3RydWN0aW9uVGFibGVbcHJvZ1tzdGF0ZS5pcF1dO1xuXG4gICAgICAgIGlmICghaW5zKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ3Vua25vd24gaW5zdHJ1Y3Rpb246IDB4JyArXG4gICAgICAgICAgICAgICAgTnVtYmVyKHByb2dbc3RhdGUuaXBdKS50b1N0cmluZygxNilcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnMoc3RhdGUpO1xuXG4gICAgICAgIC8vIHZlcnkgZXh0ZW5zaXZlIGRlYnVnZ2luZyBmb3IgZWFjaCBzdGVwXG4gICAgICAgIC8qXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICB2YXIgZGE7XG4gICAgICAgICAgICBpZiAoc3RhdGUuZ1pvbmUpIHtcbiAgICAgICAgICAgICAgICBkYSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuZ1pvbmUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBkYS5wdXNoKGkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZ1pvbmVbaV0ueCAqIDY0ICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmdab25lW2ldLnkgKiA2NCArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUuZ1pvbmVbaV0ueFRvdWNoZWQgPyAneCcgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHN0YXRlLmdab25lW2ldLnlUb3VjaGVkID8gJ3knIDogJycpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdHWicsIGRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHN0YXRlLnRab25lKSB7XG4gICAgICAgICAgICAgICAgZGEgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnRab25lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhLnB1c2goaSArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS50Wm9uZVtpXS54ICogNjQgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUudFpvbmVbaV0ueSAqIDY0ICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS50Wm9uZVtpXS54VG91Y2hlZCA/ICd4JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUudFpvbmVbaV0ueVRvdWNoZWQgPyAneScgOiAnJylcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1RaJywgZGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3RhdGUuc3RhY2subGVuZ3RoID4gMTApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuc3RhY2subGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAnLi4uJywgc3RhdGUuc3RhY2suc2xpY2Uoc3RhdGUuc3RhY2subGVuZ3RoIC0gMTApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coc3RhdGUuc3RhY2subGVuZ3RoLCBzdGF0ZS5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICB9XG59O1xuXG4vKlxuKiBJbml0aWFsaXplcyB0aGUgdHdpbGlnaHQgem9uZS5cbipcbiogVGhpcyBpcyBvbmx5IGRvbmUgaWYgYSBTWlB4IGluc3RydWN0aW9uXG4qIHJlZmVycyB0byB0aGUgdHdpbGlnaHQgem9uZS5cbiovXG5mdW5jdGlvbiBpbml0VFpvbmUoc3RhdGUpXG57XG4gICAgdmFyIHRab25lID0gc3RhdGUudFpvbmUgPSBuZXcgQXJyYXkoc3RhdGUuZ1pvbmUubGVuZ3RoKTtcblxuICAgIC8vIG5vIGlkZWEgaWYgdGhpcyBpcyBhY3R1YWxseSBjb3JyZWN0Li4uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0Wm9uZS5sZW5ndGg7IGkrKylcbiAgICB7XG4gICAgICAgIHRab25lW2ldID0gbmV3IEhQb2ludCgwLCAwKTtcbiAgICB9XG59XG5cbi8qXG4qIFNraXBzIHRoZSBpbnN0cnVjdGlvbiBwb2ludGVyIGFoZWFkIG92ZXIgYW4gSUYvRUxTRSBibG9jay5cbiogaGFuZGxlRWxzZSAuLiBpZiB0cnVlIGJyZWFrcyBvbiBtYXRjaGluZyBFTFNFXG4qL1xuZnVuY3Rpb24gc2tpcChzdGF0ZSwgaGFuZGxlRWxzZSlcbntcbiAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG4gICAgdmFyIGlwID0gc3RhdGUuaXA7XG4gICAgdmFyIG5lc3RpbmcgPSAxO1xuICAgIHZhciBpbnM7XG5cbiAgICBkbyB7XG4gICAgICAgIGlucyA9IHByb2dbKytpcF07XG4gICAgICAgIGlmIChpbnMgPT09IDB4NTgpIC8vIElGXG4gICAgICAgICAgICB7IG5lc3RpbmcrKzsgfVxuICAgICAgICBlbHNlIGlmIChpbnMgPT09IDB4NTkpIC8vIEVJRlxuICAgICAgICAgICAgeyBuZXN0aW5nLS07IH1cbiAgICAgICAgZWxzZSBpZiAoaW5zID09PSAweDQwKSAvLyBOUFVTSEJcbiAgICAgICAgICAgIHsgaXAgKz0gcHJvZ1tpcCArIDFdICsgMTsgfVxuICAgICAgICBlbHNlIGlmIChpbnMgPT09IDB4NDEpIC8vIE5QVVNIV1xuICAgICAgICAgICAgeyBpcCArPSAyICogcHJvZ1tpcCArIDFdICsgMTsgfVxuICAgICAgICBlbHNlIGlmIChpbnMgPj0gMHhCMCAmJiBpbnMgPD0gMHhCNykgLy8gUFVTSEJcbiAgICAgICAgICAgIHsgaXAgKz0gaW5zIC0gMHhCMCArIDE7IH1cbiAgICAgICAgZWxzZSBpZiAoaW5zID49IDB4QjggJiYgaW5zIDw9IDB4QkYpIC8vIFBVU0hXXG4gICAgICAgICAgICB7IGlwICs9IChpbnMgLSAweEI4ICsgMSkgKiAyOyB9XG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZUVsc2UgJiYgbmVzdGluZyA9PT0gMSAmJiBpbnMgPT09IDB4MUIpIC8vIEVMU0VcbiAgICAgICAgICAgIHsgYnJlYWs7IH1cbiAgICB9IHdoaWxlIChuZXN0aW5nID4gMCk7XG5cbiAgICBzdGF0ZS5pcCA9IGlwO1xufVxuXG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qXG4qICAgICAgICAgIEFuZCB0aGVuIGEgbG90IG9mIGluc3RydWN0aW9ucy4uLiAgICAgICAgICAgICAgICAqXG4qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbi8vIFNWVENBW2FdIFNldCBmcmVlZG9tIGFuZCBwcm9qZWN0aW9uIFZlY3RvcnMgVG8gQ29vcmRpbmF0ZSBBeGlzXG4vLyAweDAwLTB4MDFcbmZ1bmN0aW9uIFNWVENBKHYsIHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NWVENBWycgKyB2LmF4aXMgKyAnXScpOyB9XG5cbiAgICBzdGF0ZS5mdiA9IHN0YXRlLnB2ID0gc3RhdGUuZHB2ID0gdjtcbn1cblxuLy8gU1BWVENBW2FdIFNldCBQcm9qZWN0aW9uIFZlY3RvciB0byBDb29yZGluYXRlIEF4aXNcbi8vIDB4MDItMHgwM1xuZnVuY3Rpb24gU1BWVENBKHYsIHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NQVlRDQVsnICsgdi5heGlzICsgJ10nKTsgfVxuXG4gICAgc3RhdGUucHYgPSBzdGF0ZS5kcHYgPSB2O1xufVxuXG4vLyBTRlZUQ0FbYV0gU2V0IEZyZWVkb20gVmVjdG9yIHRvIENvb3JkaW5hdGUgQXhpc1xuLy8gMHgwNC0weDA1XG5mdW5jdGlvbiBTRlZUQ0Eodiwgc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0ZWVENBWycgKyB2LmF4aXMgKyAnXScpOyB9XG5cbiAgICBzdGF0ZS5mdiA9IHY7XG59XG5cbi8vIFNQVlRMW2FdIFNldCBQcm9qZWN0aW9uIFZlY3RvciBUbyBMaW5lXG4vLyAweDA2LTB4MDdcbmZ1bmN0aW9uIFNQVlRMKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHAyaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwMWkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcDIgPSBzdGF0ZS56MltwMmldO1xuICAgIHZhciBwMSA9IHN0YXRlLnoxW3AxaV07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZygnU1BWVExbJyArIGEgKyAnXScsIHAyaSwgcDFpKTsgfVxuXG4gICAgdmFyIGR4O1xuICAgIHZhciBkeTtcblxuICAgIGlmICghYSkge1xuICAgICAgICBkeCA9IHAxLnggLSBwMi54O1xuICAgICAgICBkeSA9IHAxLnkgLSBwMi55O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGR4ID0gcDIueSAtIHAxLnk7XG4gICAgICAgIGR5ID0gcDEueCAtIHAyLng7XG4gICAgfVxuXG4gICAgc3RhdGUucHYgPSBzdGF0ZS5kcHYgPSBnZXRVbml0VmVjdG9yKGR4LCBkeSk7XG59XG5cbi8vIFNGVlRMW2FdIFNldCBGcmVlZG9tIFZlY3RvciBUbyBMaW5lXG4vLyAweDA4LTB4MDlcbmZ1bmN0aW9uIFNGVlRMKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHAyaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwMWkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcDIgPSBzdGF0ZS56MltwMmldO1xuICAgIHZhciBwMSA9IHN0YXRlLnoxW3AxaV07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZygnU0ZWVExbJyArIGEgKyAnXScsIHAyaSwgcDFpKTsgfVxuXG4gICAgdmFyIGR4O1xuICAgIHZhciBkeTtcblxuICAgIGlmICghYSkge1xuICAgICAgICBkeCA9IHAxLnggLSBwMi54O1xuICAgICAgICBkeSA9IHAxLnkgLSBwMi55O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGR4ID0gcDIueSAtIHAxLnk7XG4gICAgICAgIGR5ID0gcDEueCAtIHAyLng7XG4gICAgfVxuXG4gICAgc3RhdGUuZnYgPSBnZXRVbml0VmVjdG9yKGR4LCBkeSk7XG59XG5cbi8vIFNQVkZTW10gU2V0IFByb2plY3Rpb24gVmVjdG9yIEZyb20gU3RhY2tcbi8vIDB4MEFcbmZ1bmN0aW9uIFNQVkZTKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgeCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NQVkZTW10nLCB5LCB4KTsgfVxuXG4gICAgc3RhdGUucHYgPSBzdGF0ZS5kcHYgPSBnZXRVbml0VmVjdG9yKHgsIHkpO1xufVxuXG4vLyBTRlZGU1tdIFNldCBGcmVlZG9tIFZlY3RvciBGcm9tIFN0YWNrXG4vLyAweDBCXG5mdW5jdGlvbiBTRlZGUyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciB5ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHggPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUFZGU1tdJywgeSwgeCk7IH1cblxuICAgIHN0YXRlLmZ2ID0gZ2V0VW5pdFZlY3Rvcih4LCB5KTtcbn1cblxuLy8gR1BWW10gR2V0IFByb2plY3Rpb24gVmVjdG9yXG4vLyAweDBDXG5mdW5jdGlvbiBHUFYoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHUFZbXScpOyB9XG5cbiAgICBzdGFjay5wdXNoKHB2LnggKiAweDQwMDApO1xuICAgIHN0YWNrLnB1c2gocHYueSAqIDB4NDAwMCk7XG59XG5cbi8vIEdGVltdIEdldCBGcmVlZG9tIFZlY3RvclxuLy8gMHgwQ1xuZnVuY3Rpb24gR0ZWKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR0ZWW10nKTsgfVxuXG4gICAgc3RhY2sucHVzaChmdi54ICogMHg0MDAwKTtcbiAgICBzdGFjay5wdXNoKGZ2LnkgKiAweDQwMDApO1xufVxuXG4vLyBTRlZUUFZbXSBTZXQgRnJlZWRvbSBWZWN0b3IgVG8gUHJvamVjdGlvbiBWZWN0b3Jcbi8vIDB4MEVcbmZ1bmN0aW9uIFNGVlRQVihzdGF0ZSkge1xuICAgIHN0YXRlLmZ2ID0gc3RhdGUucHY7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0ZWVFBWW10nKTsgfVxufVxuXG4vLyBJU0VDVFtdIG1vdmVzIHBvaW50IHAgdG8gdGhlIEludGVyU0VDVGlvbiBvZiB0d28gbGluZXNcbi8vIDB4MEZcbmZ1bmN0aW9uIElTRUNUKHN0YXRlKVxue1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwYTBpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHBhMWkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcGIwaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwYjFpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHowID0gc3RhdGUuejA7XG4gICAgdmFyIHoxID0gc3RhdGUuejE7XG4gICAgdmFyIHBhMCA9IHowW3BhMGldO1xuICAgIHZhciBwYTEgPSB6MFtwYTFpXTtcbiAgICB2YXIgcGIwID0gejFbcGIwaV07XG4gICAgdmFyIHBiMSA9IHoxW3BiMWldO1xuICAgIHZhciBwID0gc3RhdGUuejJbcGldO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coJ0lTRUNUW10sICcsIHBhMGksIHBhMWksIHBiMGksIHBiMWksIHBpKTsgfVxuXG4gICAgLy8gbWF0aCBmcm9tXG4gICAgLy8gZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmUlRTIlODAlOTNsaW5lX2ludGVyc2VjdGlvbiNHaXZlbl90d29fcG9pbnRzX29uX2VhY2hfbGluZVxuXG4gICAgdmFyIHgxID0gcGEwLng7XG4gICAgdmFyIHkxID0gcGEwLnk7XG4gICAgdmFyIHgyID0gcGExLng7XG4gICAgdmFyIHkyID0gcGExLnk7XG4gICAgdmFyIHgzID0gcGIwLng7XG4gICAgdmFyIHkzID0gcGIwLnk7XG4gICAgdmFyIHg0ID0gcGIxLng7XG4gICAgdmFyIHk0ID0gcGIxLnk7XG5cbiAgICB2YXIgZGl2ID0gKHgxIC0geDIpICogKHkzIC0geTQpIC0gKHkxIC0geTIpICogKHgzIC0geDQpO1xuICAgIHZhciBmMSA9IHgxICogeTIgLSB5MSAqIHgyO1xuICAgIHZhciBmMiA9IHgzICogeTQgLSB5MyAqIHg0O1xuXG4gICAgcC54ID0gKGYxICogKHgzIC0geDQpIC0gZjIgKiAoeDEgLSB4MikpIC8gZGl2O1xuICAgIHAueSA9IChmMSAqICh5MyAtIHk0KSAtIGYyICogKHkxIC0geTIpKSAvIGRpdjtcbn1cblxuLy8gU1JQMFtdIFNldCBSZWZlcmVuY2UgUG9pbnQgMFxuLy8gMHgxMFxuZnVuY3Rpb24gU1JQMChzdGF0ZSkge1xuICAgIHN0YXRlLnJwMCA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NSUDBbXScsIHN0YXRlLnJwMCk7IH1cbn1cblxuLy8gU1JQMVtdIFNldCBSZWZlcmVuY2UgUG9pbnQgMVxuLy8gMHgxMVxuZnVuY3Rpb24gU1JQMShzdGF0ZSkge1xuICAgIHN0YXRlLnJwMSA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NSUDFbXScsIHN0YXRlLnJwMSk7IH1cbn1cblxuLy8gU1JQMVtdIFNldCBSZWZlcmVuY2UgUG9pbnQgMlxuLy8gMHgxMlxuZnVuY3Rpb24gU1JQMihzdGF0ZSkge1xuICAgIHN0YXRlLnJwMiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NSUDJbXScsIHN0YXRlLnJwMik7IH1cbn1cblxuLy8gU1pQMFtdIFNldCBab25lIFBvaW50ZXIgMFxuLy8gMHgxM1xuZnVuY3Rpb24gU1pQMChzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1pQMFtdJywgbik7IH1cblxuICAgIHN0YXRlLnpwMCA9IG47XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS50Wm9uZSkgeyBpbml0VFpvbmUoc3RhdGUpOyB9XG4gICAgICAgICAgICBzdGF0ZS56MCA9IHN0YXRlLnRab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSA6XG4gICAgICAgICAgICBzdGF0ZS56MCA9IHN0YXRlLmdab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHpvbmUgcG9pbnRlcicpO1xuICAgIH1cbn1cblxuLy8gU1pQMVtdIFNldCBab25lIFBvaW50ZXIgMVxuLy8gMHgxNFxuZnVuY3Rpb24gU1pQMShzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1pQMVtdJywgbik7IH1cblxuICAgIHN0YXRlLnpwMSA9IG47XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS50Wm9uZSkgeyBpbml0VFpvbmUoc3RhdGUpOyB9XG4gICAgICAgICAgICBzdGF0ZS56MSA9IHN0YXRlLnRab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSA6XG4gICAgICAgICAgICBzdGF0ZS56MSA9IHN0YXRlLmdab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHpvbmUgcG9pbnRlcicpO1xuICAgIH1cbn1cblxuLy8gU1pQMltdIFNldCBab25lIFBvaW50ZXIgMlxuLy8gMHgxNVxuZnVuY3Rpb24gU1pQMihzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1pQMltdJywgbik7IH1cblxuICAgIHN0YXRlLnpwMiA9IG47XG5cbiAgICBzd2l0Y2ggKG4pIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCFzdGF0ZS50Wm9uZSkgeyBpbml0VFpvbmUoc3RhdGUpOyB9XG4gICAgICAgICAgICBzdGF0ZS56MiA9IHN0YXRlLnRab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSA6XG4gICAgICAgICAgICBzdGF0ZS56MiA9IHN0YXRlLmdab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHpvbmUgcG9pbnRlcicpO1xuICAgIH1cbn1cblxuLy8gU1pQU1tdIFNldCBab25lIFBvaW50ZXJTXG4vLyAweDE2XG5mdW5jdGlvbiBTWlBTKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTWlBTW10nLCBuKTsgfVxuXG4gICAgc3RhdGUuenAwID0gc3RhdGUuenAxID0gc3RhdGUuenAyID0gbjtcblxuICAgIHN3aXRjaCAobikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIXN0YXRlLnRab25lKSB7IGluaXRUWm9uZShzdGF0ZSk7IH1cbiAgICAgICAgICAgIHN0YXRlLnowID0gc3RhdGUuejEgPSBzdGF0ZS56MiA9IHN0YXRlLnRab25lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSA6XG4gICAgICAgICAgICBzdGF0ZS56MCA9IHN0YXRlLnoxID0gc3RhdGUuejIgPSBzdGF0ZS5nWm9uZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB6b25lIHBvaW50ZXInKTtcbiAgICB9XG59XG5cbi8vIFNMT09QW10gU2V0IExPT1AgdmFyaWFibGVcbi8vIDB4MTdcbmZ1bmN0aW9uIFNMT09QKHN0YXRlKSB7XG4gICAgc3RhdGUubG9vcCA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NMT09QW10nLCBzdGF0ZS5sb29wKTsgfVxufVxuXG4vLyBSVEdbXSBSb3VuZCBUbyBHcmlkXG4vLyAweDE4XG5mdW5jdGlvbiBSVEcoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlRHW10nKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZFRvR3JpZDtcbn1cblxuLy8gUlRIR1tdIFJvdW5kIFRvIEhhbGYgR3JpZFxuLy8gMHgxOVxuZnVuY3Rpb24gUlRIRyhzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSVEhHW10nKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZFRvSGFsZkdyaWQ7XG59XG5cbi8vIFNNRFtdIFNldCBNaW5pbXVtIERpc3RhbmNlXG4vLyAweDFBXG5mdW5jdGlvbiBTTUQoc3RhdGUpIHtcbiAgICB2YXIgZCA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NNRFtdJywgZCk7IH1cblxuICAgIHN0YXRlLm1pbkRpcyA9IGQgLyAweDQwO1xufVxuXG4vLyBFTFNFW10gRUxTRSBjbGF1c2Vcbi8vIDB4MUJcbmZ1bmN0aW9uIEVMU0Uoc3RhdGUpIHtcbiAgICAvLyBUaGlzIGluc3RydWN0aW9uIGhhcyBiZWVuIHJlYWNoZWQgYnkgZXhlY3V0aW5nIGEgdGhlbiBicmFuY2hcbiAgICAvLyBzbyBpdCBqdXN0IHNraXBzIGFoZWFkIHVudGlsIG1hdGNoaW5nIEVJRi5cbiAgICAvL1xuICAgIC8vIEluIGNhc2UgdGhlIElGIHdhcyBuZWdhdGl2ZSB0aGUgSUZbXSBpbnN0cnVjdGlvbiBhbHJlYWR5XG4gICAgLy8gc2tpcHBlZCBmb3J3YXJkIG92ZXIgdGhlIEVMU0VbXVxuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0VMU0VbXScpOyB9XG5cbiAgICBza2lwKHN0YXRlLCBmYWxzZSk7XG59XG5cbi8vIEpNUFJbXSBKdU1QIFJlbGF0aXZlXG4vLyAweDFDXG5mdW5jdGlvbiBKTVBSKHN0YXRlKSB7XG4gICAgdmFyIG8gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdKTVBSW10nLCBvKTsgfVxuXG4gICAgLy8gQSBqdW1wIGJ5IDEgd291bGQgZG8gbm90aGluZy5cbiAgICBzdGF0ZS5pcCArPSBvIC0gMTtcbn1cblxuLy8gU0NWVENJW10gU2V0IENvbnRyb2wgVmFsdWUgVGFibGUgQ3V0LUluXG4vLyAweDFEXG5mdW5jdGlvbiBTQ1ZUQ0koc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NDVlRDSVtdJywgbik7IH1cblxuICAgIHN0YXRlLmN2Q3V0SW4gPSBuIC8gMHg0MDtcbn1cblxuLy8gRFVQW10gRFVQbGljYXRlIHRvcCBzdGFjayBlbGVtZW50XG4vLyAweDIwXG5mdW5jdGlvbiBEVVAoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdEVVBbXScpOyB9XG5cbiAgICBzdGFjay5wdXNoKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdKTtcbn1cblxuLy8gUE9QW10gUE9QIHRvcCBzdGFjayBlbGVtZW50XG4vLyAweDIxXG5mdW5jdGlvbiBQT1Aoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUE9QW10nKTsgfVxuXG4gICAgc3RhdGUuc3RhY2sucG9wKCk7XG59XG5cbi8vIENMRUFSW10gQ0xFQVIgdGhlIHN0YWNrXG4vLyAweDIyXG5mdW5jdGlvbiBDTEVBUihzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdDTEVBUltdJyk7IH1cblxuICAgIHN0YXRlLnN0YWNrLmxlbmd0aCA9IDA7XG59XG5cbi8vIFNXQVBbXSBTV0FQIHRoZSB0b3AgdHdvIGVsZW1lbnRzIG9uIHRoZSBzdGFja1xuLy8gMHgyM1xuZnVuY3Rpb24gU1dBUChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG4gICAgdmFyIGEgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgYiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NXQVBbXScpOyB9XG5cbiAgICBzdGFjay5wdXNoKGEpO1xuICAgIHN0YWNrLnB1c2goYik7XG59XG5cbi8vIERFUFRIW10gREVQVEggb2YgdGhlIHN0YWNrXG4vLyAweDI0XG5mdW5jdGlvbiBERVBUSChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RFUFRIW10nKTsgfVxuXG4gICAgc3RhY2sucHVzaChzdGFjay5sZW5ndGgpO1xufVxuXG4vLyBMT09QQ0FMTFtdIExPT1BDQUxMIGZ1bmN0aW9uXG4vLyAweDJBXG5mdW5jdGlvbiBMT09QQ0FMTChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBmbiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBjID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTE9PUENBTExbXScsIGZuLCBjKTsgfVxuXG4gICAgLy8gc2F2ZXMgY2FsbGVycyBwcm9ncmFtXG4gICAgdmFyIGNpcCA9IHN0YXRlLmlwO1xuICAgIHZhciBjcHJvZyA9IHN0YXRlLnByb2c7XG5cbiAgICBzdGF0ZS5wcm9nID0gc3RhdGUuZnVuY3NbZm5dO1xuXG4gICAgLy8gZXhlY3V0ZXMgdGhlIGZ1bmN0aW9uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjOyBpKyspIHtcbiAgICAgICAgZXhlYyhzdGF0ZSk7XG5cbiAgICAgICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coXG4gICAgICAgICAgICArK3N0YXRlLnN0ZXAsXG4gICAgICAgICAgICBpICsgMSA8IGMgPyAnbmV4dCBsb29wY2FsbCcgOiAnZG9uZSBsb29wY2FsbCcsXG4gICAgICAgICAgICBpXG4gICAgICAgICk7IH1cbiAgICB9XG5cbiAgICAvLyByZXN0b3JlcyB0aGUgY2FsbGVycyBwcm9ncmFtXG4gICAgc3RhdGUuaXAgPSBjaXA7XG4gICAgc3RhdGUucHJvZyA9IGNwcm9nO1xufVxuXG4vLyBDQUxMW10gQ0FMTCBmdW5jdGlvblxuLy8gMHgyQlxuZnVuY3Rpb24gQ0FMTChzdGF0ZSkge1xuICAgIHZhciBmbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0NBTExbXScsIGZuKTsgfVxuXG4gICAgLy8gc2F2ZXMgY2FsbGVycyBwcm9ncmFtXG4gICAgdmFyIGNpcCA9IHN0YXRlLmlwO1xuICAgIHZhciBjcHJvZyA9IHN0YXRlLnByb2c7XG5cbiAgICBzdGF0ZS5wcm9nID0gc3RhdGUuZnVuY3NbZm5dO1xuXG4gICAgLy8gZXhlY3V0ZXMgdGhlIGZ1bmN0aW9uXG4gICAgZXhlYyhzdGF0ZSk7XG5cbiAgICAvLyByZXN0b3JlcyB0aGUgY2FsbGVycyBwcm9ncmFtXG4gICAgc3RhdGUuaXAgPSBjaXA7XG4gICAgc3RhdGUucHJvZyA9IGNwcm9nO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coKytzdGF0ZS5zdGVwLCAncmV0dXJuaW5nIGZyb20nLCBmbik7IH1cbn1cblxuLy8gQ0lOREVYW10gQ29weSB0aGUgSU5ERVhlZCBlbGVtZW50IHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4vLyAweDI1XG5mdW5jdGlvbiBDSU5ERVgoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgayA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0NJTkRFWFtdJywgayk7IH1cblxuICAgIC8vIEluIGNhc2Ugb2YgayA9PSAxLCBpdCBjb3BpZXMgdGhlIGxhc3QgZWxlbWVudCBhZnRlciBwb3BwaW5nXG4gICAgLy8gdGh1cyBzdGFjay5sZW5ndGggLSBrLlxuICAgIHN0YWNrLnB1c2goc3RhY2tbc3RhY2subGVuZ3RoIC0ga10pO1xufVxuXG4vLyBNSU5ERVhbXSBNb3ZlIHRoZSBJTkRFWGVkIGVsZW1lbnQgdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2tcbi8vIDB4MjZcbmZ1bmN0aW9uIE1JTkRFWChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBrID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTUlOREVYW10nLCBrKTsgfVxuXG4gICAgc3RhY2sucHVzaChzdGFjay5zcGxpY2Uoc3RhY2subGVuZ3RoIC0gaywgMSlbMF0pO1xufVxuXG4vLyBGREVGW10gRnVuY3Rpb24gREVGaW5pdGlvblxuLy8gMHgyQ1xuZnVuY3Rpb24gRkRFRihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5lbnYgIT09ICdmcGdtJykgeyB0aHJvdyBuZXcgRXJyb3IoJ0ZERUYgbm90IGFsbG93ZWQgaGVyZScpOyB9XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuXG4gICAgdmFyIGZuID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGlwQmVnaW4gPSBpcDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdGREVGW10nLCBmbik7IH1cblxuICAgIHdoaWxlIChwcm9nWysraXBdICE9PSAweDJEKXsgIH1cblxuICAgIHN0YXRlLmlwID0gaXA7XG4gICAgc3RhdGUuZnVuY3NbZm5dID0gcHJvZy5zbGljZShpcEJlZ2luICsgMSwgaXApO1xufVxuXG4vLyBNREFQW2FdIE1vdmUgRGlyZWN0IEFic29sdXRlIFBvaW50XG4vLyAweDJFLTB4MkZcbmZ1bmN0aW9uIE1EQVAocm91bmQsIHN0YXRlKSB7XG4gICAgdmFyIHBpID0gc3RhdGUuc3RhY2sucG9wKCk7XG4gICAgdmFyIHAgPSBzdGF0ZS56MFtwaV07XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTURBUFsnICsgcm91bmQgKyAnXScsIHBpKTsgfVxuXG4gICAgdmFyIGQgPSBwdi5kaXN0YW5jZShwLCBIUFplcm8pO1xuXG4gICAgaWYgKHJvdW5kKSB7IGQgPSBzdGF0ZS5yb3VuZChkKTsgfVxuXG4gICAgZnYuc2V0UmVsYXRpdmUocCwgSFBaZXJvLCBkLCBwdik7XG4gICAgZnYudG91Y2gocCk7XG5cbiAgICBzdGF0ZS5ycDAgPSBzdGF0ZS5ycDEgPSBwaTtcbn1cblxuLy8gSVVQW2FdIEludGVycG9sYXRlIFVudG91Y2hlZCBQb2ludHMgdGhyb3VnaCB0aGUgb3V0bGluZVxuLy8gMHgzMFxuZnVuY3Rpb24gSVVQKHYsIHN0YXRlKSB7XG4gICAgdmFyIHoyID0gc3RhdGUuejI7XG4gICAgdmFyIHBMZW4gPSB6Mi5sZW5ndGggLSAyO1xuICAgIHZhciBjcDtcbiAgICB2YXIgcHA7XG4gICAgdmFyIG5wO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0lVUFsnICsgdi5heGlzICsgJ10nKTsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwTGVuOyBpKyspIHtcbiAgICAgICAgY3AgPSB6MltpXTsgLy8gY3VycmVudCBwb2ludFxuXG4gICAgICAgIC8vIGlmIHRoaXMgcG9pbnQgaGFzIGJlZW4gdG91Y2hlZCBnbyBvblxuICAgICAgICBpZiAodi50b3VjaGVkKGNwKSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHBwID0gY3AucHJldlRvdWNoZWQodik7XG5cbiAgICAgICAgLy8gbm8gcG9pbnQgb24gdGhlIGNvbnRvdXIgaGFzIGJlZW4gdG91Y2hlZD9cbiAgICAgICAgaWYgKHBwID09PSBjcCkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgIG5wID0gY3AubmV4dFRvdWNoZWQodik7XG5cbiAgICAgICAgaWYgKHBwID09PSBucCkge1xuICAgICAgICAgICAgLy8gb25seSBvbmUgcG9pbnQgb24gdGhlIGNvbnRvdXIgaGFzIGJlZW4gdG91Y2hlZFxuICAgICAgICAgICAgLy8gc28gc2ltcGx5IG1vdmVzIHRoZSBwb2ludCBsaWtlIHRoYXRcblxuICAgICAgICAgICAgdi5zZXRSZWxhdGl2ZShjcCwgY3AsIHYuZGlzdGFuY2UocHAsIHBwLCBmYWxzZSwgdHJ1ZSksIHYsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdi5pbnRlcnBvbGF0ZShjcCwgcHAsIG5wLCB2KTtcbiAgICB9XG59XG5cbi8vIFNIUFtdIFNIaWZ0IFBvaW50IHVzaW5nIHJlZmVyZW5jZSBwb2ludFxuLy8gMHgzMi0weDMzXG5mdW5jdGlvbiBTSFAoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcnBpID0gYSA/IHN0YXRlLnJwMSA6IHN0YXRlLnJwMjtcbiAgICB2YXIgcnAgPSAoYSA/IHN0YXRlLnowIDogc3RhdGUuejEpW3JwaV07XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG4gICAgdmFyIGxvb3AgPSBzdGF0ZS5sb29wO1xuICAgIHZhciB6MiA9IHN0YXRlLnoyO1xuXG4gICAgd2hpbGUgKGxvb3AtLSlcbiAgICB7XG4gICAgICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcCA9IHoyW3BpXTtcblxuICAgICAgICB2YXIgZCA9IHB2LmRpc3RhbmNlKHJwLCBycCwgZmFsc2UsIHRydWUpO1xuICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBwLCBkLCBwdik7XG4gICAgICAgIGZ2LnRvdWNoKHApO1xuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgICAgIChzdGF0ZS5sb29wID4gMSA/XG4gICAgICAgICAgICAgICAgICAgJ2xvb3AgJyArIChzdGF0ZS5sb29wIC0gbG9vcCkgKyAnOiAnIDpcbiAgICAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgICAgICdTSFBbJyArIChhID8gJ3JwMScgOiAncnAyJykgKyAnXScsIHBpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUubG9vcCA9IDE7XG59XG5cbi8vIFNIQ1tdIFNIaWZ0IENvbnRvdXIgdXNpbmcgcmVmZXJlbmNlIHBvaW50XG4vLyAweDM2LTB4MzdcbmZ1bmN0aW9uIFNIQyhhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBycGkgPSBhID8gc3RhdGUucnAxIDogc3RhdGUucnAyO1xuICAgIHZhciBycCA9IChhID8gc3RhdGUuejAgOiBzdGF0ZS56MSlbcnBpXTtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcbiAgICB2YXIgY2kgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgc3AgPSBzdGF0ZS56MltzdGF0ZS5jb250b3Vyc1tjaV1dO1xuICAgIHZhciBwID0gc3A7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0hDWycgKyBhICsgJ10nLCBjaSk7IH1cblxuICAgIHZhciBkID0gcHYuZGlzdGFuY2UocnAsIHJwLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICBkbyB7XG4gICAgICAgIGlmIChwICE9PSBycCkgeyBmdi5zZXRSZWxhdGl2ZShwLCBwLCBkLCBwdik7IH1cbiAgICAgICAgcCA9IHAubmV4dFBvaW50T25Db250b3VyO1xuICAgIH0gd2hpbGUgKHAgIT09IHNwKTtcbn1cblxuLy8gU0haW10gU0hpZnQgWm9uZSB1c2luZyByZWZlcmVuY2UgcG9pbnRcbi8vIDB4MzYtMHgzN1xuZnVuY3Rpb24gU0haKGEsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHJwaSA9IGEgPyBzdGF0ZS5ycDEgOiBzdGF0ZS5ycDI7XG4gICAgdmFyIHJwID0gKGEgPyBzdGF0ZS56MCA6IHN0YXRlLnoxKVtycGldO1xuICAgIHZhciBmdiA9IHN0YXRlLmZ2O1xuICAgIHZhciBwdiA9IHN0YXRlLnB2O1xuXG4gICAgdmFyIGUgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTSFpbJyArIGEgKyAnXScsIGUpOyB9XG5cbiAgICB2YXIgejtcbiAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgY2FzZSAwIDogeiA9IHN0YXRlLnRab25lOyBicmVhaztcbiAgICAgICAgY2FzZSAxIDogeiA9IHN0YXRlLmdab25lOyBicmVhaztcbiAgICAgICAgZGVmYXVsdCA6IHRocm93IG5ldyBFcnJvcignSW52YWxpZCB6b25lJyk7XG4gICAgfVxuXG4gICAgdmFyIHA7XG4gICAgdmFyIGQgPSBwdi5kaXN0YW5jZShycCwgcnAsIGZhbHNlLCB0cnVlKTtcbiAgICB2YXIgcExlbiA9IHoubGVuZ3RoIC0gMjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBMZW47IGkrKylcbiAgICB7XG4gICAgICAgIHAgPSB6W2ldO1xuICAgICAgICBmdi5zZXRSZWxhdGl2ZShwLCBwLCBkLCBwdik7XG4gICAgICAgIC8vaWYgKHAgIT09IHJwKSBmdi5zZXRSZWxhdGl2ZShwLCBwLCBkLCBwdik7XG4gICAgfVxufVxuXG4vLyBTSFBJWFtdIFNIaWZ0IHBvaW50IGJ5IGEgUElYZWwgYW1vdW50XG4vLyAweDM4XG5mdW5jdGlvbiBTSFBJWChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBsb29wID0gc3RhdGUubG9vcDtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgZCA9IHN0YWNrLnBvcCgpIC8gMHg0MDtcbiAgICB2YXIgejIgPSBzdGF0ZS56MjtcblxuICAgIHdoaWxlIChsb29wLS0pIHtcbiAgICAgICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBwID0gejJbcGldO1xuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgICAgIChzdGF0ZS5sb29wID4gMSA/ICdsb29wICcgKyAoc3RhdGUubG9vcCAtIGxvb3ApICsgJzogJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgJ1NIUElYW10nLCBwaSwgZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ2LnNldFJlbGF0aXZlKHAsIHAsIGQpO1xuICAgICAgICBmdi50b3VjaChwKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5sb29wID0gMTtcbn1cblxuLy8gSVBbXSBJbnRlcnBvbGF0ZSBQb2ludFxuLy8gMHgzOVxuZnVuY3Rpb24gSVAoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcnAxaSA9IHN0YXRlLnJwMTtcbiAgICB2YXIgcnAyaSA9IHN0YXRlLnJwMjtcbiAgICB2YXIgbG9vcCA9IHN0YXRlLmxvb3A7XG4gICAgdmFyIHJwMSA9IHN0YXRlLnowW3JwMWldO1xuICAgIHZhciBycDIgPSBzdGF0ZS56MVtycDJpXTtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5kcHY7XG4gICAgdmFyIHoyID0gc3RhdGUuejI7XG5cbiAgICB3aGlsZSAobG9vcC0tKSB7XG4gICAgICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcCA9IHoyW3BpXTtcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICAgICAoc3RhdGUubG9vcCA+IDEgPyAnbG9vcCAnICsgKHN0YXRlLmxvb3AgLSBsb29wKSArICc6ICcgOiAnJykgK1xuICAgICAgICAgICAgICAgICdJUFtdJywgcGksIHJwMWksICc8LT4nLCBycDJpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgZnYuaW50ZXJwb2xhdGUocCwgcnAxLCBycDIsIHB2KTtcblxuICAgICAgICBmdi50b3VjaChwKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5sb29wID0gMTtcbn1cblxuLy8gTVNJUlBbYV0gTW92ZSBTdGFjayBJbmRpcmVjdCBSZWxhdGl2ZSBQb2ludFxuLy8gMHgzQS0weDNCXG5mdW5jdGlvbiBNU0lSUChhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBkID0gc3RhY2sucG9wKCkgLyA2NDtcbiAgICB2YXIgcGkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcCA9IHN0YXRlLnoxW3BpXTtcbiAgICB2YXIgcnAwID0gc3RhdGUuejBbc3RhdGUucnAwXTtcbiAgICB2YXIgZnYgPSBzdGF0ZS5mdjtcbiAgICB2YXIgcHYgPSBzdGF0ZS5wdjtcblxuICAgIGZ2LnNldFJlbGF0aXZlKHAsIHJwMCwgZCwgcHYpO1xuICAgIGZ2LnRvdWNoKHApO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01TSVJQWycgKyBhICsgJ10nLCBkLCBwaSk7IH1cblxuICAgIHN0YXRlLnJwMSA9IHN0YXRlLnJwMDtcbiAgICBzdGF0ZS5ycDIgPSBwaTtcbiAgICBpZiAoYSkgeyBzdGF0ZS5ycDAgPSBwaTsgfVxufVxuXG4vLyBBTElHTlJQW10gQWxpZ24gdG8gcmVmZXJlbmNlIHBvaW50LlxuLy8gMHgzQ1xuZnVuY3Rpb24gQUxJR05SUChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBycDBpID0gc3RhdGUucnAwO1xuICAgIHZhciBycDAgPSBzdGF0ZS56MFtycDBpXTtcbiAgICB2YXIgbG9vcCA9IHN0YXRlLmxvb3A7XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG4gICAgdmFyIHoxID0gc3RhdGUuejE7XG5cbiAgICB3aGlsZSAobG9vcC0tKSB7XG4gICAgICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgcCA9IHoxW3BpXTtcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgc3RhdGUuc3RlcCxcbiAgICAgICAgICAgICAgICAoc3RhdGUubG9vcCA+IDEgPyAnbG9vcCAnICsgKHN0YXRlLmxvb3AgLSBsb29wKSArICc6ICcgOiAnJykgK1xuICAgICAgICAgICAgICAgICdBTElHTlJQW10nLCBwaVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ2LnNldFJlbGF0aXZlKHAsIHJwMCwgMCwgcHYpO1xuICAgICAgICBmdi50b3VjaChwKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5sb29wID0gMTtcbn1cblxuLy8gUlRHW10gUm91bmQgVG8gRG91YmxlIEdyaWRcbi8vIDB4M0RcbmZ1bmN0aW9uIFJUREcoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUlRER1tdJyk7IH1cblxuICAgIHN0YXRlLnJvdW5kID0gcm91bmRUb0RvdWJsZUdyaWQ7XG59XG5cbi8vIE1JQVBbYV0gTW92ZSBJbmRpcmVjdCBBYnNvbHV0ZSBQb2ludFxuLy8gMHgzRS0weDNGXG5mdW5jdGlvbiBNSUFQKHJvdW5kLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAgPSBzdGF0ZS56MFtwaV07XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG4gICAgdmFyIGN2ID0gc3RhdGUuY3Z0W25dO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBzdGF0ZS5zdGVwLFxuICAgICAgICAgICAgJ01JQVBbJyArIHJvdW5kICsgJ10nLFxuICAgICAgICAgICAgbiwgJygnLCBjdiwgJyknLCBwaVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHZhciBkID0gcHYuZGlzdGFuY2UocCwgSFBaZXJvKTtcblxuICAgIGlmIChyb3VuZCkge1xuICAgICAgICBpZiAoTWF0aC5hYnMoZCAtIGN2KSA8IHN0YXRlLmN2Q3V0SW4pIHsgZCA9IGN2OyB9XG5cbiAgICAgICAgZCA9IHN0YXRlLnJvdW5kKGQpO1xuICAgIH1cblxuICAgIGZ2LnNldFJlbGF0aXZlKHAsIEhQWmVybywgZCwgcHYpO1xuXG4gICAgaWYgKHN0YXRlLnpwMCA9PT0gMCkge1xuICAgICAgICBwLnhvID0gcC54O1xuICAgICAgICBwLnlvID0gcC55O1xuICAgIH1cblxuICAgIGZ2LnRvdWNoKHApO1xuXG4gICAgc3RhdGUucnAwID0gc3RhdGUucnAxID0gcGk7XG59XG5cbi8vIE5QVVNCW10gUFVTSCBOIEJ5dGVzXG4vLyAweDQwXG5mdW5jdGlvbiBOUFVTSEIoc3RhdGUpIHtcbiAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG4gICAgdmFyIGlwID0gc3RhdGUuaXA7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG5cbiAgICB2YXIgbiA9IHByb2dbKytpcF07XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTlBVU0hCW10nLCBuKTsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHsgc3RhY2sucHVzaChwcm9nWysraXBdKTsgfVxuXG4gICAgc3RhdGUuaXAgPSBpcDtcbn1cblxuLy8gTlBVU0hXW10gUFVTSCBOIFdvcmRzXG4vLyAweDQxXG5mdW5jdGlvbiBOUFVTSFcoc3RhdGUpIHtcbiAgICB2YXIgaXAgPSBzdGF0ZS5pcDtcbiAgICB2YXIgcHJvZyA9IHN0YXRlLnByb2c7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBwcm9nWysraXBdO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05QVVNIV1tdJywgbik7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gKHByb2dbKytpcF0gPDwgOCkgfCBwcm9nWysraXBdO1xuICAgICAgICBpZiAodyAmIDB4ODAwMCkgeyB3ID0gLSgodyBeIDB4ZmZmZikgKyAxKTsgfVxuICAgICAgICBzdGFjay5wdXNoKHcpO1xuICAgIH1cblxuICAgIHN0YXRlLmlwID0gaXA7XG59XG5cbi8vIFdTW10gV3JpdGUgU3RvcmVcbi8vIDB4NDJcbmZ1bmN0aW9uIFdTKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHN0b3JlID0gc3RhdGUuc3RvcmU7XG5cbiAgICBpZiAoIXN0b3JlKSB7IHN0b3JlID0gc3RhdGUuc3RvcmUgPSBbXTsgfVxuXG4gICAgdmFyIHYgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1dTJywgdiwgbCk7IH1cblxuICAgIHN0b3JlW2xdID0gdjtcbn1cblxuLy8gUlNbXSBSZWFkIFN0b3JlXG4vLyAweDQzXG5mdW5jdGlvbiBSUyhzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBzdG9yZSA9IHN0YXRlLnN0b3JlO1xuXG4gICAgdmFyIGwgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdSUycsIGwpOyB9XG5cbiAgICB2YXIgdiA9IChzdG9yZSAmJiBzdG9yZVtsXSkgfHwgMDtcblxuICAgIHN0YWNrLnB1c2godik7XG59XG5cbi8vIFdDVlRQW10gV3JpdGUgQ29udHJvbCBWYWx1ZSBUYWJsZSBpbiBQaXhlbCB1bml0c1xuLy8gMHg0NFxuZnVuY3Rpb24gV0NWVFAoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcblxuICAgIHZhciB2ID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGwgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdXQ1ZUUCcsIHYsIGwpOyB9XG5cbiAgICBzdGF0ZS5jdnRbbF0gPSB2IC8gMHg0MDtcbn1cblxuLy8gUkNWVFtdIFJlYWQgQ29udHJvbCBWYWx1ZSBUYWJsZSBlbnRyeVxuLy8gMHg0NVxuZnVuY3Rpb24gUkNWVChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBjdnRlID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUkNWVCcsIGN2dGUpOyB9XG5cbiAgICBzdGFjay5wdXNoKHN0YXRlLmN2dFtjdnRlXSAqIDB4NDApO1xufVxuXG4vLyBHQ1tdIEdldCBDb29yZGluYXRlIHByb2plY3RlZCBvbnRvIHRoZSBwcm9qZWN0aW9uIHZlY3RvclxuLy8gMHg0Ni0weDQ3XG5mdW5jdGlvbiBHQyhhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwID0gc3RhdGUuejJbcGldO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dDWycgKyBhICsgJ10nLCBwaSk7IH1cblxuICAgIHN0YWNrLnB1c2goc3RhdGUuZHB2LmRpc3RhbmNlKHAsIEhQWmVybywgYSwgZmFsc2UpICogMHg0MCk7XG59XG5cbi8vIE1EW2FdIE1lYXN1cmUgRGlzdGFuY2Vcbi8vIDB4NDktMHg0QVxuZnVuY3Rpb24gTUQoYSwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgcGkyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHBpMSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBwMiA9IHN0YXRlLnoxW3BpMl07XG4gICAgdmFyIHAxID0gc3RhdGUuejBbcGkxXTtcbiAgICB2YXIgZCA9IHN0YXRlLmRwdi5kaXN0YW5jZShwMSwgcDIsIGEsIGEpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01EWycgKyBhICsgJ10nLCBwaTIsIHBpMSwgJy0+JywgZCk7IH1cblxuICAgIHN0YXRlLnN0YWNrLnB1c2goTWF0aC5yb3VuZChkICogNjQpKTtcbn1cblxuLy8gTVBQRU1bXSBNZWFzdXJlIFBpeGVscyBQZXIgRU1cbi8vIDB4NEJcbmZ1bmN0aW9uIE1QUEVNKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01QUEVNW10nKTsgfVxuICAgIHN0YXRlLnN0YWNrLnB1c2goc3RhdGUucHBlbSk7XG59XG5cbi8vIEZMSVBPTltdIHNldCB0aGUgYXV0byBGTElQIEJvb2xlYW4gdG8gT05cbi8vIDB4NERcbmZ1bmN0aW9uIEZMSVBPTihzdGF0ZSkge1xuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdGTElQT05bXScpOyB9XG4gICAgc3RhdGUuYXV0b0ZsaXAgPSB0cnVlO1xufVxuXG4vLyBMVFtdIExlc3MgVGhhblxuLy8gMHg1MFxuZnVuY3Rpb24gTFQoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdMVFtdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChlMSA8IGUyID8gMSA6IDApO1xufVxuXG4vLyBMVEVRW10gTGVzcyBUaGFuIG9yIEVRdWFsXG4vLyAweDUzXG5mdW5jdGlvbiBMVEVRKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTFRFUVtdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChlMSA8PSBlMiA/IDEgOiAwKTtcbn1cblxuLy8gR1RFUVtdIEdyZWF0ZXIgVGhhblxuLy8gMHg1MlxuZnVuY3Rpb24gR1Qoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdHVFtdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChlMSA+IGUyID8gMSA6IDApO1xufVxuXG4vLyBHVEVRW10gR3JlYXRlciBUaGFuIG9yIEVRdWFsXG4vLyAweDUzXG5mdW5jdGlvbiBHVEVRKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnR1RFUVtdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChlMSA+PSBlMiA/IDEgOiAwKTtcbn1cblxuLy8gRVFbXSBFUXVhbFxuLy8gMHg1NFxuZnVuY3Rpb24gRVEoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgZTIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgZTEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdFUVtdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChlMiA9PT0gZTEgPyAxIDogMCk7XG59XG5cbi8vIE5FUVtdIE5vdCBFUXVhbFxuLy8gMHg1NVxuZnVuY3Rpb24gTkVRKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTkVRW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKGUyICE9PSBlMSA/IDEgOiAwKTtcbn1cblxuLy8gT0REW10gT0REXG4vLyAweDU2XG5mdW5jdGlvbiBPREQoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ09ERFtdJywgbik7IH1cblxuICAgIHN0YWNrLnB1c2goTWF0aC50cnVuYyhuKSAlIDIgPyAxIDogMCk7XG59XG5cbi8vIEVWRU5bXSBFVkVOXG4vLyAweDU3XG5mdW5jdGlvbiBFVkVOKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdFVkVOW10nLCBuKTsgfVxuXG4gICAgc3RhY2sucHVzaChNYXRoLnRydW5jKG4pICUgMiA/IDAgOiAxKTtcbn1cblxuLy8gSUZbXSBJRiB0ZXN0XG4vLyAweDU4XG5mdW5jdGlvbiBJRihzdGF0ZSkge1xuICAgIHZhciB0ZXN0ID0gc3RhdGUuc3RhY2sucG9wKCk7XG4gICAgdmFyIGlucztcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdJRltdJywgdGVzdCk7IH1cblxuICAgIC8vIGlmIHRlc3QgaXMgdHJ1ZSBpdCBqdXN0IGNvbnRpbnVlc1xuICAgIC8vIGlmIG5vdCB0aGUgaXAgaXMgc2tpcHBlZCB1bnRpbCBtYXRjaGluZyBFTFNFIG9yIEVJRlxuICAgIGlmICghdGVzdCkge1xuICAgICAgICBza2lwKHN0YXRlLCB0cnVlKTtcblxuICAgICAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCBpbnMgPT09IDB4MUIgPyAnRUxTRVtdJyA6ICdFSUZbXScpOyB9XG4gICAgfVxufVxuXG4vLyBFSUZbXSBFbmQgSUZcbi8vIDB4NTlcbmZ1bmN0aW9uIEVJRihzdGF0ZSkge1xuICAgIC8vIHRoaXMgY2FuIGJlIHJlYWNoZWQgbm9ybWFsbHkgd2hlblxuICAgIC8vIGV4ZWN1dGluZyBhbiBlbHNlIGJyYW5jaC5cbiAgICAvLyAtPiBqdXN0IGlnbm9yZSBpdFxuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0VJRltdJyk7IH1cbn1cblxuLy8gQU5EW10gbG9naWNhbCBBTkRcbi8vIDB4NUFcbmZ1bmN0aW9uIEFORChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0FORFtdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChlMiAmJiBlMSA/IDEgOiAwKTtcbn1cblxuLy8gT1JbXSBsb2dpY2FsIE9SXG4vLyAweDVCXG5mdW5jdGlvbiBPUihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ09SW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKGUyIHx8IGUxID8gMSA6IDApO1xufVxuXG4vLyBOT1RbXSBsb2dpY2FsIE5PVFxuLy8gMHg1Q1xuZnVuY3Rpb24gTk9UKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdOT1RbXScsIGUpOyB9XG5cbiAgICBzdGFjay5wdXNoKGUgPyAwIDogMSk7XG59XG5cbi8vIERFTFRBUDFbXSBERUxUQSBleGNlcHRpb24gUDFcbi8vIERFTFRBUDJbXSBERUxUQSBleGNlcHRpb24gUDJcbi8vIERFTFRBUDNbXSBERUxUQSBleGNlcHRpb24gUDNcbi8vIDB4NUQsIDB4NzEsIDB4NzJcbmZ1bmN0aW9uIERFTFRBUDEyMyhiLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUucHY7XG4gICAgdmFyIHBwZW0gPSBzdGF0ZS5wcGVtO1xuICAgIHZhciBiYXNlID0gc3RhdGUuZGVsdGFCYXNlICsgKGIgLSAxKSAqIDE2O1xuICAgIHZhciBkcyA9IHN0YXRlLmRlbHRhU2hpZnQ7XG4gICAgdmFyIHowID0gc3RhdGUuejA7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnREVMVEFQWycgKyBiICsgJ10nLCBuLCBzdGFjayk7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBwaSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgYXJnID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZhciBhcHBlbSA9IGJhc2UgKyAoKGFyZyAmIDB4RjApID4+IDQpO1xuICAgICAgICBpZiAoYXBwZW0gIT09IHBwZW0pIHsgY29udGludWU7IH1cblxuICAgICAgICB2YXIgbWFnID0gKGFyZyAmIDB4MEYpIC0gODtcbiAgICAgICAgaWYgKG1hZyA+PSAwKSB7IG1hZysrOyB9XG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdERUxUQVBGSVgnLCBwaSwgJ2J5JywgbWFnICogZHMpOyB9XG5cbiAgICAgICAgdmFyIHAgPSB6MFtwaV07XG4gICAgICAgIGZ2LnNldFJlbGF0aXZlKHAsIHAsIG1hZyAqIGRzLCBwdik7XG4gICAgfVxufVxuXG4vLyBTREJbXSBTZXQgRGVsdGEgQmFzZSBpbiB0aGUgZ3JhcGhpY3Mgc3RhdGVcbi8vIDB4NUVcbmZ1bmN0aW9uIFNEQihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0RCW10nLCBuKTsgfVxuXG4gICAgc3RhdGUuZGVsdGFCYXNlID0gbjtcbn1cblxuLy8gU0RTW10gU2V0IERlbHRhIFNoaWZ0IGluIHRoZSBncmFwaGljcyBzdGF0ZVxuLy8gMHg1RlxuZnVuY3Rpb24gU0RTKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTRFNbXScsIG4pOyB9XG5cbiAgICBzdGF0ZS5kZWx0YVNoaWZ0ID0gTWF0aC5wb3coMC41LCBuKTtcbn1cblxuLy8gQUREW10gQUREXG4vLyAweDYwXG5mdW5jdGlvbiBBREQoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbjIgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgbjEgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdBRERbXScsIG4yLCBuMSk7IH1cblxuICAgIHN0YWNrLnB1c2gobjEgKyBuMik7XG59XG5cbi8vIFNVQltdIFNVQlxuLy8gMHg2MVxuZnVuY3Rpb24gU1VCKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4yID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIG4xID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU1VCW10nLCBuMiwgbjEpOyB9XG5cbiAgICBzdGFjay5wdXNoKG4xIC0gbjIpO1xufVxuXG4vLyBESVZbXSBESVZcbi8vIDB4NjJcbmZ1bmN0aW9uIERJVihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBuMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0RJVltdJywgbjIsIG4xKTsgfVxuXG4gICAgc3RhY2sucHVzaChuMSAqIDY0IC8gbjIpO1xufVxuXG4vLyBNVUxbXSBNVUxcbi8vIDB4NjNcbmZ1bmN0aW9uIE1VTChzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBuMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01VTFtdJywgbjIsIG4xKTsgfVxuXG4gICAgc3RhY2sucHVzaChuMSAqIG4yIC8gNjQpO1xufVxuXG4vLyBBQlNbXSBBQlNvbHV0ZSB2YWx1ZVxuLy8gMHg2NFxuZnVuY3Rpb24gQUJTKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdBQlNbXScsIG4pOyB9XG5cbiAgICBzdGFjay5wdXNoKE1hdGguYWJzKG4pKTtcbn1cblxuLy8gTkVHW10gTkVHYXRlXG4vLyAweDY1XG5mdW5jdGlvbiBORUcoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ05FR1tdJywgbik7IH1cblxuICAgIHN0YWNrLnB1c2goLW4pO1xufVxuXG4vLyBGTE9PUltdIEZMT09SXG4vLyAweDY2XG5mdW5jdGlvbiBGTE9PUihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBuID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnRkxPT1JbXScsIG4pOyB9XG5cbiAgICBzdGFjay5wdXNoKE1hdGguZmxvb3IobiAvIDB4NDApICogMHg0MCk7XG59XG5cbi8vIENFSUxJTkdbXSBDRUlMSU5HXG4vLyAweDY3XG5mdW5jdGlvbiBDRUlMSU5HKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdDRUlMSU5HW10nLCBuKTsgfVxuXG4gICAgc3RhY2sucHVzaChNYXRoLmNlaWwobiAvIDB4NDApICogMHg0MCk7XG59XG5cbi8vIFJPVU5EW2FiXSBST1VORCB2YWx1ZVxuLy8gMHg2OC0weDZCXG5mdW5jdGlvbiBST1VORChkdCwgc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgbiA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JPVU5EW10nKTsgfVxuXG4gICAgc3RhY2sucHVzaChzdGF0ZS5yb3VuZChuIC8gMHg0MCkgKiAweDQwKTtcbn1cblxuLy8gV0NWVEZbXSBXcml0ZSBDb250cm9sIFZhbHVlIFRhYmxlIGluIEZ1bml0c1xuLy8gMHg3MFxuZnVuY3Rpb24gV0NWVEYoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgdiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBsID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnV0NWVEZbXScsIHYsIGwpOyB9XG5cbiAgICBzdGF0ZS5jdnRbbF0gPSB2ICogc3RhdGUucHBlbSAvIHN0YXRlLmZvbnQudW5pdHNQZXJFbTtcbn1cblxuLy8gREVMVEFDMVtdIERFTFRBIGV4Y2VwdGlvbiBDMVxuLy8gREVMVEFDMltdIERFTFRBIGV4Y2VwdGlvbiBDMlxuLy8gREVMVEFDM1tdIERFTFRBIGV4Y2VwdGlvbiBDM1xuLy8gMHg3MywgMHg3NCwgMHg3NVxuZnVuY3Rpb24gREVMVEFDMTIzKGIsIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIG4gPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcHBlbSA9IHN0YXRlLnBwZW07XG4gICAgdmFyIGJhc2UgPSBzdGF0ZS5kZWx0YUJhc2UgKyAoYiAtIDEpICogMTY7XG4gICAgdmFyIGRzID0gc3RhdGUuZGVsdGFTaGlmdDtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdERUxUQUNbJyArIGIgKyAnXScsIG4sIHN0YWNrKTsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGMgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIGFyZyA9IHN0YWNrLnBvcCgpO1xuICAgICAgICB2YXIgYXBwZW0gPSBiYXNlICsgKChhcmcgJiAweEYwKSA+PiA0KTtcbiAgICAgICAgaWYgKGFwcGVtICE9PSBwcGVtKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgdmFyIG1hZyA9IChhcmcgJiAweDBGKSAtIDg7XG4gICAgICAgIGlmIChtYWcgPj0gMCkgeyBtYWcrKzsgfVxuXG4gICAgICAgIHZhciBkZWx0YSA9IG1hZyAqIGRzO1xuXG4gICAgICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdERUxUQUNGSVgnLCBjLCAnYnknLCBkZWx0YSk7IH1cblxuICAgICAgICBzdGF0ZS5jdnRbY10gKz0gZGVsdGE7XG4gICAgfVxufVxuXG4vLyBTUk9VTkRbXSBTdXBlciBST1VORFxuLy8gMHg3NlxuZnVuY3Rpb24gU1JPVU5EKHN0YXRlKSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdTUk9VTkRbXScsIG4pOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kU3VwZXI7XG5cbiAgICB2YXIgcGVyaW9kO1xuXG4gICAgc3dpdGNoIChuICYgMHhDMCkge1xuICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICBwZXJpb2QgPSAwLjU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDQwOlxuICAgICAgICAgICAgcGVyaW9kID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4ODA6XG4gICAgICAgICAgICBwZXJpb2QgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgU1JPVU5EIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgc3RhdGUuc3JQZXJpb2QgPSBwZXJpb2Q7XG5cbiAgICBzd2l0Y2ggKG4gJiAweDMwKSB7XG4gICAgICAgIGNhc2UgMHgwMDpcbiAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgxMDpcbiAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwLjI1ICogcGVyaW9kO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgyMDpcbiAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwLjUgICogcGVyaW9kO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgzMDpcbiAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwLjc1ICogcGVyaW9kO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignaW52YWxpZCBTUk9VTkQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICBuICY9IDB4MEY7XG5cbiAgICBpZiAobiA9PT0gMCkgeyBzdGF0ZS5zclRocmVzaG9sZCA9IDA7IH1cbiAgICBlbHNlIHsgc3RhdGUuc3JUaHJlc2hvbGQgPSAobiAvIDggLSAwLjUpICogcGVyaW9kOyB9XG59XG5cbi8vIFM0NVJPVU5EW10gU3VwZXIgUk9VTkQgNDUgZGVncmVlc1xuLy8gMHg3N1xuZnVuY3Rpb24gUzQ1Uk9VTkQoc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1M0NVJPVU5EW10nLCBuKTsgfVxuXG4gICAgc3RhdGUucm91bmQgPSByb3VuZFN1cGVyO1xuXG4gICAgdmFyIHBlcmlvZDtcblxuICAgIHN3aXRjaCAobiAmIDB4QzApIHtcbiAgICAgICAgY2FzZSAweDAwOlxuICAgICAgICAgICAgcGVyaW9kID0gTWF0aC5zcXJ0KDIpIC8gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDB4NDA6XG4gICAgICAgICAgICBwZXJpb2QgPSBNYXRoLnNxcnQoMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAweDgwOlxuICAgICAgICAgICAgcGVyaW9kID0gMiAqIE1hdGguc3FydCgyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFM0NVJPVU5EIHZhbHVlJyk7XG4gICAgfVxuXG4gICAgc3RhdGUuc3JQZXJpb2QgPSBwZXJpb2Q7XG5cbiAgICBzd2l0Y2ggKG4gJiAweDMwKSB7XG4gICAgICAgIGNhc2UgMHgwMDpcbiAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgxMDpcbiAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwLjI1ICogcGVyaW9kO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgyMDpcbiAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwLjUgICogcGVyaW9kO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMHgzMDpcbiAgICAgICAgICAgIHN0YXRlLnNyUGhhc2UgPSAwLjc1ICogcGVyaW9kO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUzQ1Uk9VTkQgdmFsdWUnKTtcbiAgICB9XG5cbiAgICBuICY9IDB4MEY7XG5cbiAgICBpZiAobiA9PT0gMCkgeyBzdGF0ZS5zclRocmVzaG9sZCA9IDA7IH1cbiAgICBlbHNlIHsgc3RhdGUuc3JUaHJlc2hvbGQgPSAobiAvIDggLSAwLjUpICogcGVyaW9kOyB9XG59XG5cbi8vIFJPRkZbXSBSb3VuZCBPZmZcbi8vIDB4N0FcbmZ1bmN0aW9uIFJPRkYoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUk9GRltdJyk7IH1cblxuICAgIHN0YXRlLnJvdW5kID0gcm91bmRPZmY7XG59XG5cbi8vIFJVVEdbXSBSb3VuZCBVcCBUbyBHcmlkXG4vLyAweDdDXG5mdW5jdGlvbiBSVVRHKHN0YXRlKSB7XG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1JVVEdbXScpOyB9XG5cbiAgICBzdGF0ZS5yb3VuZCA9IHJvdW5kVXBUb0dyaWQ7XG59XG5cbi8vIFJEVEdbXSBSb3VuZCBEb3duIFRvIEdyaWRcbi8vIDB4N0RcbmZ1bmN0aW9uIFJEVEcoc3RhdGUpIHtcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnUkRUR1tdJyk7IH1cblxuICAgIHN0YXRlLnJvdW5kID0gcm91bmREb3duVG9HcmlkO1xufVxuXG4vLyBTQ0FOQ1RSTFtdIFNDQU4gY29udmVyc2lvbiBDb25UUm9MXG4vLyAweDg1XG5mdW5jdGlvbiBTQ0FOQ1RSTChzdGF0ZSkge1xuICAgIHZhciBuID0gc3RhdGUuc3RhY2sucG9wKCk7XG5cbiAgICAvLyBpZ25vcmVkIGJ5IG9wZW50eXBlLmpzXG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0NBTkNUUkxbXScsIG4pOyB9XG59XG5cbi8vIFNEUFZUTFthXSBTZXQgRHVhbCBQcm9qZWN0aW9uIFZlY3RvciBUbyBMaW5lXG4vLyAweDg2LTB4ODdcbmZ1bmN0aW9uIFNEUFZUTChhLCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBwMmkgPSBzdGFjay5wb3AoKTtcbiAgICB2YXIgcDFpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHAyID0gc3RhdGUuejJbcDJpXTtcbiAgICB2YXIgcDEgPSBzdGF0ZS56MVtwMWldO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1NEUFZUTFsnICsgYSArICddJywgcDJpLCBwMWkpOyB9XG5cbiAgICB2YXIgZHg7XG4gICAgdmFyIGR5O1xuXG4gICAgaWYgKCFhKSB7XG4gICAgICAgIGR4ID0gcDEueCAtIHAyLng7XG4gICAgICAgIGR5ID0gcDEueSAtIHAyLnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZHggPSBwMi55IC0gcDEueTtcbiAgICAgICAgZHkgPSBwMS54IC0gcDIueDtcbiAgICB9XG5cbiAgICBzdGF0ZS5kcHYgPSBnZXRVbml0VmVjdG9yKGR4LCBkeSk7XG59XG5cbi8vIEdFVElORk9bXSBHRVQgSU5GT3JtYXRpb25cbi8vIDB4ODhcbmZ1bmN0aW9uIEdFVElORk8oc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgc2VsID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHIgPSAwO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0dFVElORk9bXScsIHNlbCk7IH1cblxuICAgIC8vIHYzNSBhcyBpbiBubyBzdWJwaXhlbCBoaW50aW5nXG4gICAgaWYgKHNlbCAmIDB4MDEpIHsgciA9IDM1OyB9XG5cbiAgICAvLyBUT0RPIHJvdGF0aW9uIGFuZCBzdHJldGNoIGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkXG4gICAgLy8gYW5kIHRodXMgdGhvc2UgR0VUSU5GTyBhcmUgYWx3YXlzIDAuXG5cbiAgICAvLyBvcGVudHlwZS5qcyBpcyBhbHdheXMgZ3JheSBzY2FsaW5nXG4gICAgaWYgKHNlbCAmIDB4MjApIHsgciB8PSAweDEwMDA7IH1cblxuICAgIHN0YWNrLnB1c2gocik7XG59XG5cbi8vIFJPTExbXSBST0xMIHRoZSB0b3AgdGhyZWUgc3RhY2sgZWxlbWVudHNcbi8vIDB4OEFcbmZ1bmN0aW9uIFJPTEwoc3RhdGUpIHtcbiAgICB2YXIgc3RhY2sgPSBzdGF0ZS5zdGFjaztcbiAgICB2YXIgYSA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBiID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGMgPSBzdGFjay5wb3AoKTtcblxuICAgIGlmIChleHBvcnRzLkRFQlVHKSB7IGNvbnNvbGUubG9nKHN0YXRlLnN0ZXAsICdST0xMW10nKTsgfVxuXG4gICAgc3RhY2sucHVzaChiKTtcbiAgICBzdGFjay5wdXNoKGEpO1xuICAgIHN0YWNrLnB1c2goYyk7XG59XG5cbi8vIE1BWFtdIE1BWGltdW0gb2YgdG9wIHR3byBzdGFjayBlbGVtZW50c1xuLy8gMHg4QlxuZnVuY3Rpb24gTUFYKHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIGUyID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIGUxID0gc3RhY2sucG9wKCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnTUFYW10nLCBlMiwgZTEpOyB9XG5cbiAgICBzdGFjay5wdXNoKE1hdGgubWF4KGUxLCBlMikpO1xufVxuXG4vLyBNSU5bXSBNSU5pbXVtIG9mIHRvcCB0d28gc3RhY2sgZWxlbWVudHNcbi8vIDB4OENcbmZ1bmN0aW9uIE1JTihzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBlMiA9IHN0YWNrLnBvcCgpO1xuICAgIHZhciBlMSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ01JTltdJywgZTIsIGUxKTsgfVxuXG4gICAgc3RhY2sucHVzaChNYXRoLm1pbihlMSwgZTIpKTtcbn1cblxuLy8gU0NBTlRZUEVbXSBTQ0FOVFlQRVxuLy8gMHg4RFxuZnVuY3Rpb24gU0NBTlRZUEUoc3RhdGUpIHtcbiAgICB2YXIgbiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuICAgIC8vIGlnbm9yZWQgYnkgb3BlbnR5cGUuanNcbiAgICBpZiAoZXhwb3J0cy5ERUJVRykgeyBjb25zb2xlLmxvZyhzdGF0ZS5zdGVwLCAnU0NBTlRZUEVbXScsIG4pOyB9XG59XG5cbi8vIElOU1RDVFJMW10gSU5TVENUUkxcbi8vIDB4OERcbmZ1bmN0aW9uIElOU1RDVFJMKHN0YXRlKSB7XG4gICAgdmFyIHMgPSBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgICB2YXIgdiA9IHN0YXRlLnN0YWNrLnBvcCgpO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ0lOU1RDVFJMW10nLCBzLCB2KTsgfVxuXG4gICAgc3dpdGNoIChzKSB7XG4gICAgICAgIGNhc2UgMSA6IHN0YXRlLmluaGliaXRHcmlkRml0ID0gISF2OyByZXR1cm47XG4gICAgICAgIGNhc2UgMiA6IHN0YXRlLmlnbm9yZUN2dCA9ICEhdjsgcmV0dXJuO1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgSU5TVENUUkxbXSBzZWxlY3RvcicpO1xuICAgIH1cbn1cblxuLy8gUFVTSEJbYWJjXSBQVVNIIEJ5dGVzXG4vLyAweEIwLTB4QjdcbmZ1bmN0aW9uIFBVU0hCKG4sIHN0YXRlKSB7XG4gICAgdmFyIHN0YWNrID0gc3RhdGUuc3RhY2s7XG4gICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIHZhciBpcCA9IHN0YXRlLmlwO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuc3RlcCwgJ1BVU0hCWycgKyBuICsgJ10nKTsgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHsgc3RhY2sucHVzaChwcm9nWysraXBdKTsgfVxuXG4gICAgc3RhdGUuaXAgPSBpcDtcbn1cblxuLy8gUFVTSFdbYWJjXSBQVVNIIFdvcmRzXG4vLyAweEI4LTB4QkZcbmZ1bmN0aW9uIFBVU0hXKG4sIHN0YXRlKSB7XG4gICAgdmFyIGlwID0gc3RhdGUuaXA7XG4gICAgdmFyIHByb2cgPSBzdGF0ZS5wcm9nO1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuXG4gICAgaWYgKGV4cG9ydHMuREVCVUcpIHsgY29uc29sZS5sb2coc3RhdGUuaXAsICdQVVNIV1snICsgbiArICddJyk7IH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gKHByb2dbKytpcF0gPDwgOCkgfCBwcm9nWysraXBdO1xuICAgICAgICBpZiAodyAmIDB4ODAwMCkgeyB3ID0gLSgodyBeIDB4ZmZmZikgKyAxKTsgfVxuICAgICAgICBzdGFjay5wdXNoKHcpO1xuICAgIH1cblxuICAgIHN0YXRlLmlwID0gaXA7XG59XG5cbi8vIE1EUlBbYWJjZGVdIE1vdmUgRGlyZWN0IFJlbGF0aXZlIFBvaW50XG4vLyAweEQwLTB4RUZcbi8vIChpZiBpbmRpcmVjdCBpcyAwKVxuLy9cbi8vIGFuZFxuLy9cbi8vIE1JUlBbYWJjZGVdIE1vdmUgSW5kaXJlY3QgUmVsYXRpdmUgUG9pbnRcbi8vIDB4RTAtMHhGRlxuLy8gKGlmIGluZGlyZWN0IGlzIDEpXG5cbmZ1bmN0aW9uIE1EUlBfTUlSUChpbmRpcmVjdCwgc2V0UnAwLCBrZWVwRCwgcm8sIGR0LCBzdGF0ZSkge1xuICAgIHZhciBzdGFjayA9IHN0YXRlLnN0YWNrO1xuICAgIHZhciBjdnRlID0gaW5kaXJlY3QgJiYgc3RhY2sucG9wKCk7XG4gICAgdmFyIHBpID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHJwMGkgPSBzdGF0ZS5ycDA7XG4gICAgdmFyIHJwID0gc3RhdGUuejBbcnAwaV07XG4gICAgdmFyIHAgPSBzdGF0ZS56MVtwaV07XG5cbiAgICB2YXIgbWQgPSBzdGF0ZS5taW5EaXM7XG4gICAgdmFyIGZ2ID0gc3RhdGUuZnY7XG4gICAgdmFyIHB2ID0gc3RhdGUuZHB2O1xuICAgIHZhciBvZDsgLy8gb3JpZ2luYWwgZGlzdGFuY2VcbiAgICB2YXIgZDsgLy8gbW92aW5nIGRpc3RhbmNlXG4gICAgdmFyIHNpZ247IC8vIHNpZ24gb2YgZGlzdGFuY2VcbiAgICB2YXIgY3Y7XG5cbiAgICBkID0gb2QgPSBwdi5kaXN0YW5jZShwLCBycCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgc2lnbiA9IGQgPj0gMCA/IDEgOiAtMTsgLy8gTWF0aC5zaWduIHdvdWxkIGJlIDAgaW4gY2FzZSBvZiAwXG5cbiAgICAvLyBUT0RPIGNvbnNpZGVyIGF1dG9GbGlwXG4gICAgZCA9IE1hdGguYWJzKGQpO1xuXG4gICAgaWYgKGluZGlyZWN0KSB7XG4gICAgICAgIGN2ID0gc3RhdGUuY3Z0W2N2dGVdO1xuXG4gICAgICAgIGlmIChybyAmJiBNYXRoLmFicyhkIC0gY3YpIDwgc3RhdGUuY3ZDdXRJbikgeyBkID0gY3Y7IH1cbiAgICB9XG5cbiAgICBpZiAoa2VlcEQgJiYgZCA8IG1kKSB7IGQgPSBtZDsgfVxuXG4gICAgaWYgKHJvKSB7IGQgPSBzdGF0ZS5yb3VuZChkKTsgfVxuXG4gICAgZnYuc2V0UmVsYXRpdmUocCwgcnAsIHNpZ24gKiBkLCBwdik7XG4gICAgZnYudG91Y2gocCk7XG5cbiAgICBpZiAoZXhwb3J0cy5ERUJVRykge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIHN0YXRlLnN0ZXAsXG4gICAgICAgICAgICAoaW5kaXJlY3QgPyAnTUlSUFsnIDogJ01EUlBbJykgK1xuICAgICAgICAgICAgKHNldFJwMCA/ICdNJyA6ICdtJykgK1xuICAgICAgICAgICAgKGtlZXBEID8gJz4nIDogJ18nKSArXG4gICAgICAgICAgICAocm8gPyAnUicgOiAnXycpICtcbiAgICAgICAgICAgIChkdCA9PT0gMCA/ICdHcicgOiAoZHQgPT09IDEgPyAnQmwnIDogKGR0ID09PSAyID8gJ1doJyA6ICcnKSkpICtcbiAgICAgICAgICAgICddJyxcbiAgICAgICAgICAgIGluZGlyZWN0ID9cbiAgICAgICAgICAgICAgICBjdnRlICsgJygnICsgc3RhdGUuY3Z0W2N2dGVdICsgJywnICsgIGN2ICsgJyknIDpcbiAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgIHBpLFxuICAgICAgICAgICAgJyhkID0nLCBvZCwgJy0+Jywgc2lnbiAqIGQsICcpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXRlLnJwMSA9IHN0YXRlLnJwMDtcbiAgICBzdGF0ZS5ycDIgPSBwaTtcbiAgICBpZiAoc2V0UnAwKSB7IHN0YXRlLnJwMCA9IHBpOyB9XG59XG5cbi8qXG4qIFRoZSBpbnN0cnVjdGlvbiB0YWJsZS5cbiovXG5pbnN0cnVjdGlvblRhYmxlID0gW1xuICAgIC8qIDB4MDAgKi8gU1ZUQ0EuYmluZCh1bmRlZmluZWQsIHlVbml0VmVjdG9yKSxcbiAgICAvKiAweDAxICovIFNWVENBLmJpbmQodW5kZWZpbmVkLCB4VW5pdFZlY3RvciksXG4gICAgLyogMHgwMiAqLyBTUFZUQ0EuYmluZCh1bmRlZmluZWQsIHlVbml0VmVjdG9yKSxcbiAgICAvKiAweDAzICovIFNQVlRDQS5iaW5kKHVuZGVmaW5lZCwgeFVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MDQgKi8gU0ZWVENBLmJpbmQodW5kZWZpbmVkLCB5VW5pdFZlY3RvciksXG4gICAgLyogMHgwNSAqLyBTRlZUQ0EuYmluZCh1bmRlZmluZWQsIHhVbml0VmVjdG9yKSxcbiAgICAvKiAweDA2ICovIFNQVlRMLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDA3ICovIFNQVlRMLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDA4ICovIFNGVlRMLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDA5ICovIFNGVlRMLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDBBICovIFNQVkZTLFxuICAgIC8qIDB4MEIgKi8gU0ZWRlMsXG4gICAgLyogMHgwQyAqLyBHUFYsXG4gICAgLyogMHgwRCAqLyBHRlYsXG4gICAgLyogMHgwRSAqLyBTRlZUUFYsXG4gICAgLyogMHgwRiAqLyBJU0VDVCxcbiAgICAvKiAweDEwICovIFNSUDAsXG4gICAgLyogMHgxMSAqLyBTUlAxLFxuICAgIC8qIDB4MTIgKi8gU1JQMixcbiAgICAvKiAweDEzICovIFNaUDAsXG4gICAgLyogMHgxNCAqLyBTWlAxLFxuICAgIC8qIDB4MTUgKi8gU1pQMixcbiAgICAvKiAweDE2ICovIFNaUFMsXG4gICAgLyogMHgxNyAqLyBTTE9PUCxcbiAgICAvKiAweDE4ICovIFJURyxcbiAgICAvKiAweDE5ICovIFJUSEcsXG4gICAgLyogMHgxQSAqLyBTTUQsXG4gICAgLyogMHgxQiAqLyBFTFNFLFxuICAgIC8qIDB4MUMgKi8gSk1QUixcbiAgICAvKiAweDFEICovIFNDVlRDSSxcbiAgICAvKiAweDFFICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIFNTV0NJXG4gICAgLyogMHgxRiAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBTU1dcbiAgICAvKiAweDIwICovIERVUCxcbiAgICAvKiAweDIxICovIFBPUCxcbiAgICAvKiAweDIyICovIENMRUFSLFxuICAgIC8qIDB4MjMgKi8gU1dBUCxcbiAgICAvKiAweDI0ICovIERFUFRILFxuICAgIC8qIDB4MjUgKi8gQ0lOREVYLFxuICAgIC8qIDB4MjYgKi8gTUlOREVYLFxuICAgIC8qIDB4MjcgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gQUxJR05QVFNcbiAgICAvKiAweDI4ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDI5ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIFVUUFxuICAgIC8qIDB4MkEgKi8gTE9PUENBTEwsXG4gICAgLyogMHgyQiAqLyBDQUxMLFxuICAgIC8qIDB4MkMgKi8gRkRFRixcbiAgICAvKiAweDJEICovIHVuZGVmaW5lZCwgICAvLyBFTkRGIChlYXRlbiBieSBGREVGKVxuICAgIC8qIDB4MkUgKi8gTURBUC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgyRiAqLyBNREFQLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDMwICovIElVUC5iaW5kKHVuZGVmaW5lZCwgeVVuaXRWZWN0b3IpLFxuICAgIC8qIDB4MzEgKi8gSVVQLmJpbmQodW5kZWZpbmVkLCB4VW5pdFZlY3RvciksXG4gICAgLyogMHgzMiAqLyBTSFAuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4MzMgKi8gU0hQLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDM0ICovIFNIQy5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHgzNSAqLyBTSEMuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4MzYgKi8gU0haLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDM3ICovIFNIWi5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHgzOCAqLyBTSFBJWCxcbiAgICAvKiAweDM5ICovIElQLFxuICAgIC8qIDB4M0EgKi8gTVNJUlAuYmluZCh1bmRlZmluZWQsIDApLFxuICAgIC8qIDB4M0IgKi8gTVNJUlAuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4M0MgKi8gQUxJR05SUCxcbiAgICAvKiAweDNEICovIFJUREcsXG4gICAgLyogMHgzRSAqLyBNSUFQLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDNGICovIE1JQVAuYmluZCh1bmRlZmluZWQsIDEpLFxuICAgIC8qIDB4NDAgKi8gTlBVU0hCLFxuICAgIC8qIDB4NDEgKi8gTlBVU0hXLFxuICAgIC8qIDB4NDIgKi8gV1MsXG4gICAgLyogMHg0MyAqLyBSUyxcbiAgICAvKiAweDQ0ICovIFdDVlRQLFxuICAgIC8qIDB4NDUgKi8gUkNWVCxcbiAgICAvKiAweDQ2ICovIEdDLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDQ3ICovIEdDLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDQ4ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIFNDRlNcbiAgICAvKiAweDQ5ICovIE1ELmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDRBICovIE1ELmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDRCICovIE1QUEVNLFxuICAgIC8qIDB4NEMgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gTVBTXG4gICAgLyogMHg0RCAqLyBGTElQT04sXG4gICAgLyogMHg0RSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBGTElQT0ZGXG4gICAgLyogMHg0RiAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBERUJVR1xuICAgIC8qIDB4NTAgKi8gTFQsXG4gICAgLyogMHg1MSAqLyBMVEVRLFxuICAgIC8qIDB4NTIgKi8gR1QsXG4gICAgLyogMHg1MyAqLyBHVEVRLFxuICAgIC8qIDB4NTQgKi8gRVEsXG4gICAgLyogMHg1NSAqLyBORVEsXG4gICAgLyogMHg1NiAqLyBPREQsXG4gICAgLyogMHg1NyAqLyBFVkVOLFxuICAgIC8qIDB4NTggKi8gSUYsXG4gICAgLyogMHg1OSAqLyBFSUYsXG4gICAgLyogMHg1QSAqLyBBTkQsXG4gICAgLyogMHg1QiAqLyBPUixcbiAgICAvKiAweDVDICovIE5PVCxcbiAgICAvKiAweDVEICovIERFTFRBUDEyMy5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHg1RSAqLyBTREIsXG4gICAgLyogMHg1RiAqLyBTRFMsXG4gICAgLyogMHg2MCAqLyBBREQsXG4gICAgLyogMHg2MSAqLyBTVUIsXG4gICAgLyogMHg2MiAqLyBESVYsXG4gICAgLyogMHg2MyAqLyBNVUwsXG4gICAgLyogMHg2NCAqLyBBQlMsXG4gICAgLyogMHg2NSAqLyBORUcsXG4gICAgLyogMHg2NiAqLyBGTE9PUixcbiAgICAvKiAweDY3ICovIENFSUxJTkcsXG4gICAgLyogMHg2OCAqLyBST1VORC5iaW5kKHVuZGVmaW5lZCwgMCksXG4gICAgLyogMHg2OSAqLyBST1VORC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHg2QSAqLyBST1VORC5iaW5kKHVuZGVmaW5lZCwgMiksXG4gICAgLyogMHg2QiAqLyBST1VORC5iaW5kKHVuZGVmaW5lZCwgMyksXG4gICAgLyogMHg2QyAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBOUk9VTkRbYWJdXG4gICAgLyogMHg2RCAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBOUk9VTkRbYWJdXG4gICAgLyogMHg2RSAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBOUk9VTkRbYWJdXG4gICAgLyogMHg2RiAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBOUk9VTkRbYWJdXG4gICAgLyogMHg3MCAqLyBXQ1ZURixcbiAgICAvKiAweDcxICovIERFTFRBUDEyMy5iaW5kKHVuZGVmaW5lZCwgMiksXG4gICAgLyogMHg3MiAqLyBERUxUQVAxMjMuYmluZCh1bmRlZmluZWQsIDMpLFxuICAgIC8qIDB4NzMgKi8gREVMVEFDMTIzLmJpbmQodW5kZWZpbmVkLCAxKSxcbiAgICAvKiAweDc0ICovIERFTFRBQzEyMy5iaW5kKHVuZGVmaW5lZCwgMiksXG4gICAgLyogMHg3NSAqLyBERUxUQUMxMjMuYmluZCh1bmRlZmluZWQsIDMpLFxuICAgIC8qIDB4NzYgKi8gU1JPVU5ELFxuICAgIC8qIDB4NzcgKi8gUzQ1Uk9VTkQsXG4gICAgLyogMHg3OCAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBKUk9UW11cbiAgICAvKiAweDc5ICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEpST0ZbXVxuICAgIC8qIDB4N0EgKi8gUk9GRixcbiAgICAvKiAweDdCICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDdDICovIFJVVEcsXG4gICAgLyogMHg3RCAqLyBSRFRHLFxuICAgIC8qIDB4N0UgKi8gUE9QLCAvLyBhY3R1YWxseSBTQU5HVywgc3VwcG9zZWQgdG8gZG8gb25seSBhIHBvcCB0aG91Z2hcbiAgICAvKiAweDdGICovIFBPUCwgLy8gYWN0dWFsbHkgQUEsIHN1cHBvc2VkIHRvIGRvIG9ubHkgYSBwb3AgdGhvdWdoXG4gICAgLyogMHg4MCAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBGTElQUFRcbiAgICAvKiAweDgxICovIHVuZGVmaW5lZCwgICAvLyBUT0RPIEZMSVBSR09OXG4gICAgLyogMHg4MiAqLyB1bmRlZmluZWQsICAgLy8gVE9ETyBGTElQUkdPRkZcbiAgICAvKiAweDgzICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDg0ICovIHVuZGVmaW5lZCxcbiAgICAvKiAweDg1ICovIFNDQU5DVFJMLFxuICAgIC8qIDB4ODYgKi8gU0RQVlRMLmJpbmQodW5kZWZpbmVkLCAwKSxcbiAgICAvKiAweDg3ICovIFNEUFZUTC5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHg4OCAqLyBHRVRJTkZPLFxuICAgIC8qIDB4ODkgKi8gdW5kZWZpbmVkLCAgIC8vIFRPRE8gSURFRlxuICAgIC8qIDB4OEEgKi8gUk9MTCxcbiAgICAvKiAweDhCICovIE1BWCxcbiAgICAvKiAweDhDICovIE1JTixcbiAgICAvKiAweDhEICovIFNDQU5UWVBFLFxuICAgIC8qIDB4OEUgKi8gSU5TVENUUkwsXG4gICAgLyogMHg4RiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5MCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5MSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5MiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5MyAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5NCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5NSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5NiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5NyAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5OCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5OSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5QSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5QiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5QyAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5RCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5RSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHg5RiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBMCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBMSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBMiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBMyAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBNCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBNSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBNiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBNyAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBOCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBOSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBQSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBQiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBQyAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBRCAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBRSAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhBRiAqLyB1bmRlZmluZWQsXG4gICAgLyogMHhCMCAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHhCMSAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgMiksXG4gICAgLyogMHhCMiAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgMyksXG4gICAgLyogMHhCMyAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgNCksXG4gICAgLyogMHhCNCAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgNSksXG4gICAgLyogMHhCNSAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgNiksXG4gICAgLyogMHhCNiAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgNyksXG4gICAgLyogMHhCNyAqLyBQVVNIQi5iaW5kKHVuZGVmaW5lZCwgOCksXG4gICAgLyogMHhCOCAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgMSksXG4gICAgLyogMHhCOSAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgMiksXG4gICAgLyogMHhCQSAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgMyksXG4gICAgLyogMHhCQiAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgNCksXG4gICAgLyogMHhCQyAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgNSksXG4gICAgLyogMHhCRCAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgNiksXG4gICAgLyogMHhCRSAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgNyksXG4gICAgLyogMHhCRiAqLyBQVVNIVy5iaW5kKHVuZGVmaW5lZCwgOCksXG4gICAgLyogMHhDMCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDAsIDApLFxuICAgIC8qIDB4QzEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAwLCAxKSxcbiAgICAvKiAweEMyICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMCwgMiksXG4gICAgLyogMHhDMyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDAsIDMpLFxuICAgIC8qIDB4QzQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAxLCAwKSxcbiAgICAvKiAweEM1ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMCwgMSwgMSksXG4gICAgLyogMHhDNiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDAsIDEsIDIpLFxuICAgIC8qIDB4QzcgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAwLCAxLCAzKSxcbiAgICAvKiAweEM4ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMCwgMCksXG4gICAgLyogMHhDOSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDAsIDEpLFxuICAgIC8qIDB4Q0EgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAwLCAyKSxcbiAgICAvKiAweENCICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMCwgMyksXG4gICAgLyogMHhDQyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDEsIDApLFxuICAgIC8qIDB4Q0QgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAwLCAxLCAxLCAxKSxcbiAgICAvKiAweENFICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMCwgMSwgMSwgMiksXG4gICAgLyogMHhDRiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDAsIDEsIDEsIDMpLFxuICAgIC8qIDB4RDAgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAwLCAwKSxcbiAgICAvKiAweEQxICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMCwgMSksXG4gICAgLyogMHhEMiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDAsIDIpLFxuICAgIC8qIDB4RDMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAwLCAzKSxcbiAgICAvKiAweEQ0ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMSwgMCksXG4gICAgLyogMHhENSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDAsIDEsIDEpLFxuICAgIC8qIDB4RDYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAwLCAxLCAyKSxcbiAgICAvKiAweEQ3ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMCwgMSwgMyksXG4gICAgLyogMHhEOCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDAsIDApLFxuICAgIC8qIDB4RDkgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAwLCAxKSxcbiAgICAvKiAweERBICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMCwgMiksXG4gICAgLyogMHhEQiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDAsIDMpLFxuICAgIC8qIDB4REMgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAxLCAwKSxcbiAgICAvKiAweEREICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMCwgMSwgMSwgMSwgMSksXG4gICAgLyogMHhERSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDAsIDEsIDEsIDEsIDIpLFxuICAgIC8qIDB4REYgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAwLCAxLCAxLCAxLCAzKSxcbiAgICAvKiAweEUwICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMCwgMCksXG4gICAgLyogMHhFMSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDAsIDEpLFxuICAgIC8qIDB4RTIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAwLCAyKSxcbiAgICAvKiAweEUzICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMCwgMyksXG4gICAgLyogMHhFNCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDEsIDApLFxuICAgIC8qIDB4RTUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAwLCAxLCAxKSxcbiAgICAvKiAweEU2ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMCwgMSwgMiksXG4gICAgLyogMHhFNyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDAsIDEsIDMpLFxuICAgIC8qIDB4RTggKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAwLCAwKSxcbiAgICAvKiAweEU5ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMCwgMSksXG4gICAgLyogMHhFQSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDAsIDIpLFxuICAgIC8qIDB4RUIgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAwLCAzKSxcbiAgICAvKiAweEVDICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMSwgMCksXG4gICAgLyogMHhFRCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDAsIDEsIDEsIDEpLFxuICAgIC8qIDB4RUUgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAwLCAxLCAxLCAyKSxcbiAgICAvKiAweEVGICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMCwgMSwgMSwgMyksXG4gICAgLyogMHhGMCAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDAsIDApLFxuICAgIC8qIDB4RjEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAwLCAxKSxcbiAgICAvKiAweEYyICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMCwgMiksXG4gICAgLyogMHhGMyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDAsIDMpLFxuICAgIC8qIDB4RjQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAxLCAwKSxcbiAgICAvKiAweEY1ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMCwgMSwgMSksXG4gICAgLyogMHhGNiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDAsIDEsIDIpLFxuICAgIC8qIDB4RjcgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAwLCAxLCAzKSxcbiAgICAvKiAweEY4ICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMCwgMCksXG4gICAgLyogMHhGOSAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDAsIDEpLFxuICAgIC8qIDB4RkEgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAwLCAyKSxcbiAgICAvKiAweEZCICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMCwgMyksXG4gICAgLyogMHhGQyAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDEsIDApLFxuICAgIC8qIDB4RkQgKi8gTURSUF9NSVJQLmJpbmQodW5kZWZpbmVkLCAxLCAxLCAxLCAxLCAxKSxcbiAgICAvKiAweEZFICovIE1EUlBfTUlSUC5iaW5kKHVuZGVmaW5lZCwgMSwgMSwgMSwgMSwgMiksXG4gICAgLyogMHhGRiAqLyBNRFJQX01JUlAuYmluZCh1bmRlZmluZWQsIDEsIDEsIDEsIDEsIDMpXG5dO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIE1hdGhlbWF0aWNhbCBDb25zaWRlcmF0aW9uc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbmZ2IC4uLiByZWZlcnMgdG8gZnJlZWRvbSB2ZWN0b3JcbnB2IC4uLiByZWZlcnMgdG8gcHJvamVjdGlvbiB2ZWN0b3JcbnJwIC4uLiByZWZlcnMgdG8gcmVmZXJlbmNlIHBvaW50XG5wICAuLi4gcmVmZXJzIHRvIHRvIHBvaW50IGJlaW5nIG9wZXJhdGVkIG9uXG5kICAuLi4gcmVmZXJzIHRvIGRpc3RhbmNlXG5cblNFVFJFTEFUSVZFOlxuPT09PT09PT09PT09XG5cbmNhc2UgZnJlZWRvbSB2ZWN0b3IgPT0geC1heGlzOlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIChwdilcbiAgICAgICAgICAgICAgICAgICAgIC4tJ1xuICAgICAgICAgICAgICBycGQgLi0nXG4gICAgICAgICAgICAgICAuLSpcbiAgICAgICAgICBkIC4tJzkwwrAnXG4gICAgICAgICAuLScgICAgICAgJ1xuICAgICAgLi0nICAgICAgICAgICAnXG4gICAqLScgICAgICAgICAgICAgICAnIGJcbiAgcnAgICAgICAgICAgICAgICAgICAnXG4gICAgICAgICAgICAgICAgICAgICAgICdcbiAgICAgICAgICAgICAgICAgICAgICAgICdcbiAgICAgICAgICAgIHAgKi0tLS0tLS0tLS0qLS0tLS0tLS0tLS0tLS0gKGZ2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICBwbVxuXG4gIHJwZHggPSBycHggKyBkICogcHYueFxuICBycGR5ID0gcnB5ICsgZCAqIHB2LnlcblxuICBlcXVhdGlvbiBvZiBsaW5lIGJcblxuICAgeSAtIHJwZHkgPSBwdm5zICogKHgtIHJwZHgpXG5cbiAgIHkgPSBwLnlcblxuICAgeCA9IHJwZHggKyAoIHAueSAtIHJwZHkgKSAvIHB2bnNcblxuXG5jYXNlIGZyZWVkb20gdmVjdG9yID09IHktYXhpczpcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgKiBwbVxuICAgIHxcXFxuICAgIHwgXFxcbiAgICB8ICBcXFxuICAgIHwgICBcXFxuICAgIHwgICAgXFxcbiAgICB8ICAgICBcXFxuICAgIHwgICAgICBcXFxuICAgIHwgICAgICAgXFxcbiAgICB8ICAgICAgICBcXFxuICAgIHwgICAgICAgICBcXCBiXG4gICAgfCAgICAgICAgICBcXFxuICAgIHwgICAgICAgICAgIFxcXG4gICAgfCAgICAgICAgICAgIFxcICAgIC4tJyAocHYpXG4gICAgfCAgICAgICAgIDkwwrAgXFwuLSdcbiAgICB8ICAgICAgICAgICAuLScqIHJwZFxuICAgIHwgICAgICAgIC4tJ1xuICAgICogICAgICotJyAgZFxuICAgIHAgICAgIHJwXG5cbiAgcnBkeCA9IHJweCArIGQgKiBwdi54XG4gIHJwZHkgPSBycHkgKyBkICogcHYueVxuXG4gIGVxdWF0aW9uIG9mIGxpbmUgYjpcbiAgICAgICAgICAgcHZucyAuLi4gbm9ybWFsIHNsb3BlIHRvIHB2XG5cbiAgIHkgLSBycGR5ID0gcHZucyAqICh4IC0gcnBkeClcblxuICAgeCA9IHAueFxuXG4gICB5ID0gcnBkeSArICBwdm5zICogKHAueCAtIHJwZHgpXG5cblxuXG5nZW5lcmljIGNhc2U6XG4tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLicoZnYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLiogcG1cbiAgICAgICAgICAgICAgICAgICAgICAgIC4nICFcbiAgICAgICAgICAgICAgICAgICAgICAuJyAgICAuXG4gICAgICAgICAgICAgICAgICAgIC4nICAgICAgIVxuICAgICAgICAgICAgICAgICAgLicgICAgICAgICAuIGJcbiAgICAgICAgICAgICAgICAuJyAgICAgICAgICAgIVxuICAgICAgICAgICAgICAgKiAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICBwICAgICAgICAgICAgICAgIVxuICAgICAgICAgICAgICAgICAgICAgICAgIDkwwrAgICAuICAgIC4uLiAocHYpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4tKi0nJydcbiAgICAgICAgICAgICAgICAgIC4uLi0tLScnJyAgICBycGRcbiAgICAgICAgIC4uLi0tLScnJyAgIGRcbiAgICotLScnJ1xuICBycFxuXG4gICAgcnBkeCA9IHJweCArIGQgKiBwdi54XG4gICAgcnBkeSA9IHJweSArIGQgKiBwdi55XG5cbiBlcXVhdGlvbiBvZiBsaW5lIGI6XG4gICAgcHZucy4uLiBub3JtYWwgc2xvcGUgdG8gcHZcblxuICAgIHkgLSBycGR5ID0gcHZucyAqICh4IC0gcnBkeClcblxuIGVxdWF0aW9uIG9mIGZyZWVkb20gdmVjdG9yIGxpbmU6XG4gICAgZnZzIC4uLiBzbG9wZSBvZiBmcmVlZG9tIHZlY3RvciAoPWZ5L2Z4KVxuXG4gICAgeSAtIHB5ID0gZnZzICogKHggLSBweClcblxuXG4gIG9uIHBtIGJvdGggZXF1YXRpb25zIGFyZSB0cnVlIGZvciBzYW1lIHgveVxuXG4gICAgeSAtIHJwZHkgPSBwdm5zICogKHggLSBycGR4KVxuXG4gICAgeSAtIHB5ID0gZnZzICogKHggLSBweClcblxuICBmb3JtIHRvIHkgYW5kIHNldCBlcXVhbDpcblxuICAgIHB2bnMgKiAoeCAtIHJwZHgpICsgcnBkeSA9IGZ2cyAqICh4IC0gcHgpICsgcHlcblxuICBleHBhbmQ6XG5cbiAgICBwdm5zICogeCAtIHB2bnMgKiBycGR4ICsgcnBkeSA9IGZ2cyAqIHggLSBmdnMgKiBweCArIHB5XG5cbiAgc3dpdGNoOlxuXG4gICAgZnZzICogeCAtIGZ2cyAqIHB4ICsgcHkgPSBwdm5zICogeCAtIHB2bnMgKiBycGR4ICsgcnBkeVxuXG4gIHNvbHZlIGZvciB4OlxuXG4gICAgZnZzICogeCAtIHB2bnMgKiB4ID0gZnZzICogcHggLSBwdm5zICogcnBkeCAtIHB5ICsgcnBkeVxuXG5cblxuICAgICAgICAgIGZ2cyAqIHB4IC0gcHZucyAqIHJwZHggKyBycGR5IC0gcHlcbiAgICB4ID0gIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAgICAgIGZ2cyAtIHB2bnNcblxuICBhbmQ6XG5cbiAgICB5ID0gZnZzICogKHggLSBweCkgKyBweVxuXG5cblxuSU5URVJQT0xBVEU6XG49PT09PT09PT09PT1cblxuRXhhbXBsZXMgb2YgcG9pbnQgaW50ZXJwb2xhdGlvbi5cblxuVGhlIHdlaWdodCBvZiB0aGUgbW92ZW1lbnQgb2YgdGhlIHJlZmVyZW5jZSBwb2ludCBnZXRzIGJpZ2dlclxudGhlIGZ1cnRoZXIgdGhlIG90aGVyIHJlZmVyZW5jZSBwb2ludCBpcyBhd2F5LCB0aHVzIHRoZSBzYWZlc3Rcbm9wdGlvbiAodGhhdCBpcyBhdm9pZGluZyAwLzAgZGl2aXNpb25zKSBpcyB0byB3ZWlnaHQgdGhlXG5vcmlnaW5hbCBkaXN0YW5jZSBvZiB0aGUgb3RoZXIgcG9pbnQgYnkgdGhlIHN1bSBvZiBib3RoIGRpc3RhbmNlcy5cblxuSWYgdGhlIHN1bSBvZiBib3RoIGRpc3RhbmNlcyBpcyAwLCB0aGVuIG1vdmUgdGhlIHBvaW50IGJ5IHRoZVxuYXJpdGhtZXRpYyBhdmVyYWdlIG9mIHRoZSBtb3ZlbWVudCBvZiBib3RoIHJlZmVyZW5jZSBwb2ludHMuXG5cblxuXG5cbiAgICAgICAgICAgKCs2KVxuICAgIHJwMW8gKi0tLS0+KnJwMVxuICAgICAgICAgLiAgICAgLiAgICAgICAgICAgICAgICAgICAgICAgICAgKCsxMilcbiAgICAgICAgIC4gICAgIC4gICAgICAgICAgICAgICAgICBycDJvICotLS0tLS0tLS0tPiogcnAyXG4gICAgICAgICAuICAgICAuICAgICAgICAgICAgICAgICAgICAgICAuICAgICAgICAgICAuXG4gICAgICAgICAuICAgICAuICAgICAgICAgICAgICAgICAgICAgICAuICAgICAgICAgICAuXG4gICAgICAgICAuICAgIDEwICAgICAgICAgIDIwICAgICAgICAgICAuICAgICAgICAgICAuXG4gICAgICAgICB8Li4uLi4uLi4ufC4uLi4uLi4uLi4uLi4uLi4uLi58ICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAuICAgLiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAuICAgLiAoKzgpICAgICAgICAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgcG8gKi0tLS0tLT4qcCAgICAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAuICAgICAgICAgICAuICAgICAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAuICAgIDEyICAgICAuICAgICAgICAgIDI0ICAgICAgICAgICAuXG4gICAgICAgICAgICAgICB8Li4uLi4uLi4uLi58Li4uLi4uLi4uLi4uLi4uLi4uLi4uLi58XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzZcblxuXG4tLS0tLS0tXG5cblxuXG4gICAgICAgICAgICgrMTApXG4gICAgcnAxbyAqLS0tLS0tLS0+KnJwMVxuICAgICAgICAgLiAgICAgICAgIC4gICAgICAgICAgICAgICAgICAgICAgKC0xMClcbiAgICAgICAgIC4gICAgICAgICAuICAgICAgICAgICAgICBycDIgKjwtLS0tLS0tLS0qIHJwbzJcbiAgICAgICAgIC4gICAgICAgICAuICAgICAgICAgICAgICAgICAgIC4gICAgICAgICAuXG4gICAgICAgICAuICAgICAgICAgLiAgICAgICAgICAgICAgICAgICAuICAgICAgICAgLlxuICAgICAgICAgLiAgICAxMCAgIC4gICAgICAgICAgMzAgICAgICAgLiAgICAgICAgIC5cbiAgICAgICAgIHwuLi4uLi4uLi58Li4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi4uLi58XG4gICAgICAgICAgICAgICAgICAgLiAgICAgICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAgLiAoKzUpICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgcG8gKi0tLT4qIHAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAgLiAgICAuICAgICAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAgLiAgICAuICAgMjAgICAgICAgICAuXG4gICAgICAgICAgICAgICAgICAgfC4uLi58Li4uLi4uLi4uLi4uLi58XG4gICAgICAgICAgICAgICAgICAgICA1ICAgICAgICAxNVxuXG5cbi0tLS0tLS1cblxuXG4gICAgICAgICAgICgrMTApXG4gICAgcnAxbyAqLS0tLS0tLS0+KnJwMVxuICAgICAgICAgLiAgICAgICAgIC5cbiAgICAgICAgIC4gICAgICAgICAuXG4gICAgcnAybyAqLS0tLS0tLS0+KnJwMlxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKzEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBwbyAqLS0tLS0tLS0+KiBwXG5cbi0tLS0tLS1cblxuXG4gICAgICAgICAgICgrMTApXG4gICAgcnAxbyAqLS0tLS0tLS0+KnJwMVxuICAgICAgICAgLiAgICAgICAgIC5cbiAgICAgICAgIC4gICAgICAgICAuKCszMClcbiAgICBycDJvICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPipycDJcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCsyNSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG8gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tPiogcFxuXG5cblxudmltOiBzZXQgdHM9NCBzdz00IGV4cGFuZHRhYjpcbioqKioqL1xuXG4vLyBUaGUgRm9udCBvYmplY3RcblxuLyoqXG4gKiBAdHlwZWRlZiBGb250T3B0aW9uc1xuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGVtcHR5IC0gd2hldGhlciB0byBjcmVhdGUgYSBuZXcgZW1wdHkgZm9udFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZhbWlseU5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdHlsZU5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZnVsbE5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gcG9zdFNjcmlwdE5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZGVzaWduZXJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gZGVzaWduZXJVUkxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gbWFudWZhY3R1cmVyXG4gKiBAcHJvcGVydHkge3N0cmluZz19IG1hbnVmYWN0dXJlclVSTFxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBsaWNlbnNlXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGxpY2Vuc2VVUkxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gdmVyc2lvblxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBkZXNjcmlwdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmc9fSBjb3B5cmlnaHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nPX0gdHJhZGVtYXJrXG4gKiBAcHJvcGVydHkge051bWJlcn0gdW5pdHNQZXJFbVxuICogQHByb3BlcnR5IHtOdW1iZXJ9IGFzY2VuZGVyXG4gKiBAcHJvcGVydHkge051bWJlcn0gZGVzY2VuZGVyXG4gKiBAcHJvcGVydHkge051bWJlcn0gY3JlYXRlZFRpbWVzdGFtcFxuICogQHByb3BlcnR5IHtzdHJpbmc9fSB3ZWlnaHRDbGFzc1xuICogQHByb3BlcnR5IHtzdHJpbmc9fSB3aWR0aENsYXNzXG4gKiBAcHJvcGVydHkge3N0cmluZz19IGZzU2VsZWN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIEZvbnQgcmVwcmVzZW50cyBhIGxvYWRlZCBPcGVuVHlwZSBmb250IGZpbGUuXG4gKiBJdCBjb250YWlucyBhIHNldCBvZiBnbHlwaHMgYW5kIG1ldGhvZHMgdG8gZHJhdyB0ZXh0IG9uIGEgZHJhd2luZyBjb250ZXh0LFxuICogb3IgdG8gZ2V0IGEgcGF0aCByZXByZXNlbnRpbmcgdGhlIHRleHQuXG4gKiBAZXhwb3J0cyBvcGVudHlwZS5Gb250XG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7Rm9udE9wdGlvbnN9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRm9udChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAoIW9wdGlvbnMuZW1wdHkpIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB3ZSd2ZSBwcm92aWRlZCB0aGUgbWluaW11bSBzZXQgb2YgbmFtZXMuXG4gICAgICAgIGNoZWNrQXJndW1lbnQob3B0aW9ucy5mYW1pbHlOYW1lLCAnV2hlbiBjcmVhdGluZyBhIG5ldyBGb250IG9iamVjdCwgZmFtaWx5TmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgY2hlY2tBcmd1bWVudChvcHRpb25zLnN0eWxlTmFtZSwgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIHN0eWxlTmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgY2hlY2tBcmd1bWVudChvcHRpb25zLnVuaXRzUGVyRW0sICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCB1bml0c1BlckVtIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICBjaGVja0FyZ3VtZW50KG9wdGlvbnMuYXNjZW5kZXIsICdXaGVuIGNyZWF0aW5nIGEgbmV3IEZvbnQgb2JqZWN0LCBhc2NlbmRlciBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgY2hlY2tBcmd1bWVudChvcHRpb25zLmRlc2NlbmRlciwgJ1doZW4gY3JlYXRpbmcgYSBuZXcgRm9udCBvYmplY3QsIGRlc2NlbmRlciBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgY2hlY2tBcmd1bWVudChvcHRpb25zLmRlc2NlbmRlciA8IDAsICdEZXNjZW5kZXIgc2hvdWxkIGJlIG5lZ2F0aXZlIChlLmcuIC01MTIpLicpO1xuXG4gICAgICAgIC8vIE9TIFggd2lsbCBjb21wbGFpbiBpZiB0aGUgbmFtZXMgYXJlIGVtcHR5LCBzbyB3ZSBwdXQgYSBzaW5nbGUgc3BhY2UgZXZlcnl3aGVyZSBieSBkZWZhdWx0LlxuICAgICAgICB0aGlzLm5hbWVzID0ge1xuICAgICAgICAgICAgZm9udEZhbWlseToge2VuOiBvcHRpb25zLmZhbWlseU5hbWUgfHwgJyAnfSxcbiAgICAgICAgICAgIGZvbnRTdWJmYW1pbHk6IHtlbjogb3B0aW9ucy5zdHlsZU5hbWUgfHwgJyAnfSxcbiAgICAgICAgICAgIGZ1bGxOYW1lOiB7ZW46IG9wdGlvbnMuZnVsbE5hbWUgfHwgb3B0aW9ucy5mYW1pbHlOYW1lICsgJyAnICsgb3B0aW9ucy5zdHlsZU5hbWV9LFxuICAgICAgICAgICAgcG9zdFNjcmlwdE5hbWU6IHtlbjogb3B0aW9ucy5wb3N0U2NyaXB0TmFtZSB8fCBvcHRpb25zLmZhbWlseU5hbWUgKyBvcHRpb25zLnN0eWxlTmFtZX0sXG4gICAgICAgICAgICBkZXNpZ25lcjoge2VuOiBvcHRpb25zLmRlc2lnbmVyIHx8ICcgJ30sXG4gICAgICAgICAgICBkZXNpZ25lclVSTDoge2VuOiBvcHRpb25zLmRlc2lnbmVyVVJMIHx8ICcgJ30sXG4gICAgICAgICAgICBtYW51ZmFjdHVyZXI6IHtlbjogb3B0aW9ucy5tYW51ZmFjdHVyZXIgfHwgJyAnfSxcbiAgICAgICAgICAgIG1hbnVmYWN0dXJlclVSTDoge2VuOiBvcHRpb25zLm1hbnVmYWN0dXJlclVSTCB8fCAnICd9LFxuICAgICAgICAgICAgbGljZW5zZToge2VuOiBvcHRpb25zLmxpY2Vuc2UgfHwgJyAnfSxcbiAgICAgICAgICAgIGxpY2Vuc2VVUkw6IHtlbjogb3B0aW9ucy5saWNlbnNlVVJMIHx8ICcgJ30sXG4gICAgICAgICAgICB2ZXJzaW9uOiB7ZW46IG9wdGlvbnMudmVyc2lvbiB8fCAnVmVyc2lvbiAwLjEnfSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB7ZW46IG9wdGlvbnMuZGVzY3JpcHRpb24gfHwgJyAnfSxcbiAgICAgICAgICAgIGNvcHlyaWdodDoge2VuOiBvcHRpb25zLmNvcHlyaWdodCB8fCAnICd9LFxuICAgICAgICAgICAgdHJhZGVtYXJrOiB7ZW46IG9wdGlvbnMudHJhZGVtYXJrIHx8ICcgJ31cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51bml0c1BlckVtID0gb3B0aW9ucy51bml0c1BlckVtIHx8IDEwMDA7XG4gICAgICAgIHRoaXMuYXNjZW5kZXIgPSBvcHRpb25zLmFzY2VuZGVyO1xuICAgICAgICB0aGlzLmRlc2NlbmRlciA9IG9wdGlvbnMuZGVzY2VuZGVyO1xuICAgICAgICB0aGlzLmNyZWF0ZWRUaW1lc3RhbXAgPSBvcHRpb25zLmNyZWF0ZWRUaW1lc3RhbXA7XG4gICAgICAgIHRoaXMudGFibGVzID0geyBvczI6IHtcbiAgICAgICAgICAgIHVzV2VpZ2h0Q2xhc3M6IG9wdGlvbnMud2VpZ2h0Q2xhc3MgfHwgdGhpcy51c1dlaWdodENsYXNzZXMuTUVESVVNLFxuICAgICAgICAgICAgdXNXaWR0aENsYXNzOiBvcHRpb25zLndpZHRoQ2xhc3MgfHwgdGhpcy51c1dpZHRoQ2xhc3Nlcy5NRURJVU0sXG4gICAgICAgICAgICBmc1NlbGVjdGlvbjogb3B0aW9ucy5mc1NlbGVjdGlvbiB8fCB0aGlzLmZzU2VsZWN0aW9uVmFsdWVzLlJFR1VMQVJcbiAgICAgICAgfSB9O1xuICAgIH1cblxuICAgIHRoaXMuc3VwcG9ydGVkID0gdHJ1ZTsgLy8gRGVwcmVjYXRlZDogcGFyc2VCdWZmZXIgd2lsbCB0aHJvdyBhbiBlcnJvciBpZiBmb250IGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgdGhpcy5nbHlwaHMgPSBuZXcgZ2x5cGhzZXQuR2x5cGhTZXQodGhpcywgb3B0aW9ucy5nbHlwaHMgfHwgW10pO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBuZXcgRGVmYXVsdEVuY29kaW5nKHRoaXMpO1xuICAgIHRoaXMucG9zaXRpb24gPSBuZXcgUG9zaXRpb24odGhpcyk7XG4gICAgdGhpcy5zdWJzdGl0dXRpb24gPSBuZXcgU3Vic3RpdHV0aW9uKHRoaXMpO1xuICAgIHRoaXMudGFibGVzID0gdGhpcy50YWJsZXMgfHwge307XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2hpbnRpbmcnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faGludGluZykgeyByZXR1cm4gdGhpcy5faGludGluZzsgfVxuICAgICAgICAgICAgaWYgKHRoaXMub3V0bGluZXNGb3JtYXQgPT09ICd0cnVldHlwZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuX2hpbnRpbmcgPSBuZXcgSGludGluZyh0aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZm9udCBoYXMgYSBnbHlwaCBmb3IgdGhlIGdpdmVuIGNoYXJhY3Rlci5cbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkZvbnQucHJvdG90eXBlLmhhc0NoYXIgPSBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RpbmcuY2hhclRvR2x5cGhJbmRleChjKSAhPT0gbnVsbDtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gY2hhcmFjdGVyIHRvIGEgc2luZ2xlIGdseXBoIGluZGV4LlxuICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IHRoZXJlIGlzIGEgb25lLXRvLW9uZSBtYXBwaW5nIGJldHdlZW5cbiAqIHRoZSBnaXZlbiBjaGFyYWN0ZXIgYW5kIGEgZ2x5cGg7IGZvciBjb21wbGV4IHNjcmlwdHMgdGhpcyBtaWdodCBub3QgYmUgdGhlIGNhc2UuXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkZvbnQucHJvdG90eXBlLmNoYXJUb0dseXBoSW5kZXggPSBmdW5jdGlvbihzKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RpbmcuY2hhclRvR2x5cGhJbmRleChzKTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4gY2hhcmFjdGVyIHRvIGEgc2luZ2xlIEdseXBoIG9iamVjdC5cbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGVyZSBpcyBhIG9uZS10by1vbmUgbWFwcGluZyBiZXR3ZWVuXG4gKiB0aGUgZ2l2ZW4gY2hhcmFjdGVyIGFuZCBhIGdseXBoOyBmb3IgY29tcGxleCBzY3JpcHRzIHRoaXMgbWlnaHQgbm90IGJlIHRoZSBjYXNlLlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7b3BlbnR5cGUuR2x5cGh9XG4gKi9cbkZvbnQucHJvdG90eXBlLmNoYXJUb0dseXBoID0gZnVuY3Rpb24oYykge1xuICAgIHZhciBnbHlwaEluZGV4ID0gdGhpcy5jaGFyVG9HbHlwaEluZGV4KGMpO1xuICAgIHZhciBnbHlwaCA9IHRoaXMuZ2x5cGhzLmdldChnbHlwaEluZGV4KTtcbiAgICBpZiAoIWdseXBoKSB7XG4gICAgICAgIC8vIC5ub3RkZWZcbiAgICAgICAgZ2x5cGggPSB0aGlzLmdseXBocy5nZXQoMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBoO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiB0ZXh0IHRvIGEgbGlzdCBvZiBHbHlwaCBvYmplY3RzLlxuICogTm90ZSB0aGF0IHRoZXJlIGlzIG5vIHN0cmljdCBvbmUtdG8tb25lIG1hcHBpbmcgYmV0d2VlbiBjaGFyYWN0ZXJzIGFuZFxuICogZ2x5cGhzLCBzbyB0aGUgbGlzdCBvZiByZXR1cm5lZCBnbHlwaHMgY2FuIGJlIGxhcmdlciBvciBzbWFsbGVyIHRoYW4gdGhlXG4gKiBsZW5ndGggb2YgdGhlIGdpdmVuIHN0cmluZy5cbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaFtdfVxuICovXG5Gb250LnByb3RvdHlwZS5zdHJpbmdUb0dseXBocyA9IGZ1bmN0aW9uKHMsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHRoaXMuZGVmYXVsdFJlbmRlck9wdGlvbnM7XG4gICAgLy8gR2V0IGdseXBoIGluZGV4ZXNcbiAgICB2YXIgaW5kZXhlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgYyA9IHNbaV07XG4gICAgICAgIGluZGV4ZXMucHVzaCh0aGlzJDEuY2hhclRvR2x5cGhJbmRleChjKSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBpbmRleGVzLmxlbmd0aDtcblxuICAgIC8vIEFwcGx5IHN1YnN0aXR1dGlvbnMgb24gZ2x5cGggaW5kZXhlc1xuICAgIGlmIChvcHRpb25zLmZlYXR1cmVzKSB7XG4gICAgICAgIHZhciBzY3JpcHQgPSBvcHRpb25zLnNjcmlwdCB8fCB0aGlzLnN1YnN0aXR1dGlvbi5nZXREZWZhdWx0U2NyaXB0TmFtZSgpO1xuICAgICAgICB2YXIgbWFueVRvT25lID0gW107XG4gICAgICAgIGlmIChvcHRpb25zLmZlYXR1cmVzLmxpZ2EpIHsgbWFueVRvT25lID0gbWFueVRvT25lLmNvbmNhdCh0aGlzLnN1YnN0aXR1dGlvbi5nZXRGZWF0dXJlKCdsaWdhJywgc2NyaXB0LCBvcHRpb25zLmxhbmd1YWdlKSk7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZmVhdHVyZXMucmxpZykgeyBtYW55VG9PbmUgPSBtYW55VG9PbmUuY29uY2F0KHRoaXMuc3Vic3RpdHV0aW9uLmdldEZlYXR1cmUoJ3JsaWcnLCBzY3JpcHQsIG9wdGlvbnMubGFuZ3VhZ2UpKTsgfVxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBsZW5ndGg7IGkkMSArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hbnlUb09uZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBsaWdhdHVyZSA9IG1hbnlUb09uZVtqXTtcbiAgICAgICAgICAgICAgICB2YXIgY29tcG9uZW50cyA9IGxpZ2F0dXJlLnN1YjtcbiAgICAgICAgICAgICAgICB2YXIgY29tcENvdW50ID0gY29tcG9uZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChrIDwgY29tcENvdW50ICYmIGNvbXBvbmVudHNba10gPT09IGluZGV4ZXNbaSQxICsga10pIHsgaysrOyB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPT09IGNvbXBDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVzLnNwbGljZShpJDEsIGNvbXBDb3VudCwgbGlnYXR1cmUuYnkpO1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBsZW5ndGggLSBjb21wQ291bnQgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgZ2x5cGggaW5kZXhlcyB0byBnbHlwaCBvYmplY3RzXG4gICAgdmFyIGdseXBocyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIHZhciBub3RkZWYgPSB0aGlzLmdseXBocy5nZXQoMCk7XG4gICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgbGVuZ3RoOyBpJDIgKz0gMSkge1xuICAgICAgICBnbHlwaHNbaSQyXSA9IHRoaXMkMS5nbHlwaHMuZ2V0KGluZGV4ZXNbaSQyXSkgfHwgbm90ZGVmO1xuICAgIH1cbiAgICByZXR1cm4gZ2x5cGhzO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkZvbnQucHJvdG90eXBlLm5hbWVUb0dseXBoSW5kZXggPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2x5cGhOYW1lcy5uYW1lVG9HbHlwaEluZGV4KG5hbWUpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtvcGVudHlwZS5HbHlwaH1cbiAqL1xuRm9udC5wcm90b3R5cGUubmFtZVRvR2x5cGggPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIGdseXBoSW5kZXggPSB0aGlzLm5hbWVUb0dseXBoSW5kZXgobmFtZSk7XG4gICAgdmFyIGdseXBoID0gdGhpcy5nbHlwaHMuZ2V0KGdseXBoSW5kZXgpO1xuICAgIGlmICghZ2x5cGgpIHtcbiAgICAgICAgLy8gLm5vdGRlZlxuICAgICAgICBnbHlwaCA9IHRoaXMuZ2x5cGhzLmdldCgwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2x5cGg7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge051bWJlcn1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuRm9udC5wcm90b3R5cGUuZ2x5cGhJbmRleFRvTmFtZSA9IGZ1bmN0aW9uKGdpZCkge1xuICAgIGlmICghdGhpcy5nbHlwaE5hbWVzLmdseXBoSW5kZXhUb05hbWUpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmdseXBoTmFtZXMuZ2x5cGhJbmRleFRvTmFtZShnaWQpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgdmFsdWUgb2YgdGhlIGtlcm5pbmcgcGFpciBiZXR3ZWVuIHRoZSBsZWZ0IGdseXBoIChvciBpdHMgaW5kZXgpXG4gKiBhbmQgdGhlIHJpZ2h0IGdseXBoIChvciBpdHMgaW5kZXgpLiBJZiBubyBrZXJuaW5nIHBhaXIgaXMgZm91bmQsIHJldHVybiAwLlxuICogVGhlIGtlcm5pbmcgdmFsdWUgZ2V0cyBhZGRlZCB0byB0aGUgYWR2YW5jZSB3aWR0aCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBzcGFjaW5nXG4gKiBiZXR3ZWVuIGdseXBocy5cbiAqIEBwYXJhbSAge29wZW50eXBlLkdseXBofSBsZWZ0R2x5cGhcbiAqIEBwYXJhbSAge29wZW50eXBlLkdseXBofSByaWdodEdseXBoXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkZvbnQucHJvdG90eXBlLmdldEtlcm5pbmdWYWx1ZSA9IGZ1bmN0aW9uKGxlZnRHbHlwaCwgcmlnaHRHbHlwaCkge1xuICAgIGxlZnRHbHlwaCA9IGxlZnRHbHlwaC5pbmRleCB8fCBsZWZ0R2x5cGg7XG4gICAgcmlnaHRHbHlwaCA9IHJpZ2h0R2x5cGguaW5kZXggfHwgcmlnaHRHbHlwaDtcbiAgICByZXR1cm4gdGhpcy5rZXJuaW5nUGFpcnNbbGVmdEdseXBoICsgJywnICsgcmlnaHRHbHlwaF0gfHwgMDtcbn07XG5cbi8qKlxuICogQHR5cGVkZWYgR2x5cGhSZW5kZXJPcHRpb25zXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2NyaXB0XSAtIHNjcmlwdCB1c2VkIHRvIGRldGVybWluZSB3aGljaCBmZWF0dXJlcyB0byBhcHBseS4gQnkgZGVmYXVsdCwgJ0RGTFQnIG9yICdsYXRuJyBpcyB1c2VkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9vdHNwZWMvc2NyaXB0dGFncy5odG1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbGFuZ3VhZ2U9J2RmbHQnXSAtIGxhbmd1YWdlIHN5c3RlbSB1c2VkIHRvIGRldGVybWluZSB3aGljaCBmZWF0dXJlcyB0byBhcHBseS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNlZSBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvZGV2ZWxvcGVycy9vcGVudHlwZS9sYW5ndWFnZXRhZ3MuYXNweFxuICogQHByb3BlcnR5IHtib29sZWFufSBba2VybmluZz10cnVlXSAtIHdoZXRoZXIgdG8gaW5jbHVkZSBrZXJuaW5nIHZhbHVlc1xuICogQHByb3BlcnR5IHtvYmplY3R9IFtmZWF0dXJlc10gLSBPcGVuVHlwZSBMYXlvdXQgZmVhdHVyZSB0YWdzLiBVc2VkIHRvIGVuYWJsZSBvciBkaXNhYmxlIHRoZSBmZWF0dXJlcyBvZiB0aGUgZ2l2ZW4gc2NyaXB0L2xhbmd1YWdlIHN5c3RlbS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU2VlIGh0dHBzOi8vd3d3Lm1pY3Jvc29mdC5jb20vdHlwb2dyYXBoeS9vdHNwZWMvZmVhdHVyZXRhZ3MuaHRtXG4gKi9cbkZvbnQucHJvdG90eXBlLmRlZmF1bHRSZW5kZXJPcHRpb25zID0ge1xuICAgIGtlcm5pbmc6IHRydWUsXG4gICAgZmVhdHVyZXM6IHtcbiAgICAgICAgbGlnYTogdHJ1ZSxcbiAgICAgICAgcmxpZzogdHJ1ZVxuICAgIH1cbn07XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGVhY2ggZ2x5cGggaW4gdGhlIGdpdmVuIHRleHQuXG4gKiBUaGUgY2FsbGJhY2sgZ2V0cyBgKGdseXBoLCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucylgLiogQHBhcmFtICB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IHRvIGFwcGx5LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW3k9MF0gLSBWZXJ0aWNhbCBwb3NpdGlvbiBvZiB0aGUgKmJhc2VsaW5lKiBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSAge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0gIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqL1xuRm9udC5wcm90b3R5cGUuZm9yRWFjaEdseXBoID0gZnVuY3Rpb24odGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB4ID0geCAhPT0gdW5kZWZpbmVkID8geCA6IDA7XG4gICAgeSA9IHkgIT09IHVuZGVmaW5lZCA/IHkgOiAwO1xuICAgIGZvbnRTaXplID0gZm9udFNpemUgIT09IHVuZGVmaW5lZCA/IGZvbnRTaXplIDogNzI7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5kZWZhdWx0UmVuZGVyT3B0aW9ucztcbiAgICB2YXIgZm9udFNjYWxlID0gMSAvIHRoaXMudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuICAgIHZhciBnbHlwaHMgPSB0aGlzLnN0cmluZ1RvR2x5cGhzKHRleHQsIG9wdGlvbnMpO1xuICAgIHZhciBrZXJuaW5nTG9va3VwcztcbiAgICBpZiAob3B0aW9ucy5rZXJuaW5nKSB7XG4gICAgICAgIHZhciBzY3JpcHQgPSBvcHRpb25zLnNjcmlwdCB8fCB0aGlzLnBvc2l0aW9uLmdldERlZmF1bHRTY3JpcHROYW1lKCk7XG4gICAgICAgIGtlcm5pbmdMb29rdXBzID0gdGhpcy5wb3NpdGlvbi5nZXRLZXJuaW5nVGFibGVzKHNjcmlwdCwgb3B0aW9ucy5sYW5ndWFnZSk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2x5cGhzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IGdseXBoc1tpXTtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzJDEsIGdseXBoLCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChnbHlwaC5hZHZhbmNlV2lkdGgpIHtcbiAgICAgICAgICAgIHggKz0gZ2x5cGguYWR2YW5jZVdpZHRoICogZm9udFNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMua2VybmluZyAmJiBpIDwgZ2x5cGhzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBhcHBseSBwb3NpdGlvbiBhZGp1c3RtZW50IGxvb2t1cHMgaW4gYSBtb3JlIGdlbmVyaWMgd2F5LlxuICAgICAgICAgICAgLy8gSGVyZSB3ZSBvbmx5IHVzZSB0aGUgeEFkdmFuY2UgdmFsdWUuXG4gICAgICAgICAgICB2YXIga2VybmluZ1ZhbHVlID0ga2VybmluZ0xvb2t1cHMgP1xuICAgICAgICAgICAgICAgICAgdGhpcyQxLnBvc2l0aW9uLmdldEtlcm5pbmdWYWx1ZShrZXJuaW5nTG9va3VwcywgZ2x5cGguaW5kZXgsIGdseXBoc1tpICsgMV0uaW5kZXgpIDpcbiAgICAgICAgICAgICAgICAgIHRoaXMkMS5nZXRLZXJuaW5nVmFsdWUoZ2x5cGgsIGdseXBoc1tpICsgMV0pO1xuICAgICAgICAgICAgeCArPSBrZXJuaW5nVmFsdWUgKiBmb250U2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5sZXR0ZXJTcGFjaW5nKSB7XG4gICAgICAgICAgICB4ICs9IG9wdGlvbnMubGV0dGVyU3BhY2luZyAqIGZvbnRTaXplO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMudHJhY2tpbmcpIHtcbiAgICAgICAgICAgIHggKz0gKG9wdGlvbnMudHJhY2tpbmcgLyAxMDAwKSAqIGZvbnRTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4O1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBQYXRoIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGdpdmVuIHRleHQuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAqIEByZXR1cm4ge29wZW50eXBlLlBhdGh9XG4gKi9cbkZvbnQucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbih0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHZhciBmdWxsUGF0aCA9IG5ldyBQYXRoKCk7XG4gICAgdGhpcy5mb3JFYWNoR2x5cGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMsIGZ1bmN0aW9uKGdseXBoLCBnWCwgZ1ksIGdGb250U2l6ZSkge1xuICAgICAgICB2YXIgZ2x5cGhQYXRoID0gZ2x5cGguZ2V0UGF0aChnWCwgZ1ksIGdGb250U2l6ZSwgb3B0aW9ucywgdGhpcyk7XG4gICAgICAgIGZ1bGxQYXRoLmV4dGVuZChnbHlwaFBhdGgpO1xuICAgIH0pO1xuICAgIHJldHVybiBmdWxsUGF0aDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IG9mIFBhdGggb2JqZWN0cyB0aGF0IHJlcHJlc2VudCB0aGUgZ2x5cGhzIG9mIGEgZ2l2ZW4gdGV4dC5cbiAqIEBwYXJhbSAge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSAge251bWJlcn0gW3g9MF0gLSBIb3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuICogQHJldHVybiB7b3BlbnR5cGUuUGF0aFtdfVxuICovXG5Gb250LnByb3RvdHlwZS5nZXRQYXRocyA9IGZ1bmN0aW9uKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgdmFyIGdseXBoUGF0aHMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2hHbHlwaCh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucywgZnVuY3Rpb24oZ2x5cGgsIGdYLCBnWSwgZ0ZvbnRTaXplKSB7XG4gICAgICAgIHZhciBnbHlwaFBhdGggPSBnbHlwaC5nZXRQYXRoKGdYLCBnWSwgZ0ZvbnRTaXplLCBvcHRpb25zLCB0aGlzKTtcbiAgICAgICAgZ2x5cGhQYXRocy5wdXNoKGdseXBoUGF0aCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZ2x5cGhQYXRocztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYWR2YW5jZSB3aWR0aCBvZiBhIHRleHQuXG4gKlxuICogVGhpcyBpcyBzb21ldGhpbmcgZGlmZmVyZW50IHRoYW4gUGF0aC5nZXRCb3VuZGluZ0JveCgpIGFzIGZvciBleGFtcGxlIGFcbiAqIHN1ZmZpeGVkIHdoaXRlc3BhY2UgaW5jcmVhc2VzIHRoZSBhZHZhbmNlV2lkdGggYnV0IG5vdCB0aGUgYm91bmRpbmcgYm94XG4gKiBvciBhbiBvdmVyaGFuZ2luZyBsZXR0ZXIgbGlrZSBhIGNhbGxpZ3JhcGhpYyAnZicgbWlnaHQgaGF2ZSBhIHF1aXRlIGxhcmdlclxuICogYm91bmRpbmcgYm94IHRoYW4gaXRzIGFkdmFuY2Ugd2lkdGguXG4gKlxuICogVGhpcyBjb3JyZXNwb25kcyB0byBjYW52YXMyZENvbnRleHQubWVhc3VyZVRleHQodGV4dCkud2lkdGhcbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICogQHBhcmFtICB7R2x5cGhSZW5kZXJPcHRpb25zPX0gb3B0aW9uc1xuICogQHJldHVybiBhZHZhbmNlIHdpZHRoXG4gKi9cbkZvbnQucHJvdG90eXBlLmdldEFkdmFuY2VXaWR0aCA9IGZ1bmN0aW9uKHRleHQsIGZvbnRTaXplLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIDAsIDAsIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbigpIHt9KTtcbn07XG5cbi8qKlxuICogRHJhdyB0aGUgdGV4dCBvbiB0aGUgZ2l2ZW4gZHJhd2luZyBjb250ZXh0LlxuICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBjcmVhdGUuXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtICB7bnVtYmVyfSBbZm9udFNpemU9NzJdIC0gRm9udCBzaXplIGluIHBpeGVscy4gV2Ugc2NhbGUgdGhlIGdseXBoIHVuaXRzIGJ5IGAxIC8gdW5pdHNQZXJFbSAqIGZvbnRTaXplYC5cbiAqIEBwYXJhbSAge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAqL1xuRm9udC5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKGN0eCwgdGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmdldFBhdGgodGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpLmRyYXcoY3R4KTtcbn07XG5cbi8qKlxuICogRHJhdyB0aGUgcG9pbnRzIG9mIGFsbCBnbHlwaHMgaW4gdGhlIHRleHQuXG4gKiBPbi1jdXJ2ZSBwb2ludHMgd2lsbCBiZSBkcmF3biBpbiBibHVlLCBvZmYtY3VydmUgcG9pbnRzIHdpbGwgYmUgZHJhd24gaW4gcmVkLlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eCAtIEEgMkQgZHJhd2luZyBjb250ZXh0LCBsaWtlIENhbnZhcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gY3JlYXRlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBwb3NpdGlvbiBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVmVydGljYWwgcG9zaXRpb24gb2YgdGhlICpiYXNlbGluZSogb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW2ZvbnRTaXplPTcyXSAtIEZvbnQgc2l6ZSBpbiBwaXhlbHMuIFdlIHNjYWxlIHRoZSBnbHlwaCB1bml0cyBieSBgMSAvIHVuaXRzUGVyRW0gKiBmb250U2l6ZWAuXG4gKiBAcGFyYW0ge0dseXBoUmVuZGVyT3B0aW9ucz19IG9wdGlvbnNcbiAqL1xuRm9udC5wcm90b3R5cGUuZHJhd1BvaW50cyA9IGZ1bmN0aW9uKGN0eCwgdGV4dCwgeCwgeSwgZm9udFNpemUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmZvckVhY2hHbHlwaCh0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucywgZnVuY3Rpb24oZ2x5cGgsIGdYLCBnWSwgZ0ZvbnRTaXplKSB7XG4gICAgICAgIGdseXBoLmRyYXdQb2ludHMoY3R4LCBnWCwgZ1ksIGdGb250U2l6ZSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIERyYXcgbGluZXMgaW5kaWNhdGluZyBpbXBvcnRhbnQgZm9udCBtZWFzdXJlbWVudHMgZm9yIGFsbCBnbHlwaHMgaW4gdGhlIHRleHQuXG4gKiBCbGFjayBsaW5lcyBpbmRpY2F0ZSB0aGUgb3JpZ2luIG9mIHRoZSBjb29yZGluYXRlIHN5c3RlbSAocG9pbnQgMCwwKS5cbiAqIEJsdWUgbGluZXMgaW5kaWNhdGUgdGhlIGdseXBoIGJvdW5kaW5nIGJveC5cbiAqIEdyZWVuIGxpbmUgaW5kaWNhdGVzIHRoZSBhZHZhbmNlIHdpZHRoIG9mIHRoZSBnbHlwaC5cbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggLSBBIDJEIGRyYXdpbmcgY29udGV4dCwgbGlrZSBDYW52YXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IHRvIGNyZWF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIEhvcml6b250YWwgcG9zaXRpb24gb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIHBvc2l0aW9uIG9mIHRoZSAqYmFzZWxpbmUqIG9mIHRoZSB0ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtmb250U2l6ZT03Ml0gLSBGb250IHNpemUgaW4gcGl4ZWxzLiBXZSBzY2FsZSB0aGUgZ2x5cGggdW5pdHMgYnkgYDEgLyB1bml0c1BlckVtICogZm9udFNpemVgLlxuICogQHBhcmFtIHtHbHlwaFJlbmRlck9wdGlvbnM9fSBvcHRpb25zXG4gKi9cbkZvbnQucHJvdG90eXBlLmRyYXdNZXRyaWNzID0gZnVuY3Rpb24oY3R4LCB0ZXh0LCB4LCB5LCBmb250U2l6ZSwgb3B0aW9ucykge1xuICAgIHRoaXMuZm9yRWFjaEdseXBoKHRleHQsIHgsIHksIGZvbnRTaXplLCBvcHRpb25zLCBmdW5jdGlvbihnbHlwaCwgZ1gsIGdZLCBnRm9udFNpemUpIHtcbiAgICAgICAgZ2x5cGguZHJhd01ldHJpY3MoY3R4LCBnWCwgZ1ksIGdGb250U2l6ZSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ31cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuRm9udC5wcm90b3R5cGUuZ2V0RW5nbGlzaE5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHRyYW5zbGF0aW9ucyA9IHRoaXMubmFtZXNbbmFtZV07XG4gICAgaWYgKHRyYW5zbGF0aW9ucykge1xuICAgICAgICByZXR1cm4gdHJhbnNsYXRpb25zLmVuO1xuICAgIH1cbn07XG5cbi8qKlxuICogVmFsaWRhdGVcbiAqL1xuRm9udC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgd2FybmluZ3MgPSBbXTtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gYXNzZXJ0KHByZWRpY2F0ZSwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZSkge1xuICAgICAgICAgICAgd2FybmluZ3MucHVzaChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzc2VydE5hbWVQcmVzZW50KG5hbWUpIHtcbiAgICAgICAgdmFyIGVuZ2xpc2hOYW1lID0gX3RoaXMuZ2V0RW5nbGlzaE5hbWUobmFtZSk7XG4gICAgICAgIGFzc2VydChlbmdsaXNoTmFtZSAmJiBlbmdsaXNoTmFtZS50cmltKCkubGVuZ3RoID4gMCxcbiAgICAgICAgICAgICAgICdObyBFbmdsaXNoICcgKyBuYW1lICsgJyBzcGVjaWZpZWQuJyk7XG4gICAgfVxuXG4gICAgLy8gSWRlbnRpZmljYXRpb24gaW5mb3JtYXRpb25cbiAgICBhc3NlcnROYW1lUHJlc2VudCgnZm9udEZhbWlseScpO1xuICAgIGFzc2VydE5hbWVQcmVzZW50KCd3ZWlnaHROYW1lJyk7XG4gICAgYXNzZXJ0TmFtZVByZXNlbnQoJ21hbnVmYWN0dXJlcicpO1xuICAgIGFzc2VydE5hbWVQcmVzZW50KCdjb3B5cmlnaHQnKTtcbiAgICBhc3NlcnROYW1lUHJlc2VudCgndmVyc2lvbicpO1xuXG4gICAgLy8gRGltZW5zaW9uIGluZm9ybWF0aW9uXG4gICAgYXNzZXJ0KHRoaXMudW5pdHNQZXJFbSA+IDAsICdObyB1bml0c1BlckVtIHNwZWNpZmllZC4nKTtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgZm9udCBvYmplY3QgdG8gYSBTRk5UIGRhdGEgc3RydWN0dXJlLlxuICogVGhpcyBzdHJ1Y3R1cmUgY29udGFpbnMgYWxsIHRoZSBuZWNlc3NhcnkgdGFibGVzIGFuZCBtZXRhZGF0YSB0byBjcmVhdGUgYSBiaW5hcnkgT1RGIGZpbGUuXG4gKiBAcmV0dXJuIHtvcGVudHlwZS5UYWJsZX1cbiAqL1xuRm9udC5wcm90b3R5cGUudG9UYWJsZXMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2ZudC5mb250VG9UYWJsZSh0aGlzKTtcbn07XG4vKipcbiAqIEBkZXByZWNhdGVkIEZvbnQudG9CdWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIEZvbnQudG9BcnJheUJ1ZmZlciBpbnN0ZWFkLlxuICovXG5Gb250LnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUud2FybignRm9udC50b0J1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgRm9udC50b0FycmF5QnVmZmVyIGluc3RlYWQuJyk7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUJ1ZmZlcigpO1xufTtcbi8qKlxuICogQ29udmVydHMgYSBgb3BlbnR5cGUuRm9udGAgaW50byBhbiBgQXJyYXlCdWZmZXJgXG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn1cbiAqL1xuRm9udC5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZm50VGFibGUgPSB0aGlzLnRvVGFibGVzKCk7XG4gICAgdmFyIGJ5dGVzID0gc2ZudFRhYmxlLmVuY29kZSgpO1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZXMubGVuZ3RoKTtcbiAgICB2YXIgaW50QXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW50QXJyYXlbaV0gPSBieXRlc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyO1xufTtcblxuLyoqXG4gKiBJbml0aWF0ZSBhIGRvd25sb2FkIG9mIHRoZSBPcGVuVHlwZSBmb250LlxuICovXG5Gb250LnByb3RvdHlwZS5kb3dubG9hZCA9IGZ1bmN0aW9uKGZpbGVOYW1lKSB7XG4gICAgdmFyIGZhbWlseU5hbWUgPSB0aGlzLmdldEVuZ2xpc2hOYW1lKCdmb250RmFtaWx5Jyk7XG4gICAgdmFyIHN0eWxlTmFtZSA9IHRoaXMuZ2V0RW5nbGlzaE5hbWUoJ2ZvbnRTdWJmYW1pbHknKTtcbiAgICBmaWxlTmFtZSA9IGZpbGVOYW1lIHx8IGZhbWlseU5hbWUucmVwbGFjZSgvXFxzL2csICcnKSArICctJyArIHN0eWxlTmFtZSArICcub3RmJztcbiAgICB2YXIgYXJyYXlCdWZmZXIgPSB0aGlzLnRvQXJyYXlCdWZmZXIoKTtcblxuICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICB3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0gPSB3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0gfHwgd2luZG93LndlYmtpdFJlcXVlc3RGaWxlU3lzdGVtO1xuICAgICAgICB3aW5kb3cucmVxdWVzdEZpbGVTeXN0ZW0od2luZG93LlRFTVBPUkFSWSwgYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCwgZnVuY3Rpb24oZnMpIHtcbiAgICAgICAgICAgIGZzLnJvb3QuZ2V0RmlsZShmaWxlTmFtZSwge2NyZWF0ZTogdHJ1ZX0sIGZ1bmN0aW9uKGZpbGVFbnRyeSkge1xuICAgICAgICAgICAgICAgIGZpbGVFbnRyeS5jcmVhdGVXcml0ZXIoZnVuY3Rpb24od3JpdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhVmlldyA9IG5ldyBEYXRhVmlldyhhcnJheUJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2RhdGFWaWV3XSwge3R5cGU6ICdmb250L29wZW50eXBlJ30pO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGUoYmxvYik7XG5cbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLmFkZEV2ZW50TGlzdGVuZXIoJ3dyaXRlZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOYXZpZ2F0aW5nIHRvIHRoZSBmaWxlIHdpbGwgZG93bmxvYWQgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbi5ocmVmID0gZmlsZUVudHJ5LnRvVVJMKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnIubmFtZSArICc6ICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG4gICAgICAgIHZhciBidWZmZXIgPSBhcnJheUJ1ZmZlclRvTm9kZUJ1ZmZlcihhcnJheUJ1ZmZlcik7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoZmlsZU5hbWUsIGJ1ZmZlcik7XG4gICAgfVxufTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuRm9udC5wcm90b3R5cGUuZnNTZWxlY3Rpb25WYWx1ZXMgPSB7XG4gICAgSVRBTElDOiAgICAgICAgICAgICAgMHgwMDEsIC8vMVxuICAgIFVOREVSU0NPUkU6ICAgICAgICAgIDB4MDAyLCAvLzJcbiAgICBORUdBVElWRTogICAgICAgICAgICAweDAwNCwgLy80XG4gICAgT1VUTElORUQ6ICAgICAgICAgICAgMHgwMDgsIC8vOFxuICAgIFNUUklLRU9VVDogICAgICAgICAgIDB4MDEwLCAvLzE2XG4gICAgQk9MRDogICAgICAgICAgICAgICAgMHgwMjAsIC8vMzJcbiAgICBSRUdVTEFSOiAgICAgICAgICAgICAweDA0MCwgLy82NFxuICAgIFVTRVJfVFlQT19NRVRSSUNTOiAgIDB4MDgwLCAvLzEyOFxuICAgIFdXUzogICAgICAgICAgICAgICAgIDB4MTAwLCAvLzI1NlxuICAgIE9CTElRVUU6ICAgICAgICAgICAgIDB4MjAwICAvLzUxMlxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5Gb250LnByb3RvdHlwZS51c1dpZHRoQ2xhc3NlcyA9IHtcbiAgICBVTFRSQV9DT05ERU5TRUQ6IDEsXG4gICAgRVhUUkFfQ09OREVOU0VEOiAyLFxuICAgIENPTkRFTlNFRDogMyxcbiAgICBTRU1JX0NPTkRFTlNFRDogNCxcbiAgICBNRURJVU06IDUsXG4gICAgU0VNSV9FWFBBTkRFRDogNixcbiAgICBFWFBBTkRFRDogNyxcbiAgICBFWFRSQV9FWFBBTkRFRDogOCxcbiAgICBVTFRSQV9FWFBBTkRFRDogOVxufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5Gb250LnByb3RvdHlwZS51c1dlaWdodENsYXNzZXMgPSB7XG4gICAgVEhJTjogMTAwLFxuICAgIEVYVFJBX0xJR0hUOiAyMDAsXG4gICAgTElHSFQ6IDMwMCxcbiAgICBOT1JNQUw6IDQwMCxcbiAgICBNRURJVU06IDUwMCxcbiAgICBTRU1JX0JPTEQ6IDYwMCxcbiAgICBCT0xEOiA3MDAsXG4gICAgRVhUUkFfQk9MRDogODAwLFxuICAgIEJMQUNLOiAgICA5MDBcbn07XG5cbi8vIFRoZSBgZnZhcmAgdGFibGUgc3RvcmVzIGZvbnQgdmFyaWF0aW9uIGF4ZXMgYW5kIGluc3RhbmNlcy5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9mb250cy9UcnVlVHlwZS1SZWZlcmVuY2UtTWFudWFsL1JNMDYvQ2hhcDZmdmFyLmh0bWxcblxuZnVuY3Rpb24gYWRkTmFtZShuYW1lLCBuYW1lcykge1xuICAgIHZhciBuYW1lU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkobmFtZSk7XG4gICAgdmFyIG5hbWVJRCA9IDI1NjtcbiAgICBmb3IgKHZhciBuYW1lS2V5IGluIG5hbWVzKSB7XG4gICAgICAgIHZhciBuID0gcGFyc2VJbnQobmFtZUtleSk7XG4gICAgICAgIGlmICghbiB8fCBuIDwgMjU2KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShuYW1lc1tuYW1lS2V5XSkgPT09IG5hbWVTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWVJRCA8PSBuKSB7XG4gICAgICAgICAgICBuYW1lSUQgPSBuICsgMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5hbWVzW25hbWVJRF0gPSBuYW1lO1xuICAgIHJldHVybiBuYW1lSUQ7XG59XG5cbmZ1bmN0aW9uIG1ha2VGdmFyQXhpcyhuLCBheGlzLCBuYW1lcykge1xuICAgIHZhciBuYW1lSUQgPSBhZGROYW1lKGF4aXMubmFtZSwgbmFtZXMpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHtuYW1lOiAndGFnXycgKyBuLCB0eXBlOiAnVEFHJywgdmFsdWU6IGF4aXMudGFnfSxcbiAgICAgICAge25hbWU6ICdtaW5WYWx1ZV8nICsgbiwgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IGF4aXMubWluVmFsdWUgPDwgMTZ9LFxuICAgICAgICB7bmFtZTogJ2RlZmF1bHRWYWx1ZV8nICsgbiwgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IGF4aXMuZGVmYXVsdFZhbHVlIDw8IDE2fSxcbiAgICAgICAge25hbWU6ICdtYXhWYWx1ZV8nICsgbiwgdHlwZTogJ0ZJWEVEJywgdmFsdWU6IGF4aXMubWF4VmFsdWUgPDwgMTZ9LFxuICAgICAgICB7bmFtZTogJ2ZsYWdzXycgKyBuLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDB9LFxuICAgICAgICB7bmFtZTogJ25hbWVJRF8nICsgbiwgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBuYW1lSUR9XG4gICAgXTtcbn1cblxuZnVuY3Rpb24gcGFyc2VGdmFyQXhpcyhkYXRhLCBzdGFydCwgbmFtZXMpIHtcbiAgICB2YXIgYXhpcyA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgYXhpcy50YWcgPSBwLnBhcnNlVGFnKCk7XG4gICAgYXhpcy5taW5WYWx1ZSA9IHAucGFyc2VGaXhlZCgpO1xuICAgIGF4aXMuZGVmYXVsdFZhbHVlID0gcC5wYXJzZUZpeGVkKCk7XG4gICAgYXhpcy5tYXhWYWx1ZSA9IHAucGFyc2VGaXhlZCgpO1xuICAgIHAuc2tpcCgndVNob3J0JywgMSk7ICAvLyByZXNlcnZlZCBmb3IgZmxhZ3M7IG5vIHZhbHVlcyBkZWZpbmVkXG4gICAgYXhpcy5uYW1lID0gbmFtZXNbcC5wYXJzZVVTaG9ydCgpXSB8fCB7fTtcbiAgICByZXR1cm4gYXhpcztcbn1cblxuZnVuY3Rpb24gbWFrZUZ2YXJJbnN0YW5jZShuLCBpbnN0LCBheGVzLCBuYW1lcykge1xuICAgIHZhciBuYW1lSUQgPSBhZGROYW1lKGluc3QubmFtZSwgbmFtZXMpO1xuICAgIHZhciBmaWVsZHMgPSBbXG4gICAgICAgIHtuYW1lOiAnbmFtZUlEXycgKyBuLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IG5hbWVJRH0sXG4gICAgICAgIHtuYW1lOiAnZmxhZ3NfJyArIG4sIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH1cbiAgICBdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBheGlzVGFnID0gYXhlc1tpXS50YWc7XG4gICAgICAgIGZpZWxkcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6ICdheGlzXycgKyBuICsgJyAnICsgYXhpc1RhZyxcbiAgICAgICAgICAgIHR5cGU6ICdGSVhFRCcsXG4gICAgICAgICAgICB2YWx1ZTogaW5zdC5jb29yZGluYXRlc1theGlzVGFnXSA8PCAxNlxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBwYXJzZUZ2YXJJbnN0YW5jZShkYXRhLCBzdGFydCwgYXhlcywgbmFtZXMpIHtcbiAgICB2YXIgaW5zdCA9IHt9O1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgaW5zdC5uYW1lID0gbmFtZXNbcC5wYXJzZVVTaG9ydCgpXSB8fCB7fTtcbiAgICBwLnNraXAoJ3VTaG9ydCcsIDEpOyAgLy8gcmVzZXJ2ZWQgZm9yIGZsYWdzOyBubyB2YWx1ZXMgZGVmaW5lZFxuXG4gICAgaW5zdC5jb29yZGluYXRlcyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpbnN0LmNvb3JkaW5hdGVzW2F4ZXNbaV0udGFnXSA9IHAucGFyc2VGaXhlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0O1xufVxuXG5mdW5jdGlvbiBtYWtlRnZhclRhYmxlKGZ2YXIsIG5hbWVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyB0YWJsZS5UYWJsZSgnZnZhcicsIFtcbiAgICAgICAge25hbWU6ICd2ZXJzaW9uJywgdHlwZTogJ1VMT05HJywgdmFsdWU6IDB4MTAwMDB9LFxuICAgICAgICB7bmFtZTogJ29mZnNldFRvRGF0YScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogMH0sXG4gICAgICAgIHtuYW1lOiAnY291bnRTaXplUGFpcnMnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDJ9LFxuICAgICAgICB7bmFtZTogJ2F4aXNDb3VudCcsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogZnZhci5heGVzLmxlbmd0aH0sXG4gICAgICAgIHtuYW1lOiAnYXhpc1NpemUnLCB0eXBlOiAnVVNIT1JUJywgdmFsdWU6IDIwfSxcbiAgICAgICAge25hbWU6ICdpbnN0YW5jZUNvdW50JywgdHlwZTogJ1VTSE9SVCcsIHZhbHVlOiBmdmFyLmluc3RhbmNlcy5sZW5ndGh9LFxuICAgICAgICB7bmFtZTogJ2luc3RhbmNlU2l6ZScsIHR5cGU6ICdVU0hPUlQnLCB2YWx1ZTogNCArIGZ2YXIuYXhlcy5sZW5ndGggKiA0fVxuICAgIF0pO1xuICAgIHJlc3VsdC5vZmZzZXRUb0RhdGEgPSByZXN1bHQuc2l6ZU9mKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZ2YXIuYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQuZmllbGRzID0gcmVzdWx0LmZpZWxkcy5jb25jYXQobWFrZUZ2YXJBeGlzKGksIGZ2YXIuYXhlc1tpXSwgbmFtZXMpKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZ2YXIuaW5zdGFuY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHJlc3VsdC5maWVsZHMgPSByZXN1bHQuZmllbGRzLmNvbmNhdChtYWtlRnZhckluc3RhbmNlKGosIGZ2YXIuaW5zdGFuY2VzW2pdLCBmdmFyLmF4ZXMsIG5hbWVzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gcGFyc2VGdmFyVGFibGUoZGF0YSwgc3RhcnQsIG5hbWVzKSB7XG4gICAgdmFyIHAgPSBuZXcgcGFyc2UuUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVVMb25nKCk7XG4gICAgY2hlY2suYXJndW1lbnQodGFibGVWZXJzaW9uID09PSAweDAwMDEwMDAwLCAnVW5zdXBwb3J0ZWQgZnZhciB0YWJsZSB2ZXJzaW9uLicpO1xuICAgIHZhciBvZmZzZXRUb0RhdGEgPSBwLnBhcnNlT2Zmc2V0MTYoKTtcbiAgICAvLyBTa2lwIGNvdW50U2l6ZVBhaXJzLlxuICAgIHAuc2tpcCgndVNob3J0JywgMSk7XG4gICAgdmFyIGF4aXNDb3VudCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgYXhpc1NpemUgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGluc3RhbmNlQ291bnQgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIGluc3RhbmNlU2l6ZSA9IHAucGFyc2VVU2hvcnQoKTtcblxuICAgIHZhciBheGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBheGlzQ291bnQ7IGkrKykge1xuICAgICAgICBheGVzLnB1c2gocGFyc2VGdmFyQXhpcyhkYXRhLCBzdGFydCArIG9mZnNldFRvRGF0YSArIGkgKiBheGlzU2l6ZSwgbmFtZXMpKTtcbiAgICB9XG5cbiAgICB2YXIgaW5zdGFuY2VzID0gW107XG4gICAgdmFyIGluc3RhbmNlU3RhcnQgPSBzdGFydCArIG9mZnNldFRvRGF0YSArIGF4aXNDb3VudCAqIGF4aXNTaXplO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5zdGFuY2VDb3VudDsgaisrKSB7XG4gICAgICAgIGluc3RhbmNlcy5wdXNoKHBhcnNlRnZhckluc3RhbmNlKGRhdGEsIGluc3RhbmNlU3RhcnQgKyBqICogaW5zdGFuY2VTaXplLCBheGVzLCBuYW1lcykpO1xuICAgIH1cblxuICAgIHJldHVybiB7YXhlczogYXhlcywgaW5zdGFuY2VzOiBpbnN0YW5jZXN9O1xufVxuXG52YXIgZnZhciA9IHsgbWFrZTogbWFrZUZ2YXJUYWJsZSwgcGFyc2U6IHBhcnNlRnZhclRhYmxlIH07XG5cbi8vIFRoZSBgR1BPU2AgdGFibGUgY29udGFpbnMga2VybmluZyBwYWlycywgYW1vbmcgb3RoZXIgdGhpbmdzLlxuLy8gaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvdHlwb2dyYXBoeS9vcGVudHlwZS9zcGVjL2dwb3NcblxudmFyIHN1YnRhYmxlUGFyc2VycyQxID0gbmV3IEFycmF5KDEwKTsgICAgICAgICAvLyBzdWJ0YWJsZVBhcnNlcnNbMF0gaXMgdW51c2VkXG5cbi8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9ncG9zI2xvb2t1cC10eXBlLTEtc2luZ2xlLWFkanVzdG1lbnQtcG9zaXRpb25pbmctc3VidGFibGVcbi8vIHRoaXMgPSBQYXJzZXIgaW5zdGFuY2VcbnN1YnRhYmxlUGFyc2VycyQxWzFdID0gZnVuY3Rpb24gcGFyc2VMb29rdXAxKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMub2Zmc2V0ICsgdGhpcy5yZWxhdGl2ZU9mZnNldDtcbiAgICB2YXIgcG9zZm9ybWF0ID0gdGhpcy5wYXJzZVVTaG9ydCgpO1xuICAgIGlmIChwb3Nmb3JtYXQgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc0Zvcm1hdDogMSxcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMucGFyc2VWYWx1ZVJlY29yZCgpXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwb3Nmb3JtYXQgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc0Zvcm1hdDogMixcbiAgICAgICAgICAgIGNvdmVyYWdlOiB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpLFxuICAgICAgICAgICAgdmFsdWVzOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmRMaXN0KClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2hlY2suYXNzZXJ0KGZhbHNlLCAnMHgnICsgc3RhcnQudG9TdHJpbmcoMTYpICsgJzogR1BPUyBsb29rdXAgdHlwZSAxIGZvcm1hdCBtdXN0IGJlIDEgb3IgMi4nKTtcbn07XG5cbi8vIGh0dHBzOi8vZG9jcy5taWNyb3NvZnQuY29tL2VuLXVzL3R5cG9ncmFwaHkvb3BlbnR5cGUvc3BlYy9ncG9zI2xvb2t1cC10eXBlLTItcGFpci1hZGp1c3RtZW50LXBvc2l0aW9uaW5nLXN1YnRhYmxlXG5zdWJ0YWJsZVBhcnNlcnMkMVsyXSA9IGZ1bmN0aW9uIHBhcnNlTG9va3VwMigpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLm9mZnNldCArIHRoaXMucmVsYXRpdmVPZmZzZXQ7XG4gICAgdmFyIHBvc0Zvcm1hdCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICB2YXIgY292ZXJhZ2UgPSB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY292ZXJhZ2UpO1xuICAgIHZhciB2YWx1ZUZvcm1hdDEgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIHZhbHVlRm9ybWF0MiA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICBpZiAocG9zRm9ybWF0ID09PSAxKSB7XG4gICAgICAgIC8vIEFkanVzdG1lbnRzIGZvciBHbHlwaCBQYWlyc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zRm9ybWF0OiBwb3NGb3JtYXQsXG4gICAgICAgICAgICBjb3ZlcmFnZTogY292ZXJhZ2UsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdDE6IHZhbHVlRm9ybWF0MSxcbiAgICAgICAgICAgIHZhbHVlRm9ybWF0MjogdmFsdWVGb3JtYXQyLFxuICAgICAgICAgICAgcGFpclNldHM6IHRoaXMucGFyc2VMaXN0KFBhcnNlci5wb2ludGVyKFBhcnNlci5saXN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7ICAgICAgICAvLyBwYWlyVmFsdWVSZWNvcmRcbiAgICAgICAgICAgICAgICAgICAgc2Vjb25kR2x5cGg6IHRoaXMucGFyc2VVU2hvcnQoKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUxOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQodmFsdWVGb3JtYXQxKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUyOiB0aGlzLnBhcnNlVmFsdWVSZWNvcmQodmFsdWVGb3JtYXQyKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSkpXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwb3NGb3JtYXQgPT09IDIpIHtcbiAgICAgICAgdmFyIGNsYXNzRGVmMSA9IHRoaXMucGFyc2VQb2ludGVyKFBhcnNlci5jbGFzc0RlZik7XG4gICAgICAgIHZhciBjbGFzc0RlZjIgPSB0aGlzLnBhcnNlUG9pbnRlcihQYXJzZXIuY2xhc3NEZWYpO1xuICAgICAgICB2YXIgY2xhc3MxQ291bnQgPSB0aGlzLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciBjbGFzczJDb3VudCA9IHRoaXMucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIENsYXNzIFBhaXIgQWRqdXN0bWVudFxuICAgICAgICAgICAgcG9zRm9ybWF0OiBwb3NGb3JtYXQsXG4gICAgICAgICAgICBjb3ZlcmFnZTogY292ZXJhZ2UsXG4gICAgICAgICAgICB2YWx1ZUZvcm1hdDE6IHZhbHVlRm9ybWF0MSxcbiAgICAgICAgICAgIHZhbHVlRm9ybWF0MjogdmFsdWVGb3JtYXQyLFxuICAgICAgICAgICAgY2xhc3NEZWYxOiBjbGFzc0RlZjEsXG4gICAgICAgICAgICBjbGFzc0RlZjI6IGNsYXNzRGVmMixcbiAgICAgICAgICAgIGNsYXNzMUNvdW50OiBjbGFzczFDb3VudCxcbiAgICAgICAgICAgIGNsYXNzMkNvdW50OiBjbGFzczJDb3VudCxcbiAgICAgICAgICAgIGNsYXNzUmVjb3JkczogdGhpcy5wYXJzZUxpc3QoY2xhc3MxQ291bnQsIFBhcnNlci5saXN0KGNsYXNzMkNvdW50LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTE6IHRoaXMucGFyc2VWYWx1ZVJlY29yZCh2YWx1ZUZvcm1hdDEpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTI6IHRoaXMucGFyc2VWYWx1ZVJlY29yZCh2YWx1ZUZvcm1hdDIpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjaGVjay5hc3NlcnQoZmFsc2UsICcweCcgKyBzdGFydC50b1N0cmluZygxNikgKyAnOiBHUE9TIGxvb2t1cCB0eXBlIDIgZm9ybWF0IG11c3QgYmUgMSBvciAyLicpO1xufTtcblxuc3VidGFibGVQYXJzZXJzJDFbM10gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDMoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgMyBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuc3VidGFibGVQYXJzZXJzJDFbNF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDQoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgNCBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuc3VidGFibGVQYXJzZXJzJDFbNV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDUoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgNSBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuc3VidGFibGVQYXJzZXJzJDFbNl0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDYoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgNiBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuc3VidGFibGVQYXJzZXJzJDFbN10gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDcoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgNyBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuc3VidGFibGVQYXJzZXJzJDFbOF0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDgoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgOCBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuc3VidGFibGVQYXJzZXJzJDFbOV0gPSBmdW5jdGlvbiBwYXJzZUxvb2t1cDkoKSB7IHJldHVybiB7IGVycm9yOiAnR1BPUyBMb29rdXAgOSBub3Qgc3VwcG9ydGVkJyB9OyB9O1xuXG4vLyBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy90eXBvZ3JhcGh5L29wZW50eXBlL3NwZWMvZ3Bvc1xuZnVuY3Rpb24gcGFyc2VHcG9zVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgdmFyIHAgPSBuZXcgUGFyc2VyKGRhdGEsIHN0YXJ0KTtcbiAgICB2YXIgdGFibGVWZXJzaW9uID0gcC5wYXJzZVZlcnNpb24oMSk7XG4gICAgY2hlY2suYXJndW1lbnQodGFibGVWZXJzaW9uID09PSAxIHx8IHRhYmxlVmVyc2lvbiA9PT0gMS4xLCAnVW5zdXBwb3J0ZWQgR1BPUyB0YWJsZSB2ZXJzaW9uICcgKyB0YWJsZVZlcnNpb24pO1xuXG4gICAgaWYgKHRhYmxlVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmVyc2lvbjogdGFibGVWZXJzaW9uLFxuICAgICAgICAgICAgc2NyaXB0czogcC5wYXJzZVNjcmlwdExpc3QoKSxcbiAgICAgICAgICAgIGZlYXR1cmVzOiBwLnBhcnNlRmVhdHVyZUxpc3QoKSxcbiAgICAgICAgICAgIGxvb2t1cHM6IHAucGFyc2VMb29rdXBMaXN0KHN1YnRhYmxlUGFyc2VycyQxKVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJzaW9uOiB0YWJsZVZlcnNpb24sXG4gICAgICAgICAgICBzY3JpcHRzOiBwLnBhcnNlU2NyaXB0TGlzdCgpLFxuICAgICAgICAgICAgZmVhdHVyZXM6IHAucGFyc2VGZWF0dXJlTGlzdCgpLFxuICAgICAgICAgICAgbG9va3VwczogcC5wYXJzZUxvb2t1cExpc3Qoc3VidGFibGVQYXJzZXJzJDEpLFxuICAgICAgICAgICAgdmFyaWF0aW9uczogcC5wYXJzZUZlYXR1cmVWYXJpYXRpb25zTGlzdCgpXG4gICAgICAgIH07XG4gICAgfVxuXG59XG5cbi8vIEdQT1MgV3JpdGluZyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBOT1QgU1VQUE9SVEVEXG52YXIgc3VidGFibGVNYWtlcnMkMSA9IG5ldyBBcnJheSgxMCk7XG5cbmZ1bmN0aW9uIG1ha2VHcG9zVGFibGUoZ3Bvcykge1xuICAgIHJldHVybiBuZXcgdGFibGUuVGFibGUoJ0dQT1MnLCBbXG4gICAgICAgIHtuYW1lOiAndmVyc2lvbicsIHR5cGU6ICdVTE9ORycsIHZhbHVlOiAweDEwMDAwfSxcbiAgICAgICAge25hbWU6ICdzY3JpcHRzJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5TY3JpcHRMaXN0KGdwb3Muc2NyaXB0cyl9LFxuICAgICAgICB7bmFtZTogJ2ZlYXR1cmVzJywgdHlwZTogJ1RBQkxFJywgdmFsdWU6IG5ldyB0YWJsZS5GZWF0dXJlTGlzdChncG9zLmZlYXR1cmVzKX0sXG4gICAgICAgIHtuYW1lOiAnbG9va3VwcycsIHR5cGU6ICdUQUJMRScsIHZhbHVlOiBuZXcgdGFibGUuTG9va3VwTGlzdChncG9zLmxvb2t1cHMsIHN1YnRhYmxlTWFrZXJzJDEpfVxuICAgIF0pO1xufVxuXG52YXIgZ3BvcyA9IHsgcGFyc2U6IHBhcnNlR3Bvc1RhYmxlLCBtYWtlOiBtYWtlR3Bvc1RhYmxlIH07XG5cbi8vIFRoZSBga2VybmAgdGFibGUgY29udGFpbnMga2VybmluZyBwYWlycy5cbi8vIE5vdGUgdGhhdCBzb21lIGZvbnRzIHVzZSB0aGUgR1BPUyBPcGVuVHlwZSBsYXlvdXQgdGFibGUgdG8gc3BlY2lmeSBrZXJuaW5nLlxuLy8gaHR0cHM6Ly93d3cubWljcm9zb2Z0LmNvbS90eXBvZ3JhcGh5L09UU1BFQy9rZXJuLmh0bVxuXG5mdW5jdGlvbiBwYXJzZVdpbmRvd3NLZXJuVGFibGUocCkge1xuICAgIHZhciBwYWlycyA9IHt9O1xuICAgIC8vIFNraXAgblRhYmxlcy5cbiAgICBwLnNraXAoJ3VTaG9ydCcpO1xuICAgIHZhciBzdWJ0YWJsZVZlcnNpb24gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgY2hlY2suYXJndW1lbnQoc3VidGFibGVWZXJzaW9uID09PSAwLCAnVW5zdXBwb3J0ZWQga2VybiBzdWItdGFibGUgdmVyc2lvbi4nKTtcbiAgICAvLyBTa2lwIHN1YnRhYmxlTGVuZ3RoLCBzdWJ0YWJsZUNvdmVyYWdlXG4gICAgcC5za2lwKCd1U2hvcnQnLCAyKTtcbiAgICB2YXIgblBhaXJzID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgIC8vIFNraXAgc2VhcmNoUmFuZ2UsIGVudHJ5U2VsZWN0b3IsIHJhbmdlU2hpZnQuXG4gICAgcC5za2lwKCd1U2hvcnQnLCAzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5QYWlyczsgaSArPSAxKSB7XG4gICAgICAgIHZhciBsZWZ0SW5kZXggPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgICAgIHZhciByaWdodEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICB2YXIgdmFsdWUgPSBwLnBhcnNlU2hvcnQoKTtcbiAgICAgICAgcGFpcnNbbGVmdEluZGV4ICsgJywnICsgcmlnaHRJbmRleF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1hY0tlcm5UYWJsZShwKSB7XG4gICAgdmFyIHBhaXJzID0ge307XG4gICAgLy8gVGhlIE1hYyBrZXJuIHRhYmxlIHN0b3JlcyB0aGUgdmVyc2lvbiBhcyBhIGZpeGVkICgzMiBiaXRzKSBidXQgd2Ugb25seSBsb2FkZWQgdGhlIGZpcnN0IDE2IGJpdHMuXG4gICAgLy8gU2tpcCB0aGUgcmVzdC5cbiAgICBwLnNraXAoJ3VTaG9ydCcpO1xuICAgIHZhciBuVGFibGVzID0gcC5wYXJzZVVMb25nKCk7XG4gICAgLy9jaGVjay5hcmd1bWVudChuVGFibGVzID09PSAxLCAnT25seSAxIHN1YnRhYmxlIGlzIHN1cHBvcnRlZCAoZ290ICcgKyBuVGFibGVzICsgJykuJyk7XG4gICAgaWYgKG5UYWJsZXMgPiAxKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignT25seSB0aGUgZmlyc3Qga2VybiBzdWJ0YWJsZSBpcyBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuICAgIHAuc2tpcCgndUxvbmcnKTtcbiAgICB2YXIgY292ZXJhZ2UgPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgdmFyIHN1YnRhYmxlVmVyc2lvbiA9IGNvdmVyYWdlICYgMHhGRjtcbiAgICBwLnNraXAoJ3VTaG9ydCcpO1xuICAgIGlmIChzdWJ0YWJsZVZlcnNpb24gPT09IDApIHtcbiAgICAgICAgdmFyIG5QYWlycyA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgLy8gU2tpcCBzZWFyY2hSYW5nZSwgZW50cnlTZWxlY3RvciwgcmFuZ2VTaGlmdC5cbiAgICAgICAgcC5za2lwKCd1U2hvcnQnLCAzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFpcnM7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGxlZnRJbmRleCA9IHAucGFyc2VVU2hvcnQoKTtcbiAgICAgICAgICAgIHZhciByaWdodEluZGV4ID0gcC5wYXJzZVVTaG9ydCgpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcC5wYXJzZVNob3J0KCk7XG4gICAgICAgICAgICBwYWlyc1tsZWZ0SW5kZXggKyAnLCcgKyByaWdodEluZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYWlycztcbn1cblxuLy8gUGFyc2UgdGhlIGBrZXJuYCB0YWJsZSB3aGljaCBjb250YWlucyBrZXJuaW5nIHBhaXJzLlxuZnVuY3Rpb24gcGFyc2VLZXJuVGFibGUoZGF0YSwgc3RhcnQpIHtcbiAgICB2YXIgcCA9IG5ldyBwYXJzZS5QYXJzZXIoZGF0YSwgc3RhcnQpO1xuICAgIHZhciB0YWJsZVZlcnNpb24gPSBwLnBhcnNlVVNob3J0KCk7XG4gICAgaWYgKHRhYmxlVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcGFyc2VXaW5kb3dzS2VyblRhYmxlKHApO1xuICAgIH0gZWxzZSBpZiAodGFibGVWZXJzaW9uID09PSAxKSB7XG4gICAgICAgIHJldHVybiBwYXJzZU1hY0tlcm5UYWJsZShwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGtlcm4gdGFibGUgdmVyc2lvbiAoJyArIHRhYmxlVmVyc2lvbiArICcpLicpO1xuICAgIH1cbn1cblxudmFyIGtlcm4gPSB7IHBhcnNlOiBwYXJzZUtlcm5UYWJsZSB9O1xuXG4vLyBUaGUgYGxvY2FgIHRhYmxlIHN0b3JlcyB0aGUgb2Zmc2V0cyB0byB0aGUgbG9jYXRpb25zIG9mIHRoZSBnbHlwaHMgaW4gdGhlIGZvbnQuXG4vLyBodHRwczovL3d3dy5taWNyb3NvZnQuY29tL3R5cG9ncmFwaHkvT1RTUEVDL2xvY2EuaHRtXG5cbi8vIFBhcnNlIHRoZSBgbG9jYWAgdGFibGUuIFRoaXMgdGFibGUgc3RvcmVzIHRoZSBvZmZzZXRzIHRvIHRoZSBsb2NhdGlvbnMgb2YgdGhlIGdseXBocyBpbiB0aGUgZm9udCxcbi8vIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGdseXBoRGF0YSB0YWJsZS5cbi8vIFRoZSBudW1iZXIgb2YgZ2x5cGhzIHN0b3JlZCBpbiB0aGUgYGxvY2FgIHRhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgYG1heHBgIHRhYmxlICh1bmRlciBudW1HbHlwaHMpXG4vLyBUaGUgbG9jYSB0YWJsZSBoYXMgdHdvIHZlcnNpb25zOiBhIHNob3J0IHZlcnNpb24gd2hlcmUgb2Zmc2V0cyBhcmUgc3RvcmVkIGFzIHVTaG9ydHMsIGFuZCBhIGxvbmdcbi8vIHZlcnNpb24gd2hlcmUgb2Zmc2V0cyBhcmUgc3RvcmVkIGFzIHVMb25ncy4gVGhlIGBoZWFkYCB0YWJsZSBzcGVjaWZpZXMgd2hpY2ggdmVyc2lvbiB0byB1c2Vcbi8vICh1bmRlciBpbmRleFRvTG9jRm9ybWF0KS5cbmZ1bmN0aW9uIHBhcnNlTG9jYVRhYmxlKGRhdGEsIHN0YXJ0LCBudW1HbHlwaHMsIHNob3J0VmVyc2lvbikge1xuICAgIHZhciBwID0gbmV3IHBhcnNlLlBhcnNlcihkYXRhLCBzdGFydCk7XG4gICAgdmFyIHBhcnNlRm4gPSBzaG9ydFZlcnNpb24gPyBwLnBhcnNlVVNob3J0IDogcC5wYXJzZVVMb25nO1xuICAgIC8vIFRoZXJlIGlzIGFuIGV4dHJhIGVudHJ5IGFmdGVyIHRoZSBsYXN0IGluZGV4IGVsZW1lbnQgdG8gY29tcHV0ZSB0aGUgbGVuZ3RoIG9mIHRoZSBsYXN0IGdseXBoLlxuICAgIC8vIFRoYXQncyB3aHkgd2UgdXNlIG51bUdseXBocyArIDEuXG4gICAgdmFyIGdseXBoT2Zmc2V0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtR2x5cGhzICsgMTsgaSArPSAxKSB7XG4gICAgICAgIHZhciBnbHlwaE9mZnNldCA9IHBhcnNlRm4uY2FsbChwKTtcbiAgICAgICAgaWYgKHNob3J0VmVyc2lvbikge1xuICAgICAgICAgICAgLy8gVGhlIHNob3J0IHRhYmxlIHZlcnNpb24gc3RvcmVzIHRoZSBhY3R1YWwgb2Zmc2V0IGRpdmlkZWQgYnkgMi5cbiAgICAgICAgICAgIGdseXBoT2Zmc2V0ICo9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBnbHlwaE9mZnNldHMucHVzaChnbHlwaE9mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdseXBoT2Zmc2V0cztcbn1cblxudmFyIGxvY2EgPSB7IHBhcnNlOiBwYXJzZUxvY2FUYWJsZSB9O1xuXG4vLyBvcGVudHlwZS5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVib3gvb3BlbnR5cGUuanNcbi8vIChjKSAyMDE1IEZyZWRlcmlrIERlIEJsZXNlclxuLy8gb3BlbnR5cGUuanMgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cbi8qIGdsb2JhbCBEYXRhVmlldywgVWludDhBcnJheSwgWE1MSHR0cFJlcXVlc3QgICovXG5cbi8qKlxuICogVGhlIG9wZW50eXBlIGxpYnJhcnkuXG4gKiBAbmFtZXNwYWNlIG9wZW50eXBlXG4gKi9cblxuLy8gRmlsZSBsb2FkZXJzIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gKiBMb2FkcyBhIGZvbnQgZnJvbSBhIGZpbGUuIFRoZSBjYWxsYmFjayB0aHJvd3MgYW4gZXJyb3IgbWVzc2FnZSBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIGlmIGl0IGZhaWxzXG4gKiBhbmQgdGhlIGZvbnQgYXMgYW4gQXJyYXlCdWZmZXIgaW4gdGhlIHNlY29uZCBwYXJhbWV0ZXIgaWYgaXQgc3VjY2VlZHMuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGggLSBUaGUgcGF0aCBvZiB0aGUgZmlsZVxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgZm9udCBsb2FkIGNvbXBsZXRlc1xuICovXG5mdW5jdGlvbiBsb2FkRnJvbUZpbGUocGF0aCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuICAgIGZzLnJlYWRGaWxlKHBhdGgsIGZ1bmN0aW9uKGVyciwgYnVmZmVyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjYWxsYmFjayhudWxsLCBub2RlQnVmZmVyVG9BcnJheUJ1ZmZlcihidWZmZXIpKTtcbiAgICB9KTtcbn1cbi8qKlxuICogTG9hZHMgYSBmb250IGZyb20gYSBVUkwuIFRoZSBjYWxsYmFjayB0aHJvd3MgYW4gZXJyb3IgbWVzc2FnZSBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIGlmIGl0IGZhaWxzXG4gKiBhbmQgdGhlIGZvbnQgYXMgYW4gQXJyYXlCdWZmZXIgaW4gdGhlIHNlY29uZCBwYXJhbWV0ZXIgaWYgaXQgc3VjY2VlZHMuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVybCAtIFRoZSBVUkwgb2YgdGhlIGZvbnQgZmlsZS5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIHdoZW4gdGhlIGZvbnQgbG9hZCBjb21wbGV0ZXNcbiAqL1xuZnVuY3Rpb24gbG9hZEZyb21VcmwodXJsLCBjYWxsYmFjaykge1xuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vcGVuKCdnZXQnLCB1cmwsIHRydWUpO1xuICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICByZXF1ZXN0Lm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocmVxdWVzdC5yZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCdGb250IGNvdWxkIG5vdCBiZSBsb2FkZWQ6ICcgKyByZXF1ZXN0LnN0YXR1c1RleHQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2soJ0ZvbnQgY291bGQgbm90IGJlIGxvYWRlZCcpO1xuICAgIH07XG5cbiAgICByZXF1ZXN0LnNlbmQoKTtcbn1cblxuLy8gVGFibGUgRGlyZWN0b3J5IEVudHJpZXMgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gKiBQYXJzZXMgT3BlblR5cGUgdGFibGUgZW50cmllcy5cbiAqIEBwYXJhbSAge0RhdGFWaWV3fVxuICogQHBhcmFtICB7TnVtYmVyfVxuICogQHJldHVybiB7T2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIHBhcnNlT3BlblR5cGVUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKSB7XG4gICAgdmFyIHRhYmxlRW50cmllcyA9IFtdO1xuICAgIHZhciBwID0gMTI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdGFnID0gcGFyc2UuZ2V0VGFnKGRhdGEsIHApO1xuICAgICAgICB2YXIgY2hlY2tzdW0gPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgNCk7XG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgOCk7XG4gICAgICAgIHZhciBsZW5ndGggPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgMTIpO1xuICAgICAgICB0YWJsZUVudHJpZXMucHVzaCh7dGFnOiB0YWcsIGNoZWNrc3VtOiBjaGVja3N1bSwgb2Zmc2V0OiBvZmZzZXQsIGxlbmd0aDogbGVuZ3RoLCBjb21wcmVzc2lvbjogZmFsc2V9KTtcbiAgICAgICAgcCArPSAxNjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGVFbnRyaWVzO1xufVxuXG4vKipcbiAqIFBhcnNlcyBXT0ZGIHRhYmxlIGVudHJpZXMuXG4gKiBAcGFyYW0gIHtEYXRhVmlld31cbiAqIEBwYXJhbSAge051bWJlcn1cbiAqIEByZXR1cm4ge09iamVjdFtdfVxuICovXG5mdW5jdGlvbiBwYXJzZVdPRkZUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKSB7XG4gICAgdmFyIHRhYmxlRW50cmllcyA9IFtdO1xuICAgIHZhciBwID0gNDQ7IC8vIG9mZnNldCB0byB0aGUgZmlyc3QgdGFibGUgZGlyZWN0b3J5IGVudHJ5LlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVGFibGVzOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHRhZyA9IHBhcnNlLmdldFRhZyhkYXRhLCBwKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHBhcnNlLmdldFVMb25nKGRhdGEsIHAgKyA0KTtcbiAgICAgICAgdmFyIGNvbXBMZW5ndGggPSBwYXJzZS5nZXRVTG9uZyhkYXRhLCBwICsgOCk7XG4gICAgICAgIHZhciBvcmlnTGVuZ3RoID0gcGFyc2UuZ2V0VUxvbmcoZGF0YSwgcCArIDEyKTtcbiAgICAgICAgdmFyIGNvbXByZXNzaW9uID0gKHZvaWQgMCk7XG4gICAgICAgIGlmIChjb21wTGVuZ3RoIDwgb3JpZ0xlbmd0aCkge1xuICAgICAgICAgICAgY29tcHJlc3Npb24gPSAnV09GRic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wcmVzc2lvbiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFibGVFbnRyaWVzLnB1c2goe3RhZzogdGFnLCBvZmZzZXQ6IG9mZnNldCwgY29tcHJlc3Npb246IGNvbXByZXNzaW9uLFxuICAgICAgICAgICAgY29tcHJlc3NlZExlbmd0aDogY29tcExlbmd0aCwgbGVuZ3RoOiBvcmlnTGVuZ3RofSk7XG4gICAgICAgIHAgKz0gMjA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhYmxlRW50cmllcztcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBUYWJsZURhdGFcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtEYXRhVmlld30gZGF0YSAtIFRoZSBEYXRhVmlld1xuICogQHByb3BlcnR5IHtudW1iZXJ9IG9mZnNldCAtIFRoZSBkYXRhIG9mZnNldC5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSAge0RhdGFWaWV3fVxuICogQHBhcmFtICB7T2JqZWN0fVxuICogQHJldHVybiB7VGFibGVEYXRhfVxuICovXG5mdW5jdGlvbiB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSkge1xuICAgIGlmICh0YWJsZUVudHJ5LmNvbXByZXNzaW9uID09PSAnV09GRicpIHtcbiAgICAgICAgdmFyIGluQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIHRhYmxlRW50cnkub2Zmc2V0ICsgMiwgdGFibGVFbnRyeS5jb21wcmVzc2VkTGVuZ3RoIC0gMik7XG4gICAgICAgIHZhciBvdXRCdWZmZXIgPSBuZXcgVWludDhBcnJheSh0YWJsZUVudHJ5Lmxlbmd0aCk7XG4gICAgICAgIHRpbnlJbmZsYXRlKGluQnVmZmVyLCBvdXRCdWZmZXIpO1xuICAgICAgICBpZiAob3V0QnVmZmVyLmJ5dGVMZW5ndGggIT09IHRhYmxlRW50cnkubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY29tcHJlc3Npb24gZXJyb3I6ICcgKyB0YWJsZUVudHJ5LnRhZyArICcgZGVjb21wcmVzc2VkIGxlbmd0aCBkb2VzblxcJ3QgbWF0Y2ggcmVjb3JkZWQgbGVuZ3RoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhvdXRCdWZmZXIuYnVmZmVyLCAwKTtcbiAgICAgICAgcmV0dXJuIHtkYXRhOiB2aWV3LCBvZmZzZXQ6IDB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7ZGF0YTogZGF0YSwgb2Zmc2V0OiB0YWJsZUVudHJ5Lm9mZnNldH07XG4gICAgfVxufVxuXG4vLyBQdWJsaWMgQVBJIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogUGFyc2UgdGhlIE9wZW5UeXBlIGZpbGUgZGF0YSAoYXMgYW4gQXJyYXlCdWZmZXIpIGFuZCByZXR1cm4gYSBGb250IG9iamVjdC5cbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgZm9udCBjb3VsZCBub3QgYmUgcGFyc2VkLlxuICogQHBhcmFtICB7QXJyYXlCdWZmZXJ9XG4gKiBAcmV0dXJuIHtvcGVudHlwZS5Gb250fVxuICovXG5mdW5jdGlvbiBwYXJzZUJ1ZmZlcihidWZmZXIpIHtcbiAgICB2YXIgaW5kZXhUb0xvY0Zvcm1hdDtcbiAgICB2YXIgbHRhZ1RhYmxlO1xuXG4gICAgLy8gU2luY2UgdGhlIGNvbnN0cnVjdG9yIGNhbiBhbHNvIGJlIGNhbGxlZCB0byBjcmVhdGUgbmV3IGZvbnRzIGZyb20gc2NyYXRjaCwgd2UgaW5kaWNhdGUgdGhpc1xuICAgIC8vIHNob3VsZCBiZSBhbiBlbXB0eSBmb250IHRoYXQgd2UnbGwgZmlsbCB3aXRoIG91ciBvd24gZGF0YS5cbiAgICB2YXIgZm9udCA9IG5ldyBGb250KHtlbXB0eTogdHJ1ZX0pO1xuXG4gICAgLy8gT3BlblR5cGUgZm9udHMgdXNlIGJpZyBlbmRpYW4gYnl0ZSBvcmRlcmluZy5cbiAgICAvLyBXZSBjYW4ndCByZWx5IG9uIHR5cGVkIGFycmF5IHZpZXcgdHlwZXMsIGJlY2F1c2UgdGhleSBvcGVyYXRlIHdpdGggdGhlIGVuZGlhbm5lc3Mgb2YgdGhlIGhvc3QgY29tcHV0ZXIuXG4gICAgLy8gSW5zdGVhZCB3ZSB1c2UgRGF0YVZpZXdzIHdoZXJlIHdlIGNhbiBzcGVjaWZ5IGVuZGlhbm5lc3MuXG4gICAgdmFyIGRhdGEgPSBuZXcgRGF0YVZpZXcoYnVmZmVyLCAwKTtcbiAgICB2YXIgbnVtVGFibGVzO1xuICAgIHZhciB0YWJsZUVudHJpZXMgPSBbXTtcbiAgICB2YXIgc2lnbmF0dXJlID0gcGFyc2UuZ2V0VGFnKGRhdGEsIDApO1xuICAgIGlmIChzaWduYXR1cmUgPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMCwgMSwgMCwgMCkgfHwgc2lnbmF0dXJlID09PSAndHJ1ZScgfHwgc2lnbmF0dXJlID09PSAndHlwMScpIHtcbiAgICAgICAgZm9udC5vdXRsaW5lc0Zvcm1hdCA9ICd0cnVldHlwZSc7XG4gICAgICAgIG51bVRhYmxlcyA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCA0KTtcbiAgICAgICAgdGFibGVFbnRyaWVzID0gcGFyc2VPcGVuVHlwZVRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpO1xuICAgIH0gZWxzZSBpZiAoc2lnbmF0dXJlID09PSAnT1RUTycpIHtcbiAgICAgICAgZm9udC5vdXRsaW5lc0Zvcm1hdCA9ICdjZmYnO1xuICAgICAgICBudW1UYWJsZXMgPSBwYXJzZS5nZXRVU2hvcnQoZGF0YSwgNCk7XG4gICAgICAgIHRhYmxlRW50cmllcyA9IHBhcnNlT3BlblR5cGVUYWJsZUVudHJpZXMoZGF0YSwgbnVtVGFibGVzKTtcbiAgICB9IGVsc2UgaWYgKHNpZ25hdHVyZSA9PT0gJ3dPRkYnKSB7XG4gICAgICAgIHZhciBmbGF2b3IgPSBwYXJzZS5nZXRUYWcoZGF0YSwgNCk7XG4gICAgICAgIGlmIChmbGF2b3IgPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMCwgMSwgMCwgMCkpIHtcbiAgICAgICAgICAgIGZvbnQub3V0bGluZXNGb3JtYXQgPSAndHJ1ZXR5cGUnO1xuICAgICAgICB9IGVsc2UgaWYgKGZsYXZvciA9PT0gJ09UVE8nKSB7XG4gICAgICAgICAgICBmb250Lm91dGxpbmVzRm9ybWF0ID0gJ2NmZic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIE9wZW5UeXBlIGZsYXZvciAnICsgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG51bVRhYmxlcyA9IHBhcnNlLmdldFVTaG9ydChkYXRhLCAxMik7XG4gICAgICAgIHRhYmxlRW50cmllcyA9IHBhcnNlV09GRlRhYmxlRW50cmllcyhkYXRhLCBudW1UYWJsZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgT3BlblR5cGUgc2lnbmF0dXJlICcgKyBzaWduYXR1cmUpO1xuICAgIH1cblxuICAgIHZhciBjZmZUYWJsZUVudHJ5O1xuICAgIHZhciBmdmFyVGFibGVFbnRyeTtcbiAgICB2YXIgZ2x5ZlRhYmxlRW50cnk7XG4gICAgdmFyIGdwb3NUYWJsZUVudHJ5O1xuICAgIHZhciBnc3ViVGFibGVFbnRyeTtcbiAgICB2YXIgaG10eFRhYmxlRW50cnk7XG4gICAgdmFyIGtlcm5UYWJsZUVudHJ5O1xuICAgIHZhciBsb2NhVGFibGVFbnRyeTtcbiAgICB2YXIgbmFtZVRhYmxlRW50cnk7XG4gICAgdmFyIG1ldGFUYWJsZUVudHJ5O1xuICAgIHZhciBwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1UYWJsZXM7IGkgKz0gMSkge1xuICAgICAgICB2YXIgdGFibGVFbnRyeSA9IHRhYmxlRW50cmllc1tpXTtcbiAgICAgICAgdmFyIHRhYmxlID0gKHZvaWQgMCk7XG4gICAgICAgIHN3aXRjaCAodGFibGVFbnRyeS50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NtYXAnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmNtYXAgPSBjbWFwLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC5lbmNvZGluZyA9IG5ldyBDbWFwRW5jb2RpbmcoZm9udC50YWJsZXMuY21hcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjdnQgJyA6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5jdnQgPSBwLnBhcnNlU2hvcnRMaXN0KHRhYmxlRW50cnkubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmdmFyJzpcbiAgICAgICAgICAgICAgICBmdmFyVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmcGdtJyA6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgcCA9IG5ldyBwYXJzZS5QYXJzZXIodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5mcGdtID0gcC5wYXJzZUJ5dGVMaXN0KHRhYmxlRW50cnkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIGZvbnQudGFibGVzLmhlYWQgPSBoZWFkLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC51bml0c1BlckVtID0gZm9udC50YWJsZXMuaGVhZC51bml0c1BlckVtO1xuICAgICAgICAgICAgICAgIGluZGV4VG9Mb2NGb3JtYXQgPSBmb250LnRhYmxlcy5oZWFkLmluZGV4VG9Mb2NGb3JtYXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdoaGVhJzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5oaGVhID0gaGhlYS5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQuYXNjZW5kZXIgPSBmb250LnRhYmxlcy5oaGVhLmFzY2VuZGVyO1xuICAgICAgICAgICAgICAgIGZvbnQuZGVzY2VuZGVyID0gZm9udC50YWJsZXMuaGhlYS5kZXNjZW5kZXI7XG4gICAgICAgICAgICAgICAgZm9udC5udW1iZXJPZkhNZXRyaWNzID0gZm9udC50YWJsZXMuaGhlYS5udW1iZXJPZkhNZXRyaWNzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG10eCc6XG4gICAgICAgICAgICAgICAgaG10eFRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbHRhZyc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgbHRhZ1RhYmxlID0gbHRhZy5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWF4cCc6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMubWF4cCA9IG1heHAucGFyc2UodGFibGUuZGF0YSwgdGFibGUub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBmb250Lm51bUdseXBocyA9IGZvbnQudGFibGVzLm1heHAubnVtR2x5cGhzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgICAgICAgbmFtZVRhYmxlRW50cnkgPSB0YWJsZUVudHJ5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnT1MvMic6XG4gICAgICAgICAgICAgICAgdGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgdGFibGVFbnRyeSk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMub3MyID0gb3MyLnBhcnNlKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwb3N0JzpcbiAgICAgICAgICAgICAgICB0YWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCB0YWJsZUVudHJ5KTtcbiAgICAgICAgICAgICAgICBmb250LnRhYmxlcy5wb3N0ID0gcG9zdC5wYXJzZSh0YWJsZS5kYXRhLCB0YWJsZS5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGZvbnQuZ2x5cGhOYW1lcyA9IG5ldyBHbHlwaE5hbWVzKGZvbnQudGFibGVzLnBvc3QpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncHJlcCcgOlxuICAgICAgICAgICAgICAgIHRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIHRhYmxlRW50cnkpO1xuICAgICAgICAgICAgICAgIHAgPSBuZXcgcGFyc2UuUGFyc2VyKHRhYmxlLmRhdGEsIHRhYmxlLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgZm9udC50YWJsZXMucHJlcCA9IHAucGFyc2VCeXRlTGlzdCh0YWJsZUVudHJ5Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdnbHlmJzpcbiAgICAgICAgICAgICAgICBnbHlmVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdsb2NhJzpcbiAgICAgICAgICAgICAgICBsb2NhVGFibGVFbnRyeSA9IHRhYmxlRW50cnk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdDRkYgJzpcbiAgICAgICAgICAgICAgICBjZmZUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2tlcm4nOlxuICAgICAgICAgICAgICAgIGtlcm5UYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0dQT1MnOlxuICAgICAgICAgICAgICAgIGdwb3NUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0dTVUInOlxuICAgICAgICAgICAgICAgIGdzdWJUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21ldGEnOlxuICAgICAgICAgICAgICAgIG1ldGFUYWJsZUVudHJ5ID0gdGFibGVFbnRyeTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuYW1lVGFibGUgPSB1bmNvbXByZXNzVGFibGUoZGF0YSwgbmFtZVRhYmxlRW50cnkpO1xuICAgIGZvbnQudGFibGVzLm5hbWUgPSBfbmFtZS5wYXJzZShuYW1lVGFibGUuZGF0YSwgbmFtZVRhYmxlLm9mZnNldCwgbHRhZ1RhYmxlKTtcbiAgICBmb250Lm5hbWVzID0gZm9udC50YWJsZXMubmFtZTtcblxuICAgIGlmIChnbHlmVGFibGVFbnRyeSAmJiBsb2NhVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgc2hvcnRWZXJzaW9uID0gaW5kZXhUb0xvY0Zvcm1hdCA9PT0gMDtcbiAgICAgICAgdmFyIGxvY2FUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBsb2NhVGFibGVFbnRyeSk7XG4gICAgICAgIHZhciBsb2NhT2Zmc2V0cyA9IGxvY2EucGFyc2UobG9jYVRhYmxlLmRhdGEsIGxvY2FUYWJsZS5vZmZzZXQsIGZvbnQubnVtR2x5cGhzLCBzaG9ydFZlcnNpb24pO1xuICAgICAgICB2YXIgZ2x5ZlRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGdseWZUYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC5nbHlwaHMgPSBnbHlmLnBhcnNlKGdseWZUYWJsZS5kYXRhLCBnbHlmVGFibGUub2Zmc2V0LCBsb2NhT2Zmc2V0cywgZm9udCk7XG4gICAgfSBlbHNlIGlmIChjZmZUYWJsZUVudHJ5KSB7XG4gICAgICAgIHZhciBjZmZUYWJsZSA9IHVuY29tcHJlc3NUYWJsZShkYXRhLCBjZmZUYWJsZUVudHJ5KTtcbiAgICAgICAgY2ZmLnBhcnNlKGNmZlRhYmxlLmRhdGEsIGNmZlRhYmxlLm9mZnNldCwgZm9udCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb250IGRvZXNuXFwndCBjb250YWluIFRydWVUeXBlIG9yIENGRiBvdXRsaW5lcy4nKTtcbiAgICB9XG5cbiAgICB2YXIgaG10eFRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGhtdHhUYWJsZUVudHJ5KTtcbiAgICBobXR4LnBhcnNlKGhtdHhUYWJsZS5kYXRhLCBobXR4VGFibGUub2Zmc2V0LCBmb250Lm51bWJlck9mSE1ldHJpY3MsIGZvbnQubnVtR2x5cGhzLCBmb250LmdseXBocyk7XG4gICAgYWRkR2x5cGhOYW1lcyhmb250KTtcblxuICAgIGlmIChrZXJuVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIga2VyblRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGtlcm5UYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC5rZXJuaW5nUGFpcnMgPSBrZXJuLnBhcnNlKGtlcm5UYWJsZS5kYXRhLCBrZXJuVGFibGUub2Zmc2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb250Lmtlcm5pbmdQYWlycyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChncG9zVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgZ3Bvc1RhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGdwb3NUYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC50YWJsZXMuZ3BvcyA9IGdwb3MucGFyc2UoZ3Bvc1RhYmxlLmRhdGEsIGdwb3NUYWJsZS5vZmZzZXQpO1xuICAgIH1cblxuICAgIGlmIChnc3ViVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgZ3N1YlRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGdzdWJUYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC50YWJsZXMuZ3N1YiA9IGdzdWIucGFyc2UoZ3N1YlRhYmxlLmRhdGEsIGdzdWJUYWJsZS5vZmZzZXQpO1xuICAgIH1cblxuICAgIGlmIChmdmFyVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgZnZhclRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIGZ2YXJUYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC50YWJsZXMuZnZhciA9IGZ2YXIucGFyc2UoZnZhclRhYmxlLmRhdGEsIGZ2YXJUYWJsZS5vZmZzZXQsIGZvbnQubmFtZXMpO1xuICAgIH1cblxuICAgIGlmIChtZXRhVGFibGVFbnRyeSkge1xuICAgICAgICB2YXIgbWV0YVRhYmxlID0gdW5jb21wcmVzc1RhYmxlKGRhdGEsIG1ldGFUYWJsZUVudHJ5KTtcbiAgICAgICAgZm9udC50YWJsZXMubWV0YSA9IG1ldGEucGFyc2UobWV0YVRhYmxlLmRhdGEsIG1ldGFUYWJsZS5vZmZzZXQpO1xuICAgICAgICBmb250Lm1ldGFzID0gZm9udC50YWJsZXMubWV0YTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9udDtcbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBsb2FkIHRoZSBmb250IGZyb20gYSBVUkwgb3IgYSBmaWxlc3lzdGVtLiBXaGVuIGRvbmUsIGNhbGwgdGhlIGNhbGxiYWNrXG4gKiB3aXRoIHR3byBhcmd1bWVudHMgYChlcnIsIGZvbnQpYC4gVGhlIGBlcnJgIHdpbGwgYmUgbnVsbCBvbiBzdWNjZXNzLFxuICogdGhlIGBmb250YCBpcyBhIEZvbnQgb2JqZWN0LlxuICogV2UgdXNlIHRoZSBub2RlLmpzIGNhbGxiYWNrIGNvbnZlbnRpb24gc28gdGhhdFxuICogb3BlbnR5cGUuanMgY2FuIGludGVncmF0ZSB3aXRoIGZyYW1ld29ya3MgbGlrZSBhc3luYy5qcy5cbiAqIEBhbGlhcyBvcGVudHlwZS5sb2FkXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHVybCAtIFRoZSBVUkwgb2YgdGhlIGZvbnQgdG8gbG9hZC5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gbG9hZCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGlzTm9kZSQkMSA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuICAgIHZhciBsb2FkRm4gPSBpc05vZGUkJDEgPyBsb2FkRnJvbUZpbGUgOiBsb2FkRnJvbVVybDtcbiAgICBsb2FkRm4odXJsLCBmdW5jdGlvbihlcnIsIGFycmF5QnVmZmVyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb250O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9udCA9IHBhcnNlQnVmZmVyKGFycmF5QnVmZmVyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBmb250KTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IGxvYWQgdGhlIGZvbnQgZnJvbSBhIFVSTCBvciBmaWxlLlxuICogV2hlbiBkb25lLCByZXR1cm5zIHRoZSBmb250IG9iamVjdCBvciB0aHJvd3MgYW4gZXJyb3IuXG4gKiBAYWxpYXMgb3BlbnR5cGUubG9hZFN5bmNcbiAqIEBwYXJhbSAge3N0cmluZ30gdXJsIC0gVGhlIFVSTCBvZiB0aGUgZm9udCB0byBsb2FkLlxuICogQHJldHVybiB7b3BlbnR5cGUuRm9udH1cbiAqL1xuZnVuY3Rpb24gbG9hZFN5bmModXJsKSB7XG4gICAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgICB2YXIgYnVmZmVyID0gZnMucmVhZEZpbGVTeW5jKHVybCk7XG4gICAgcmV0dXJuIHBhcnNlQnVmZmVyKG5vZGVCdWZmZXJUb0FycmF5QnVmZmVyKGJ1ZmZlcikpO1xufVxuXG5leHBvcnRzLkZvbnQgPSBGb250O1xuZXhwb3J0cy5HbHlwaCA9IEdseXBoO1xuZXhwb3J0cy5QYXRoID0gUGF0aDtcbmV4cG9ydHMuQm91bmRpbmdCb3ggPSBCb3VuZGluZ0JveDtcbmV4cG9ydHMuX3BhcnNlID0gcGFyc2U7XG5leHBvcnRzLnBhcnNlID0gcGFyc2VCdWZmZXI7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy5sb2FkU3luYyA9IGxvYWRTeW5jO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b3BlbnR5cGUuanMubWFwXG4iLCJpbXBvcnQgUGF0aCBmcm9tICcuL2dsY2F0LXBhdGgnO1xuXG5jb25zdCBnbHNsaWZ5ID0gcmVxdWlyZSggJ2dsc2xpZnknICk7XG5cbmxldCByZXF1aXJlZEZpZWxkcyA9ICggb2JqZWN0LCBuYW5pdGhlZnVjaywgZmllbGRzICkgPT4ge1xuICBmaWVsZHMubWFwKCBmaWVsZCA9PiB7XG4gICAgaWYgKCB0eXBlb2Ygb2JqZWN0WyBmaWVsZCBdID09PSBcInVuZGVmaW5lZFwiICkge1xuICAgICAgdGhyb3cgXCJHTENhdC1QYXRoOiBcIiArIGZpZWxkICsgXCIgaXMgcmVxdWlyZWQgZm9yIFwiICsgbmFuaXRoZWZ1Y2s7XG4gICAgfVxuICB9ICk7XG59O1xuXG5sZXQgUGF0aEdVSSA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCBnbENhdCwgcGFyYW1zICkge1xuICAgIHN1cGVyKCBnbENhdCwgcGFyYW1zICk7XG4gICAgbGV0IGl0ID0gdGhpcztcblxuICAgIHJlcXVpcmVkRmllbGRzKCBwYXJhbXMsIFwicGFyYW1zXCIsIFtcbiAgICAgIFwiY2FudmFzXCIsXG4gICAgICBcImVsXCJcbiAgICBdICk7XG5cbiAgICBpdC5ndWkgPSB7IHBhcmVudDogaXQucGFyYW1zLmVsIH07XG5cbiAgICBpdC5ndWkuaW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic3BhblwiICk7XG4gICAgaXQuZ3VpLnBhcmVudC5hcHBlbmRDaGlsZCggaXQuZ3VpLmluZm8gKTtcbiAgICBcbiAgICBpdC5ndWkucmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcbiAgICBpdC5ndWkucmFuZ2UudHlwZSA9IFwicmFuZ2VcIjtcbiAgICBpdC5ndWkucmFuZ2UubWluID0gMDtcbiAgICBpdC5ndWkucmFuZ2UubWF4ID0gMDtcbiAgICBpdC5ndWkucmFuZ2Uuc3RlcCA9IDE7XG4gICAgaXQuZ3VpLnBhcmVudC5hcHBlbmRDaGlsZCggaXQuZ3VpLnJhbmdlICk7XG5cbiAgICBpdC5kYXRlTGlzdCA9IG5ldyBBcnJheSggMzAgKS5maWxsKCAwICk7XG4gICAgaXQuZGF0ZUxpc3RJbmRleCA9IDA7XG4gICAgaXQudG90YWxGcmFtZXMgPSAwO1xuICAgIGl0LmZwcyA9IDA7XG4gICAgaXQuY3VycmVudEluZGV4ID0gMDtcbiAgICBpdC52aWV3TmFtZSA9IFwiXCI7XG4gICAgaXQudmlld0luZGV4ID0gMDtcblxuICAgIGxldCBnbCA9IGdsQ2F0LmdsO1xuICAgIGxldCB2Ym9RdWFkID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBbIC0xLCAtMSwgMSwgLTEsIC0xLCAxLCAxLCAxIF0gKTtcbiAgICBpdC5hZGQoIHtcbiAgICAgIF9fUGF0aEd1aVJldHVybjoge1xuICAgICAgICB3aWR0aDogaXQucGFyYW1zLmNhbnZhcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBpdC5wYXJhbXMuY2FudmFzLmhlaWdodCxcbiAgICAgICAgdmVydDogXCJhdHRyaWJ1dGUgdmVjMiBwO3ZvaWQgbWFpbigpe2dsX1Bvc2l0aW9uPXZlYzQocCwwLDEpO31cIixcbiAgICAgICAgZnJhZzogXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dW5pZm9ybSB2ZWMyIHI7dW5pZm9ybSBzYW1wbGVyMkQgczt2b2lkIG1haW4oKXtnbF9GcmFnQ29sb3I9dGV4dHVyZTJEKHMsZ2xfRnJhZ0Nvb3JkLnh5L3IpO31cIixcbiAgICAgICAgYmxlbmQ6IFsgZ2wuT05FLCBnbC5PTkUgXSxcbiAgICAgICAgY2xlYXI6IFsgMC4wLCAwLjAsIDAuMCwgMS4wIF0sXG4gICAgICAgIGZ1bmM6ICggX3AsIHBhcmFtcyApID0+IHtcbiAgICAgICAgICBnbC52aWV3cG9ydCggMCwgMCwgaXQucGFyYW1zLmNhbnZhcy53aWR0aCwgaXQucGFyYW1zLmNhbnZhcy5oZWlnaHQgKTtcbiAgICAgICAgICBnbENhdC51bmlmb3JtMmZ2KCAncicsIFsgaXQucGFyYW1zLmNhbnZhcy53aWR0aCwgaXQucGFyYW1zLmNhbnZhcy5oZWlnaHQgXSApO1xuICAgIFxuICAgICAgICAgIGdsQ2F0LmF0dHJpYnV0ZSggJ3AnLCB2Ym9RdWFkLCAyICk7XG4gICAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzJywgcGFyYW1zLmlucHV0LCAwICk7XG4gICAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICB9ICk7XG4gIH1cblxuICBiZWdpbigpIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuXG4gICAgaXQuY3VycmVudEluZGV4ID0gMDtcbiAgfVxuXG4gIGVuZCgpIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuXG4gICAgaXQuZ3VpLnJhbmdlLm1heCA9IE1hdGgubWF4KCBpdC5ndWkucmFuZ2UubWF4LCBpdC5jdXJyZW50SW5kZXggKTtcbiAgICBpdC5jdXJyZW50SW5kZXggPSAwO1xuXG4gICAgbGV0IG5vdyA9ICtuZXcgRGF0ZSgpICogMUUtMztcbiAgICBpdC5kYXRlTGlzdFsgaXQuZGF0ZUxpc3RJbmRleCBdID0gbm93O1xuICAgIGl0LmRhdGVMaXN0SW5kZXggPSAoIGl0LmRhdGVMaXN0SW5kZXggKyAxICkgJSBpdC5kYXRlTGlzdC5sZW5ndGg7XG4gICAgaXQuZnBzID0gKFxuICAgICAgKCBpdC5kYXRlTGlzdC5sZW5ndGggLSAxIClcbiAgICAgIC8gKCBub3cgLSBpdC5kYXRlTGlzdFsgaXQuZGF0ZUxpc3RJbmRleCBdIClcbiAgICApLnRvRml4ZWQoIDEgKTtcbiAgICBcbiAgICBpdC50b3RhbEZyYW1lcyArKztcblxuICAgIGl0Lmd1aS5pbmZvLmlubmVyVGV4dCA9IChcbiAgICAgIFwiUGF0aDogXCIgKyBpdC52aWV3TmFtZSArIFwiIChcIiArIGl0LnZpZXdJbmRleCArIFwiKVxcblwiXG4gICAgICArIGl0LmZwcyArIFwiIEZQU1xcblwiXG4gICAgICArIGl0LnRvdGFsRnJhbWVzICsgXCIgZnJhbWVzXFxuXCJcbiAgICApO1xuICB9XG5cbiAgcmVuZGVyKCBuYW1lLCBwYXJhbXMgKSB7XG4gICAgbGV0IGl0ID0gdGhpcztcbiAgICBcbiAgICBpdC5jdXJyZW50SW5kZXggKys7XG4gICAgbGV0IHZpZXcgPSBwYXJzZUludCggaXQuZ3VpLnJhbmdlLnZhbHVlICk7XG5cbiAgICBpZiAoIGl0LmN1cnJlbnRJbmRleCA8PSB2aWV3IHx8IHZpZXcgPT09IDAgKSB7XG4gICAgICBpdC52aWV3TmFtZSA9IHZpZXcgPT09IDAgPyBcIipGdWxsKlwiIDogbmFtZTtcbiAgICAgIGl0LnZpZXdJbmRleCA9IGl0LmN1cnJlbnRJbmRleDtcblxuICAgICAgc3VwZXIucmVuZGVyKCBuYW1lLCBwYXJhbXMgKTtcblxuICAgICAgaWYgKCBpdC5jdXJyZW50SW5kZXggPT09IHZpZXcgKSB7XG4gICAgICAgIGxldCB0ID0gKFxuICAgICAgICAgICggcGFyYW1zICYmIHBhcmFtcy50YXJnZXQgKVxuICAgICAgICAgID8gcGFyYW1zLnRhcmdldFxuICAgICAgICAgIDogaXQucGF0aHNbIG5hbWUgXS5mcmFtZWJ1ZmZlclxuICAgICAgICApO1xuXG4gICAgICAgIGlmICggdCAmJiB0LmZyYW1lYnVmZmVyICkge1xuICAgICAgICAgIGxldCBpID0gdC50ZXh0dXJlcyA/IHQudGV4dHVyZXNbIDAgXSA6IHQudGV4dHVyZTtcbiAgICAgICAgICBpZiAoIGl0LnBhcmFtcy5zdHJldGNoICkge1xuICAgICAgICAgICAgc3VwZXIucmVuZGVyKCBcIl9fUGF0aEd1aVJldHVyblwiLCB7XG4gICAgICAgICAgICAgIHRhcmdldDogUGF0aEdVSS5udWxsRmIsXG4gICAgICAgICAgICAgIGlucHV0OiBpLFxuICAgICAgICAgICAgICB3aWR0aDogaXQucGFyYW1zLmNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgICAgaGVpZ2h0OiBpdC5wYXJhbXMuY2FudmFzLmhlaWdodFxuICAgICAgICAgICAgfSApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpdC5wYXJhbXMuY2FudmFzLndpZHRoID0gKCBwYXJhbXMgPyBwYXJhbXMud2lkdGggOiAwICkgfHwgaXQucGF0aHNbIG5hbWUgXS53aWR0aCB8fCBpdC5wYXJhbXMud2lkdGg7XG4gICAgICAgICAgICBpdC5wYXJhbXMuY2FudmFzLmhlaWdodCA9ICggcGFyYW1zID8gcGFyYW1zLmhlaWdodCA6IDAgKSB8fCBpdC5wYXRoc1sgbmFtZSBdLmhlaWdodCB8fCBpdC5wYXJhbXMuaGVpZ2h0O1xuICAgICAgICAgICAgc3VwZXIucmVuZGVyKCBcIl9fUGF0aEd1aVJldHVyblwiLCB7XG4gICAgICAgICAgICAgIHRhcmdldDogUGF0aEdVSS5udWxsRmIsXG4gICAgICAgICAgICAgIGlucHV0OiBpXG4gICAgICAgICAgICB9ICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBQYXRoR1VJOyIsImNvbnN0IGdsc2xpZnkgPSByZXF1aXJlKCAnZ2xzbGlmeScgKTtcblxubGV0IHJlcXVpcmVkRmllbGRzID0gKCBvYmplY3QsIG5hbml0aGVmdWNrLCBmaWVsZHMgKSA9PiB7XG4gIGZpZWxkcy5tYXAoIGZpZWxkID0+IHtcbiAgICBpZiAoIHR5cGVvZiBvYmplY3RbIGZpZWxkIF0gPT09IFwidW5kZWZpbmVkXCIgKSB7XG4gICAgICB0aHJvdyBcIkdMQ2F0LVBhdGg6IFwiICsgZmllbGQgKyBcIiBpcyByZXF1aXJlZCBmb3IgXCIgKyBuYW5pdGhlZnVjaztcbiAgICB9XG4gIH0gKTtcbn07XG5cbmxldCBQYXRoID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvciggZ2xDYXQsIHBhcmFtcyApIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuXG4gICAgaXQuZ2xDYXQgPSBnbENhdDtcbiAgICBpdC5nbCA9IGdsQ2F0LmdsO1xuXG4gICAgaXQucGF0aHMgPSB7fTtcbiAgICBpdC5nbG9iYWxGdW5jID0gKCkgPT4ge307XG4gICAgaXQucGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICB9XG5cbiAgYWRkKCBwYXRocyApIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuXG4gICAgZm9yICggbGV0IG5hbWUgaW4gcGF0aHMgKSB7XG4gICAgICBsZXQgcGF0aCA9IHBhdGhzWyBuYW1lIF07XG4gICAgICByZXF1aXJlZEZpZWxkcyggcGF0aCwgXCJwYXRoIG9iamVjdFwiLCBbXG4gICAgICAgIFwidmVydFwiLFxuICAgICAgICBcImZyYWdcIlxuICAgICAgXSApO1xuICAgICAgaXQucGF0aHNbIG5hbWUgXSA9IHBhdGg7XG5cbiAgICAgIGlmICggdHlwZW9mIHBhdGguZGVwdGhUZXN0ID09PSBcInVuZGVmaW5lZFwiICkgeyBwYXRoLmRlcHRoVGVzdCA9IHRydWU7IH1cbiAgICAgIGlmICggdHlwZW9mIHBhdGguZGVwdGhXcml0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHsgcGF0aC5kZXB0aFdyaXRlID0gdHJ1ZTsgfVxuICAgICAgaWYgKCB0eXBlb2YgcGF0aC5ibGVuZCA9PT0gXCJ1bmRlZmluZWRcIiApIHsgcGF0aC5ibGVuZCA9IFsgaXQuZ2wuU1JDX0FMUEhBLCBpdC5nbC5PTkVfTUlOVVNfU1JDX0FMUEhBIF07IH1cbiAgICAgIGlmICggdHlwZW9mIHBhdGguY3VsbCA9PT0gXCJ1bmRlZmluZWRcIiApIHsgcGF0aC5jdWxsID0gdHJ1ZTsgfVxuICAgICAgXG4gICAgICBpZiAoIHBhdGguZnJhbWVidWZmZXIgKSB7XG4gICAgICAgIGlmICggcGF0aC5kcmF3YnVmZmVycyApIHtcbiAgICAgICAgICBwYXRoLmZyYW1lYnVmZmVyID0gaXQuZ2xDYXQuY3JlYXRlRHJhd0J1ZmZlcnMoIHBhdGgud2lkdGgsIHBhdGguaGVpZ2h0LCBwYXRoLmRyYXdidWZmZXJzICk7XG4gICAgICAgIH0gZWxzZSBpZiAoIHBhdGguZmxvYXQgKSB7XG4gICAgICAgICAgcGF0aC5mcmFtZWJ1ZmZlciA9IGl0LmdsQ2F0LmNyZWF0ZUZsb2F0RnJhbWVidWZmZXIoIHBhdGgud2lkdGgsIHBhdGguaGVpZ2h0ICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aC5mcmFtZWJ1ZmZlciA9IGl0LmdsQ2F0LmNyZWF0ZUZyYW1lYnVmZmVyKCBwYXRoLndpZHRoLCBwYXRoLmhlaWdodCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBhdGgucHJvZ3JhbSA9IGl0LmdsQ2F0LmNyZWF0ZVByb2dyYW0oIHBhdGgudmVydCwgcGF0aC5mcmFnICk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyKCBuYW1lLCBwYXJhbXMgKSB7XG4gICAgbGV0IGl0ID0gdGhpcztcbiBcbiAgICBsZXQgcGF0aCA9IGl0LnBhdGhzWyBuYW1lIF07XG4gICAgaWYgKCAhcGF0aCApIHsgdGhyb3cgXCJHTENhdC1QYXRoOiBUaGUgcGF0aCBjYWxsZWQgXCIgKyBuYW1lICsgXCIgaXMgbm90IGRlZmluZWQhXCI7IH1cbiAgICBcbiAgICBpZiAoICFwYXJhbXMgKSB7IHBhcmFtcyA9IHt9OyB9XG4gICAgcGFyYW1zLmZyYW1lYnVmZmVyID0gdHlwZW9mIHBhcmFtcy50YXJnZXQgIT09IFwidW5kZWZpbmVkXCIgPyBwYXJhbXMudGFyZ2V0LmZyYW1lYnVmZmVyIDogcGF0aC5mcmFtZWJ1ZmZlciA/IHBhdGguZnJhbWVidWZmZXIuZnJhbWVidWZmZXIgOiBudWxsO1xuXG4gICAgbGV0IHdpZHRoID0gcGFyYW1zLndpZHRoIHx8IHBhdGgud2lkdGg7XG4gICAgbGV0IGhlaWdodCA9IHBhcmFtcy5oZWlnaHQgfHwgcGF0aC5oZWlnaHQ7XG5cbiAgICBpZiAoICF3aWR0aCB8fCAhaGVpZ2h0ICkge1xuICAgICAgdGhyb3cgJ0dMQ2F0LVBhdGg6IHdpZHRoIG9yIGhlaWdodCBpcyBpbnZhbGlkJztcbiAgICB9XG4gICAgXG4gICAgaXQuZ2wudmlld3BvcnQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcbiAgICBpdC5nbENhdC51c2VQcm9ncmFtKCBwYXRoLnByb2dyYW0gKTtcbiAgICBwYXRoLmN1bGwgPyBpdC5nbC5lbmFibGUoIGl0LmdsLkNVTExfRkFDRSApIDogaXQuZ2wuZGlzYWJsZSggaXQuZ2wuQ1VMTF9GQUNFICk7XG4gICAgaXQuZ2wuYmluZEZyYW1lYnVmZmVyKCBpdC5nbC5GUkFNRUJVRkZFUiwgcGFyYW1zLmZyYW1lYnVmZmVyICk7XG4gICAgaWYgKCBpdC5wYXJhbXMuZHJhd2J1ZmZlcnMgKSB7XG4gICAgICBpdC5nbENhdC5kcmF3QnVmZmVycyggcGF0aC5kcmF3YnVmZmVycyA/IHBhdGguZHJhd2J1ZmZlcnMgOiBwYXJhbXMuZnJhbWVidWZmZXIgPT09IG51bGwgPyBbIGl0LmdsLkJBQ0sgXSA6IFsgaXQuZ2wuQ09MT1JfQVRUQUNITUVOVDAgXSApO1xuICAgIH1cbiAgICBpdC5nbC5ibGVuZEZ1bmMoIC4uLnBhdGguYmxlbmQgKTtcbiAgICBpZiAoIHBhdGguY2xlYXIgKSB7IGl0LmdsQ2F0LmNsZWFyKCAuLi5wYXRoLmNsZWFyICk7IH1cbiAgICBwYXRoLmRlcHRoVGVzdCA/IGl0LmdsLmVuYWJsZSggaXQuZ2wuREVQVEhfVEVTVCApIDogaXQuZ2wuZGlzYWJsZSggaXQuZ2wuREVQVEhfVEVTVCApO1xuICAgIHBhdGguZGVwdGhXcml0ZSA/IGl0LmdsLmRlcHRoTWFzayggdHJ1ZSApIDogaXQuZ2wuZGVwdGhNYXNrKCBmYWxzZSApO1xuIFxuICAgIGl0LmdsQ2F0LnVuaWZvcm0yZnYoICdyZXNvbHV0aW9uJywgWyB3aWR0aCwgaGVpZ2h0IF0gKTtcbiAgICBpdC5nbG9iYWxGdW5jKCBwYXRoLCBwYXJhbXMgKTtcblxuICAgIGlmICggcGF0aC5mdW5jICkgeyBwYXRoLmZ1bmMoIHBhdGgsIHBhcmFtcyApOyB9XG4gIH1cblxuICByZXNpemUoIG5hbWUsIHdpZHRoLCBoZWlnaHQgKSB7XG4gICAgbGV0IGl0ID0gdGhpcztcblxuICAgIGxldCBwYXRoID0gaXQucGF0aHNbIG5hbWUgXTtcblxuICAgIHBhdGgud2lkdGggPSB3aWR0aDtcbiAgICBwYXRoLmhlaWdodCA9IGhlaWdodDtcblxuICAgIGlmICggcGF0aC5mcmFtZWJ1ZmZlciApIHtcbiAgICAgIGlmICggaXQucGFyYW1zLmRyYXdidWZmZXJzICYmIHBhdGguZHJhd2J1ZmZlcnMgKSB7XG4gICAgICAgIHBhdGguZnJhbWVidWZmZXIgPSBpdC5nbENhdC5jcmVhdGVEcmF3QnVmZmVycyggcGF0aC53aWR0aCwgcGF0aC5oZWlnaHQsIHBhdGguZHJhd2J1ZmZlcnMgKTtcbiAgICAgIH0gZWxzZSBpZiAoIHBhdGguZmxvYXQgKSB7XG4gICAgICAgIGl0LmdsQ2F0LnJlc2l6ZUZsb2F0RnJhbWVidWZmZXIoIHBhdGguZnJhbWVidWZmZXIsIHBhdGgud2lkdGgsIHBhdGguaGVpZ2h0ICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdC5nbENhdC5yZXNpemVGcmFtZWJ1ZmZlciggcGF0aC5mcmFtZWJ1ZmZlciwgcGF0aC53aWR0aCwgcGF0aC5oZWlnaHQgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIHR5cGVvZiBwYXRoLm9ucmVzaXplID09PSBcImZ1bmN0aW9uXCIgKSB7XG4gICAgICBwYXRoLm9ucmVzaXplKCBwYXRoLCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgfVxuICB9XG5cbiAgc2V0R2xvYmFsRnVuYyggZnVuYyApIHsgdGhpcy5nbG9iYWxGdW5jID0gZnVuYzsgfVxuXG4gIGZiKCBuYW1lICkge1xuICAgIGlmICggIXRoaXMucGF0aHNbIG5hbWUgXSApIHsgdGhyb3cgXCJnbGNhdC1wYXRoLmZiOiBwYXRoIGNhbGxlZCBcIiArIG5hbWUgKyBcIiBpcyBub3QgZGVmaW5lZFwiOyB9XG4gICAgaWYgKCAhdGhpcy5wYXRoc1sgbmFtZSBdLmZyYW1lYnVmZmVyICkgeyB0aHJvdyBcImdsY2F0LXBhdGguZmI6IHRoZXJlIGlzIG5vIGZyYW1lYnVmZmVyIGZvciB0aGUgcGF0aCBcIiArIG5hbWU7IH1cblxuICAgIHJldHVybiB0aGlzLnBhdGhzWyBuYW1lIF0uZnJhbWVidWZmZXI7XG4gIH1cbn07XG5cblBhdGgubnVsbEZiID0geyBmcmFtZWJ1ZmZlcjogbnVsbCB9O1xuXG5leHBvcnQgZGVmYXVsdCBQYXRoOyIsImxldCBHTENhdCA9IGNsYXNzIHtcblx0Y29uc3RydWN0b3IoIF9nbCApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXG5cdFx0aXQuZ2wgPSBfZ2w7XG4gICAgbGV0IGdsID0gaXQuZ2w7XG5cblx0ICBnbC5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcblx0ICBnbC5kZXB0aEZ1bmMoIGdsLkxFUVVBTCApO1xuXHQgIGdsLmVuYWJsZSggZ2wuQkxFTkQgKTtcblx0ICBnbC5ibGVuZEZ1bmMoIGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xuXG5cdFx0aXQuZXh0ZW5zaW9ucyA9IHt9O1xuXG5cdFx0aXQuY3VycmVudFByb2dyYW0gPSBudWxsO1xuXHR9XG5cblx0Z2V0RXh0ZW5zaW9uKCBfbmFtZSwgX3Rocm93ICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG4gICAgbGV0IGdsID0gaXQuZ2w7XG5cblx0XHRpZiAoIHR5cGVvZiBfbmFtZSA9PT0gXCJvYmplY3RcIiAmJiBfbmFtZS5pc0FycmF5KCkgKSB7XG5cdFx0XHRyZXR1cm4gX25hbWUuZXZlcnkoIG5hbWUgPT4gaXQuZ2V0RXh0ZW5zaW9uKCBuYW1lLCBfdGhyb3cgKSApO1xuXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBfbmFtZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGlmICggaXQuZXh0ZW5zaW9uc1sgX25hbWUgXSApIHtcblx0XHRcdFx0cmV0dXJuIGl0LmV4dGVuc2lvbnNbIF9uYW1lIF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpdC5leHRlbnNpb25zWyBfbmFtZSBdID0gZ2wuZ2V0RXh0ZW5zaW9uKCBfbmFtZSApO1xuXHRcdFx0XHRpZiAoIGl0LmV4dGVuc2lvbnNbIF9uYW1lIF0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGl0LmV4dGVuc2lvbnNbIF9uYW1lIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBfdGhyb3cgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBjb25zb2xlLmVycm9yKCBcIlRoZSBleHRlbnNpb24gXFxcIlwiICsgX25hbWUgKyBcIlxcXCIgaXMgbm90IHN1cHBvcnRlZFwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICEhKCBpdC5leHRlbnNpb25zWyBfbmFtZSBdICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IFwiR0xDYXQuZ2V0RXh0ZW5zaW9uOiBfbmFtZSBtdXN0IGJlIHN0cmluZyBvciBhcnJheVwiXG5cdFx0fVxuXHR9XG5cblx0Y3JlYXRlUHJvZ3JhbSggX3ZlcnQsIF9mcmFnLCBfb25FcnJvciApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0bGV0IGVycm9yO1xuXHRcdGlmICggdHlwZW9mIF9vbkVycm9yID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0ZXJyb3IgPSBfb25FcnJvcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXJyb3IgPSAoIF9zdHIgKSA9PiB7IGNvbnNvbGUuZXJyb3IoIF9zdHIgKTsgfVxuXHRcdH1cblxuXHRcdGxldCB2ZXJ0ID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XG5cdFx0Z2wuc2hhZGVyU291cmNlKCB2ZXJ0LCBfdmVydCApO1xuXHRcdGdsLmNvbXBpbGVTaGFkZXIoIHZlcnQgKTtcblx0XHRpZiAoICFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoIHZlcnQsIGdsLkNPTVBJTEVfU1RBVFVTICkgKSB7XG5cdFx0XHRlcnJvciggZ2wuZ2V0U2hhZGVySW5mb0xvZyggdmVydCApICk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRsZXQgZnJhZyA9IGdsLmNyZWF0ZVNoYWRlciggZ2wuRlJBR01FTlRfU0hBREVSICk7XG5cdFx0Z2wuc2hhZGVyU291cmNlKCBmcmFnLCBfZnJhZyApO1xuXHRcdGdsLmNvbXBpbGVTaGFkZXIoIGZyYWcgKTtcblx0XHRpZiAoICFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoIGZyYWcsIGdsLkNPTVBJTEVfU1RBVFVTICkgKSB7XG5cdFx0XHRlcnJvciggZ2wuZ2V0U2hhZGVySW5mb0xvZyggZnJhZyApICk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRsZXQgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcblx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIHZlcnQgKTtcblx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGZyYWcgKTtcblx0XHRnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xuXHRcdGlmICggZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMgKSApIHtcblx0ICAgIHByb2dyYW0ubG9jYXRpb25zID0ge307XG5cdFx0XHRyZXR1cm4gcHJvZ3JhbTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXJyb3IoIGdsLmdldFByb2dyYW1JbmZvTG9nKCBwcm9ncmFtICkgKTtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXG5cdHVzZVByb2dyYW0oIF9wcm9ncmFtICkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0XHRnbC51c2VQcm9ncmFtKCBfcHJvZ3JhbSApO1xuXHRcdGl0LmN1cnJlbnRQcm9ncmFtID0gX3Byb2dyYW07XG5cdH1cblxuXHRjcmVhdGVWZXJ0ZXhidWZmZXIoIF9hcnJheSApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdCAgbGV0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG5cdFx0aWYgKCBfYXJyYXkgKSB7IGl0LnNldFZlcnRleGJ1ZmZlciggYnVmZmVyLCBfYXJyYXkgKTsgfVxuXG5cdCAgcmV0dXJuIGJ1ZmZlcjtcblx0fVxuXG5cdHNldFZlcnRleGJ1ZmZlciggX2J1ZmZlciwgX2FycmF5LCBfbW9kZSApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0bGV0IG1vZGUgPSBfbW9kZSB8fCBnbC5TVEFUSUNfRFJBVztcblxuXHQgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgX2J1ZmZlciApO1xuXHQgIGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheSggX2FycmF5ICksIG1vZGUgKTtcblx0ICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIG51bGwgKTtcblxuXHQgIF9idWZmZXIubGVuZ3RoID0gX2FycmF5Lmxlbmd0aDtcblx0fVxuXG5cdGNyZWF0ZUluZGV4YnVmZmVyKCBfYXJyYXkgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHQgIGxldCBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcblxuXHRcdGlmICggX2FycmF5ICkgeyBpdC5zZXRJbmRleGJ1ZmZlciggYnVmZmVyLCBfYXJyYXkgKTsgfVxuXG5cdCAgcmV0dXJuIGJ1ZmZlcjtcblx0fVxuXG5cdHNldEluZGV4YnVmZmVyKCBfYnVmZmVyLCBfYXJyYXksIF9tb2RlICkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0XHRsZXQgbW9kZSA9IF9tb2RlIHx8IGdsLlNUQVRJQ19EUkFXO1xuXG5cdCAgZ2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIF9idWZmZXIgKTtcblx0ICBnbC5idWZmZXJEYXRhKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbmV3IEludDE2QXJyYXkoIF9hcnJheSApLCBtb2RlICk7XG5cdCAgZ2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwgKTtcblxuXHQgIF9idWZmZXIubGVuZ3RoID0gX2FycmF5Lmxlbmd0aDtcblx0fVxuXG5cdGdldEF0dHJpYkxvY2F0aW9uKCBfbmFtZSApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0bGV0IGxvY2F0aW9uO1xuXHQgIGlmICggaXQuY3VycmVudFByb2dyYW0ubG9jYXRpb25zWyBfbmFtZSBdICkge1xuXHQgICAgbG9jYXRpb24gPSBpdC5jdXJyZW50UHJvZ3JhbS5sb2NhdGlvbnNbIF9uYW1lIF07XG5cdCAgfSBlbHNlIHtcblx0ICAgIGxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oIGl0LmN1cnJlbnRQcm9ncmFtLCBfbmFtZSApO1xuXHQgICAgaXQuY3VycmVudFByb2dyYW0ubG9jYXRpb25zWyBfbmFtZSBdID0gbG9jYXRpb247XG5cdCAgfVxuXG5cdFx0cmV0dXJuIGxvY2F0aW9uO1xuXHR9XG5cblx0YXR0cmlidXRlKCBfbmFtZSwgX2J1ZmZlciwgX3N0cmlkZSwgX2RpdiApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0aWYgKCBfZGl2ICkge1xuXHRcdFx0aXQuZ2V0RXh0ZW5zaW9uKCBcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIiwgdHJ1ZSApO1xuXHRcdH1cblxuXHQgIGxldCBsb2NhdGlvbiA9IGl0LmdldEF0dHJpYkxvY2F0aW9uKCBfbmFtZSApO1xuXG5cdCAgZ2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCBfYnVmZmVyICk7XG5cdCAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGxvY2F0aW9uICk7XG5cdCAgZ2wudmVydGV4QXR0cmliUG9pbnRlciggbG9jYXRpb24sIF9zdHJpZGUsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xuXG5cdFx0bGV0IGV4dCA9IGl0LmdldEV4dGVuc2lvbiggXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIgKTtcblx0XHRpZiAoIGV4dCApIHtcblx0XHRcdGxldCBkaXYgPSBfZGl2IHx8IDA7XG5cdFx0XHRleHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKCBsb2NhdGlvbiwgZGl2ICk7XG5cdFx0fVxuXG5cdCAgZ2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCBudWxsICk7XG5cdH1cblxuXHRnZXRVbmlmb3JtTG9jYXRpb24oIF9uYW1lICkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0ICBsZXQgbG9jYXRpb247XG5cblx0XHRpZiAoIHR5cGVvZiBpdC5jdXJyZW50UHJvZ3JhbS5sb2NhdGlvbnNbIF9uYW1lIF0gIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRsb2NhdGlvbiA9IGl0LmN1cnJlbnRQcm9ncmFtLmxvY2F0aW9uc1sgX25hbWUgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIGl0LmN1cnJlbnRQcm9ncmFtLCBfbmFtZSApO1xuXHRcdFx0aXQuY3VycmVudFByb2dyYW0ubG9jYXRpb25zWyBfbmFtZSBdID0gbG9jYXRpb247XG5cdFx0fVxuXG5cdCAgcmV0dXJuIGxvY2F0aW9uO1xuXHR9XG5cblx0dW5pZm9ybTFpKCBfbmFtZSwgX3ZhbHVlICkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0XHRsZXQgbG9jYXRpb24gPSBpdC5nZXRVbmlmb3JtTG9jYXRpb24oIF9uYW1lICk7XG5cdFx0Z2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgX3ZhbHVlICk7XG5cdH1cblxuXHR1bmlmb3JtMWYoIF9uYW1lLCBfdmFsdWUgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdGxldCBsb2NhdGlvbiA9IGl0LmdldFVuaWZvcm1Mb2NhdGlvbiggX25hbWUgKTtcblx0XHRnbC51bmlmb3JtMWYoIGxvY2F0aW9uLCBfdmFsdWUgKTtcblx0fVxuXG5cdHVuaWZvcm0yZnYoIF9uYW1lLCBfdmFsdWUgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdGxldCBsb2NhdGlvbiA9IGl0LmdldFVuaWZvcm1Mb2NhdGlvbiggX25hbWUgKTtcblx0XHRnbC51bmlmb3JtMmZ2KCBsb2NhdGlvbiwgX3ZhbHVlICk7XG5cdH1cblxuXHR1bmlmb3JtM2Z2KCBfbmFtZSwgX3ZhbHVlICkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0XHRsZXQgbG9jYXRpb24gPSBpdC5nZXRVbmlmb3JtTG9jYXRpb24oIF9uYW1lICk7XG5cdFx0Z2wudW5pZm9ybTNmdiggbG9jYXRpb24sIF92YWx1ZSApO1xuXHR9XG5cblx0dW5pZm9ybTRmdiggX25hbWUsIF92YWx1ZSApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0bGV0IGxvY2F0aW9uID0gaXQuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbmFtZSApO1xuXHRcdGdsLnVuaWZvcm00ZnYoIGxvY2F0aW9uLCBfdmFsdWUgKTtcblx0fVxuXG5cdHVuaWZvcm1NYXRyaXg0ZnYoIF9uYW1lLCBfdmFsdWUsIF90cmFuc3Bvc2UgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdGxldCBsb2NhdGlvbiA9IGl0LmdldFVuaWZvcm1Mb2NhdGlvbiggX25hbWUgKTtcblx0XHRnbC51bmlmb3JtTWF0cml4NGZ2KCBsb2NhdGlvbiwgX3RyYW5zcG9zZSB8fCBmYWxzZSwgX3ZhbHVlICk7XG5cdH1cblxuXHR1bmlmb3JtQ3ViZW1hcCggX25hbWUsIF90ZXh0dXJlLCBfbnVtYmVyICkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0XHRsZXQgbG9jYXRpb24gPSBpdC5nZXRVbmlmb3JtTG9jYXRpb24oIF9uYW1lICk7XG5cdCAgZ2wuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKyBfbnVtYmVyICk7XG5cdCAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfQ1VCRV9NQVAsIF90ZXh0dXJlICk7XG5cdCAgZ2wudW5pZm9ybTFpKCBsb2NhdGlvbiwgX251bWJlciApO1xuXHR9XG5cblx0dW5pZm9ybVRleHR1cmUoIF9uYW1lLCBfdGV4dHVyZSwgX251bWJlciApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0bGV0IGxvY2F0aW9uID0gaXQuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbmFtZSApO1xuXHQgIGdsLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICsgX251bWJlciApO1xuXHQgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBfdGV4dHVyZSApO1xuXHQgIGdsLnVuaWZvcm0xaSggbG9jYXRpb24sIF9udW1iZXIgKTtcblx0fVxuXG5cdGNyZWF0ZVRleHR1cmUoKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdGxldCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXHRcdGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlICk7XG5cdCAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIgKTtcblx0ICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUiApO1xuXHQgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XG5cdCAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcblx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cdH1cblxuXHR0ZXh0dXJlRmlsdGVyKCBfdGV4dHVyZSwgX2ZpbHRlciApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0Z2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIF90ZXh0dXJlICk7XG5cdCAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBfZmlsdGVyICk7XG5cdCAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBfZmlsdGVyICk7XG5cdFx0Z2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcblx0fVxuXG5cdHRleHR1cmVXcmFwKCBfdGV4dHVyZSwgX3dyYXAgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBfdGV4dHVyZSApO1xuXHQgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBfd3JhcCApO1xuXHQgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBfd3JhcCApO1xuXHRcdGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG5cdH1cblxuXHRzZXRUZXh0dXJlKCBfdGV4dHVyZSwgX2ltYWdlICkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgX3RleHR1cmUgKTtcblx0XHRnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBfaW1hZ2UgKTtcblx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXHR9XG5cblx0c2V0VGV4dHVyZUZyb21BcnJheSggX3RleHR1cmUsIF93aWR0aCwgX2hlaWdodCwgX2FycmF5ICkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgX3RleHR1cmUgKTtcblx0XHRnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBfd2lkdGgsIF9oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG5ldyBVaW50OEFycmF5KCBfYXJyYXkgKSApO1xuXHRcdGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG5cdH1cblxuXHRzZXRUZXh0dXJlRnJvbUZsb2F0QXJyYXkoIF90ZXh0dXJlLCBfd2lkdGgsIF9oZWlnaHQsIF9hcnJheSApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0aXQuZ2V0RXh0ZW5zaW9uKCBcIk9FU190ZXh0dXJlX2Zsb2F0XCIsIHRydWUgKTtcblxuXHRcdGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBfdGV4dHVyZSApO1xuXHRcdGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIF93aWR0aCwgX2hlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG5ldyBGbG9hdDMyQXJyYXkoIF9hcnJheSApICk7XG5cdFx0aWYgKCAhaXQuZ2V0RXh0ZW5zaW9uKCBcIk9FU190ZXh0dXJlX2Zsb2F0X2xpbmVhclwiICkgKSB7IGl0LnRleHR1cmVGaWx0ZXIoIF90ZXh0dXJlLCBnbC5ORUFSRVNUICk7IH1cblx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXHR9XG5cblx0Y29weVRleHR1cmUoIF90ZXh0dXJlLCBfd2lkdGgsIF9oZWlnaHQgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBfdGV4dHVyZSApO1xuXHRcdGdsLmNvcHlUZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAwLCAwLCBfd2lkdGgsIF9oZWlnaHQsIDAgKTtcblx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXHR9XG5cblx0Y3JlYXRlQ3ViZW1hcCggX2FycmF5T2ZJbWFnZSApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0Ly8gb3JkZXIgOiBYKywgWC0sIFkrLCBZLSwgWissIFotXG5cdFx0bGV0IHRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG5cblx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZSApO1xuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cdFx0XHRnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBfYXJyYXlPZkltYWdlWyBpIF0gKTtcblx0XHR9XG5cdFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIgKTtcblx0ICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUiApO1xuXHQgIGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XG5cdCAgZ2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcblx0XHRnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCApO1xuXG5cdFx0cmV0dXJuIHRleHR1cmU7XG5cdH1cblxuXHRjcmVhdGVGcmFtZWJ1ZmZlciggX3dpZHRoLCBfaGVpZ2h0ICkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0ICBsZXQgZnJhbWVidWZmZXIgPSB7fTtcblx0XHRmcmFtZWJ1ZmZlci5mcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cdCAgZ2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIuZnJhbWVidWZmZXIgKTtcblxuXHRcdGZyYW1lYnVmZmVyLmRlcHRoID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0Z2wuYmluZFJlbmRlcmJ1ZmZlciggZ2wuUkVOREVSQlVGRkVSLCBmcmFtZWJ1ZmZlci5kZXB0aCApO1xuXHRcdGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfQ09NUE9ORU5UMTYsIF93aWR0aCwgX2hlaWdodCApO1xuXHQgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCBmcmFtZWJ1ZmZlci5kZXB0aCApO1xuXG5cdFx0ZnJhbWVidWZmZXIudGV4dHVyZSA9IGl0LmNyZWF0ZVRleHR1cmUoKTtcblx0ICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgZnJhbWVidWZmZXIudGV4dHVyZSApO1xuXHQgIGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIF93aWR0aCwgX2hlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCApO1xuXHQgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBudWxsICk7XG5cblx0ICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCBmcmFtZWJ1ZmZlci50ZXh0dXJlLCAwICk7XG5cdCAgZ2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXG5cdCAgcmV0dXJuIGZyYW1lYnVmZmVyO1xuXHR9XG5cblx0cmVzaXplRnJhbWVidWZmZXIoIF9mcmFtZWJ1ZmZlciwgX3dpZHRoLCBfaGVpZ2h0ICkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBfZnJhbWVidWZmZXIuZnJhbWVidWZmZXIgKTtcblxuXHRcdGdsLmJpbmRSZW5kZXJidWZmZXIoIGdsLlJFTkRFUkJVRkZFUiwgX2ZyYW1lYnVmZmVyLmRlcHRoICk7XG5cdFx0Z2wucmVuZGVyYnVmZmVyU3RvcmFnZSggZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9DT01QT05FTlQxNiwgX3dpZHRoLCBfaGVpZ2h0ICk7XG5cdFx0Z2wuYmluZFJlbmRlcmJ1ZmZlciggZ2wuUkVOREVSQlVGRkVSLCBudWxsICk7XG5cdFx0XG5cdCAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIF9mcmFtZWJ1ZmZlci50ZXh0dXJlICk7XG5cdFx0Z2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgX3dpZHRoLCBfaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsICk7XG5cdCAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcblx0XHRcblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBudWxsICk7XG5cdH1cblxuXHRjcmVhdGVGbG9hdEZyYW1lYnVmZmVyKCBfd2lkdGgsIF9oZWlnaHQgKSB7XG5cdFx0bGV0IGl0ID0gdGhpcztcblx0XHRsZXQgZ2wgPSBpdC5nbDtcblxuXHRcdGl0LmdldEV4dGVuc2lvbiggXCJPRVNfdGV4dHVyZV9mbG9hdFwiLCB0cnVlICk7XG5cblx0ICBsZXQgZnJhbWVidWZmZXIgPSB7fTtcblx0XHRmcmFtZWJ1ZmZlci5mcmFtZWJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG5cdCAgZ2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIuZnJhbWVidWZmZXIgKTtcblxuXHRcdGZyYW1lYnVmZmVyLmRlcHRoID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG5cdFx0Z2wuYmluZFJlbmRlcmJ1ZmZlciggZ2wuUkVOREVSQlVGRkVSLCBmcmFtZWJ1ZmZlci5kZXB0aCApO1xuXHRcdGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfQ09NUE9ORU5UMTYsIF93aWR0aCwgX2hlaWdodCApO1xuXHQgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCBmcmFtZWJ1ZmZlci5kZXB0aCApO1xuXG5cdFx0ZnJhbWVidWZmZXIudGV4dHVyZSA9IGl0LmNyZWF0ZVRleHR1cmUoKTtcblx0ICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgZnJhbWVidWZmZXIudGV4dHVyZSApO1xuXHQgIGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIF93aWR0aCwgX2hlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwgKTtcblx0XHRpZiAoICFpdC5nZXRFeHRlbnNpb24oIFwiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXCIgKSApIHsgaXQudGV4dHVyZUZpbHRlciggZnJhbWVidWZmZXIudGV4dHVyZSwgZ2wuTkVBUkVTVCApOyB9XG5cdCAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcblxuXHQgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIGZyYW1lYnVmZmVyLnRleHR1cmUsIDAgKTtcblx0ICBnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBudWxsICk7XG5cblx0ICByZXR1cm4gZnJhbWVidWZmZXI7XG5cdH1cblxuXHRyZXNpemVGbG9hdEZyYW1lYnVmZmVyKCBfZnJhbWVidWZmZXIsIF93aWR0aCwgX2hlaWdodCApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgX2ZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyICk7XG5cblx0XHRnbC5iaW5kUmVuZGVyYnVmZmVyKCBnbC5SRU5ERVJCVUZGRVIsIF9mcmFtZWJ1ZmZlci5kZXB0aCApO1xuXHRcdGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfQ09NUE9ORU5UMTYsIF93aWR0aCwgX2hlaWdodCApO1xuXHRcdGdsLmJpbmRSZW5kZXJidWZmZXIoIGdsLlJFTkRFUkJVRkZFUiwgbnVsbCApO1xuXHRcdFxuXHQgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBfZnJhbWVidWZmZXIudGV4dHVyZSApO1xuXHRcdGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIF93aWR0aCwgX2hlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwgKTtcblx0ICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXHRcdFxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcblx0fVxuXG5cdGNyZWF0ZURyYXdCdWZmZXJzKCBfd2lkdGgsIF9oZWlnaHQsIF9udW1EcmF3QnVmZmVycyApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0aXQuZ2V0RXh0ZW5zaW9uKCAnT0VTX3RleHR1cmVfZmxvYXQnLCB0cnVlICk7XG5cdFx0bGV0IGV4dCA9IGl0LmdldEV4dGVuc2lvbiggJ1dFQkdMX2RyYXdfYnVmZmVycycsIHRydWUgKTtcblxuXHRcdGlmICggZXh0Lk1BWF9EUkFXX0JVRkZFUlNfV0VCR0wgPCBfbnVtRHJhd0J1ZmZlcnMgKSB7XG5cdFx0XHR0aHJvdyBcImNyZWF0ZURyYXdCdWZmZXJzOiBNQVhfRFJBV19CVUZGRVJTX1dFQkdMIGlzIFwiICsgZXh0Lk1BWF9EUkFXX0JVRkZFUlNfV0VCR0w7XG5cdFx0fVxuXG5cdFx0bGV0IGZyYW1lYnVmZmVyID0ge307XG5cdFx0ZnJhbWVidWZmZXIuZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyLmZyYW1lYnVmZmVyICk7XG5cblx0XHRmcmFtZWJ1ZmZlci5kZXB0aCA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuXHRcdGdsLmJpbmRSZW5kZXJidWZmZXIoIGdsLlJFTkRFUkJVRkZFUiwgZnJhbWVidWZmZXIuZGVwdGggKTtcblx0XHRnbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX0NPTVBPTkVOVDE2LCBfd2lkdGgsIF9oZWlnaHQgKTtcblx0XHRnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlJFTkRFUkJVRkZFUiwgZnJhbWVidWZmZXIuZGVwdGggKTtcblxuXHRcdGZyYW1lYnVmZmVyLnRleHR1cmVzID0gW107XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgX251bURyYXdCdWZmZXJzOyBpICsrICkge1xuXHRcdFx0ZnJhbWVidWZmZXIudGV4dHVyZXNbIGkgXSA9IGl0LmNyZWF0ZVRleHR1cmUoKTtcblx0XHQgIGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBmcmFtZWJ1ZmZlci50ZXh0dXJlc1sgaSBdICk7XG5cdFx0XHRnbC50ZXhJbWFnZTJEKCBnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBfd2lkdGgsIF9oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLkZMT0FULCBudWxsICk7XG5cdFx0XHRpZiAoICFpdC5nZXRFeHRlbnNpb24oIFwiT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyXCIgKSApIHsgaXQudGV4dHVyZUZpbHRlciggZnJhbWVidWZmZXIudGV4dHVyZXNbIGkgXSwgZ2wuTkVBUkVTVCApOyB9XG5cdFx0ICBnbC5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xuXG5cdFx0ICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggZ2wuRlJBTUVCVUZGRVIsIGV4dC5DT0xPUl9BVFRBQ0hNRU5UMF9XRUJHTCArIGksIGdsLlRFWFRVUkVfMkQsIGZyYW1lYnVmZmVyLnRleHR1cmVzWyBpIF0sIDAgKTtcblx0XHR9XG5cblx0XHRsZXQgc3RhdHVzID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyggZ2wuRlJBTUVCVUZGRVIgKTtcblx0XHRpZiAoIHN0YXR1cyAhPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUgKSB7XG5cdFx0XHR0aHJvdyBcImNyZWF0ZURyYXdCdWZmZXJzOiBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKCBnbC5GUkFNRUJVRkZFUiApIHJldHVybnMgXCIgKyBzdGF0dXM7XG5cdFx0fVxuXHRcdGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcblxuXHRcdHJldHVybiBmcmFtZWJ1ZmZlcjtcblx0fVxuXG5cdHJlc2l6ZURyYXdCdWZmZXJzKCBfZnJhbWVidWZmZXIsIF93aWR0aCwgaGVpZ2h0ICkge1xuXHRcdGxldCBpdCA9IHRoaXM7XG5cdFx0bGV0IGdsID0gaXQuZ2w7XG5cblx0XHRnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBfZnJhbWVidWZmZXIuZnJhbWVidWZmZXIgKTtcblxuXHRcdGdsLmJpbmRSZW5kZXJidWZmZXIoIGdsLlJFTkRFUkJVRkZFUiwgX2ZyYW1lYnVmZmVyLmRlcHRoICk7XG5cdFx0Z2wucmVuZGVyYnVmZmVyU3RvcmFnZSggZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9DT01QT05FTlQxNiwgX3dpZHRoLCBfaGVpZ2h0ICk7XG5cdFx0Z2wuYmluZFJlbmRlcmJ1ZmZlciggZ2wuUkVOREVSQlVGRkVSLCBudWxsICk7XG5cdFx0XG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgX2ZyYW1lYnVmZmVyLnRleHR1cmVzLmxlbmd0aDsgaSArKyApIHtcblx0XHRcdGdsLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBfZnJhbWVidWZmZXIudGV4dHVyZXNbIGkgXSApO1xuXHRcdFx0Z2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgX3dpZHRoLCBfaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCApO1xuXHRcdFx0Z2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIG51bGwgKTtcblx0XHR9XG5cdFx0XG5cdFx0Z2wuYmluZEZyYW1lYnVmZmVyKCBnbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xuXHR9XG5cblx0ZHJhd0J1ZmZlcnMoIF9udW1EcmF3QnVmZmVycyApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXHRcdFxuXHRcdGxldCBleHQgPSBpdC5nZXRFeHRlbnNpb24oIFwiV0VCR0xfZHJhd19idWZmZXJzXCIsIHRydWUgKTtcblxuXHRcdGxldCBhcnJheSA9IFtdO1xuXHRcdGlmICggdHlwZW9mIF9udW1EcmF3QnVmZmVycyA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IF9udW1EcmF3QnVmZmVyczsgaSArKyApIHtcblx0XHRcdFx0YXJyYXkucHVzaCggZXh0LkNPTE9SX0FUVEFDSE1FTlQwX1dFQkdMICsgaSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRhcnJheSA9IGFycmF5LmNvbmNhdCggX251bURyYXdCdWZmZXJzICk7XG5cdFx0fVxuXHRcdGV4dC5kcmF3QnVmZmVyc1dFQkdMKCBhcnJheSApO1xuXHR9XG5cblx0Y2xlYXIoIF9yLCBfZywgX2IsIF9hLCBfZCApIHtcblx0XHRsZXQgaXQgPSB0aGlzO1xuXHRcdGxldCBnbCA9IGl0LmdsO1xuXG5cdFx0bGV0IHIgPSBfciB8fCAwLjA7XG5cdFx0bGV0IGcgPSBfZyB8fCAwLjA7XG5cdFx0bGV0IGIgPSBfYiB8fCAwLjA7XG5cdFx0bGV0IGEgPSB0eXBlb2YgX2EgPT09ICdudW1iZXInID8gX2EgOiAxLjA7XG5cdFx0bGV0IGQgPSB0eXBlb2YgX2QgPT09ICdudW1iZXInID8gX2QgOiAxLjA7XG5cblx0ICBnbC5jbGVhckNvbG9yKCByLCBnLCBiLCBhICk7XG5cdCAgZ2wuY2xlYXJEZXB0aCggZCApO1xuXHQgIGdsLmNsZWFyKCBnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCApO1xuXHR9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBHTENhdDtcbiIsIi8vIOOBq+OCg+ODvOOCk1xyXG5cclxubGV0IE1hdGhDYXQgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBhZGRzIGEgdHdvIHZlY1xyXG4gKiBAcGFyYW0ge2FycmF5fSBhIC0gdmVjXHJcbiAqIEBwYXJhbSB7YXJyYXl9IGIgLSB2ZWNcclxuICovXHJcbk1hdGhDYXQudmVjQWRkID0gKCBhLCBiICkgPT4gYS5tYXAoICggZSwgaSApID0+IGUgKyBiW2ldICk7XHJcblxyXG4vKipcclxuICogc3Vic3RyYWN0cyBhIHZlYyBmcm9tIGFuIGFub3RoZXIgdmVjXHJcbiAqIEBwYXJhbSB7YXJyYXl9IGEgLSB2ZWNcclxuICogQHBhcmFtIHthcnJheX0gYiAtIHZlY1xyXG4gKi9cclxuTWF0aENhdC52ZWNTdWIgPSAoIGEsIGIgKSA9PiBhLm1hcCggKCBlLCBpICkgPT4gZSAtIGJbaV0gKTtcclxuXHJcbi8qKlxyXG4gKiByZXR1cm5zIGEgY3Jvc3Mgb2YgdHdvIHZlYzNzXHJcbiAqIEBwYXJhbSB7YXJyYXl9IGEgLSB2ZWMzXHJcbiAqIEBwYXJhbSB7YXJyYXl9IGIgLSB2ZWMzXHJcbiAqL1xyXG5NYXRoQ2F0LnZlYzNDcm9zcyA9ICggYSwgYiApID0+IFtcclxuICBhWzFdICogYlsyXSAtIGFbMl0gKiBiWzFdLFxyXG4gIGFbMl0gKiBiWzBdIC0gYVswXSAqIGJbMl0sXHJcbiAgYVswXSAqIGJbMV0gLSBhWzFdICogYlswXVxyXG5dO1xyXG5cclxuLyoqXHJcbiAqIHNjYWxlcyBhIHZlYyBieSBzY2FsYXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHMgLSBzY2FsYXJcclxuICogQHBhcmFtIHthcnJheX0gdiAtIHZlY1xyXG4gKi9cclxuTWF0aENhdC52ZWNTY2FsZSA9ICggcywgdiApID0+IHYubWFwKCBlID0+IGUgKiBzICk7XHJcblxyXG4vKipcclxuICogcmV0dXJucyBsZW5ndGggb2YgYSB2ZWNcclxuICogQHBhcmFtIHthcnJheX0gdiAtIHZlY1xyXG4gKi9cclxuTWF0aENhdC52ZWNMZW5ndGggPSB2ID0+IE1hdGguc3FydCggdi5yZWR1Y2UoICggcCwgYyApID0+IHAgKyBjICogYywgMC4wICkgKTtcclxuXHJcbi8qKlxyXG4gKiBub3JtYWxpemVzIGEgdmVjXHJcbiAqIEBwYXJhbSB7YXJyYXl9IHYgLSB2ZWNcclxuICovXHJcbk1hdGhDYXQudmVjTm9ybWFsaXplID0gdiA9PiBNYXRoQ2F0LnZlY1NjYWxlKCAxLjAgLyBNYXRoQ2F0LnZlY0xlbmd0aCggdiApLCB2ICk7XHJcblxyXG4vKipcclxuICogYXBwbGllcyB0d28gbWF0NHNcclxuICogQHBhcmFtIHthcnJheX0gYSAtIG1hdDRcclxuICogQHBhcmFtIHthcnJheX0gYiAtIG1hdDRcclxuICovXHJcbk1hdGhDYXQubWF0NEFwcGx5ID0gKCBhLCBiICkgPT4ge1xyXG4gIHJldHVybiBbXHJcbiAgICBhWyAwXSAqIGJbIDBdICsgYVsgNF0gKiBiWyAxXSArIGFbIDhdICogYlsgMl0gKyBhWzEyXSAqIGJbIDNdLFxyXG4gICAgYVsgMV0gKiBiWyAwXSArIGFbIDVdICogYlsgMV0gKyBhWyA5XSAqIGJbIDJdICsgYVsxM10gKiBiWyAzXSxcclxuICAgIGFbIDJdICogYlsgMF0gKyBhWyA2XSAqIGJbIDFdICsgYVsxMF0gKiBiWyAyXSArIGFbMTRdICogYlsgM10sXHJcbiAgICBhWyAzXSAqIGJbIDBdICsgYVsgN10gKiBiWyAxXSArIGFbMTFdICogYlsgMl0gKyBhWzE1XSAqIGJbIDNdLFxyXG5cclxuICAgIGFbIDBdICogYlsgNF0gKyBhWyA0XSAqIGJbIDVdICsgYVsgOF0gKiBiWyA2XSArIGFbMTJdICogYlsgN10sXHJcbiAgICBhWyAxXSAqIGJbIDRdICsgYVsgNV0gKiBiWyA1XSArIGFbIDldICogYlsgNl0gKyBhWzEzXSAqIGJbIDddLFxyXG4gICAgYVsgMl0gKiBiWyA0XSArIGFbIDZdICogYlsgNV0gKyBhWzEwXSAqIGJbIDZdICsgYVsxNF0gKiBiWyA3XSxcclxuICAgIGFbIDNdICogYlsgNF0gKyBhWyA3XSAqIGJbIDVdICsgYVsxMV0gKiBiWyA2XSArIGFbMTVdICogYlsgN10sXHJcblxyXG4gICAgYVsgMF0gKiBiWyA4XSArIGFbIDRdICogYlsgOV0gKyBhWyA4XSAqIGJbMTBdICsgYVsxMl0gKiBiWzExXSxcclxuICAgIGFbIDFdICogYlsgOF0gKyBhWyA1XSAqIGJbIDldICsgYVsgOV0gKiBiWzEwXSArIGFbMTNdICogYlsxMV0sXHJcbiAgICBhWyAyXSAqIGJbIDhdICsgYVsgNl0gKiBiWyA5XSArIGFbMTBdICogYlsxMF0gKyBhWzE0XSAqIGJbMTFdLFxyXG4gICAgYVsgM10gKiBiWyA4XSArIGFbIDddICogYlsgOV0gKyBhWzExXSAqIGJbMTBdICsgYVsxNV0gKiBiWzExXSxcclxuICAgIFxyXG4gICAgYVsgMF0gKiBiWzEyXSArIGFbIDRdICogYlsxM10gKyBhWyA4XSAqIGJbMTRdICsgYVsxMl0gKiBiWzE1XSxcclxuICAgIGFbIDFdICogYlsxMl0gKyBhWyA1XSAqIGJbMTNdICsgYVsgOV0gKiBiWzE0XSArIGFbMTNdICogYlsxNV0sXHJcbiAgICBhWyAyXSAqIGJbMTJdICsgYVsgNl0gKiBiWzEzXSArIGFbMTBdICogYlsxNF0gKyBhWzE0XSAqIGJbMTVdLFxyXG4gICAgYVsgM10gKiBiWzEyXSArIGFbIDddICogYlsxM10gKyBhWzExXSAqIGJbMTRdICsgYVsxNV0gKiBiWzE1XVxyXG4gIF07XHJcbn07XHJcblxyXG4vKipcclxuICogdHJhbnNwb3NlIGEgbWF0NFxyXG4gKiBAcGFyYW0ge2FycmF5fSBtIC0gbWF0NFxyXG4gKi9cclxuTWF0aENhdC5tYXQ0VHJhbnNwb3NlID0gbSA9PiBbXHJcbiAgbVsgMF0sbVsgNF0sbVsgOF0sbVsxMl0sXHJcbiAgbVsgMV0sbVsgNV0sbVsgOV0sbVsxM10sXHJcbiAgbVsgMl0sbVsgNl0sbVsxMF0sbVsxNF0sXHJcbiAgbVsgM10sbVsgN10sbVsxMV0sbVsxNV1cclxuXTtcclxuXHJcbi8qKlxyXG4gKiByZXR1cm5zIGFuIGluZGVudGl0eSBtYXQ0XHJcbiAqL1xyXG5NYXRoQ2F0Lm1hdDRJZGVudGl0eSA9ICgpID0+IFsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCwwLDAsMCwxXTtcclxuXHJcbk1hdGhDYXQubWF0NFRyYW5zbGF0ZSA9ICggdiApID0+IFsxLDAsMCwwLDAsMSwwLDAsMCwwLDEsMCx2WzBdLHZbMV0sdlsyXSwxXTtcclxuXHJcbk1hdGhDYXQubWF0NFNjYWxlID0gKCB2ICkgPT4gW1xyXG4gIHZbMF0sMCwwLDAsXHJcbiAgMCx2WzFdLDAsMCxcclxuICAwLDAsdlsyXSwwLFxyXG4gIDAsMCwwLDFcclxuXTtcclxuXHJcbk1hdGhDYXQubWF0NFNjYWxlWFlaID0gKCBzICkgPT4gW1xyXG4gIHMsMCwwLDAsXHJcbiAgMCxzLDAsMCxcclxuICAwLDAscywwLFxyXG4gIDAsMCwwLDFcclxuXTtcclxuXHJcbk1hdGhDYXQubWF0NFJvdGF0ZVggPSAoIHQgKSA9PiBbXHJcbiAgMSwwLDAsMCxcclxuICAwLE1hdGguY29zKHQpLC1NYXRoLnNpbih0KSwwLFxyXG4gIDAsTWF0aC5zaW4odCksTWF0aC5jb3ModCksMCxcclxuICAwLDAsMCwxXHJcbl07XHJcblxyXG5NYXRoQ2F0Lm1hdDRSb3RhdGVZID0gKCB0ICkgPT4gW1xyXG4gIE1hdGguY29zKHQpLDAsTWF0aC5zaW4odCksMCxcclxuICAwLDEsMCwwLFxyXG4gIC1NYXRoLnNpbih0KSwwLE1hdGguY29zKHQpLDAsXHJcbiAgMCwwLDAsMVxyXG5dO1xyXG5cclxuTWF0aENhdC5tYXQ0Um90YXRlWiA9ICggdCApID0+IFtcclxuICBNYXRoLmNvcyh0KSwtTWF0aC5zaW4odCksMCwwLFxyXG4gIE1hdGguc2luKHQpLE1hdGguY29zKHQpLDAsMCxcclxuICAwLDAsMSwwLFxyXG4gIDAsMCwwLDFcclxuXTtcclxuXHJcbk1hdGhDYXQubWF0NExvb2tBdCA9ICggcG9zLCB0YXIsIGFpciwgcm90ICkgPT4ge1xyXG4gIGxldCBkaXIgPSBNYXRoQ2F0LnZlY05vcm1hbGl6ZSggTWF0aENhdC52ZWNTdWIoIHRhciwgcG9zICkgKTtcclxuICBsZXQgc2lkID0gTWF0aENhdC52ZWNOb3JtYWxpemUoIE1hdGhDYXQudmVjM0Nyb3NzKCBkaXIsIGFpciApICk7XHJcbiAgbGV0IHRvcCA9IE1hdGhDYXQudmVjM0Nyb3NzKCBzaWQsIGRpciApO1xyXG4gIHNpZCA9IE1hdGhDYXQudmVjQWRkKFxyXG4gICAgTWF0aENhdC52ZWNTY2FsZSggTWF0aC5jb3MoIHJvdCApLCBzaWQgKSxcclxuICAgIE1hdGhDYXQudmVjU2NhbGUoIE1hdGguc2luKCByb3QgKSwgdG9wIClcclxuICApO1xyXG4gIHRvcCA9IE1hdGhDYXQudmVjM0Nyb3NzKCBzaWQsIGRpciApO1xyXG5cclxuICByZXR1cm4gW1xyXG4gICAgc2lkWzBdLCB0b3BbMF0sIGRpclswXSwgMC4wLFxyXG4gICAgc2lkWzFdLCB0b3BbMV0sIGRpclsxXSwgMC4wLFxyXG4gICAgc2lkWzJdLCB0b3BbMl0sIGRpclsyXSwgMC4wLFxyXG4gICAgLSBzaWRbMF0gKiBwb3NbMF0gLSBzaWRbMV0gKiBwb3NbMV0gLSBzaWRbMl0gKiBwb3NbMl0sXHJcbiAgICAtIHRvcFswXSAqIHBvc1swXSAtIHRvcFsxXSAqIHBvc1sxXSAtIHRvcFsyXSAqIHBvc1syXSxcclxuICAgIC0gZGlyWzBdICogcG9zWzBdIC0gZGlyWzFdICogcG9zWzFdIC0gZGlyWzJdICogcG9zWzJdLFxyXG4gICAgMS4wXHJcbiAgXTtcclxufTtcclxuXHJcbk1hdGhDYXQubWF0NFBlcnNwZWN0aXZlID0gKCBmb3YsIG5lYXIsIGZhciApID0+IHtcclxuICBsZXQgcCA9IDEuMCAvIE1hdGgudGFuKCBmb3YgKiBNYXRoLlBJIC8gMzYwLjAgKTtcclxuICBsZXQgZCA9ICggZmFyIC0gbmVhciApO1xyXG4gIHJldHVybiBbXHJcbiAgICBwLCAwLjAsIDAuMCwgMC4wLFxyXG4gICAgMC4wLCBwLCAwLjAsIDAuMCxcclxuICAgIDAuMCwgMC4wLCAoIGZhciArIG5lYXIgKSAvIGQsIDEuMCxcclxuICAgIDAuMCwgMC4wLCAtMiAqIGZhciAqIG5lYXIgLyBkLCAwLjBcclxuICBdO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWF0aENhdDsiLCJsZXQgc3RlcCA9ICggX29iaiApID0+IHtcclxuICBsZXQgb2JqID0gX29iajtcclxuICBsZXQgY291bnQgPSAtMTtcclxuXHJcbiAgbGV0IGZ1bmMgPSAoKSA9PiB7XHJcbiAgICBjb3VudCArKztcclxuICAgIGlmICggdHlwZW9mIG9ialsgY291bnQgXSA9PT0gJ2Z1bmN0aW9uJyApIHtcclxuICAgICAgb2JqWyBjb3VudCBdKCBmdW5jICk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBmdW5jKCk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBzdGVwO1xyXG4iLCJsZXQgVHdlYWsgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCBfZWwgKSB7XG4gICAgbGV0IGl0ID0gdGhpcztcblxuICAgIGl0LnBhcmVudCA9IF9lbDtcbiAgICBpdC52YWx1ZXMgPSB7fTtcbiAgICBpdC5lbGVtZW50cyA9IHt9O1xuICB9XG5cbiAgYnV0dG9uKCBfbmFtZSwgX3Byb3BzICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG5cbiAgICBsZXQgcHJvcHMgPSBfcHJvcHMgfHwge307XG5cbiAgICBpZiAoIHR5cGVvZiBpdC52YWx1ZXNbIF9uYW1lIF0gPT09ICd1bmRlZmluZWQnICkge1xuICAgICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG4gICAgICBpdC5wYXJlbnQuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG4gICAgICBsZXQgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnaW5wdXQnICk7XG4gICAgICBkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG4gICAgICBpbnB1dC50eXBlID0gJ2J1dHRvbic7XG4gICAgICBpbnB1dC52YWx1ZSA9IF9uYW1lO1xuXG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIGl0LnZhbHVlc1sgX25hbWUgXSA9IHRydWU7XG4gICAgICB9ICk7XG5cbiAgICAgIGl0LmVsZW1lbnRzWyBfbmFtZSBdID0ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgaW5wdXQ6IGlucHV0XG4gICAgICB9O1xuICAgIH1cblxuICAgIGxldCB0ZW1wdmFsdWUgPSBpdC52YWx1ZXNbIF9uYW1lIF07XG4gICAgaXQudmFsdWVzWyBfbmFtZSBdID0gZmFsc2U7XG4gICAgaWYgKCB0eXBlb2YgcHJvcHMuc2V0ID09PSAnYm9vbGVhbicgKSB7XG4gICAgICBpdC52YWx1ZXNbIF9uYW1lIF0gPSBwcm9wcy5zZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRlbXB2YWx1ZTtcbiAgfVxuXG4gIGNoZWNrYm94KCBfbmFtZSwgX3Byb3BzICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG5cbiAgICBsZXQgcHJvcHMgPSBfcHJvcHMgfHwge307XG5cbiAgICBsZXQgdmFsdWU7XG5cbiAgICBpZiAoIHR5cGVvZiBpdC52YWx1ZXNbIF9uYW1lIF0gPT09ICd1bmRlZmluZWQnICkge1xuICAgICAgdmFsdWUgPSBwcm9wcy52YWx1ZSB8fCBmYWxzZTtcblxuICAgICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG4gICAgICBpdC5wYXJlbnQuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG4gICAgICBsZXQgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdzcGFuJyApO1xuICAgICAgZGl2LmFwcGVuZENoaWxkKCBuYW1lICk7XG4gICAgICBuYW1lLmlubmVyVGV4dCA9IF9uYW1lO1xuXG4gICAgICBsZXQgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnaW5wdXQnICk7XG4gICAgICBkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG4gICAgICBpbnB1dC50eXBlID0gJ2NoZWNrYm94JztcbiAgICAgIGlucHV0LmNoZWNrZWQgPSB2YWx1ZTtcblxuICAgICAgaXQuZWxlbWVudHNbIF9uYW1lIF0gPSB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBpbnB1dDogaW5wdXRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlID0gaXQuZWxlbWVudHNbIF9uYW1lIF0uaW5wdXQuY2hlY2tlZDtcbiAgICB9XG5cbiAgICBpZiAoIHR5cGVvZiBwcm9wcy5zZXQgPT09ICdib29sZWFuJyApIHtcbiAgICAgIHZhbHVlID0gcHJvcHMuc2V0O1xuICAgIH1cblxuICAgIGl0LmVsZW1lbnRzWyBfbmFtZSBdLmlucHV0LmNoZWNrZWQgPSB2YWx1ZTtcbiAgICBpdC52YWx1ZXNbIF9uYW1lIF0gPSB2YWx1ZTtcblxuICAgIHJldHVybiBpdC52YWx1ZXNbIF9uYW1lIF07XG4gIH1cblxuICByYW5nZSggX25hbWUsIF9wcm9wcyApIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuXG4gICAgbGV0IHByb3BzID0gX3Byb3BzIHx8IHt9O1xuXG4gICAgbGV0IHZhbHVlO1xuXG4gICAgaWYgKCB0eXBlb2YgaXQudmFsdWVzWyBfbmFtZSBdID09PSAndW5kZWZpbmVkJyApIHtcbiAgICAgIGxldCBtaW4gPSBwcm9wcy5taW4gfHwgMC4wO1xuICAgICAgbGV0IG1heCA9IHByb3BzLm1heCB8fCAxLjA7XG4gICAgICBsZXQgc3RlcCA9IHByb3BzLnN0ZXAgfHwgMC4wMDE7XG4gICAgICB2YWx1ZSA9IHByb3BzLnZhbHVlIHx8IG1pbjtcblxuICAgICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG4gICAgICBpdC5wYXJlbnQuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG4gICAgICBsZXQgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdzcGFuJyApO1xuICAgICAgZGl2LmFwcGVuZENoaWxkKCBuYW1lICk7XG4gICAgICBuYW1lLmlubmVyVGV4dCA9IF9uYW1lO1xuXG4gICAgICBsZXQgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnaW5wdXQnICk7XG4gICAgICBkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG4gICAgICBpbnB1dC50eXBlID0gJ3JhbmdlJztcbiAgICAgIGlucHV0LnZhbHVlID0gdmFsdWU7XG4gICAgICBpbnB1dC5taW4gPSBtaW47XG4gICAgICBpbnB1dC5tYXggPSBtYXg7XG4gICAgICBpbnB1dC5zdGVwID0gc3RlcDtcblxuICAgICAgbGV0IHZhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdzcGFuJyApO1xuICAgICAgdmFsLmlubmVyVGV4dCA9IHZhbHVlLnRvRml4ZWQoIDMgKTtcbiAgICAgIGRpdi5hcHBlbmRDaGlsZCggdmFsICk7XG4gICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCAnaW5wdXQnLCAoIF9ldmVudCApID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyc2VGbG9hdCggaW5wdXQudmFsdWUgKTtcbiAgICAgICAgdmFsLmlubmVyVGV4dCA9IHZhbHVlLnRvRml4ZWQoIDMgKTtcbiAgICAgIH0gKTtcblxuICAgICAgaXQuZWxlbWVudHNbIF9uYW1lIF0gPSB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBpbnB1dDogaW5wdXQsXG4gICAgICAgIHZhbDogdmFsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQoIGl0LmVsZW1lbnRzWyBfbmFtZSBdLmlucHV0LnZhbHVlICk7XG4gICAgfVxuXG4gICAgaWYgKCB0eXBlb2YgcHJvcHMuc2V0ID09PSAnbnVtYmVyJyApIHtcbiAgICAgIHZhbHVlID0gcHJvcHMuc2V0O1xuICAgIH1cblxuICAgIGl0LnZhbHVlc1sgX25hbWUgXSA9IHZhbHVlO1xuICAgIGl0LmVsZW1lbnRzWyBfbmFtZSBdLmlucHV0LnZhbHVlID0gdmFsdWU7XG5cbiAgICByZXR1cm4gaXQudmFsdWVzWyBfbmFtZSBdO1xuICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVHdlYWs7XG4iLCJsZXQgc2VlZDtcbmxldCB4b3JzaGlmdCA9ICggX3NlZWQgKSA9PiB7XG4gIHNlZWQgPSBfc2VlZCB8fCBzZWVkIHx8IDE7XG4gIHNlZWQgPSBzZWVkIF4gKCBzZWVkIDw8IDEzICk7XG4gIHNlZWQgPSBzZWVkIF4gKCBzZWVkID4+PiAxNyApO1xuICBzZWVkID0gc2VlZCBeICggc2VlZCA8PCA1ICk7XG4gIHJldHVybiBzZWVkIC8gTWF0aC5wb3coIDIsIDMyICkgKyAwLjU7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB4b3JzaGlmdDtcbiIsImltcG9ydCB4b3JzaGlmdCBmcm9tICcuL2xpYnMveG9yc2hpZnQnO1xuaW1wb3J0IFR3ZWFrIGZyb20gJy4vbGlicy90d2Vhayc7XG5pbXBvcnQgR0xDYXQgZnJvbSAnLi9saWJzL2dsY2F0JztcbmltcG9ydCBHTENhdFBhdGggZnJvbSAnLi9saWJzL2dsY2F0LXBhdGgtZ3VpJztcbmltcG9ydCBNYXRoQ2F0IGZyb20gJy4vbGlicy9tYXRoY2F0JztcbmltcG9ydCBzdGVwIGZyb20gJy4vbGlicy9zdGVwJztcblxuaW1wb3J0IHBhdGhMb2ZpUGF0aCBmcm9tICcuL3BhdGgtbG9maXBhdGgnO1xuaW1wb3J0IHBhdGhQaWVjZXMgZnJvbSAnLi9wYXRoLXBpZWNlcyc7XG5pbXBvcnQgcGF0aFBvc3RmeCBmcm9tICcuL3BhdGgtcG9zdGZ4JztcbmltcG9ydCBwYXRoQ29uc29sZSBmcm9tICcuL3BhdGgtY29uc29sZSc7XG5pbXBvcnQgcGF0aEdyaWQgZnJvbSAnLi9wYXRoLWdyaWQnO1xuXG5sZXQgZ2xzbGlmeSA9IHJlcXVpcmUoICdnbHNsaWZ5JyApO1xuXG4vLyAtLS0tLS1cblxueG9yc2hpZnQoIDMyNjc4OTE1Nzg5MCApO1xuXG4vLyAtLS0tLS1cblxubGV0IHdpZHRoID0gY2FudmFzLndpZHRoID0gNDgwO1xubGV0IGhlaWdodCA9IGNhbnZhcy5oZWlnaHQgPSA0ODA7XG5cbmxldCByZW5kZXJBID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2EnICk7XG5cbmxldCBzYXZlRnJhbWUgPSAoKSA9PiB7XG4gIHJlbmRlckEuaHJlZiA9IGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgcmVuZGVyQS5kb3dubG9hZCA9ICggJzAwMDAnICsgdG90YWxGcmFtZSApLnNsaWNlKCAtNSApICsgJy5wbmcnO1xuICByZW5kZXJBLmNsaWNrKCk7XG59O1xuXG4vLyAtLS0tLS1cblxubGV0IGdsID0gY2FudmFzLmdldENvbnRleHQoICd3ZWJnbCcgKTtcbmdsLmxpbmVXaWR0aCggMSApO1xuXG5sZXQgZ2xDYXQgPSBuZXcgR0xDYXQoIGdsICk7XG5cbmdsQ2F0LmdldEV4dGVuc2lvbiggJ09FU190ZXh0dXJlX2Zsb2F0JywgdHJ1ZSApO1xuZ2xDYXQuZ2V0RXh0ZW5zaW9uKCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJywgdHJ1ZSApO1xuZ2xDYXQuZ2V0RXh0ZW5zaW9uKCAnRVhUX2ZyYWdfZGVwdGgnLCB0cnVlICk7XG5nbENhdC5nZXRFeHRlbnNpb24oICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJywgdHJ1ZSApO1xuXG5sZXQgZ2xDYXRQYXRoID0gbmV3IEdMQ2F0UGF0aCggZ2xDYXQsIHtcbiAgZWw6IGRpdlBhdGgsXG4gIGNhbnZhczogY2FudmFzLFxuICBzdHJldGNoOiB0cnVlXG59ICk7XG5cbi8vIC0tLS0tLVxuXG5sZXQgdHdlYWsgPSBuZXcgVHdlYWsoIGRpdlR3ZWFrICk7XG5cbi8vIC0tLS0tLVxuXG5sZXQgdG90YWxGcmFtZSA9IDA7XG5sZXQgaW5pdCA9IGZhbHNlO1xuXG5sZXQgYXV0b21hdG9uID0gbmV3IEF1dG9tYXRvbigge1xuICBndWk6IGRpdkF1dG9tYXRvbixcbiAgZnBzOiA2MCxcbiAgZGF0YTogYFxuICB7XCJ2XCI6XCIxLjEuMVwiLFwibGVuZ3RoXCI6MyxcInJlc29sdXRpb25cIjoxMDAwLFwicGFyYW1zXCI6e1wiY2FtZXJhUG9zWFwiOlt7XCJ0aW1lXCI6MCxcInZhbHVlXCI6MCxcIm1vZGVcIjoxLFwicGFyYW1zXCI6e30sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjAuNSxcInZhbHVlXCI6MCxcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwMDAsXCJkYW1wXCI6MX0sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjEsXCJ2YWx1ZVwiOjAuMzY4NTA4NDU0MTA2Mjc5MSxcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwMDAsXCJkYW1wXCI6MX0sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjEuNjI1LFwidmFsdWVcIjotMC4zMjg1MDI0MTU0NTg5Mzk1NSxcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwMDAsXCJkYW1wXCI6MX0sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjIsXCJ2YWx1ZVwiOjAuMzMxODIzNjcxNDk3NTg0NixcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwMDAsXCJkYW1wXCI6MX0sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjMsXCJ2YWx1ZVwiOjAsXCJtb2RlXCI6NCxcInBhcmFtc1wiOntcInJhdGVcIjoyMDAwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19XSxcInBhdGhCZWdpblwiOlt7XCJ0aW1lXCI6MCxcInZhbHVlXCI6MC4yLFwibW9kZVwiOjEsXCJwYXJhbXNcIjp7fSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6MyxcInZhbHVlXCI6MCxcIm1vZGVcIjoxLFwicGFyYW1zXCI6e30sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX1dLFwicGF0aFNlZ3NcIjpbe1widGltZVwiOjAsXCJ2YWx1ZVwiOjMwLjAwMDAwMDAwMDAwMDAwNyxcIm1vZGVcIjoxLFwicGFyYW1zXCI6e30sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjEuMjUsXCJ2YWx1ZVwiOjQsXCJtb2RlXCI6NCxcInBhcmFtc1wiOntcInJhdGVcIjozMCxcImRhbXBcIjoxfSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6MyxcInZhbHVlXCI6MzAsXCJtb2RlXCI6NCxcInBhcmFtc1wiOntcInJhdGVcIjozMCxcImRhbXBcIjoxfSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfV0sXCJkZWZvcm1BbXBcIjpbe1widGltZVwiOjAsXCJ2YWx1ZVwiOjUsXCJtb2RlXCI6MSxcInBhcmFtc1wiOnt9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19LHtcInRpbWVcIjoxLjI1LFwidmFsdWVcIjo1Ljc0NDgwMDAwMzI0MzU5NixcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19LHtcInRpbWVcIjoyLjQzMTQ4Njg4MDQ2NjQ3MjcsXCJ2YWx1ZVwiOjAsXCJtb2RlXCI6NCxcInBhcmFtc1wiOntcInJhdGVcIjo5MSxcImRhbXBcIjoxfSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6Mi42ODUxMzExOTUzMzUyNzcsXCJ2YWx1ZVwiOjEuNzkzOTE3NjA0MjQxNjg5MSxcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwMCxcImRhbXBcIjoxfSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6MyxcInZhbHVlXCI6NSxcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwMCxcImRhbXBcIjoxfSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfV0sXCJkZWZvcm1GcmVxXCI6W3tcInRpbWVcIjowLFwidmFsdWVcIjoxLFwibW9kZVwiOjEsXCJwYXJhbXNcIjp7fSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6MS4yNSxcInZhbHVlXCI6MC4xNTE2MTU3NDA2NDc1NzEzMyxcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19LHtcInRpbWVcIjozLFwidmFsdWVcIjoxLFwibW9kZVwiOjQsXCJwYXJhbXNcIjp7XCJyYXRlXCI6NTAwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19XSxcImRlZm9ybU9mZnNldFwiOlt7XCJ0aW1lXCI6MCxcInZhbHVlXCI6MCxcIm1vZGVcIjoxLFwicGFyYW1zXCI6e30sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjMsXCJ2YWx1ZVwiOjEuMDAxNDU3MzAzOTE4NjMxNCxcIm1vZGVcIjoxLFwicGFyYW1zXCI6e30sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX1dLFwiY2FtZXJhUG9zWVwiOlt7XCJ0aW1lXCI6MCxcInZhbHVlXCI6MCxcIm1vZGVcIjoxLFwicGFyYW1zXCI6e30sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjAuNzUsXCJ2YWx1ZVwiOjAsXCJtb2RlXCI6NCxcInBhcmFtc1wiOntcInJhdGVcIjo1MDAwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19LHtcInRpbWVcIjoxLjI1LFwidmFsdWVcIjowLjQwMTI2ODExNTk0MjAyOTI3LFwibW9kZVwiOjQsXCJwYXJhbXNcIjp7XCJyYXRlXCI6NTAwMCxcImRhbXBcIjoxfSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6MS44NzUsXCJ2YWx1ZVwiOi0wLjczNTk2MDE0NDkyNzUzNyxcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwMDAsXCJkYW1wXCI6MX0sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjIsXCJ2YWx1ZVwiOjAuNDAxMjY4MTE1OTQyMDI4NCxcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjUwMDAsXCJkYW1wXCI6MX0sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjMsXCJ2YWx1ZVwiOjAsXCJtb2RlXCI6NCxcInBhcmFtc1wiOntcInJhdGVcIjo1MDAwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19XSxcImNhbWVyYVBvc1pcIjpbe1widGltZVwiOjAsXCJ2YWx1ZVwiOjEwLFwibW9kZVwiOjEsXCJwYXJhbXNcIjp7fSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6MS4yNSxcInZhbHVlXCI6MTguMDgwNTE5MTkyMDU1NjY0LFwibW9kZVwiOjQsXCJwYXJhbXNcIjp7XCJyYXRlXCI6MjUwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19LHtcInRpbWVcIjoyLFwidmFsdWVcIjo5LjU3MjQ2Mzc2ODExNTk0MyxcIm1vZGVcIjo0LFwicGFyYW1zXCI6e1wicmF0ZVwiOjI1MCxcImRhbXBcIjoxfSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6MyxcInZhbHVlXCI6MTAsXCJtb2RlXCI6NCxcInBhcmFtc1wiOntcInJhdGVcIjo1MDAwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19XSxcImdsaXRjaFwiOlt7XCJ0aW1lXCI6MCxcInZhbHVlXCI6MC4zNjUwNTQyMDA5OTkxMTQ4LFwibW9kZVwiOjEsXCJwYXJhbXNcIjp7fSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6Mi41LFwidmFsdWVcIjowLFwibW9kZVwiOjQsXCJwYXJhbXNcIjp7XCJyYXRlXCI6MTkwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSx7XCJmcmVxXCI6MSxcImFtcFwiOjAuMDI0LFwicmVzb1wiOjgsXCJyZWN1cnNpb25cIjo0LFwic2VlZFwiOjIwLjA3fSx7XCJmcmVxXCI6MTl9XX0se1widGltZVwiOjMsXCJ2YWx1ZVwiOjAuMzExNDY2NTQwNjU1MzY0MTcsXCJtb2RlXCI6MixcInBhcmFtc1wiOnt9LFwibW9kc1wiOlt7XCJ2ZWxvY2l0eVwiOjB9LGZhbHNlLGZhbHNlLGZhbHNlXX1dLFwiZ2xpdGNoU2VlZFwiOlt7XCJ0aW1lXCI6MCxcInZhbHVlXCI6MCxcIm1vZGVcIjoxLFwicGFyYW1zXCI6e30sXCJtb2RzXCI6W2ZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlXX0se1widGltZVwiOjAuMDQwNTQwNTQwNTQwNTQwNTQsXCJ2YWx1ZVwiOjAuMDUzMTQwMDk2NjE4MzU3NDQ2LFwibW9kZVwiOjAsXCJwYXJhbXNcIjp7fSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6MC40NzIzMDMyMDY5OTcwODQ2LFwidmFsdWVcIjowLjE4MzU3NDg3OTIyNzA1MzE4LFwibW9kZVwiOjAsXCJwYXJhbXNcIjp7fSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6Mi41NTA5ODEwMTAxNjQ2ODM1LFwidmFsdWVcIjowLjcyNDg4MzAwMTIwNzcyOTQsXCJtb2RlXCI6MSxcInBhcmFtc1wiOnt9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSx7XCJmcmVxXCI6MzF9XX0se1widGltZVwiOjIuOTIxLFwidmFsdWVcIjowLjg4NDA1Nzk3MTAxNDQ5MzIsXCJtb2RlXCI6MCxcInBhcmFtc1wiOnt9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19LHtcInRpbWVcIjozLFwidmFsdWVcIjoxLFwibW9kZVwiOjEsXCJwYXJhbXNcIjp7fSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfV0sXCJtZWFzdXJlUGhhc2UxXCI6W3tcInRpbWVcIjowLFwidmFsdWVcIjoxLFwibW9kZVwiOjEsXCJwYXJhbXNcIjp7fSxcIm1vZHNcIjpbZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2VdfSx7XCJ0aW1lXCI6MS4yNSxcInZhbHVlXCI6NS41NTExMTUxMjMxMjU3ODNlLTE3LFwibW9kZVwiOjQsXCJwYXJhbXNcIjp7XCJyYXRlXCI6NTAwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19LHtcInRpbWVcIjozLFwidmFsdWVcIjoxLFwibW9kZVwiOjQsXCJwYXJhbXNcIjp7XCJyYXRlXCI6NTAwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19XSxcIm1lYXN1cmVQaGFzZTJcIjpbe1widGltZVwiOjAsXCJ2YWx1ZVwiOjEsXCJtb2RlXCI6MSxcInBhcmFtc1wiOnt9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19LHtcInRpbWVcIjoxLjU4MDExNTgzMDExNTgzMDUsXCJ2YWx1ZVwiOjAuMDA0ODMwOTE3ODc0Mzk2MTAxLFwibW9kZVwiOjQsXCJwYXJhbXNcIjp7XCJyYXRlXCI6NTAwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19LHtcInRpbWVcIjozLFwidmFsdWVcIjoxLFwibW9kZVwiOjQsXCJwYXJhbXNcIjp7XCJyYXRlXCI6NTAwLFwiZGFtcFwiOjF9LFwibW9kc1wiOltmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZV19XX0sXCJndWlcIjp7XCJzbmFwXCI6e1wiZW5hYmxlXCI6dHJ1ZSxcImJwbVwiOlwiNjBcIixcIm9mZnNldFwiOlwiMFwifX19XG5gXG59ICk7XG5sZXQgYXV0byA9IGF1dG9tYXRvbi5hdXRvO1xuXG4vLyAtLS0tLS1cblxubGV0IGNhbWVyYVBvcyA9IFsgMC4wLCAwLjAsIDEwLjAgXTtcbmxldCBjYW1lcmFUYXIgPSBbIDAuMCwgMC4wLCAwLjAgXTtcbmxldCBjYW1lcmFSb2xsID0gMC4wO1xubGV0IGNhbWVyYUZvdiA9IDcwLjA7XG5cbmxldCBjYW1lcmFOZWFyID0gMC4xO1xubGV0IGNhbWVyYUZhciA9IDEwMC4wO1xuXG5sZXQgbGlnaHRQb3MgPSBbIDEwLjAsIDguMCwgMTAuMCBdO1xuXG5sZXQgbWF0UDtcbmxldCBtYXRWO1xubGV0IG1hdFBMO1xubGV0IG1hdFZMO1xuXG5sZXQgdXBkYXRlTWF0cmljZXMgPSAoKSA9PiB7XG4gIGNhbWVyYVBvc1sgMCBdID0gYXV0byggJ2NhbWVyYVBvc1gnICk7XG4gIGNhbWVyYVBvc1sgMSBdID0gYXV0byggJ2NhbWVyYVBvc1knICk7XG4gIGNhbWVyYVBvc1sgMiBdID0gYXV0byggJ2NhbWVyYVBvc1onICk7XG5cbiAgbWF0UCA9IE1hdGhDYXQubWF0NFBlcnNwZWN0aXZlKCBjYW1lcmFGb3YsIGNhbWVyYU5lYXIsIGNhbWVyYUZhciApO1xuICBtYXRWID0gTWF0aENhdC5tYXQ0TG9va0F0KCBjYW1lcmFQb3MsIGNhbWVyYVRhciwgWyAwLjAsIDEuMCwgMC4wIF0sIGNhbWVyYVJvbGwgKTtcblxuICBtYXRQTCA9IE1hdGhDYXQubWF0NFBlcnNwZWN0aXZlKCBjYW1lcmFGb3YsIGNhbWVyYU5lYXIsIGNhbWVyYUZhciApO1xuICBtYXRWTCA9IE1hdGhDYXQubWF0NExvb2tBdCggbGlnaHRQb3MsIGNhbWVyYVRhciwgWyAwLjAsIDEuMCwgMC4wIF0sIDAuMCApO1xufTtcbnVwZGF0ZU1hdHJpY2VzKCk7XG5cbi8vIC0tLS0tLVxuXG5sZXQgbW91c2VYID0gMC4wO1xubGV0IG1vdXNlWSA9IDAuMDtcblxuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoICdtb3VzZW1vdmUnLCAoIGV2ZW50ICkgPT4ge1xuICBtb3VzZVggPSBldmVudC5vZmZzZXRYO1xuICBtb3VzZVkgPSBldmVudC5vZmZzZXRZO1xufSApO1xuXG4vLyAtLS0tLS1cblxubGV0IHZib1F1YWQgPSBnbENhdC5jcmVhdGVWZXJ0ZXhidWZmZXIoIFsgLTEsIC0xLCAxLCAtMSwgLTEsIDEsIDEsIDEgXSApO1xuXG4vLyAtLS0tLS1cblxubGV0IGJnQ29sb3IgPSBbIDAuMDEsIDAuMDEsIDAuMDEsIDEuMCBdO1xuXG4vLyAtLS0tLS1cblxuZ2xDYXRQYXRoLnNldEdsb2JhbEZ1bmMoICgpID0+IHtcbiAgZ2xDYXQudW5pZm9ybTFpKCAnaW5pdCcsIGluaXQgKTtcbiAgZ2xDYXQudW5pZm9ybTFmKCAndGltZScsIGF1dG9tYXRvbi50aW1lICk7XG4gIGdsQ2F0LnVuaWZvcm0xZiggJ2RlbHRhVGltZScsIGF1dG9tYXRvbi5kZWx0YVRpbWUgKTtcblxuICBnbENhdC51bmlmb3JtMWYoICd0b3RhbEZyYW1lJywgdG90YWxGcmFtZSApO1xuICBnbENhdC51bmlmb3JtMmZ2KCAnbW91c2UnLCBbIG1vdXNlWCwgbW91c2VZIF0gKTtcblxuICBnbENhdC51bmlmb3JtM2Z2KCAnY2FtZXJhUG9zJywgY2FtZXJhUG9zICk7XG4gIGdsQ2F0LnVuaWZvcm0zZnYoICdjYW1lcmFUYXInLCBjYW1lcmFUYXIgKTtcbiAgZ2xDYXQudW5pZm9ybTFmKCAnY2FtZXJhUm9sbCcsIGNhbWVyYVJvbGwgKTtcbiAgZ2xDYXQudW5pZm9ybTFmKCAnY2FtZXJhRm92JywgY2FtZXJhRm92ICk7XG4gIGdsQ2F0LnVuaWZvcm0xZiggJ2NhbWVyYU5lYXInLCBjYW1lcmFOZWFyICk7XG4gIGdsQ2F0LnVuaWZvcm0xZiggJ2NhbWVyYUZhcicsIGNhbWVyYUZhciApO1xuICBnbENhdC51bmlmb3JtM2Z2KCAnbGlnaHRQb3MnLCBsaWdodFBvcyApO1xuXG4gIGdsQ2F0LnVuaWZvcm1NYXRyaXg0ZnYoICdtYXRQJywgbWF0UCApO1xuICBnbENhdC51bmlmb3JtTWF0cml4NGZ2KCAnbWF0VicsIG1hdFYgKTtcbiAgZ2xDYXQudW5pZm9ybU1hdHJpeDRmdiggJ21hdFBMJywgbWF0UEwgKTtcbiAgZ2xDYXQudW5pZm9ybU1hdHJpeDRmdiggJ21hdFZMJywgbWF0VkwgKTtcbiAgZ2xDYXQudW5pZm9ybTRmdiggJ2JnQ29sb3InLCBiZ0NvbG9yICk7XG59ICk7XG5cbmdsQ2F0UGF0aC5hZGQoIHtcbiAgcmV0dXJuOiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHZlcnQ6IGdsc2xpZnkoICcuL3NoYWRlci9xdWFkLnZlcnQnICksXG4gICAgZnJhZzogZ2xzbGlmeSggJy4vc2hhZGVyL3JldHVybi5mcmFnJyApLFxuICAgIGJsZW5kOiBbIGdsLk9ORSwgZ2wuWkVSTyBdLFxuICAgIGNsZWFyOiBbIDAuMCwgMC4wLCAwLjAsIDEuMCBdLFxuICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xuICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcbiAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlcjAnLCBwYXJhbXMuaW5wdXQsIDAgKTtcbiAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XG4gICAgfVxuICB9LFxuXG4gIGluc3BlY3Rvcjoge1xuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICB2ZXJ0OiBnbHNsaWZ5KCAnLi9zaGFkZXIvcXVhZC52ZXJ0JyApLFxuICAgIGZyYWc6IGdsc2xpZnkoICcuL3NoYWRlci9pbnNwZWN0b3IuZnJhZycgKSxcbiAgICBibGVuZDogWyBnbC5PTkUsIGdsLlpFUk8gXSxcbiAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAxLjAgXSxcbiAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcbiAgICAgIGdsQ2F0LmF0dHJpYnV0ZSggJ3AnLCB2Ym9RdWFkLCAyICk7XG4gICAgICBnbENhdC51bmlmb3JtM2Z2KCAnY2lyY2xlQ29sb3InLCBbIDEuMCwgMS4wLCAxLjAgXSApO1xuICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyMCcsIHBhcmFtcy5pbnB1dCwgMCApO1xuICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICB9XG4gIH0sXG5cbiAgJ3RhcmdldCc6IHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgdmVydDogZ2xzbGlmeSggJy4vc2hhZGVyL3F1YWQudmVydCcgKSxcbiAgICBmcmFnOiBnbHNsaWZ5KCAnLi9zaGFkZXIvYmcuZnJhZycgKSxcbiAgICBibGVuZDogWyBnbC5PTkUsIGdsLlpFUk8gXSxcbiAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAxLjAgXSxcbiAgICBmcmFtZWJ1ZmZlcjogdHJ1ZSxcbiAgICBmbG9hdDogdHJ1ZSxcbiAgICBkZXB0aFdyaXRlOiBmYWxzZSxcbiAgICBmdW5jOiAoKSA9PiB7XG4gICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xuICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcbiAgICB9XG4gIH0sXG59ICk7XG5cbi8vIC0tLS0tLVxuXG5sZXQgdXBkYXRlVUkgPSAoKSA9PiB7XG4gIGxldCBub3cgPSBuZXcgRGF0ZSgpO1xuICBsZXQgZGVhZGxpbmUgPSBuZXcgRGF0ZSggMjAxOCwgMiwgMTYsIDAsIDAgKTtcblxuICBkaXZDb3VudGRvd24uaW5uZXJUZXh0ID0gJ0RlYWRsaW5lOiAnICsgTWF0aC5mbG9vciggKCBkZWFkbGluZSAtIG5vdyApIC8gMTAwMCApO1xufTtcblxuLy8gLS0tLS0tXG5cbmxldCB1cGRhdGUgPSAoKSA9PiB7XG4gIGlmICggIXR3ZWFrLmNoZWNrYm94KCAncGxheScsIHsgdmFsdWU6IHRydWUgfSApICkge1xuICAgIHNldFRpbWVvdXQoIHVwZGF0ZSwgMTAwICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXV0b21hdG9uLnVwZGF0ZSgpO1xuXG4gIHVwZGF0ZVVJKCk7XG4gIHVwZGF0ZU1hdHJpY2VzKCk7XG5cbiAgLy8gLS0tLS0tXG5cbiAgZ2xDYXRQYXRoLmJlZ2luKCk7XG5cbiAgZ2xDYXRQYXRoLnJlbmRlciggJ3RhcmdldCcgKTtcblxuICBnbENhdFBhdGgucmVuZGVyKCAncGllY2VzQ29tcHV0ZVJldHVybicgKTtcbiAgZ2xDYXRQYXRoLnJlbmRlciggJ3BpZWNlc0NvbXB1dGUnICk7XG5cbiAgZ2xDYXRQYXRoLnJlbmRlciggJ2xvZmlwYXRoJywge1xuICAgIHRhcmdldDogZ2xDYXRQYXRoLmZiKCAndGFyZ2V0JyApLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBiZWdpbjogYXV0byggJ3BhdGhCZWdpbicgKSxcbiAgICBzZWdzOiBhdXRvKCAncGF0aFNlZ3MnIClcbiAgfSApO1xuXG4gIGdsQ2F0UGF0aC5yZW5kZXIoICdwaWVjZXNSZW5kZXInLCB7XG4gICAgdGFyZ2V0OiBnbENhdFBhdGguZmIoICd0YXJnZXQnICksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH0gKTtcblxuICBnbENhdFBhdGgucmVuZGVyKCAnY29uc29sZScsIHtcbiAgICB0YXJnZXQ6IGdsQ2F0UGF0aC5mYiggJ3RhcmdldCcgKSxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgdGltZTogYXV0b21hdG9uLnRpbWUsXG4gICAgZnJhbWU6IGF1dG9tYXRvbi5mcmFtZSxcbiAgICBjYW1lcmFYOiBjYW1lcmFQb3NbIDAgXSxcbiAgICBjYW1lcmFZOiBjYW1lcmFQb3NbIDEgXSxcbiAgICBjYW1lcmFaOiBjYW1lcmFQb3NbIDIgXVxuICB9ICk7XG5cbiAgZ2xDYXRQYXRoLnJlbmRlciggJ21lYXN1cmUnLCB7XG4gICAgdGFyZ2V0OiBnbENhdFBhdGguZmIoICd0YXJnZXQnICksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHBoYXNlMTogYXV0byggJ21lYXN1cmVQaGFzZTEnICksXG4gICAgcGhhc2UyOiBhdXRvKCAnbWVhc3VyZVBoYXNlMicgKVxuICB9ICk7XG5cbiAgZ2xDYXRQYXRoLnJlbmRlciggJ2dyaWQnLCB7XG4gICAgdGFyZ2V0OiBnbENhdFBhdGguZmIoICd0YXJnZXQnICksXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH0gKTtcblxuICBnbENhdFBhdGgucmVuZGVyKCAnZ2xpdGNoJywge1xuICAgIGlucHV0OiBnbENhdFBhdGguZmIoICd0YXJnZXQnICkudGV4dHVyZSxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgYW1wOiBhdXRvKCAnZ2xpdGNoJyApLFxuICAgIHNlZWQ6IGF1dG8oICdnbGl0Y2hTZWVkJyApXG4gIH0gKTtcblxuICBnbENhdFBhdGgucmVuZGVyKCAncG9zdCcsIHtcbiAgICB0YXJnZXQ6IEdMQ2F0UGF0aC5udWxsRmIsXG4gICAgaW5wdXQ6IGdsQ2F0UGF0aC5mYiggJ2dsaXRjaCcgKS50ZXh0dXJlLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgfSApO1xuXG4gIGdsQ2F0UGF0aC5lbmQoKTtcblxuICBpbml0ID0gZmFsc2U7XG4gIHRvdGFsRnJhbWUgKys7XG5cbiAgLy8gLS0tLS0tXG5cbiAgaWYgKCB0d2Vhay5jaGVja2JveCggJ3NhdmUnLCB7IHZhbHVlOiBmYWxzZSB9ICkgKSB7XG4gICAgc2F2ZUZyYW1lKCk7XG4gIH1cblxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHVwZGF0ZSApO1xufVxuXG5cbnN0ZXAoIHtcbiAgMDogKCBzdGVwICkgPT4ge1xuICAgIHBhdGhMb2ZpUGF0aCggZ2xDYXRQYXRoLCBhdXRvLCBzdGVwICk7XG4gICAgcGF0aFBvc3RmeCggZ2xDYXRQYXRoLCB3aWR0aCwgaGVpZ2h0ICk7XG4gICAgcGF0aENvbnNvbGUoIGdsQ2F0UGF0aCwgd2lkdGgsIGhlaWdodCApO1xuICAgIHBhdGhQaWVjZXMoIGdsQ2F0UGF0aCwgYXV0b21hdG9uICk7XG4gICAgcGF0aEdyaWQoIGdsQ2F0UGF0aCApO1xuICB9LFxuXG4gIDE6ICggc3RlcCApID0+IHtcbiAgICB1cGRhdGUoKTtcbiAgfVxufSApO1xuXG4vLyAtLS0tLS1cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdrZXlkb3duJywgKCBfZSApID0+IHtcbiAgaWYgKCBfZS53aGljaCA9PT0gMjcgKSB7XG4gICAgdHdlYWsuY2hlY2tib3goICdwbGF5JywgeyBzZXQ6IGZhbHNlIH0gKTtcbiAgfVxufSApO1xuIiwiY29uc3QgZ2xzbGlmeSA9IHJlcXVpcmUoICdnbHNsaWZ5JyApO1xyXG5cclxuLy8gLS0tLS0tXHJcblxyXG5sZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcclxubGV0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xyXG5cclxuLy8gLS0tLS0tXHJcblxyXG5sZXQgdGV4dFdpdGhCZyA9ICggdGV4dCwgeCwgeSApID0+IHtcclxuICBjb250ZXh0LmZvbnQgPSAnNTAwIDIwcHggV3QtUG9zaXRpb24nO1xyXG4gIGNvbnRleHQudGV4dEFsaWduID0gJ2xlZnQnO1xyXG4gIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2hhbmdpbmcnO1xyXG5cclxuICBsZXQgbXQgPSBjb250ZXh0Lm1lYXN1cmVUZXh0KCB0ZXh0ICk7XHJcblxyXG4gIGNvbnRleHQuZmlsbFN0eWxlID0gJyNmZmYnO1xyXG4gIGNvbnRleHQuZmlsbFJlY3QoIHggLSA0LCB5IC0gNCwgbXQud2lkdGggKyA4LCAyMCApO1xyXG5cclxuICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjMDAwJztcclxuICBjb250ZXh0LmZpbGxUZXh0KCB0ZXh0LCB4LCB5ICk7XHJcbn07XHJcblxyXG5sZXQgdGV4dEJvdHRvbSA9ICggdGV4dCwgc2l6ZSwgeCwgeSApID0+IHtcclxuICBjb250ZXh0LmZvbnQgPSAnOTAwICcgKyBzaXplICsgJ3B4IEhlbHZldGljYSBOZXVlJztcclxuICBjb250ZXh0LnRleHRBbGlnbiA9ICdyaWdodCc7XHJcbiAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XHJcblxyXG4gIGNvbnRleHQuZmlsbFN0eWxlID0gJyNmZmYnO1xyXG4gIGNvbnRleHQuZmlsbFRleHQoIHRleHQsIHgsIHkgKTtcclxufTtcclxuXHJcbi8vIC0tLS0tLVxyXG5cclxubGV0IHBhdGhDb25zb2xlID0gKCBnbENhdFBhdGgsIHdpZHRoLCBoZWlnaHQgKSA9PiB7XHJcbiAgbGV0IGdsQ2F0ID0gZ2xDYXRQYXRoLmdsQ2F0O1xyXG4gIGxldCBnbCA9IGdsQ2F0LmdsO1xyXG5cclxuICAvLyAtLS0tLS1cclxuXHJcbiAgbGV0IHcgPSBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICBsZXQgaCA9IGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gIGxldCB2Ym9RdWFkID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBbIC0xLCAtMSwgMSwgLTEsIC0xLCAxLCAxLCAxIF0gKTtcclxuICBsZXQgdGV4dHVyZSA9IGdsQ2F0LmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcbiAgLy8gLS0tLS0tXHJcblxyXG4gIGdsQ2F0UGF0aC5hZGQoIHtcclxuICAgIGNvbnNvbGU6IHtcclxuICAgICAgdmVydDogZ2xzbGlmeSggJy4vc2hhZGVyL3F1YWQudmVydCcgKSxcclxuICAgICAgZnJhZzogZ2xzbGlmeSggJy4vc2hhZGVyL3JldHVybi15aW52ZXJ0LmZyYWcnICksXHJcbiAgICAgIGZsb2F0OiB0cnVlLFxyXG4gICAgICBibGVuZDogWyBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgXSxcclxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXHJcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXHJcbiAgICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xyXG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KCAwLCAwLCB3LCBoICk7XHJcblxyXG4gICAgICAgIHRleHRXaXRoQmcoICdSQU5ET00gRiolI0lORyBOVU1CRVI6ICcgKyAoIDI1Ni4wICogTWF0aC5yYW5kb20oKSApLnRvRml4ZWQoIDMgKSwgMTAsIDEwICk7XHJcbiAgICAgICAgdGV4dFdpdGhCZyggJ0NBTUVSQSBYOiAnICsgcGFyYW1zLmNhbWVyYVgudG9GaXhlZCggMyApLCAxMCwgNDAgKTtcclxuICAgICAgICB0ZXh0V2l0aEJnKCAnQ0FNRVJBIFk6ICcgKyBwYXJhbXMuY2FtZXJhWS50b0ZpeGVkKCAzICksIDEwLCA3MCApO1xyXG4gICAgICAgIHRleHRXaXRoQmcoICdDQU1FUkEgWjogJyArIHBhcmFtcy5jYW1lcmFaLnRvRml4ZWQoIDMgKSwgMTAsIDEwMCApO1xyXG5cclxuICAgICAgICB0ZXh0Qm90dG9tKCBwYXJhbXMudGltZS50b0ZpeGVkKCAzICksIDMwLCB3aWR0aCAtIDEwLCBoZWlnaHQgLSA4MCApO1xyXG4gICAgICAgIHRleHRCb3R0b20oICd1bmRlZmluZWQnLCAzMCwgd2lkdGggLSAxMCwgaGVpZ2h0IC0gNTAgKTtcclxuICAgICAgICB0ZXh0Qm90dG9tKCAnW1BsYWNlaG9sZGVyXScsIDQwLCB3aWR0aCAtIDEwLCBoZWlnaHQgLSAxMCApO1xyXG5cclxuICAgICAgICBnbENhdC5zZXRUZXh0dXJlKCB0ZXh0dXJlLCBjYW52YXMgKTtcclxuXHJcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcclxuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXIwJywgdGV4dHVyZSwgMCApO1xyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgfSApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgcGF0aENvbnNvbGU7IiwiaW1wb3J0IE1hdGhDYXQgZnJvbSAnLi9saWJzL21hdGhjYXQnO1xyXG5jb25zdCBnbHNsaWZ5ID0gcmVxdWlyZSggJ2dsc2xpZnknICk7XHJcblxyXG4vLyAtLS0tLS1cclxuXHJcbmxldCBwYXRoR3JpZCA9ICggZ2xDYXRQYXRoICkgPT4ge1xyXG4gIGxldCBnbENhdCA9IGdsQ2F0UGF0aC5nbENhdDtcclxuICBsZXQgZ2wgPSBnbENhdC5nbDtcclxuXHJcbiAgLy8gLS0tLS0tXHJcblxyXG4gIGxldCB2Ym9RdWFkID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBbIC0xLCAtMSwgMSwgLTEsIC0xLCAxLCAxLCAxIF0gKTtcclxuXHJcbiAgbGV0IGxheWVyID0gW107XHJcbiAgZm9yICggbGV0IGkgPSAtMzsgaSA8IDA7IGkgKysgKSB7XHJcbiAgICBsYXllci5wdXNoKCAoIGkgKyAwLjUgKSAqIDAuMDUgKTtcclxuICB9XHJcbiAgbGV0IHZib0xheWVyID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBsYXllciApO1xyXG5cclxuICAvLyAtLS0tLS1cclxuXHJcbiAgZ2xDYXRQYXRoLmFkZCgge1xyXG4gICAgZ3JpZDoge1xyXG4gICAgICB2ZXJ0OiBnbHNsaWZ5KCAnLi9zaGFkZXIvcGF0aDJkei52ZXJ0JyApLFxyXG4gICAgICBmcmFnOiBnbHNsaWZ5KCAnLi9zaGFkZXIvZ3JpZC5mcmFnJyApLFxyXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcclxuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICd6JywgdmJvTGF5ZXIsIDEsIDEgKTtcclxuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xyXG5cclxuICAgICAgICBsZXQgbWF0TSA9IE1hdGhDYXQubWF0NElkZW50aXR5KCk7XHJcbiAgICAgICAgbWF0TSA9IE1hdGhDYXQubWF0NEFwcGx5KCBNYXRoQ2F0Lm1hdDRTY2FsZVhZWiggMTAwLjAgKSwgbWF0TSApO1xyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm1NYXRyaXg0ZnYoICdtYXRNJywgbWF0TSApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0zZnYoICdjb2xvcicsIFsgMS4wLCAxLjAsIDEuMCBdICk7XHJcblxyXG4gICAgICAgIGxldCBleHQgPSBnbENhdC5nZXRFeHRlbnNpb24oIFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiICk7XHJcbiAgICAgICAgZXh0LmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQsIHZib0xheWVyLmxlbmd0aCApO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIG1lYXN1cmU6IHtcclxuICAgICAgdmVydDogZ2xzbGlmeSggJy4vc2hhZGVyL3BhdGgyZC52ZXJ0JyApLFxyXG4gICAgICBmcmFnOiBnbHNsaWZ5KCAnLi9zaGFkZXIvbWVhc3VyZS5mcmFnJyApLFxyXG4gICAgICBmdW5jOiAoIHBhdGgsIHBhcmFtcyApID0+IHtcclxuICAgICAgICBnbENhdC5hdHRyaWJ1dGUoICdwJywgdmJvUXVhZCwgMiApO1xyXG5cclxuICAgICAgICBsZXQgbWF0TSA9IE1hdGhDYXQubWF0NElkZW50aXR5KCk7XHJcbiAgICAgICAgbWF0TSA9IE1hdGhDYXQubWF0NEFwcGx5KCBNYXRoQ2F0Lm1hdDRTY2FsZVhZWiggMTAwLjAgKSwgbWF0TSApO1xyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm1NYXRyaXg0ZnYoICdtYXRNJywgbWF0TSApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ3BoYXNlMScsIHBhcmFtcy5waGFzZTEgKTtcclxuICAgICAgICBnbENhdC51bmlmb3JtMWYoICdwaGFzZTInLCBwYXJhbXMucGhhc2UyICk7XHJcbiAgICAgICAgZ2xDYXQudW5pZm9ybTNmdiggJ2NvbG9yJywgWyAxLjAsIDEuMCwgMS4wIF0gKTtcclxuXHJcbiAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICB9ICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBwYXRoR3JpZDsiLCJpbXBvcnQgc3ZnUGF0aCBmcm9tICcuL3N2Zy1wYXRoJztcclxuaW1wb3J0IE1hdGhDYXQgZnJvbSAnLi9saWJzL21hdGhjYXQnO1xyXG5pbXBvcnQgVmVydFBoYXNlciBmcm9tICcuL3ZlcnRwaGFzZXInO1xyXG5pbXBvcnQgKiBhcyBvcGVudHlwZSBmcm9tICdvcGVudHlwZS5qcyc7XHJcbmNvbnN0IGdsc2xpZnkgPSByZXF1aXJlKCAnZ2xzbGlmeScgKTtcclxuXHJcbi8vIC0tLS0tLVxyXG5cclxubGV0IHBhdGhMb2ZpUGF0aCA9ICggZ2xDYXRQYXRoLCBhdXRvLCBjYWxsYmFjayApID0+IHtcclxuICBsZXQgZ2xDYXQgPSBnbENhdFBhdGguZ2xDYXQ7XHJcbiAgbGV0IGdsID0gZ2xDYXQuZ2w7XHJcblxyXG4gIC8vIC0tLS0tLVxyXG5cclxuICBsZXQgcGhhc2VycztcclxuXHJcbiAgb3BlbnR5cGUubG9hZCggJ2ZvbnRzL09yYml0cm9uLUJsYWNrLnR0ZicsIGZ1bmN0aW9uKCBlcnJvciwgZm9udCApIHtcclxuICAgIGlmICggZXJyb3IgKSB7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBsZXQgZm9udFNpemUgPSAxMi4wO1xyXG4gICAgbGV0IHRleHQgPSAnVmVjJztcclxuICAgIGxldCB3aWQgPSBmb250LmdldEFkdmFuY2VXaWR0aCggdGV4dCwgZm9udFNpemUgKTtcclxuICAgIGxldCBwYXRoID0gZm9udC5nZXRQYXRoKCB0ZXh0LCAwLCAwLCBmb250U2l6ZSApLnRvUGF0aERhdGEoKTtcclxuICAgIGxldCB2cyA9IHN2Z1BhdGgoIHBhdGgsIHsgY3VydmVTZWdzOiA4IH0gKTtcclxuICAgIHBoYXNlcnMgPSB2cy5tYXAoICggdiApID0+IHtcclxuICAgICAgZm9yICggbGV0IGkgPSAwOyBpIDwgdi5sZW5ndGggLyAyOyBpICsrICkge1xyXG4gICAgICAgIHZbIGkgKiAyICsgMCBdID0gICggdlsgaSAqIDIgKyAwIF0gLSB3aWQgLyAyICk7XHJcbiAgICAgICAgdlsgaSAqIDIgKyAxIF0gPSAtKCB2WyBpICogMiArIDEgXSArIGZvbnRTaXplICogMC4zNSApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBuZXcgVmVydFBoYXNlciggdiApO1xyXG4gICAgfSApO1xyXG5cclxuICAgIGNhbGxiYWNrKCk7XHJcbiAgfSApO1xyXG5cclxuICBsZXQgdmJvUG9zID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBmYWxzZSApO1xyXG5cclxuICAvLyAtLS0tLS1cclxuXHJcbiAgZ2xDYXRQYXRoLmFkZCgge1xyXG4gICAgbG9maXBhdGg6IHtcclxuICAgICAgdmVydDogZ2xzbGlmeSggJy4vc2hhZGVyL3BhdGgtZGVmb3JtZXIudmVydCcgKSxcclxuICAgICAgZnJhZzogZ2xzbGlmeSggJy4vc2hhZGVyL3BvaW50LWNpcmNsZS5mcmFnJyApLFxyXG4gICAgICBmbG9hdDogdHJ1ZSxcclxuICAgICAgZGVwdGhXcml0ZTogZmFsc2UsXHJcbiAgICAgIGRlcHRoVGVzdDogZmFsc2UsXHJcbiAgICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xyXG4gICAgICAgIGxldCBtYXRNID0gTWF0aENhdC5tYXQ0SWRlbnRpdHkoKTtcclxuICAgICAgICBtYXRNID0gTWF0aENhdC5tYXQ0QXBwbHkoIE1hdGhDYXQubWF0NFNjYWxlWFlaKCAwLjQgKSwgbWF0TSApO1xyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm1NYXRyaXg0ZnYoICdtYXRNJywgbWF0TSApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0zZnYoICdjb2xvcicsIFsgMS4wLCAxLjAsIDEuMCBdICk7XHJcblxyXG4gICAgICAgIC8vIC0tLS0tLVxyXG5cclxuICAgICAgICBwaGFzZXJzLm1hcCggcGhhc2VyID0+IHtcclxuICAgICAgICAgIGxldCBiZWdpbiA9IHBhcmFtcy5iZWdpbiB8fCAwLjA7XHJcbiAgICAgICAgICBsZXQgc2VncyA9IE1hdGgubWF4KCAzLCBwYXJhbXMuc2VncyB8fCAzICk7XHJcbiAgICAgICAgICBsZXQgYXJyID0gcGhhc2VyLmxvZmkoIGJlZ2luLCBzZWdzICk7XHJcblxyXG4gICAgICAgICAgZ2xDYXQuc2V0VmVydGV4YnVmZmVyKCB2Ym9Qb3MsIGFyciwgZ2wuRFlOQU1JQ19EUkFXICk7XHJcblxyXG4gICAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1BvcywgMiApO1xyXG5cclxuICAgICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ2RlZm9ybUFtcCcsIGF1dG8oICdkZWZvcm1BbXAnICkgKTtcclxuICAgICAgICAgIGdsQ2F0LnVuaWZvcm0xZiggJ2RlZm9ybUZyZXEnLCBhdXRvKCAnZGVmb3JtRnJlcScgKSApO1xyXG4gICAgICAgICAgZ2xDYXQudW5pZm9ybTFmKCAnZGVmb3JtT2Zmc2V0JywgYXV0byggJ2RlZm9ybU9mZnNldCcgKSApO1xyXG5cclxuICAgICAgICAgIGdsQ2F0LnVuaWZvcm0xaSggJ2lzUG9pbnQnLCBmYWxzZSApO1xyXG4gICAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuTElORV9TVFJJUCwgMCwgYXJyLmxlbmd0aCAvIDIgKTtcclxuXHJcbiAgICAgICAgICBnbENhdC51bmlmb3JtMWkoICdpc1BvaW50JywgdHJ1ZSApO1xyXG4gICAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuUE9JTlRTLCAwLCBhcnIubGVuZ3RoIC8gMiApO1xyXG4gICAgICAgIH0gKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICB9ICk7XHJcbn07XHJcblxyXG5leHBvcnQgZGVmYXVsdCBwYXRoTG9maVBhdGg7IiwiaW1wb3J0IE1hdGhDYXQgZnJvbSAnLi9saWJzL21hdGhjYXQnO1xyXG5pbXBvcnQgeG9yc2hpZnQgZnJvbSAnLi9saWJzL3hvcnNoaWZ0JztcclxuY29uc3QgZ2xzbGlmeSA9IHJlcXVpcmUoICdnbHNsaWZ5JyApO1xyXG5cclxueG9yc2hpZnQoIDQ4NzcyMyApO1xyXG5cclxuLy8gLS0tLS0tXHJcblxyXG5sZXQgcGFydGljbGVQaXhlbHMgPSAyO1xyXG5sZXQgcGFydGljbGVzU3FydCA9IDg7XHJcbmxldCBwYXJ0aWNsZXMgPSBwYXJ0aWNsZXNTcXJ0ICogcGFydGljbGVzU3FydDtcclxuLy8gbGV0IHZlcnRzUGVyUGFydGljbGUgPSBsdW5hTGVuIC8gMztcclxuXHJcbi8vIC0tLS0tLVxyXG5cclxubGV0IHBhdGhQaWVjZXMgPSAoIGdsQ2F0UGF0aCwgYXV0b21hdG9uICkgPT4ge1xyXG4gIGxldCBnbENhdCA9IGdsQ2F0UGF0aC5nbENhdDtcclxuICBsZXQgZ2wgPSBnbENhdC5nbDtcclxuXHJcbiAgLy8gLS0tLS0tXHJcblxyXG4gIGxldCB2Ym9RdWFkID0gZ2xDYXQuY3JlYXRlVmVydGV4YnVmZmVyKCBbIC0xLCAtMSwgMSwgLTEsIC0xLCAxLCAxLCAxIF0gKTtcclxuXHJcbiAgbGV0IHZib1BhcnRpY2xlVVYgPSBnbENhdC5jcmVhdGVWZXJ0ZXhidWZmZXIoICggKCkgPT4ge1xyXG4gICAgbGV0IHJldCA9IFtdO1xyXG4gICAgZm9yICggbGV0IGkgPSAwOyBpIDwgcGFydGljbGVzOyBpICsrICkge1xyXG4gICAgICBsZXQgaXggPSBpICUgcGFydGljbGVzU3FydDtcclxuICAgICAgbGV0IGl5ID0gTWF0aC5mbG9vciggaSAvIHBhcnRpY2xlc1NxcnQgKTtcclxuICAgICAgXHJcbiAgICAgIHJldC5wdXNoKCBpeCAqIHBhcnRpY2xlUGl4ZWxzICk7XHJcbiAgICAgIHJldC5wdXNoKCBpeSApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJldDtcclxuICB9ICkoKSApO1xyXG5cclxuICAvLyAtLS0tLS1cclxuXHJcbiAgbGV0IHRleHR1cmVSYW5kb21TaXplID0gMzI7XHJcbiAgbGV0IHRleHR1cmVSYW5kb21VcGRhdGUgPSAoIF90ZXggKSA9PiB7XHJcbiAgICBnbENhdC5zZXRUZXh0dXJlRnJvbUFycmF5KCBfdGV4LCB0ZXh0dXJlUmFuZG9tU2l6ZSwgdGV4dHVyZVJhbmRvbVNpemUsICggKCkgPT4ge1xyXG4gICAgICBsZXQgbGVuID0gdGV4dHVyZVJhbmRvbVNpemUgKiB0ZXh0dXJlUmFuZG9tU2l6ZSAqIDQ7XHJcbiAgICAgIGxldCByZXQgPSBuZXcgVWludDhBcnJheSggbGVuICk7XHJcbiAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IGxlbjsgaSArKyApIHtcclxuICAgICAgICByZXRbIGkgXSA9IE1hdGguZmxvb3IoIHhvcnNoaWZ0KCkgKiAyNTYuMCApO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9ICkoKSApO1xyXG4gIH07XHJcbiAgXHJcbiAgbGV0IHRleHR1cmVSYW5kb21TdGF0aWMgPSBnbENhdC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgZ2xDYXQudGV4dHVyZVdyYXAoIHRleHR1cmVSYW5kb21TdGF0aWMsIGdsLlJFUEVBVCApO1xyXG4gIHRleHR1cmVSYW5kb21VcGRhdGUoIHRleHR1cmVSYW5kb21TdGF0aWMgKTtcclxuICBcclxuICBsZXQgdGV4dHVyZVJhbmRvbSA9IGdsQ2F0LmNyZWF0ZVRleHR1cmUoKTtcclxuICBnbENhdC50ZXh0dXJlV3JhcCggdGV4dHVyZVJhbmRvbSwgZ2wuUkVQRUFUICk7XHJcblxyXG4gIC8vIC0tLS0tLVxyXG5cclxuICBnbENhdFBhdGguYWRkKCB7XHJcbiAgICBwaWVjZXNDb21wdXRlUmV0dXJuOiB7XHJcbiAgICAgIHdpZHRoOiBwYXJ0aWNsZXNTcXJ0ICogcGFydGljbGVQaXhlbHMsXHJcbiAgICAgIGhlaWdodDogcGFydGljbGVzU3FydCxcclxuICAgICAgdmVydDogZ2xzbGlmeSggJy4vc2hhZGVyL3F1YWQudmVydCcgKSxcclxuICAgICAgZnJhZzogZ2xzbGlmeSggJy4vc2hhZGVyL3JldHVybi5mcmFnJyApLFxyXG4gICAgICBibGVuZDogWyBnbC5PTkUsIGdsLlpFUk8gXSxcclxuICAgICAgY2xlYXI6IFsgMC4wLCAwLjAsIDAuMCwgMC4wIF0sXHJcbiAgICAgIGZyYW1lYnVmZmVyOiB0cnVlLFxyXG4gICAgICBmbG9hdDogdHJ1ZSxcclxuICAgICAgZnVuYzogKCBwYXRoLCBwYXJhbXMgKSA9PiB7XHJcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcclxuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXIwJywgZ2xDYXRQYXRoLmZiKCBcInBpZWNlc0NvbXB1dGVcIiApLnRleHR1cmUsIDAgKTtcclxuICAgICAgICBnbC5kcmF3QXJyYXlzKCBnbC5UUklBTkdMRV9TVFJJUCwgMCwgNCApO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIFxyXG4gICAgcGllY2VzQ29tcHV0ZToge1xyXG4gICAgICB3aWR0aDogcGFydGljbGVzU3FydCAqIHBhcnRpY2xlUGl4ZWxzLFxyXG4gICAgICBoZWlnaHQ6IHBhcnRpY2xlc1NxcnQsXHJcbiAgICAgIHZlcnQ6IGdsc2xpZnkoICcuL3NoYWRlci9xdWFkLnZlcnQnICksXHJcbiAgICAgIGZyYWc6IGdsc2xpZnkoICcuL3NoYWRlci9waWVjZXMtY29tcHV0ZS5mcmFnJyApLFxyXG4gICAgICBibGVuZDogWyBnbC5PTkUsIGdsLlpFUk8gXSxcclxuICAgICAgY2xlYXI6IFsgMC4wLCAwLjAsIDAuMCwgMC4wIF0sXHJcbiAgICAgIGZyYW1lYnVmZmVyOiB0cnVlLFxyXG4gICAgICBmbG9hdDogdHJ1ZSxcclxuICAgICAgZnVuYzogKCBwYXRoLCBwYXJhbXMgKSA9PiB7XHJcbiAgICAgICAgaWYgKCBhdXRvbWF0b24uZnJhbWUgPT09IDEgKSB7XHJcbiAgICAgICAgICB4b3JzaGlmdCggNDg3NzIzICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRleHR1cmVSYW5kb21VcGRhdGUoIHRleHR1cmVSYW5kb20gKTtcclxuXHJcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcclxuXHJcbiAgICAgICAgZ2xDYXQudW5pZm9ybTFmKCAncGFydGljbGVzU3FydCcsIHBhcnRpY2xlc1NxcnQgKTtcclxuICAgICAgICBnbENhdC51bmlmb3JtMWYoICdwYXJ0aWNsZVBpeGVscycsIHBhcnRpY2xlUGl4ZWxzICk7XHJcblxyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm1UZXh0dXJlKCAnc2FtcGxlclBjb21wdXRlJywgZ2xDYXRQYXRoLmZiKCBcInBpZWNlc0NvbXB1dGVSZXR1cm5cIiApLnRleHR1cmUsIDAgKTtcclxuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXJSYW5kb20nLCB0ZXh0dXJlUmFuZG9tLCAxICk7XHJcblxyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBcclxuICAgIHBpZWNlc1JlbmRlcjoge1xyXG4gICAgICB2ZXJ0OiBnbHNsaWZ5KCAnLi9zaGFkZXIvcGllY2VzLXJlbmRlci52ZXJ0JyApLFxyXG4gICAgICBmcmFnOiBnbHNsaWZ5KCAnLi9zaGFkZXIvcGllY2VzLXJlbmRlci5mcmFnJyApLFxyXG4gICAgICBibGVuZDogWyBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgXSxcclxuICAgICAgZnVuYzogKCBwYXRoLCBwYXJhbXMgKSA9PiB7XHJcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAnY29tcHV0ZVVWJywgdmJvUGFydGljbGVVViwgMiwgMSApO1xyXG4gICAgICAgIGdsQ2F0LmF0dHJpYnV0ZSggJ3JlY3QnLCB2Ym9RdWFkLCAyICk7XHJcbiAgXHJcbiAgICAgICAgZ2xDYXQudW5pZm9ybTFmKCAncGFydGljbGVzU3FydCcsIHBhcnRpY2xlc1NxcnQgKTtcclxuICAgICAgICBnbENhdC51bmlmb3JtMWYoICdwYXJ0aWNsZVBpeGVscycsIHBhcnRpY2xlUGl4ZWxzICk7XHJcblxyXG4gICAgICAgIGdsQ2F0LnVuaWZvcm0yZnYoICdyZXNvbHV0aW9uUGNvbXB1dGUnLCBbIHBhcnRpY2xlc1NxcnQgKiBwYXJ0aWNsZVBpeGVscywgcGFydGljbGVzU3FydCBdICk7XHJcbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyUGNvbXB1dGUnLCBnbENhdFBhdGguZmIoIFwicGllY2VzQ29tcHV0ZVwiICkudGV4dHVyZSwgMSApO1xyXG4gIFxyXG4gICAgICAgIGxldCBleHQgPSBnbENhdC5nZXRFeHRlbnNpb24oIFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiICk7XHJcbiAgICAgICAgZXh0LmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQsIHBhcnRpY2xlcyApO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIH0gKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHBhdGhQaWVjZXM7IiwiaW1wb3J0IE1hdGhDYXQgZnJvbSAnLi9saWJzL21hdGhjYXQnO1xyXG5jb25zdCBnbHNsaWZ5ID0gcmVxdWlyZSggJ2dsc2xpZnknICk7XHJcblxyXG4vLyAtLS0tLS1cclxuXHJcbmxldCBwYXRoUG9zdGZ4ID0gKCBnbENhdFBhdGgsIHdpZHRoLCBoZWlnaHQgKSA9PiB7XHJcbiAgbGV0IGdsQ2F0ID0gZ2xDYXRQYXRoLmdsQ2F0O1xyXG4gIGxldCBnbCA9IGdsQ2F0LmdsO1xyXG5cclxuICAvLyAtLS0tLS1cclxuXHJcbiAgbGV0IHZib1F1YWQgPSBnbENhdC5jcmVhdGVWZXJ0ZXhidWZmZXIoIFsgLTEsIC0xLCAxLCAtMSwgLTEsIDEsIDEsIDEgXSApO1xyXG5cclxuICAvLyAtLS0tLS1cclxuXHJcbiAgZ2xDYXRQYXRoLmFkZCgge1xyXG4gICAgZnhhYToge1xyXG4gICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICB2ZXJ0OiBnbHNsaWZ5KCAnLi9zaGFkZXIvcXVhZC52ZXJ0JyApLFxyXG4gICAgICBmcmFnOiBnbHNsaWZ5KCAnLi9zaGFkZXIvZnhhYS5mcmFnJyApLFxyXG4gICAgICBjbGVhcjogWyAwLjAsIDAuMCwgMC4wLCAxLjAgXSxcclxuICAgICAgZnJhbWVidWZmZXI6IHRydWUsXHJcbiAgICAgIGZsb2F0OiB0cnVlLFxyXG4gICAgICBibGVuZDogWyBnbC5PTkUsIGdsLlpFUk8gXSxcclxuICAgICAgZnVuYzogKCBwYXRoLCBwYXJhbXMgKSA9PiB7XHJcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcclxuICAgICAgICBnbENhdC51bmlmb3JtVGV4dHVyZSggJ3NhbXBsZXIwJywgcGFyYW1zLmlucHV0LCAwICk7XHJcbiAgICAgICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQgKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICBcclxuICAgIHBvc3Q6IHtcclxuICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgdmVydDogZ2xzbGlmeSggJy4vc2hhZGVyL3F1YWQudmVydCcgKSxcclxuICAgICAgZnJhZzogZ2xzbGlmeSggJy4vc2hhZGVyL3Bvc3QuZnJhZycgKSxcclxuICAgICAgYmxlbmQ6IFsgZ2wuT05FLCBnbC5aRVJPIF0sXHJcbiAgICAgIGNsZWFyOiBbIDAuMCwgMC4wLCAwLjAsIDAuMCBdLFxyXG4gICAgICBmcmFtZWJ1ZmZlcjogdHJ1ZSxcclxuICAgICAgZmxvYXQ6IHRydWUsXHJcbiAgICAgIGZ1bmM6ICggcGF0aCwgcGFyYW1zICkgPT4ge1xyXG4gICAgICAgIGdsQ2F0LmF0dHJpYnV0ZSggJ3AnLCB2Ym9RdWFkLCAyICk7XHJcbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyMCcsIHBhcmFtcy5pbnB1dCwgMCApO1xyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgXHJcbiAgICBnbGl0Y2g6IHtcclxuICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgdmVydDogZ2xzbGlmeSggJy4vc2hhZGVyL3F1YWQudmVydCcgKSxcclxuICAgICAgZnJhZzogZ2xzbGlmeSggJy4vc2hhZGVyL2dsaXRjaC5mcmFnJyApLFxyXG4gICAgICBibGVuZDogWyBnbC5PTkUsIGdsLlpFUk8gXSxcclxuICAgICAgY2xlYXI6IFsgMC4wLCAwLjAsIDAuMCwgMC4wIF0sXHJcbiAgICAgIGZyYW1lYnVmZmVyOiB0cnVlLFxyXG4gICAgICBmbG9hdDogdHJ1ZSxcclxuICAgICAgZnVuYzogKCBwYXRoLCBwYXJhbXMgKSA9PiB7XHJcbiAgICAgICAgZ2xDYXQuYXR0cmlidXRlKCAncCcsIHZib1F1YWQsIDIgKTtcclxuICAgICAgICBnbENhdC51bmlmb3JtMWYoICdhbXAnLCBwYXJhbXMuYW1wICk7XHJcbiAgICAgICAgZ2xDYXQudW5pZm9ybTFmKCAnc2VlZCcsIHBhcmFtcy5zZWVkICk7XHJcbiAgICAgICAgZ2xDYXQudW5pZm9ybVRleHR1cmUoICdzYW1wbGVyMCcsIHBhcmFtcy5pbnB1dCwgMCApO1xyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoIGdsLlRSSUFOR0xFX1NUUklQLCAwLCA0ICk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgfSApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgcGF0aFBvc3RmeDsiLCJsZXQgcmVNb2RlID0gLyhbTW1MbEhoVnZaekNjU3NRcVR0QWFdKS87XHJcbmxldCByZUNvbW1hbmQgPSAvKFtNbUxsSGhWdlp6Q2NTc1FxVHRBYV18LT9bXFxkXSsoXFwuXFxkKyk/KS9nO1xyXG5cclxubGV0IHN2Z1BhdGggPSAoIF9zdHIsIF9wYXJhbXMgKSA9PiB7XHJcbiAgbGV0IHN0ciA9IF9zdHI7XHJcbiAgbGV0IHBhcmFtcyA9IHtcclxuICAgIGN1cnZlU2VnczogNFxyXG4gIH07XHJcbiAgZm9yICggbGV0IGtleSBpbiBfcGFyYW1zICkge1xyXG4gICAgcGFyYW1zWyBrZXkgXSA9IF9wYXJhbXNbIGtleSBdO1xyXG4gIH1cclxuXHJcbiAgbGV0IGFyciA9IHN0ci5tYXRjaCggcmVDb21tYW5kICk7XHJcblxyXG4gIGxldCBwYXRocyA9IFtdO1xyXG5cclxuICBsZXQgaGVhZCA9IDA7XHJcbiAgbGV0IHggPSAwO1xyXG4gIGxldCB5ID0gMDtcclxuICBsZXQgY3VyUGF0aCA9IG51bGw7XHJcblxyXG4gIGxldCByZWZ4ID0gMDtcclxuICBsZXQgcmVmeSA9IDA7XHJcbiAgbGV0IHByZXZNb2RlID0gJyc7XHJcbiAgbGV0IHByZXZNb2RlVSA9ICcnO1xyXG5cclxuICB3aGlsZSAoIGhlYWQgPCBhcnIubGVuZ3RoICkge1xyXG4gICAgbGV0IG1vZGUgPSBhcnJbIGhlYWQgXTtcclxuICAgIGlmICggbW9kZS5tYXRjaCggcmVNb2RlICkgKSB7XHJcbiAgICAgIGhlYWQgKys7XHJcbiAgICB9IGVsc2UgeyAvLyBzdHJlYWshXHJcbiAgICAgIG1vZGUgPSBwcmV2TW9kZTtcclxuICAgIH1cclxuICAgIGxldCBtb2RlVSA9IG1vZGUudG9VcHBlckNhc2UoKTtcclxuICAgIGxldCBhYnMgPSBtb2RlID09PSBtb2RlVTtcclxuXHJcbiAgICBsZXQgYXggPSBhYnMgPyAwIDogeDtcclxuICAgIGxldCBheSA9IGFicyA/IDAgOiB5O1xyXG5cclxuICAgIGlmICggbW9kZVUgPT09ICdNJyApIHsgLy8gbW92ZVxyXG4gICAgICB4ID0gcGFyc2VGbG9hdCggYXJyWyBoZWFkICsgMCBdICkgKyBheDtcclxuICAgICAgeSA9IHBhcnNlRmxvYXQoIGFyclsgaGVhZCArIDEgXSApICsgYXk7XHJcblxyXG4gICAgICBjdXJQYXRoID0gWyB4LCB5IF07XHJcbiAgICAgIHBhdGhzLnB1c2goIGN1clBhdGggKTtcclxuXHJcbiAgICAgIGhlYWQgKz0gMjtcclxuXHJcbiAgICB9IGVsc2UgaWYgKCBtb2RlVSA9PT0gJ0wnICkgeyAvLyBsaW5lXHJcbiAgICAgIHggPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyAwIF0gKSArIGF4O1xyXG4gICAgICB5ID0gcGFyc2VGbG9hdCggYXJyWyBoZWFkICsgMSBdICkgKyBheTtcclxuXHJcbiAgICAgIGN1clBhdGgucHVzaCggeCwgeSApO1xyXG5cclxuICAgICAgaGVhZCArPSAyO1xyXG5cclxuICAgIH0gZWxzZSBpZiAoIG1vZGVVID09PSAnSCcgKSB7IC8vIGhvcml6b250YWxcclxuICAgICAgeCA9IHBhcnNlRmxvYXQoIGFyclsgaGVhZCArIDAgXSApICsgYXg7XHJcblxyXG4gICAgICBjdXJQYXRoLnB1c2goIHgsIHkgKTtcclxuXHJcbiAgICAgIGhlYWQgKz0gMTtcclxuXHJcbiAgICB9IGVsc2UgaWYgKCBtb2RlVSA9PT0gJ1YnICkgeyAvLyB2ZXJ0aWNhbFxyXG4gICAgICB5ID0gcGFyc2VGbG9hdCggYXJyWyBoZWFkICsgMCBdICkgKyBheTtcclxuXHJcbiAgICAgIGN1clBhdGgucHVzaCggeCwgeSApO1xyXG5cclxuICAgICAgaGVhZCArPSAxO1xyXG5cclxuICAgIH0gZWxzZSBpZiAoIG1vZGVVID09PSAnWicgKSB7IC8vIGNsb3NlIHBhdGhcclxuICAgICAgY3VyUGF0aC5wdXNoKCBjdXJQYXRoWyAwIF0sIGN1clBhdGhbIDEgXSApO1xyXG5cclxuICAgIH0gZWxzZSBpZiAoIG1vZGVVID09PSAnQycgKSB7IC8vIGN1YmljIGJlemllclxyXG4gICAgICBsZXQgeDAgPSB4O1xyXG4gICAgICBsZXQgeTAgPSB5O1xyXG4gICAgICBsZXQgeDEgPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyAwIF0gKSArIGF4O1xyXG4gICAgICBsZXQgeTEgPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyAxIF0gKSArIGF5O1xyXG4gICAgICBsZXQgeDIgPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyAyIF0gKSArIGF4O1xyXG4gICAgICBsZXQgeTIgPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyAzIF0gKSArIGF5O1xyXG4gICAgICB4ID0gcGFyc2VGbG9hdCggYXJyWyBoZWFkICsgNCBdICkgKyBheDtcclxuICAgICAgeSA9IHBhcnNlRmxvYXQoIGFyclsgaGVhZCArIDUgXSApICsgYXk7XHJcblxyXG4gICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBwYXJhbXMuY3VydmVTZWdzOyBpICsrICkge1xyXG4gICAgICAgIGxldCB0ID0gKCBpICsgMSApIC8gcGFyYW1zLmN1cnZlU2VncztcclxuICAgICAgICBsZXQgdSA9ICggMS4wIC0gdCApO1xyXG4gICAgICAgIGN1clBhdGgucHVzaChcclxuICAgICAgICAgIHUgKiB1ICogdSAqIHgwICsgMyAqIHQgKiB1ICogdSAqIHgxICsgMyAqIHQgKiB0ICogdSAqIHgyICsgdCAqIHQgKiB0ICogeCxcclxuICAgICAgICAgIHUgKiB1ICogdSAqIHkwICsgMyAqIHQgKiB1ICogdSAqIHkxICsgMyAqIHQgKiB0ICogdSAqIHkyICsgdCAqIHQgKiB0ICogeVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlZnggPSAyICogeCAtIHgyO1xyXG4gICAgICByZWZ5ID0gMiAqIHkgLSB5MjtcclxuXHJcbiAgICAgIGhlYWQgKz0gNjtcclxuXHJcbiAgICB9IGVsc2UgaWYgKCBtb2RlVSA9PT0gJ1MnICkgeyAvLyBjdWJpYyBiZXppZXIsIHdpdGggcmVmbGVjdGlvblxyXG4gICAgICBsZXQgcHJldlZhbGlkID0gcHJldk1vZGVVID09PSAnQycgfHwgcHJldk1vZGVVID09PSAnUyc7XHJcbiAgICAgIGlmICggIXByZXZWYWxpZCApIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oICdzdmdQYXRoOiBJbnZhbGlkIFMvcyBjb21tYW5kIHVzZSBkZXRlY3RlZCcgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHgwID0geDtcclxuICAgICAgbGV0IHkwID0geTtcclxuICAgICAgbGV0IHgxID0gcHJldlZhbGlkID8gcmVmeCA6IHg7XHJcbiAgICAgIGxldCB5MSA9IHByZXZWYWxpZCA/IHJlZnkgOiB5O1xyXG4gICAgICBsZXQgeDIgPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyAwIF0gKSArIGF4O1xyXG4gICAgICBsZXQgeTIgPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyAxIF0gKSArIGF5O1xyXG4gICAgICB4ID0gcGFyc2VGbG9hdCggYXJyWyBoZWFkICsgMiBdICkgKyBheDtcclxuICAgICAgeSA9IHBhcnNlRmxvYXQoIGFyclsgaGVhZCArIDMgXSApICsgYXk7XHJcblxyXG4gICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBwYXJhbXMuY3VydmVTZWdzOyBpICsrICkge1xyXG4gICAgICAgIGxldCB0ID0gKCBpICsgMSApIC8gcGFyYW1zLmN1cnZlU2VncztcclxuICAgICAgICBsZXQgdSA9ICggMS4wIC0gdCApO1xyXG4gICAgICAgIGN1clBhdGgucHVzaChcclxuICAgICAgICAgIHUgKiB1ICogdSAqIHgwICsgMyAqIHQgKiB1ICogdSAqIHgxICsgMyAqIHQgKiB0ICogdSAqIHgyICsgdCAqIHQgKiB0ICogeCxcclxuICAgICAgICAgIHUgKiB1ICogdSAqIHkwICsgMyAqIHQgKiB1ICogdSAqIHkxICsgMyAqIHQgKiB0ICogdSAqIHkyICsgdCAqIHQgKiB0ICogeVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlZnggPSAyICogeCAtIHgyO1xyXG4gICAgICByZWZ5ID0gMiAqIHkgLSB5MjtcclxuXHJcbiAgICAgIGhlYWQgKz0gNDtcclxuXHJcbiAgICB9IGVsc2UgaWYgKCBtb2RlVSA9PT0gJ1EnICkgeyAvLyBxdWFkIGJlemllclxyXG4gICAgICBsZXQgeDAgPSB4O1xyXG4gICAgICBsZXQgeTAgPSB5O1xyXG4gICAgICBsZXQgeDEgPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyAwIF0gKSArIGF4O1xyXG4gICAgICBsZXQgeTEgPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyAxIF0gKSArIGF5O1xyXG4gICAgICB4ID0gcGFyc2VGbG9hdCggYXJyWyBoZWFkICsgMiBdICkgKyBheDtcclxuICAgICAgeSA9IHBhcnNlRmxvYXQoIGFyclsgaGVhZCArIDMgXSApICsgYXk7XHJcblxyXG4gICAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBwYXJhbXMuY3VydmVTZWdzOyBpICsrICkge1xyXG4gICAgICAgIGxldCB0ID0gKCBpICsgMSApIC8gcGFyYW1zLmN1cnZlU2VncztcclxuICAgICAgICBsZXQgdSA9ICggMS4wIC0gdCApO1xyXG4gICAgICAgIGN1clBhdGgucHVzaChcclxuICAgICAgICAgIHUgKiB1ICogeDAgKyAyICogdCAqIHUgKiB4MSArIHQgKiB0ICogeCxcclxuICAgICAgICAgIHUgKiB1ICogeTAgKyAyICogdCAqIHUgKiB5MSArIHQgKiB0ICogeVxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlZnggPSAyICogeCAtIHgxO1xyXG4gICAgICByZWZ5ID0gMiAqIHkgLSB5MTtcclxuXHJcbiAgICAgIGhlYWQgKz0gNDtcclxuXHJcbiAgICB9IGVsc2UgaWYgKCBtb2RlVSA9PT0gJ1QnICkgeyAvLyBxdWFkIGJlemllciwgd2l0aCByZWZsZWN0aW9uXHJcbiAgICAgIGxldCBwcmV2VmFsaWQgPSBwcmV2TW9kZVUgPT09ICdRJyB8fCBwcmV2TW9kZVUgPT09ICdUJztcclxuICAgICAgaWYgKCAhcHJldlZhbGlkICkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybiggJ3N2Z1BhdGg6IEludmFsaWQgVC90IGNvbW1hbmQgdXNlIGRldGVjdGVkJyApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBsZXQgeDAgPSB4O1xyXG4gICAgICBsZXQgeTAgPSB5O1xyXG4gICAgICBsZXQgeDEgPSBwcmV2VmFsaWQgPyByZWZ4IDogeDtcclxuICAgICAgbGV0IHkxID0gcHJldlZhbGlkID8gcmVmeSA6IHk7XHJcbiAgICAgIHggPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyAwIF0gKSArIGF4O1xyXG4gICAgICB5ID0gcGFyc2VGbG9hdCggYXJyWyBoZWFkICsgMSBdICkgKyBheTtcclxuXHJcbiAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHBhcmFtcy5jdXJ2ZVNlZ3M7IGkgKysgKSB7XHJcbiAgICAgICAgbGV0IHQgPSAoIGkgKyAxICkgLyBwYXJhbXMuY3VydmVTZWdzO1xyXG4gICAgICAgIGxldCB1ID0gKCAxLjAgLSB0ICk7XHJcbiAgICAgICAgY3VyUGF0aC5wdXNoKFxyXG4gICAgICAgICAgdSAqIHUgKiB4MCArIDIgKiB0ICogdSAqIHgxICsgdCAqIHQgKiB4LFxyXG4gICAgICAgICAgdSAqIHUgKiB5MCArIDIgKiB0ICogdSAqIHkxICsgdCAqIHQgKiB5XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmVmeCA9IDIgKiB4IC0geDE7XHJcbiAgICAgIHJlZnkgPSAyICogeSAtIHkxO1xyXG5cclxuICAgICAgaGVhZCArPSAyO1xyXG5cclxuICAgIH0gZWxzZSBpZiAoIG1vZGVVID09PSAnQScgKSB7IC8vIGFyY1xyXG4gICAgICAvLyBUSElTLiBJUy4gSEVMTC5cclxuICAgICAgLy8gcmVmOiBodHRwczovL3RyaXBsZS11bmRlcnNjb3JlLmdpdGh1Yi5pby9TVkcxMS9pbXBsbm90ZS5odG1sI1BhdGhFbGVtZW50SW1wbGVtZW50YXRpb25Ob3Rlc1xyXG5cclxuICAgICAgbGV0IHgwID0geDtcclxuICAgICAgbGV0IHkwID0geTtcclxuICAgICAgbGV0IHJ4ID0gTWF0aC5hYnMoIHBhcnNlRmxvYXQoIGFyclsgaGVhZCArIDAgXSApICk7XHJcbiAgICAgIGxldCByeSA9IE1hdGguYWJzKCBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyAxIF0gKSApO1xyXG4gICAgICBsZXQgcm90ID0gcGFyc2VGbG9hdCggYXJyWyBoZWFkICsgMiBdICk7XHJcbiAgICAgIGxldCBsYXJnZSA9IGFyclsgaGVhZCArIDMgXSAhPT0gXCIwXCI7XHJcbiAgICAgIGxldCBzd2VlcCA9IGFyclsgaGVhZCArIDQgXSAhPT0gXCIwXCI7XHJcbiAgICAgIHggPSBwYXJzZUZsb2F0KCBhcnJbIGhlYWQgKyA1IF0gKSArIGF4O1xyXG4gICAgICB5ID0gcGFyc2VGbG9hdCggYXJyWyBoZWFkICsgNiBdICkgKyBheTtcclxuXHJcbiAgICAgIGlmICggeDAgPT09IHggJiYgeTAgPT09IHkgKSB7IC8vIGVuZHBvaW50cyBhcmUgc2FtZSwgd2lsbCBiZSBvbWl0dGVkXHJcbiAgICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgICB9IGVsc2UgaWYgKCByeCA9PT0gMCB8fCByeSA9PT0gMCApIHsgLy8gcmFkaXVzIGlzIDAsIHdpbGwgYmUgbGluZVxyXG4gICAgICAgIGN1clBhdGgucHVzaCggeCwgeSApO1xyXG4gICAgICB9IGVsc2UgeyAvLyBoZWxsXHJcbiAgICAgICAgbGV0IGNvc3IgPSBNYXRoLmNvcyggcm90IC8gMTgwICogTWF0aC5QSSApO1xyXG4gICAgICAgIGxldCBzaW5yID0gTWF0aC5zaW4oIHJvdCAvIDE4MCAqIE1hdGguUEkgKTtcclxuXHJcbiAgICAgICAgbGV0IHgwcCA9IGNvc3IgKiAoIHgwIC0geCApIC8gMiArIHNpbnIgKiAoIHkwIC0geSApIC8gMjtcclxuICAgICAgICBsZXQgeTBwID0gLXNpbnIgKiAoIHgwIC0geCApIC8gMiArIGNvc3IgKiAoIHkwIC0geSApIC8gMjtcclxuICAgICAgICBjb25zb2xlLmxvZyggeDBwLCB5MHAgKTtcclxuXHJcbiAgICAgICAgbGV0IGxhbWJkYSA9ICggeDBwICogeDBwICkgLyAoIHJ4ICogcnggKSArICggeTBwICogeTBwICkgLyAoIHJ5ICogcnkgKTtcclxuICAgICAgICBpZiAoIDEuMCA8IGxhbWJkYSApIHtcclxuICAgICAgICAgIGxldCBrID0gTWF0aC5zcXJ0KCBsYW1iZGEgKTtcclxuICAgICAgICAgIHJ4ICo9IHJ4O1xyXG4gICAgICAgICAgcnkgKj0gcnk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdDEgPSByeCAqIHJ4ICogeTBwICogeTBwO1xyXG4gICAgICAgIGxldCB0MiA9IHJ5ICogcnkgKiB4MHAgKiB4MHA7XHJcbiAgICAgICAgbGV0IGN0cCA9IE1hdGguc3FydChcclxuICAgICAgICAgICggcnggKiByeCAqIHJ5ICogcnkgLSB0MSAtIHQyIClcclxuICAgICAgICAgIC8gKCB0MSArIHQyIClcclxuICAgICAgICApICogKCBsYXJnZSA9PT0gc3dlZXAgPyAtMSA6IDEgKTtcclxuICAgICAgICBsZXQgY3hwID0gY3RwICogcnggKiB5MHAgLyByeTtcclxuICAgICAgICBsZXQgY3lwID0gLWN0cCAqIHJ5ICogeDBwIC8gcng7XHJcbiAgICAgICAgY29uc29sZS5sb2coIGN4cCwgY3lwICk7XHJcblxyXG4gICAgICAgIGxldCBjeCA9IGNvc3IgKiBjeHAgLSBzaW5yICogY3lwICsgKCB4MCArIHggKSAvIDI7XHJcbiAgICAgICAgbGV0IGN5ID0gc2luciAqIGN4cCArIGNvc3IgKiBjeXAgKyAoIHkwICsgeSApIC8gMjtcclxuICAgICAgICBjb25zb2xlLmxvZyggY3gsIGN5ICk7XHJcblxyXG4gICAgICAgIGxldCB0aGV0YTAgPSBNYXRoLmF0YW4yKCAoIHkwcCAtIGN5cCApIC8gcnksICggeDBwIC0gY3hwICkgLyByeCApO1xyXG4gICAgICAgIGxldCB0aGV0YTEgPSBNYXRoLmF0YW4yKCAoIC15MHAgLSBjeXAgKSAvIHJ5LCAoIC14MHAgLSBjeHAgKSAvIHJ4ICk7XHJcbiAgICAgICAgaWYgKCB0aGV0YTEgPCB0aGV0YTAgJiYgc3dlZXAgKSB7XHJcbiAgICAgICAgICB0aGV0YTEgKz0gTWF0aC5QSSAqIDIuMDtcclxuICAgICAgICB9IGVsc2UgaWYgKCB0aGV0YTAgPCB0aGV0YTEgJiYgIXN3ZWVwICkge1xyXG4gICAgICAgICAgdGhldGExIC09IE1hdGguUEkgKiAyLjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBkdGhldGEgPSB0aGV0YTEgLSB0aGV0YTA7XHJcbiAgICAgICAgY29uc29sZS5sb2coIHRoZXRhMCwgdGhldGExICk7XHJcblxyXG4gICAgICAgIGZvciAoIGxldCBpID0gMDsgaSA8IHBhcmFtcy5jdXJ2ZVNlZ3M7IGkgKysgKSB7XHJcbiAgICAgICAgICBsZXQgdCA9ICggaSArIDEgKSAvIHBhcmFtcy5jdXJ2ZVNlZ3M7XHJcbiAgICAgICAgICBsZXQgdGhldGEgPSB0aGV0YTAgKyBkdGhldGEgKiB0O1xyXG5cclxuICAgICAgICAgIGxldCB4ZiA9IHJ4ICogTWF0aC5jb3MoIHRoZXRhICk7XHJcbiAgICAgICAgICBsZXQgeWYgPSByeSAqIE1hdGguc2luKCB0aGV0YSApO1xyXG5cclxuICAgICAgICAgIGN1clBhdGgucHVzaChcclxuICAgICAgICAgICAgY3ggKyBjb3NyICogeGYgLSBzaW5yICogeWYsXHJcbiAgICAgICAgICAgIGN5ICsgc2luciAqIHhmICsgY29zciAqIHlmXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaGVhZCArPSA3O1xyXG5cclxuICAgIH0gZWxzZSB7IC8vIGludmFsaWRcclxuICAgICAgY29uc29sZS53YXJuKCAnc3ZnUGF0aDogSW52YWxpZCBjb21tYW5kOiAnICsgbW9kZSApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBwcmV2TW9kZSA9IG1vZGU7XHJcbiAgICBwcmV2TW9kZVUgPSBtb2RlVTtcclxuICB9XHJcblxyXG4gIHJldHVybiBwYXRocztcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHN2Z1BhdGg7IiwibGV0IGxlcnAgPSAoIGEsIGIsIHggKSA9PiBhICsgKCBiIC0gYSApICogeDtcbmxldCBkaXN0ID0gKCBheCwgYXksIGJ4LCBieSApID0+IE1hdGguc3FydCggKCBieCAtIGF4ICkgKiAoIGJ4IC0gYXggKSArICggYnkgLSBheSApICogKCBieSAtIGF5ICkgKTtcblxubGV0IFZlcnRQaGFzZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCBfdmVydCApIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuXG4gICAgaXQudmVydCA9IF92ZXJ0LmNvbmNhdCgpO1xuICAgIGl0LnRvdGFsTGVuZ3RoID0gMC4wO1xuICAgIGl0Lmxlbmd0aE1hcCA9IFtdO1xuXG4gICAgaXQuY2FsY0xlbmd0aCgpO1xuICB9XG5cbiAgY2FsY0xlbmd0aCgpIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuXG4gICAgaXQudG90YWxMZW5ndGggPSAwLjA7XG4gICAgaXQubGVuZ3RoTWFwID0gW107XG5cbiAgICBmb3IgKCBsZXQgaSA9IDA7IGkgPCBpdC52ZXJ0Lmxlbmd0aCAvIDIgLSAxOyBpICsrICkge1xuICAgICAgbGV0IGwgPSBkaXN0KFxuICAgICAgICBpdC52ZXJ0WyBpICogMiArIDAgXSxcbiAgICAgICAgaXQudmVydFsgaSAqIDIgKyAxIF0sXG4gICAgICAgIGl0LnZlcnRbIGkgKiAyICsgMiBdLFxuICAgICAgICBpdC52ZXJ0WyBpICogMiArIDMgXVxuICAgICAgKTtcbiAgICAgIGl0LnRvdGFsTGVuZ3RoICs9IGw7XG4gICAgICBpdC5sZW5ndGhNYXAucHVzaCggbCApO1xuICAgIH1cblxuICAgIGxldCBsID0gZGlzdChcbiAgICAgIGl0LnZlcnRbIGl0LnZlcnQubGVuZ3RoIC0gMiBdLFxuICAgICAgaXQudmVydFsgaXQudmVydC5sZW5ndGggLSAxIF0sXG4gICAgICBpdC52ZXJ0WyAwIF0sXG4gICAgICBpdC52ZXJ0WyAxIF1cbiAgICApO1xuICAgIGl0LnRvdGFsTGVuZ3RoICs9IGw7XG4gICAgaXQubGVuZ3RoTWFwLnB1c2goIGwgKTtcbiAgfVxuXG4gIGdldFBoYXNlSW5mbyggX3BoYXNlICkge1xuICAgIGxldCBpdCA9IHRoaXM7XG5cbiAgICBsZXQgcGhhc2UgPSBfcGhhc2UgJSAxLjA7XG4gICAgbGV0IGxlbiA9IHBoYXNlICogaXQudG90YWxMZW5ndGg7XG5cbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IHBzdW0gPSAwLjA7XG4gICAgbGV0IHN1bSA9IDAuMDtcbiAgICB3aGlsZSAoIHN1bSA8PSBsZW4gKSB7XG4gICAgICBwc3VtID0gc3VtO1xuICAgICAgc3VtICs9IGl0Lmxlbmd0aE1hcFsgaSBdO1xuICAgICAgaSArKztcbiAgICB9XG5cbiAgICBsZXQgcCA9ICggbGVuIC0gcHN1bSApIC8gKCBzdW0gLSBwc3VtICk7XG4gICAgbGV0IHggPSBsZXJwKFxuICAgICAgaXQudmVydFsgaSAqIDIgLSAyIF0sXG4gICAgICBpdC52ZXJ0WyAoIGkgKiAyICsgMCApICUgaXQudmVydC5sZW5ndGggXSxcbiAgICAgIHBcbiAgICApO1xuICAgIGxldCB5ID0gbGVycChcbiAgICAgIGl0LnZlcnRbIGkgKiAyIC0gMSBdLFxuICAgICAgaXQudmVydFsgKCBpICogMiArIDEgKSAlIGl0LnZlcnQubGVuZ3RoIF0sIFxuICAgICAgcFxuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGhhc2U6IHBoYXNlLFxuICAgICAgbGVuZ3RoOiBsZW4sXG4gICAgICBpOiBpLFxuICAgICAgeDogeCxcbiAgICAgIHk6IHksXG4gICAgICBwOiBwXG4gICAgfTtcbiAgfVxuXG4gIGRvKCBfYmVnaW4sIF9waGFzZSApIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuXG4gICAgbGV0IGJlZ2luID0gaXQuZ2V0UGhhc2VJbmZvKCBfYmVnaW4gKTtcbiAgICBsZXQgZW5kID0gaXQuZ2V0UGhhc2VJbmZvKCBfYmVnaW4gKyBfcGhhc2UgKTtcblxuICAgIGxldCByZXQgPSBbIGJlZ2luLngsIGJlZ2luLnkgXTtcbiAgICBpZiAoIGJlZ2luLnBoYXNlIDw9IGVuZC5waGFzZSApIHtcbiAgICAgIHJldCA9IHJldC5jb25jYXQoIGl0LnZlcnQuc2xpY2UoIGJlZ2luLmkgKiAyLCBlbmQuaSAqIDIgKSApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQgPSByZXQuY29uY2F0KCBpdC52ZXJ0LnNsaWNlKCBiZWdpbi5pICogMiApICk7XG4gICAgICByZXQgPSByZXQuY29uY2F0KCBpdC52ZXJ0LnNsaWNlKCAwLCBlbmQuaSAqIDIgKSApO1xuICAgIH1cbiAgICByZXQucHVzaCggZW5kLngsIGVuZC55ICk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgbG9maSggX2JlZ2luLCBfc2VncyApIHtcbiAgICBsZXQgaXQgPSB0aGlzO1xuXG4gICAgbGV0IHNlZ3MgPSBfc2VncztcbiAgICBpZiAoIHNlZ3MgPCAxICkgeyB0aHJvdyAnVmVydFBoYXNlci5sb2ZpOiBzZWdzIDwgMSwgaXRcXCdzIGludmFsaWQnOyB9XG5cbiAgICBsZXQgYmVnaW4gPSBpdC5nZXRQaGFzZUluZm8oIF9iZWdpbiApO1xuXG4gICAgbGV0IHJldCA9IFsgYmVnaW4ueCwgYmVnaW4ueSBdO1xuICAgIGZvciAoIGxldCBpID0gMTsgaSA8IE1hdGguZmxvb3IoIHNlZ3MgKyAxICk7IGkgKysgKSB7XG4gICAgICBsZXQgcCA9IF9iZWdpbiArIGkgLyBzZWdzO1xuICAgICAgbGV0IHNlZyA9IGl0LmdldFBoYXNlSW5mbyggcCApO1xuICAgICAgcmV0LnB1c2goIHNlZy54LCBzZWcueSApO1xuICAgIH1cbiAgICByZXQucHVzaCggYmVnaW4ueCwgYmVnaW4ueSApO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgVmVydFBoYXNlcjsiXX0=
